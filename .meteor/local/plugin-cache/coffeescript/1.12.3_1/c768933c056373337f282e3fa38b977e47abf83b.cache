{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar JobCollectionBase,\n    _validId,\n    _validIntGTEOne,\n    _validIntGTEZero,\n    _validJobDoc,\n    _validLaterJSObj,\n    _validLog,\n    _validLogLevel,\n    _validNumGTEOne,\n    _validNumGTEZero,\n    _validNumGTZero,\n    _validProgress,\n    _validRetryBackoff,\n    _validStatus,\n    indexOf = [].indexOf || function (item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item) return i;\n  }\n\n  return -1;\n},\n    extend = function (child, parent) {\n  for (var key in meteorBabelHelpers.sanitizeForInObject(parent)) {\n    if (hasProp.call(parent, key)) child[key] = parent[key];\n  }\n\n  function ctor() {\n    this.constructor = child;\n  }\n\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n  child.__super__ = parent.prototype;\n  return child;\n},\n    hasProp = {}.hasOwnProperty,\n    slice = [].slice;\n\n_validNumGTEZero = function (v) {\n  return Match.test(v, Number) && v >= 0.0;\n};\n\n_validNumGTZero = function (v) {\n  return Match.test(v, Number) && v > 0.0;\n};\n\n_validNumGTEOne = function (v) {\n  return Match.test(v, Number) && v >= 1.0;\n};\n\n_validIntGTEZero = function (v) {\n  return _validNumGTEZero(v) && Math.floor(v) === v;\n};\n\n_validIntGTEOne = function (v) {\n  return _validNumGTEOne(v) && Math.floor(v) === v;\n};\n\n_validStatus = function (v) {\n  return Match.test(v, String) && indexOf.call(Job.jobStatuses, v) >= 0;\n};\n\n_validLogLevel = function (v) {\n  return Match.test(v, String) && indexOf.call(Job.jobLogLevels, v) >= 0;\n};\n\n_validRetryBackoff = function (v) {\n  return Match.test(v, String) && indexOf.call(Job.jobRetryBackoffMethods, v) >= 0;\n};\n\n_validId = function (v) {\n  return Match.test(v, Match.OneOf(String, Mongo.Collection.ObjectID));\n};\n\n_validLog = function () {\n  return [{\n    time: Date,\n    runId: Match.OneOf(Match.Where(_validId), null),\n    level: Match.Where(_validLogLevel),\n    message: String,\n    data: Match.Optional(Object)\n  }];\n};\n\n_validProgress = function () {\n  return {\n    completed: Match.Where(_validNumGTEZero),\n    total: Match.Where(_validNumGTEZero),\n    percent: Match.Where(_validNumGTEZero)\n  };\n};\n\n_validLaterJSObj = function () {\n  return {\n    schedules: [Object],\n    exceptions: Match.Optional([Object])\n  };\n};\n\n_validJobDoc = function () {\n  return {\n    _id: Match.Optional(Match.OneOf(Match.Where(_validId), null)),\n    runId: Match.OneOf(Match.Where(_validId), null),\n    type: String,\n    status: Match.Where(_validStatus),\n    data: Object,\n    result: Match.Optional(Object),\n    failures: Match.Optional([Object]),\n    priority: Match.Integer,\n    depends: [Match.Where(_validId)],\n    resolved: [Match.Where(_validId)],\n    after: Date,\n    updated: Date,\n    workTimeout: Match.Optional(Match.Where(_validIntGTEOne)),\n    expiresAfter: Match.Optional(Date),\n    log: Match.Optional(_validLog()),\n    progress: _validProgress(),\n    retries: Match.Where(_validIntGTEZero),\n    retried: Match.Where(_validIntGTEZero),\n    repeatRetries: Match.Optional(Match.Where(_validIntGTEZero)),\n    retryUntil: Date,\n    retryWait: Match.Where(_validIntGTEZero),\n    retryBackoff: Match.Where(_validRetryBackoff),\n    repeats: Match.Where(_validIntGTEZero),\n    repeated: Match.Where(_validIntGTEZero),\n    repeatUntil: Date,\n    repeatWait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj)),\n    created: Date\n  };\n};\n\nJobCollectionBase = function (superClass) {\n  extend(JobCollectionBase, superClass);\n\n  function JobCollectionBase(root, options) {\n    var collectionName;\n    this.root = root != null ? root : 'queue';\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (!(this instanceof JobCollectionBase)) {\n      return new JobCollectionBase(this.root, options);\n    }\n\n    if (!(this instanceof Mongo.Collection)) {\n      throw new Error('The global definition of Mongo.Collection has changed since the job-collection package was loaded. Please ensure that any packages that redefine Mongo.Collection are loaded before job-collection.');\n    }\n\n    if (Mongo.Collection !== Mongo.Collection.prototype.constructor) {\n      throw new Meteor.Error('The global definition of Mongo.Collection has been patched by another package, and the prototype constructor has been left in an inconsistent state. Please see this link for a workaround: https://github.com/vsivsi/meteor-file-sample-app/issues/2#issuecomment-120780592');\n    }\n\n    this.later = later;\n\n    if (options.noCollectionSuffix == null) {\n      options.noCollectionSuffix = false;\n    }\n\n    collectionName = this.root;\n\n    if (!options.noCollectionSuffix) {\n      collectionName += '.jobs';\n    }\n\n    delete options.noCollectionSuffix;\n    Job.setDDP(options.connection, this.root);\n\n    this._createLogEntry = function (message, runId, level, time, data) {\n      var l;\n\n      if (message == null) {\n        message = '';\n      }\n\n      if (runId == null) {\n        runId = null;\n      }\n\n      if (level == null) {\n        level = 'info';\n      }\n\n      if (time == null) {\n        time = new Date();\n      }\n\n      if (data == null) {\n        data = null;\n      }\n\n      l = {\n        time: time,\n        runId: runId,\n        message: message,\n        level: level\n      };\n      return l;\n    };\n\n    this._logMessage = {\n      'readied': function () {\n        return this._createLogEntry(\"Promoted to ready\");\n      }.bind(this),\n      'forced': function (id) {\n        return this._createLogEntry(\"Dependencies force resolved\", null, 'warning');\n      }.bind(this),\n      'rerun': function (id, runId) {\n        return this._createLogEntry(\"Rerunning job\", null, 'info', new Date(), {\n          previousJob: {\n            id: id,\n            runId: runId\n          }\n        });\n      }.bind(this),\n      'running': function (runId) {\n        return this._createLogEntry(\"Job Running\", runId);\n      }.bind(this),\n      'paused': function () {\n        return this._createLogEntry(\"Job Paused\");\n      }.bind(this),\n      'resumed': function () {\n        return this._createLogEntry(\"Job Resumed\");\n      }.bind(this),\n      'cancelled': function () {\n        return this._createLogEntry(\"Job Cancelled\", null, 'warning');\n      }.bind(this),\n      'restarted': function () {\n        return this._createLogEntry(\"Job Restarted\");\n      }.bind(this),\n      'resubmitted': function () {\n        return this._createLogEntry(\"Job Resubmitted\");\n      }.bind(this),\n      'submitted': function () {\n        return this._createLogEntry(\"Job Submitted\");\n      }.bind(this),\n      'completed': function (runId) {\n        return this._createLogEntry(\"Job Completed\", runId, 'success');\n      }.bind(this),\n      'resolved': function (id, runId) {\n        return this._createLogEntry(\"Dependency resolved\", null, 'info', new Date(), {\n          dependency: {\n            id: id,\n            runId: runId\n          }\n        });\n      }.bind(this),\n      'failed': function (runId, fatal, err) {\n        var level, msg, value;\n        value = err.value;\n        msg = \"Job Failed with\" + (fatal ? ' Fatal' : '') + \" Error\" + (value != null && typeof value === 'string' ? ': ' + value : '') + \".\";\n        level = fatal ? 'danger' : 'warning';\n        return this._createLogEntry(msg, runId, level);\n      }.bind(this)\n    };\n\n    JobCollectionBase.__super__.constructor.call(this, collectionName, options);\n  }\n\n  JobCollectionBase.prototype._validNumGTEZero = _validNumGTEZero;\n  JobCollectionBase.prototype._validNumGTZero = _validNumGTZero;\n  JobCollectionBase.prototype._validNumGTEOne = _validNumGTEOne;\n  JobCollectionBase.prototype._validIntGTEZero = _validIntGTEZero;\n  JobCollectionBase.prototype._validIntGTEOne = _validIntGTEOne;\n  JobCollectionBase.prototype._validStatus = _validStatus;\n  JobCollectionBase.prototype._validLogLevel = _validLogLevel;\n  JobCollectionBase.prototype._validRetryBackoff = _validRetryBackoff;\n  JobCollectionBase.prototype._validId = _validId;\n  JobCollectionBase.prototype._validLog = _validLog;\n  JobCollectionBase.prototype._validProgress = _validProgress;\n  JobCollectionBase.prototype._validJobDoc = _validJobDoc;\n  JobCollectionBase.prototype.jobLogLevels = Job.jobLogLevels;\n  JobCollectionBase.prototype.jobPriorities = Job.jobPriorities;\n  JobCollectionBase.prototype.jobStatuses = Job.jobStatuses;\n  JobCollectionBase.prototype.jobStatusCancellable = Job.jobStatusCancellable;\n  JobCollectionBase.prototype.jobStatusPausable = Job.jobStatusPausable;\n  JobCollectionBase.prototype.jobStatusRemovable = Job.jobStatusRemovable;\n  JobCollectionBase.prototype.jobStatusRestartable = Job.jobStatusRestartable;\n  JobCollectionBase.prototype.forever = Job.forever;\n  JobCollectionBase.prototype.foreverDate = Job.foreverDate;\n  JobCollectionBase.prototype.ddpMethods = Job.ddpMethods;\n  JobCollectionBase.prototype.ddpPermissionLevels = Job.ddpPermissionLevels;\n  JobCollectionBase.prototype.ddpMethodPermissions = Job.ddpMethodPermissions;\n\n  JobCollectionBase.prototype.processJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function (func, args, ctor) {\n      ctor.prototype = func.prototype;\n      var child = new ctor(),\n          result = func.apply(child, args);\n      return Object(result) === result ? result : child;\n    }(Job.processJobs, [this.root].concat(slice.call(params)), function () {});\n  };\n\n  JobCollectionBase.prototype.getJob = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getJob.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.getWork = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getWork.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.getJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.readyJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.readyJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.cancelJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.cancelJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.pauseJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.pauseJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.resumeJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.resumeJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.restartJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.restartJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.removeJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.removeJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.setDDP = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.setDDP.apply(Job, params);\n  };\n\n  JobCollectionBase.prototype.startJobServer = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.startJobServer.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.shutdownJobServer = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.shutdownJobServer.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.startJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.startJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.stopJobs = function () {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.stopJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.jobDocPattern = _validJobDoc();\n\n  JobCollectionBase.prototype.allow = function () {\n    throw new Error(\"Server-only function jc.allow() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.deny = function () {\n    throw new Error(\"Server-only function jc.deny() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.promote = function () {\n    throw new Error(\"Server-only function jc.promote() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.setLogStream = function () {\n    throw new Error(\"Server-only function jc.setLogStream() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.logConsole = function () {\n    throw new Error(\"Client-only function jc.logConsole() invoked on server.\");\n  };\n\n  JobCollectionBase.prototype.makeJob = function () {\n    var dep;\n    dep = false;\n    return function () {\n      var params;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\n      if (!dep) {\n        dep = true;\n        console.warn(\"WARNING: jc.makeJob() has been deprecated. Use new Job(jc, doc) instead.\");\n      }\n\n      return function (func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor(),\n            result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      }(Job, [this.root].concat(slice.call(params)), function () {});\n    };\n  }();\n\n  JobCollectionBase.prototype.createJob = function () {\n    var dep;\n    dep = false;\n    return function () {\n      var params;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\n      if (!dep) {\n        dep = true;\n        console.warn(\"WARNING: jc.createJob() has been deprecated. Use new Job(jc, type, data) instead.\");\n      }\n\n      return function (func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor(),\n            result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      }(Job, [this.root].concat(slice.call(params)), function () {});\n    };\n  }();\n\n  JobCollectionBase.prototype._methodWrapper = function (method, func) {\n    var ref, toLog, unblockDDPMethods;\n    toLog = this._toLog;\n    unblockDDPMethods = (ref = this._unblockDDPMethods) != null ? ref : false;\n    return function () {\n      var params, ref1, retval, user;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      user = (ref1 = this.userId) != null ? ref1 : \"[UNAUTHENTICATED]\";\n      toLog(user, method, \"params: \" + JSON.stringify(params));\n\n      if (unblockDDPMethods) {\n        this.unblock();\n      }\n\n      retval = func.apply(null, params);\n      toLog(user, method, \"returned: \" + JSON.stringify(retval));\n      return retval;\n    };\n  };\n\n  JobCollectionBase.prototype._generateMethods = function () {\n    var baseMethodName, methodFunc, methodName, methodPrefix, methodsOut, ref;\n    methodsOut = {};\n    methodPrefix = '_DDPMethod_';\n    ref = this;\n\n    for (methodName in meteorBabelHelpers.sanitizeForInObject(ref)) {\n      methodFunc = ref[methodName];\n\n      if (!(methodName.slice(0, methodPrefix.length) === methodPrefix)) {\n        continue;\n      }\n\n      baseMethodName = methodName.slice(methodPrefix.length);\n      methodsOut[this.root + \"_\" + baseMethodName] = this._methodWrapper(baseMethodName, methodFunc.bind(this));\n    }\n\n    return methodsOut;\n  };\n\n  JobCollectionBase.prototype._idsOfDeps = function (ids, antecedents, dependents, jobStatuses) {\n    var antsArray, dependsIds, dependsQuery;\n    dependsQuery = [];\n\n    if (dependents) {\n      dependsQuery.push({\n        depends: {\n          $elemMatch: {\n            $in: ids\n          }\n        }\n      });\n    }\n\n    if (antecedents) {\n      antsArray = [];\n      this.find({\n        _id: {\n          $in: ids\n        }\n      }, {\n        fields: {\n          depends: 1\n        },\n        transform: null\n      }).forEach(function (d) {\n        var i, j, len, ref, results;\n\n        if (indexOf.call(antsArray, i) < 0) {\n          ref = d.depends;\n          results = [];\n\n          for (j = 0, len = ref.length; j < len; j++) {\n            i = ref[j];\n            results.push(antsArray.push(i));\n          }\n\n          return results;\n        }\n      });\n\n      if (antsArray.length > 0) {\n        dependsQuery.push({\n          _id: {\n            $in: antsArray\n          }\n        });\n      }\n    }\n\n    if (dependsQuery) {\n      dependsIds = [];\n      this.find({\n        status: {\n          $in: jobStatuses\n        },\n        $or: dependsQuery\n      }, {\n        fields: {\n          _id: 1\n        },\n        transform: null\n      }).forEach(function (d) {\n        var ref;\n\n        if (ref = d._id, indexOf.call(dependsIds, ref) < 0) {\n          return dependsIds.push(d._id);\n        }\n      });\n    }\n\n    return dependsIds;\n  };\n\n  JobCollectionBase.prototype._rerun_job = function (doc, repeats, wait, repeatUntil) {\n    var id, jobId, logObj, runId, time;\n\n    if (repeats == null) {\n      repeats = doc.repeats - 1;\n    }\n\n    if (wait == null) {\n      wait = doc.repeatWait;\n    }\n\n    if (repeatUntil == null) {\n      repeatUntil = doc.repeatUntil;\n    }\n\n    id = doc._id;\n    runId = doc.runId;\n    time = new Date();\n    delete doc._id;\n    delete doc.result;\n    delete doc.failures;\n    delete doc.expiresAfter;\n    delete doc.workTimeout;\n    doc.runId = null;\n    doc.status = \"waiting\";\n    doc.repeatRetries = doc.repeatRetries != null ? doc.repeatRetries : doc.retries + doc.retried;\n    doc.retries = doc.repeatRetries;\n\n    if (doc.retries > this.forever) {\n      doc.retries = this.forever;\n    }\n\n    doc.retryUntil = repeatUntil;\n    doc.retried = 0;\n    doc.repeats = repeats;\n\n    if (doc.repeats > this.forever) {\n      doc.repeats = this.forever;\n    }\n\n    doc.repeatUntil = repeatUntil;\n    doc.repeated = doc.repeated + 1;\n    doc.updated = time;\n    doc.created = time;\n    doc.progress = {\n      completed: 0,\n      total: 1,\n      percent: 0\n    };\n\n    if (logObj = this._logMessage.rerun(id, runId)) {\n      doc.log = [logObj];\n    } else {\n      doc.log = [];\n    }\n\n    doc.after = new Date(time.valueOf() + wait);\n\n    if (jobId = this.insert(doc)) {\n      this._DDPMethod_jobReady(jobId);\n\n      return jobId;\n    } else {\n      console.warn(\"Job rerun/repeat failed to reschedule!\", id, runId);\n    }\n\n    return null;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_startJobServer = function (options) {\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (!this.isSimulation) {\n      if (this.stopped && this.stopped !== true) {\n        Meteor.clearTimeout(this.stopped);\n      }\n\n      this.stopped = false;\n    }\n\n    return true;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_startJobs = function () {\n    var depFlag;\n    depFlag = false;\n    return function (options) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Deprecation Warning: jc.startJobs() has been renamed to jc.startJobServer()\");\n      }\n\n      return this._DDPMethod_startJobServer(options);\n    };\n  }();\n\n  JobCollectionBase.prototype._DDPMethod_shutdownJobServer = function (options) {\n    check(options, Match.Optional({\n      timeout: Match.Optional(Match.Where(_validIntGTEOne))\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.timeout == null) {\n      options.timeout = 60 * 1000;\n    }\n\n    if (!this.isSimulation) {\n      if (this.stopped && this.stopped !== true) {\n        Meteor.clearTimeout(this.stopped);\n      }\n\n      this.stopped = Meteor.setTimeout(function (_this) {\n        return function () {\n          var cursor, failedJobs;\n          cursor = _this.find({\n            status: 'running'\n          }, {\n            transform: null\n          });\n          failedJobs = cursor.count();\n\n          if (failedJobs !== 0) {\n            console.warn(\"Failing \" + failedJobs + \" jobs on queue stop.\");\n          }\n\n          cursor.forEach(function (d) {\n            return _this._DDPMethod_jobFail(d._id, d.runId, \"Running at Job Server shutdown.\");\n          });\n\n          if (_this.logStream != null) {\n            _this.logStream.end();\n\n            return _this.logStream = null;\n          }\n        };\n      }(this), options.timeout);\n    }\n\n    return true;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_stopJobs = function () {\n    var depFlag;\n    depFlag = false;\n    return function (options) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Deprecation Warning: jc.stopJobs() has been renamed to jc.shutdownJobServer()\");\n      }\n\n      return this._DDPMethod_shutdownJobServer(options);\n    };\n  }();\n\n  JobCollectionBase.prototype._DDPMethod_getJob = function (ids, options) {\n    var d, docs, fields, single;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      getLog: Match.Optional(Boolean),\n      getFailures: Match.Optional(Boolean)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n\n    if (options.getFailures == null) {\n      options.getFailures = false;\n    }\n\n    single = false;\n\n    if (_validId(ids)) {\n      ids = [ids];\n      single = true;\n    }\n\n    if (ids.length === 0) {\n      return null;\n    }\n\n    fields = {\n      _private: 0\n    };\n\n    if (!options.getLog) {\n      fields.log = 0;\n    }\n\n    if (!options.getFailures) {\n      fields.failures = 0;\n    }\n\n    docs = this.find({\n      _id: {\n        $in: ids\n      }\n    }, {\n      fields: fields,\n      transform: null\n    }).fetch();\n\n    if (docs != null ? docs.length : void 0) {\n      if (this.scrub != null) {\n        docs = function () {\n          var j, len, results;\n          results = [];\n\n          for (j = 0, len = docs.length; j < len; j++) {\n            d = docs[j];\n            results.push(this.scrub(d));\n          }\n\n          return results;\n        }.call(this);\n      }\n\n      check(docs, [_validJobDoc()]);\n\n      if (single) {\n        return docs[0];\n      } else {\n        return docs;\n      }\n    }\n\n    return null;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_getWork = function (type, options) {\n    var d, docs, foundDocs, ids, logObj, mods, num, runId, time;\n    check(type, Match.OneOf(String, [String]));\n    check(options, Match.Optional({\n      maxJobs: Match.Optional(Match.Where(_validIntGTEOne)),\n      workTimeout: Match.Optional(Match.Where(_validIntGTEOne))\n    }));\n\n    if (this.isSimulation) {\n      return;\n    }\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.maxJobs == null) {\n      options.maxJobs = 1;\n    }\n\n    if (this.stopped) {\n      return [];\n    }\n\n    if (typeof type === 'string') {\n      type = [type];\n    }\n\n    time = new Date();\n    docs = [];\n    runId = this._makeNewID();\n\n    while (docs.length < options.maxJobs) {\n      ids = this.find({\n        type: {\n          $in: type\n        },\n        status: 'ready',\n        runId: null\n      }, {\n        sort: {\n          priority: 1,\n          retryUntil: 1,\n          after: 1\n        },\n        limit: options.maxJobs - docs.length,\n        fields: {\n          _id: 1\n        },\n        transform: null\n      }).map(function (d) {\n        return d._id;\n      });\n\n      if (!((ids != null ? ids.length : void 0) > 0)) {\n        break;\n      }\n\n      mods = {\n        $set: {\n          status: 'running',\n          runId: runId,\n          updated: time\n        },\n        $inc: {\n          retries: -1,\n          retried: 1\n        }\n      };\n\n      if (logObj = this._logMessage.running(runId)) {\n        mods.$push = {\n          log: logObj\n        };\n      }\n\n      if (options.workTimeout != null) {\n        mods.$set.workTimeout = options.workTimeout;\n        mods.$set.expiresAfter = new Date(time.valueOf() + options.workTimeout);\n      } else {\n        if (mods.$unset == null) {\n          mods.$unset = {};\n        }\n\n        mods.$unset.workTimeout = \"\";\n        mods.$unset.expiresAfter = \"\";\n      }\n\n      num = this.update({\n        _id: {\n          $in: ids\n        },\n        status: 'ready',\n        runId: null\n      }, mods, {\n        multi: true\n      });\n\n      if (num > 0) {\n        foundDocs = this.find({\n          _id: {\n            $in: ids\n          },\n          runId: runId\n        }, {\n          fields: {\n            log: 0,\n            failures: 0,\n            _private: 0\n          },\n          transform: null\n        }).fetch();\n\n        if ((foundDocs != null ? foundDocs.length : void 0) > 0) {\n          if (this.scrub != null) {\n            foundDocs = function () {\n              var j, len, results;\n              results = [];\n\n              for (j = 0, len = foundDocs.length; j < len; j++) {\n                d = foundDocs[j];\n                results.push(this.scrub(d));\n              }\n\n              return results;\n            }.call(this);\n          }\n\n          check(docs, [_validJobDoc()]);\n          docs = docs.concat(foundDocs);\n        }\n      }\n    }\n\n    return docs;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRemove = function (ids, options) {\n    var num;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    num = this.remove({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusRemovable\n      }\n    });\n\n    if (num > 0) {\n      return true;\n    } else {\n      console.warn(\"jobRemove failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobPause = function (ids, options) {\n    var logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"paused\",\n        updated: time\n      }\n    };\n\n    if (logObj = this._logMessage.paused()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusPausable\n      }\n    }, mods, {\n      multi: true\n    });\n\n    if (num > 0) {\n      return true;\n    } else {\n      console.warn(\"jobPause failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobResume = function (ids, options) {\n    var logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"waiting\",\n        updated: time\n      }\n    };\n\n    if (logObj = this._logMessage.resumed()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: \"paused\",\n      updated: {\n        $ne: time\n      }\n    }, mods, {\n      multi: true\n    });\n\n    if (num > 0) {\n      this._DDPMethod_jobReady(ids);\n\n      return true;\n    } else {\n      console.warn(\"jobResume failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobReady = function (ids, options) {\n    var l, logObj, mods, now, num, query;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      force: Match.Optional(Boolean),\n      time: Match.Optional(Date)\n    }));\n\n    if (this.isSimulation) {\n      return;\n    }\n\n    now = new Date();\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.force == null) {\n      options.force = false;\n    }\n\n    if (options.time == null) {\n      options.time = now;\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    query = {\n      status: \"waiting\",\n      after: {\n        $lte: options.time\n      }\n    };\n    mods = {\n      $set: {\n        status: \"ready\",\n        updated: now\n      }\n    };\n\n    if (ids.length > 0) {\n      query._id = {\n        $in: ids\n      };\n      mods.$set.after = now;\n    }\n\n    logObj = [];\n\n    if (options.force) {\n      mods.$set.depends = [];\n      l = this._logMessage.forced();\n\n      if (l) {\n        logObj.push(l);\n      }\n    } else {\n      query.depends = {\n        $size: 0\n      };\n    }\n\n    l = this._logMessage.readied();\n\n    if (l) {\n      logObj.push(l);\n    }\n\n    if (logObj.length > 0) {\n      mods.$push = {\n        log: {\n          $each: logObj\n        }\n      };\n    }\n\n    num = this.update(query, mods, {\n      multi: true\n    });\n\n    if (num > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobCancel = function (ids, options) {\n    var cancelIds, depsCancelled, logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      antecedents: Match.Optional(Boolean),\n      dependents: Match.Optional(Boolean)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.antecedents == null) {\n      options.antecedents = false;\n    }\n\n    if (options.dependents == null) {\n      options.dependents = true;\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"cancelled\",\n        runId: null,\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      }\n    };\n\n    if (logObj = this._logMessage.cancelled()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusCancellable\n      }\n    }, mods, {\n      multi: true\n    });\n    cancelIds = this._idsOfDeps(ids, options.antecedents, options.dependents, this.jobStatusCancellable);\n    depsCancelled = false;\n\n    if (cancelIds.length > 0) {\n      depsCancelled = this._DDPMethod_jobCancel(cancelIds, options);\n    }\n\n    if (num > 0 || depsCancelled) {\n      return true;\n    } else {\n      console.warn(\"jobCancel failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRestart = function (ids, options) {\n    var depsRestarted, logObj, mods, num, query, restartIds, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      retries: Match.Optional(Match.Where(_validIntGTEZero)),\n      until: Match.Optional(Date),\n      antecedents: Match.Optional(Boolean),\n      dependents: Match.Optional(Boolean)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.retries == null) {\n      options.retries = 1;\n    }\n\n    if (options.retries > this.forever) {\n      options.retries = this.forever;\n    }\n\n    if (options.dependents == null) {\n      options.dependents = false;\n    }\n\n    if (options.antecedents == null) {\n      options.antecedents = true;\n    }\n\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n\n    if (ids.length === 0) {\n      return false;\n    }\n\n    time = new Date();\n    query = {\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusRestartable\n      }\n    };\n    mods = {\n      $set: {\n        status: \"waiting\",\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      },\n      $inc: {\n        retries: options.retries\n      }\n    };\n\n    if (logObj = this._logMessage.restarted()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    if (options.until != null) {\n      mods.$set.retryUntil = options.until;\n    }\n\n    num = this.update(query, mods, {\n      multi: true\n    });\n    restartIds = this._idsOfDeps(ids, options.antecedents, options.dependents, this.jobStatusRestartable);\n    depsRestarted = false;\n\n    if (restartIds.length > 0) {\n      depsRestarted = this._DDPMethod_jobRestart(restartIds, options);\n    }\n\n    if (num > 0 || depsRestarted) {\n      this._DDPMethod_jobReady(ids);\n\n      return true;\n    } else {\n      console.warn(\"jobRestart failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobSave = function (doc, options) {\n    var logObj, mods, newId, next, nextDate, num, ref, time;\n    check(doc, _validJobDoc());\n    check(options, Match.Optional({\n      cancelRepeats: Match.Optional(Boolean)\n    }));\n    check(doc.status, Match.Where(function (v) {\n      return Match.test(v, String) && (v === 'waiting' || v === 'paused');\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.cancelRepeats == null) {\n      options.cancelRepeats = false;\n    }\n\n    if (doc.repeats > this.forever) {\n      doc.repeats = this.forever;\n    }\n\n    if (doc.retries > this.forever) {\n      doc.retries = this.forever;\n    }\n\n    time = new Date();\n\n    if (doc.after < time) {\n      doc.after = time;\n    }\n\n    if (doc.retryUntil < time) {\n      doc.retryUntil = time;\n    }\n\n    if (doc.repeatUntil < time) {\n      doc.repeatUntil = time;\n    }\n\n    if (this.later != null && typeof doc.repeatWait !== 'number') {\n      if (!(next = (ref = this.later) != null ? ref.schedule(doc.repeatWait).next(1, doc.after) : void 0)) {\n        console.warn(\"No valid available later.js times in schedule after \" + doc.after);\n        return null;\n      }\n\n      nextDate = new Date(next);\n\n      if (!(nextDate <= doc.repeatUntil)) {\n        console.warn(\"No valid available later.js times in schedule before \" + doc.repeatUntil);\n        return null;\n      }\n\n      doc.after = nextDate;\n    } else if (this.later == null && doc.repeatWait !== 'number') {\n      console.warn(\"Later.js not loaded...\");\n      return null;\n    }\n\n    if (doc._id) {\n      mods = {\n        $set: {\n          status: 'waiting',\n          data: doc.data,\n          retries: doc.retries,\n          repeatRetries: doc.repeatRetries != null ? doc.repeatRetries : doc.retries + doc.retried,\n          retryUntil: doc.retryUntil,\n          retryWait: doc.retryWait,\n          retryBackoff: doc.retryBackoff,\n          repeats: doc.repeats,\n          repeatUntil: doc.repeatUntil,\n          repeatWait: doc.repeatWait,\n          depends: doc.depends,\n          priority: doc.priority,\n          after: doc.after,\n          updated: time\n        }\n      };\n\n      if (logObj = this._logMessage.resubmitted()) {\n        mods.$push = {\n          log: logObj\n        };\n      }\n\n      num = this.update({\n        _id: doc._id,\n        status: 'paused',\n        runId: null\n      }, mods);\n\n      if (num) {\n        this._DDPMethod_jobReady(doc._id);\n\n        return doc._id;\n      } else {\n        return null;\n      }\n    } else {\n      if (doc.repeats === this.forever && options.cancelRepeats) {\n        this.find({\n          type: doc.type,\n          status: {\n            $in: this.jobStatusCancellable\n          }\n        }, {\n          transform: null\n        }).forEach(function (_this) {\n          return function (d) {\n            return _this._DDPMethod_jobCancel(d._id, {});\n          };\n        }(this));\n      }\n\n      doc.created = time;\n      doc.log.push(this._logMessage.submitted());\n      newId = this.insert(doc);\n\n      this._DDPMethod_jobReady(newId);\n\n      return newId;\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobProgress = function (id, runId, completed, total, options) {\n    var job, mods, num, progress, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(completed, Match.Where(_validNumGTEZero));\n    check(total, Match.Where(_validNumGTZero));\n    check(options, Match.Optional({}));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (this.stopped) {\n      return null;\n    }\n\n    progress = {\n      completed: completed,\n      total: total,\n      percent: 100 * completed / total\n    };\n    check(progress, Match.Where(function (v) {\n      var ref;\n      return v.total >= v.completed && 0 <= (ref = v.percent) && ref <= 100;\n    }));\n    time = new Date();\n    job = this.findOne({\n      _id: id\n    }, {\n      fields: {\n        workTimeout: 1\n      }\n    });\n    mods = {\n      $set: {\n        progress: progress,\n        updated: time\n      }\n    };\n\n    if ((job != null ? job.workTimeout : void 0) != null) {\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout);\n    }\n\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobProgress failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobLog = function (id, runId, message, options) {\n    var job, logObj, mods, num, ref, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.OneOf(Match.Where(_validId), null));\n    check(message, String);\n    check(options, Match.Optional({\n      level: Match.Optional(Match.Where(_validLogLevel)),\n      data: Match.Optional(Object)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    time = new Date();\n    logObj = {\n      time: time,\n      runId: runId,\n      level: (ref = options.level) != null ? ref : 'info',\n      message: message\n    };\n\n    if (options.data != null) {\n      logObj.data = options.data;\n    }\n\n    job = this.findOne({\n      _id: id\n    }, {\n      fields: {\n        status: 1,\n        workTimeout: 1\n      }\n    });\n    mods = {\n      $push: {\n        log: logObj\n      },\n      $set: {\n        updated: time\n      }\n    };\n\n    if ((job != null ? job.workTimeout : void 0) != null && job.status === 'running') {\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout);\n    }\n\n    num = this.update({\n      _id: id\n    }, mods);\n\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobLog failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRerun = function (id, options) {\n    var doc;\n    check(id, Match.Where(_validId));\n    check(options, Match.Optional({\n      repeats: Match.Optional(Match.Where(_validIntGTEZero)),\n      until: Match.Optional(Date),\n      wait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj))\n    }));\n    doc = this.findOne({\n      _id: id,\n      status: \"completed\"\n    }, {\n      fields: {\n        result: 0,\n        failures: 0,\n        log: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        status: 0\n      },\n      transform: null\n    });\n\n    if (doc != null) {\n      if (options == null) {\n        options = {};\n      }\n\n      if (options.repeats == null) {\n        options.repeats = 0;\n      }\n\n      if (options.repeats > this.forever) {\n        options.repeats = this.forever;\n      }\n\n      if (options.until == null) {\n        options.until = doc.repeatUntil;\n      }\n\n      if (options.wait == null) {\n        options.wait = 0;\n      }\n\n      return this._rerun_job(doc, options.repeats, options.wait, options.until);\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobDone = function (id, runId, result, options) {\n    var after, d, doc, ids, jobId, logObj, mods, n, next, num, ref, time, wait;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(result, Object);\n    check(options, Match.Optional({\n      repeatId: Match.Optional(Boolean),\n      delayDeps: Match.Optional(Match.Where(_validIntGTEZero))\n    }));\n\n    if (options == null) {\n      options = {\n        repeatId: false\n      };\n    }\n\n    time = new Date();\n    doc = this.findOne({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, {\n      fields: {\n        log: 0,\n        failures: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        status: 0\n      },\n      transform: null\n    });\n\n    if (doc == null) {\n      if (!this.isSimulation) {\n        console.warn(\"Running job not found\", id, runId);\n      }\n\n      return false;\n    }\n\n    mods = {\n      $set: {\n        status: \"completed\",\n        result: result,\n        progress: {\n          completed: 1,\n          total: 1,\n          percent: 100\n        },\n        updated: time\n      }\n    };\n\n    if (logObj = this._logMessage.completed(runId)) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n\n    if (num === 1) {\n      if (doc.repeats > 0) {\n        if (typeof doc.repeatWait === 'number') {\n          if (doc.repeatUntil - doc.repeatWait >= time) {\n            jobId = this._rerun_job(doc);\n          }\n        } else {\n          next = (ref = this.later) != null ? ref.schedule(doc.repeatWait).next(2) : void 0;\n\n          if (next && next.length > 0) {\n            d = new Date(next[0]);\n\n            if (d - time > 500 || next.length > 1) {\n              if (d - time <= 500) {\n                d = new Date(next[1]);\n              } else {}\n\n              wait = d - time;\n\n              if (doc.repeatUntil - wait >= time) {\n                jobId = this._rerun_job(doc, doc.repeats - 1, wait);\n              }\n            }\n          }\n        }\n      }\n\n      ids = this.find({\n        depends: {\n          $all: [id]\n        }\n      }, {\n        transform: null,\n        fields: {\n          _id: 1\n        }\n      }).fetch().map(function (_this) {\n        return function (d) {\n          return d._id;\n        };\n      }(this));\n\n      if (ids.length > 0) {\n        mods = {\n          $pull: {\n            depends: id\n          },\n          $push: {\n            resolved: id\n          }\n        };\n\n        if (options.delayDeps != null) {\n          after = new Date(time.valueOf() + options.delayDeps);\n          mods.$max = {\n            after: after\n          };\n        }\n\n        if (logObj = this._logMessage.resolved(id, runId)) {\n          mods.$push.log = logObj;\n        }\n\n        n = this.update({\n          _id: {\n            $in: ids\n          }\n        }, mods, {\n          multi: true\n        });\n\n        if (n !== ids.length) {\n          console.warn(\"Not all dependent jobs were resolved \" + ids.length + \" > \" + n);\n        }\n\n        this._DDPMethod_jobReady(ids);\n      }\n\n      if (options.repeatId && jobId != null) {\n        return jobId;\n      } else {\n        return true;\n      }\n    } else {\n      console.warn(\"jobDone failed\");\n    }\n\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobFail = function (id, runId, err, options) {\n    var after, doc, logObj, mods, newStatus, num, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(err, Object);\n    check(options, Match.Optional({\n      fatal: Match.Optional(Boolean)\n    }));\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (options.fatal == null) {\n      options.fatal = false;\n    }\n\n    time = new Date();\n    doc = this.findOne({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, {\n      fields: {\n        log: 0,\n        failures: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        runId: 0,\n        status: 0\n      },\n      transform: null\n    });\n\n    if (doc == null) {\n      if (!this.isSimulation) {\n        console.warn(\"Running job not found\", id, runId);\n      }\n\n      return false;\n    }\n\n    after = function () {\n      switch (doc.retryBackoff) {\n        case 'exponential':\n          return new Date(time.valueOf() + doc.retryWait * Math.pow(2, doc.retried - 1));\n\n        default:\n          return new Date(time.valueOf() + doc.retryWait);\n      }\n    }();\n\n    newStatus = !options.fatal && doc.retries > 0 && doc.retryUntil >= after ? \"waiting\" : \"failed\";\n    err.runId = runId;\n    mods = {\n      $set: {\n        status: newStatus,\n        runId: null,\n        after: after,\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      },\n      $push: {\n        failures: err\n      }\n    };\n\n    if (logObj = this._logMessage.failed(runId, newStatus === 'failed', err)) {\n      mods.$push.log = logObj;\n    }\n\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n\n    if (newStatus === \"failed\" && num === 1) {\n      this.find({\n        depends: {\n          $all: [id]\n        }\n      }, {\n        transform: null\n      }).forEach(function (_this) {\n        return function (d) {\n          return _this._DDPMethod_jobCancel(d._id);\n        };\n      }(this));\n    }\n\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobFail failed\");\n    }\n\n    return false;\n  };\n\n  return JobCollectionBase;\n}(Mongo.Collection);\n\nshare.JobCollectionBase = JobCollectionBase;","sourceMap":{"version":3,"sources":["/packages/vsivsi_job-collection/src/shared.coffee","/src/shared.coffee.js"],"names":["JobCollectionBase","_validId","_validIntGTEOne","_validIntGTEZero","_validJobDoc","_validLaterJSObj","_validLog","_validLogLevel","_validNumGTEOne","_validNumGTEZero","_validNumGTZero","_validProgress","_validRetryBackoff","_validStatus","indexOf","item","i","l","length","extend","child","parent","key","hasProp","call","ctor","constructor","prototype","__super__","hasOwnProperty","slice","v","Match","test","Number","Math","floor","String","Job","jobStatuses","jobLogLevels","jobRetryBackoffMethods","OneOf","Mongo","Collection","ObjectID","time","Date","runId","Where","level","message","data","Optional","Object","completed","total","percent","schedules","exceptions","_id","type","status","result","failures","priority","Integer","depends","resolved","after","updated","workTimeout","expiresAfter","log","progress","retries","retried","repeatRetries","retryUntil","retryWait","retryBackoff","repeats","repeated","repeatUntil","repeatWait","created","superClass","root","options","collectionName","Error","Meteor","later","noCollectionSuffix","setDDP","connection","_createLogEntry","_logMessage","bind","id","previousJob","dependency","fatal","err","msg","value","jobPriorities","jobStatusCancellable","jobStatusPausable","jobStatusRemovable","jobStatusRestartable","forever","foreverDate","ddpMethods","ddpPermissionLevels","ddpMethodPermissions","processJobs","params","arguments","func","args","apply","concat","getJob","getWork","getJobs","readyJobs","cancelJobs","pauseJobs","resumeJobs","restartJobs","removeJobs","startJobServer","shutdownJobServer","startJobs","stopJobs","jobDocPattern","allow","deny","promote","setLogStream","logConsole","makeJob","dep","console","warn","createJob","_methodWrapper","method","ref","toLog","unblockDDPMethods","_toLog","_unblockDDPMethods","ref1","retval","user","userId","JSON","stringify","unblock","_generateMethods","baseMethodName","methodFunc","methodName","methodPrefix","methodsOut","_idsOfDeps","ids","antecedents","dependents","antsArray","dependsIds","dependsQuery","push","$elemMatch","$in","find","fields","transform","forEach","d","j","len","results","$or","_rerun_job","doc","wait","jobId","logObj","rerun","valueOf","insert","_DDPMethod_jobReady","_DDPMethod_startJobServer","check","isSimulation","stopped","clearTimeout","_DDPMethod_startJobs","depFlag","_DDPMethod_shutdownJobServer","timeout","setTimeout","_this","cursor","failedJobs","count","_DDPMethod_jobFail","logStream","end","_DDPMethod_stopJobs","_DDPMethod_getJob","docs","single","getLog","Boolean","getFailures","_private","fetch","scrub","_DDPMethod_getWork","foundDocs","mods","num","maxJobs","_makeNewID","sort","limit","map","$set","$inc","running","$push","$unset","update","multi","_DDPMethod_jobRemove","remove","_DDPMethod_jobPause","paused","_DDPMethod_jobResume","resumed","$ne","now","query","force","$lte","forced","$size","readied","$each","_DDPMethod_jobCancel","cancelIds","depsCancelled","cancelled","_DDPMethod_jobRestart","depsRestarted","restartIds","until","restarted","_DDPMethod_jobSave","newId","next","nextDate","cancelRepeats","schedule","resubmitted","submitted","_DDPMethod_jobProgress","job","findOne","_DDPMethod_jobLog","_DDPMethod_jobRerun","_DDPMethod_jobDone","n","repeatId","delayDeps","$all","$pull","$max","newStatus","pow","failed","share"],"mappings":"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","file":"/packages/vsivsi:job-collection/src/shared.coffee.map","sourcesContent":["############################################################################\n#     Copyright (C) 2014-2016 by Vaughn Iverson\n#     job-collection is free software released under the MIT/X11 license.\n#     See included LICENSE file for details.\n############################################################################\n\n_validNumGTEZero = (v) ->\n  Match.test(v, Number) and v >= 0.0\n\n_validNumGTZero = (v) ->\n  Match.test(v, Number) and v > 0.0\n\n_validNumGTEOne = (v) ->\n  Match.test(v, Number) and v >= 1.0\n\n_validIntGTEZero = (v) ->\n  _validNumGTEZero(v) and Math.floor(v) is v\n\n_validIntGTEOne = (v) ->\n  _validNumGTEOne(v) and Math.floor(v) is v\n\n_validStatus = (v) ->\n  Match.test(v, String) and v in Job.jobStatuses\n\n_validLogLevel = (v) ->\n  Match.test(v, String) and v in Job.jobLogLevels\n\n_validRetryBackoff = (v) ->\n  Match.test(v, String) and v in Job.jobRetryBackoffMethods\n\n_validId = (v) ->\n  Match.test(v, Match.OneOf(String, Mongo.Collection.ObjectID))\n\n_validLog = () ->\n  [{\n      time: Date\n      runId: Match.OneOf(Match.Where(_validId), null)\n      level: Match.Where(_validLogLevel)\n      message: String\n      data: Match.Optional Object\n  }]\n\n_validProgress = () ->\n  completed: Match.Where(_validNumGTEZero)\n  total: Match.Where(_validNumGTEZero)\n  percent: Match.Where(_validNumGTEZero)\n\n_validLaterJSObj = () ->\n  schedules: [ Object ]\n  exceptions: Match.Optional [ Object ]\n\n_validJobDoc = () ->\n  _id: Match.Optional Match.OneOf(Match.Where(_validId), null)\n  runId: Match.OneOf(Match.Where(_validId), null)\n  type: String\n  status: Match.Where _validStatus\n  data: Object\n  result: Match.Optional Object\n  failures: Match.Optional [ Object ]\n  priority: Match.Integer\n  depends: [ Match.Where(_validId) ]\n  resolved: [ Match.Where(_validId) ]\n  after: Date\n  updated: Date\n  workTimeout: Match.Optional Match.Where(_validIntGTEOne)\n  expiresAfter: Match.Optional Date\n  log: Match.Optional _validLog()\n  progress: _validProgress()\n  retries: Match.Where _validIntGTEZero\n  retried: Match.Where _validIntGTEZero\n  repeatRetries: Match.Optional Match.Where _validIntGTEZero\n  retryUntil: Date\n  retryWait: Match.Where _validIntGTEZero\n  retryBackoff: Match.Where _validRetryBackoff\n  repeats: Match.Where _validIntGTEZero\n  repeated: Match.Where _validIntGTEZero\n  repeatUntil: Date\n  repeatWait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj))\n  created: Date\n\nclass JobCollectionBase extends Mongo.Collection\n\n  constructor: (@root = 'queue', options = {}) ->\n    unless @ instanceof JobCollectionBase\n      return new JobCollectionBase(@root, options)\n\n    unless @ instanceof Mongo.Collection\n      throw new Error 'The global definition of Mongo.Collection has changed since the job-collection package was loaded. Please ensure that any packages that redefine Mongo.Collection are loaded before job-collection.'\n\n    unless Mongo.Collection is Mongo.Collection.prototype.constructor\n      throw new Meteor.Error 'The global definition of Mongo.Collection has been patched by another package, and the prototype constructor has been left in an inconsistent state. Please see this link for a workaround: https://github.com/vsivsi/meteor-file-sample-app/issues/2#issuecomment-120780592'\n\n    @later = later  # later object, for convenience\n\n    options.noCollectionSuffix ?= false\n\n    collectionName = @root\n\n    unless options.noCollectionSuffix\n      collectionName += '.jobs'\n\n    # Remove non-standard options before\n    # calling Mongo.Collection constructor\n    delete options.noCollectionSuffix\n\n    Job.setDDP(options.connection, @root)\n\n    @_createLogEntry = (message = '', runId = null, level = 'info', time = new Date(), data = null) ->\n      l = { time: time, runId: runId, message: message, level: level }\n      return l\n\n    @_logMessage =\n      'readied': (() -> @_createLogEntry \"Promoted to ready\").bind(@)\n      'forced': ((id) -> @_createLogEntry \"Dependencies force resolved\", null, 'warning').bind(@)\n      'rerun': ((id, runId) -> @_createLogEntry \"Rerunning job\", null, 'info', new Date(), {previousJob:{id:id,runId:runId}}).bind(@)\n      'running': ((runId) -> @_createLogEntry \"Job Running\", runId).bind(@)\n      'paused': (() -> @_createLogEntry \"Job Paused\").bind(@)\n      'resumed': (() -> @_createLogEntry \"Job Resumed\").bind(@)\n      'cancelled': (() -> @_createLogEntry \"Job Cancelled\", null, 'warning').bind(@)\n      'restarted': (() -> @_createLogEntry \"Job Restarted\").bind(@)\n      'resubmitted': (() -> @_createLogEntry \"Job Resubmitted\").bind(@)\n      'submitted': (() -> @_createLogEntry \"Job Submitted\").bind(@)\n      'completed': ((runId) -> @_createLogEntry \"Job Completed\", runId, 'success').bind(@)\n      'resolved': ((id, runId) -> @_createLogEntry \"Dependency resolved\", null, 'info', new Date(), {dependency:{id:id,runId:runId}}).bind(@)\n      'failed': ((runId, fatal, err) ->\n        value = err.value\n        msg = \"Job Failed with#{if fatal then ' Fatal' else ''} Error#{if value? and typeof value is 'string' then ': ' + value else ''}.\"\n        level = if fatal then 'danger' else 'warning'\n        @_createLogEntry msg, runId, level).bind(@)\n\n    # Call super's constructor\n    super collectionName, options\n\n  _validNumGTEZero: _validNumGTEZero\n  _validNumGTZero: _validNumGTZero\n  _validNumGTEOne: _validNumGTEOne\n  _validIntGTEZero: _validIntGTEZero\n  _validIntGTEOne: _validIntGTEOne\n  _validStatus: _validStatus\n  _validLogLevel: _validLogLevel\n  _validRetryBackoff: _validRetryBackoff\n  _validId: _validId\n  _validLog: _validLog\n  _validProgress: _validProgress\n  _validJobDoc: _validJobDoc\n\n  jobLogLevels: Job.jobLogLevels\n  jobPriorities: Job.jobPriorities\n  jobStatuses: Job.jobStatuses\n  jobStatusCancellable: Job.jobStatusCancellable\n  jobStatusPausable: Job.jobStatusPausable\n  jobStatusRemovable: Job.jobStatusRemovable\n  jobStatusRestartable: Job.jobStatusRestartable\n  forever: Job.forever\n  foreverDate: Job.foreverDate\n\n  ddpMethods: Job.ddpMethods\n  ddpPermissionLevels: Job.ddpPermissionLevels\n  ddpMethodPermissions: Job.ddpMethodPermissions\n\n  processJobs: (params...) -> new Job.processJobs @root, params...\n  getJob: (params...) -> Job.getJob @root, params...\n  getWork: (params...) -> Job.getWork @root, params...\n  getJobs: (params...) -> Job.getJobs @root, params...\n  readyJobs: (params...) -> Job.readyJobs @root, params...\n  cancelJobs: (params...) -> Job.cancelJobs @root, params...\n  pauseJobs: (params...) -> Job.pauseJobs @root, params...\n  resumeJobs: (params...) -> Job.resumeJobs @root, params...\n  restartJobs: (params...) -> Job.restartJobs @root, params...\n  removeJobs: (params...) -> Job.removeJobs @root, params...\n\n  setDDP: (params...) -> Job.setDDP params...\n\n  startJobServer: (params...) -> Job.startJobServer @root, params...\n  shutdownJobServer: (params...) -> Job.shutdownJobServer @root, params...\n\n  # These are deprecated and will be removed\n  startJobs: (params...) -> Job.startJobs @root, params...\n  stopJobs: (params...) -> Job.stopJobs @root, params...\n\n  jobDocPattern: _validJobDoc()\n\n  # Warning Stubs for server-only calls\n  allow: () -> throw new Error \"Server-only function jc.allow() invoked on client.\"\n  deny: () -> throw new Error \"Server-only function jc.deny() invoked on client.\"\n  promote: () -> throw new Error \"Server-only function jc.promote() invoked on client.\"\n  setLogStream: () -> throw new Error \"Server-only function jc.setLogStream() invoked on client.\"\n\n  # Warning Stubs for client-only calls\n  logConsole: () -> throw new Error \"Client-only function jc.logConsole() invoked on server.\"\n\n  # Deprecated. Remove in next major version\n  makeJob: do () ->\n    dep = false\n    (params...) ->\n      unless dep\n        dep = true\n        console.warn \"WARNING: jc.makeJob() has been deprecated. Use new Job(jc, doc) instead.\"\n      new Job @root, params...\n\n  # Deprecated. Remove in next major version\n  createJob: do () ->\n    dep = false\n    (params...) ->\n      unless dep\n        dep = true\n        console.warn \"WARNING: jc.createJob() has been deprecated. Use new Job(jc, type, data) instead.\"\n      new Job @root, params...\n\n  _methodWrapper: (method, func) ->\n    toLog = @_toLog\n    unblockDDPMethods = @_unblockDDPMethods ? false\n    # Return the wrapper function that the Meteor method will actually invoke\n    return (params...) ->\n      user = this.userId ? \"[UNAUTHENTICATED]\"\n      toLog user, method, \"params: \" + JSON.stringify(params)\n      this.unblock() if unblockDDPMethods\n      retval = func(params...)\n      toLog user, method, \"returned: \" + JSON.stringify(retval)\n      return retval\n\n  _generateMethods: () ->\n    methodsOut = {}\n    methodPrefix = '_DDPMethod_'\n    for methodName, methodFunc of @ when methodName[0...methodPrefix.length] is methodPrefix\n      baseMethodName = methodName[methodPrefix.length..]\n      methodsOut[\"#{@root}_#{baseMethodName}\"] = @_methodWrapper(baseMethodName, methodFunc.bind(@))\n    return methodsOut\n\n  _idsOfDeps: (ids, antecedents, dependents, jobStatuses) ->\n    # Cancel the entire tree of antecedents and/or dependents\n    # Dependents: jobs that list one of the ids in their depends list\n    # Antecedents: jobs with an id listed in the depends list of one of the jobs in ids\n    dependsQuery = []\n    if dependents\n      dependsQuery.push\n        depends:\n          $elemMatch:\n            $in: ids\n    if antecedents\n      antsArray = []\n      @find(\n        {\n          _id:\n            $in: ids\n        }\n        {\n          fields:\n            depends: 1\n          transform: null\n        }\n      ).forEach (d) -> antsArray.push(i) for i in d.depends unless i in antsArray\n      if antsArray.length > 0\n        dependsQuery.push\n          _id:\n            $in: antsArray\n    if dependsQuery\n      dependsIds = []\n      @find(\n        {\n          status:\n            $in: jobStatuses\n          $or: dependsQuery\n        }\n        {\n          fields:\n            _id: 1\n          transform: null\n        }\n      ).forEach (d) ->\n        dependsIds.push d._id unless d._id in dependsIds\n    return dependsIds\n\n  _rerun_job: (doc, repeats = doc.repeats - 1, wait = doc.repeatWait, repeatUntil = doc.repeatUntil) ->\n    # Repeat? if so, make a new job from the old one\n    id = doc._id\n    runId = doc.runId\n    time = new Date()\n    delete doc._id\n    delete doc.result\n    delete doc.failures\n    delete doc.expiresAfter\n    delete doc.workTimeout\n    doc.runId = null\n    doc.status = \"waiting\"\n    doc.repeatRetries = if doc.repeatRetries? then doc.repeatRetries else doc.retries + doc.retried\n    doc.retries = doc.repeatRetries\n    doc.retries = @forever if doc.retries > @forever\n    doc.retryUntil = repeatUntil\n    doc.retried = 0\n    doc.repeats = repeats\n    doc.repeats = @forever if doc.repeats > @forever\n    doc.repeatUntil = repeatUntil\n    doc.repeated = doc.repeated + 1\n    doc.updated = time\n    doc.created = time\n    doc.progress =\n      completed: 0\n      total: 1\n      percent: 0\n    if logObj = @_logMessage.rerun id, runId\n      doc.log = [logObj]\n    else\n      doc.log = []\n\n    doc.after = new Date(time.valueOf() + wait)\n    if jobId = @insert doc\n      @_DDPMethod_jobReady jobId\n      return jobId\n    else\n      console.warn \"Job rerun/repeat failed to reschedule!\", id, runId\n    return null\n\n  _DDPMethod_startJobServer: (options) ->\n    check options, Match.Optional {}\n    options ?= {}\n    # The client can't actually do this, so skip it\n    unless @isSimulation\n      Meteor.clearTimeout(@stopped) if @stopped and @stopped isnt true\n      @stopped = false\n    return true\n\n  _DDPMethod_startJobs: do () =>\n    depFlag = false\n    (options) ->\n      unless depFlag\n        depFlag = true\n        console.warn \"Deprecation Warning: jc.startJobs() has been renamed to jc.startJobServer()\"\n      return @_DDPMethod_startJobServer options\n\n  _DDPMethod_shutdownJobServer: (options) ->\n    check options, Match.Optional\n      timeout: Match.Optional(Match.Where _validIntGTEOne)\n    options ?= {}\n    options.timeout ?= 60*1000\n\n    # The client can't actually do any of this, so skip it\n    unless @isSimulation\n      Meteor.clearTimeout(@stopped) if @stopped and @stopped isnt true\n      @stopped = Meteor.setTimeout(\n        () =>\n          cursor = @find(\n            {\n              status: 'running'\n            },\n            {\n              transform: null\n            }\n          )\n          failedJobs = cursor.count()\n          console.warn \"Failing #{failedJobs} jobs on queue stop.\" if failedJobs isnt 0\n          cursor.forEach (d) => @_DDPMethod_jobFail d._id, d.runId, \"Running at Job Server shutdown.\"\n          if @logStream? # Shutting down closes the logStream!\n            @logStream.end()\n            @logStream = null\n        options.timeout\n      )\n    return true\n\n  _DDPMethod_stopJobs: do () =>\n    depFlag = false\n    (options) ->\n      unless depFlag\n        depFlag = true\n        console.warn \"Deprecation Warning: jc.stopJobs() has been renamed to jc.shutdownJobServer()\"\n      return @_DDPMethod_shutdownJobServer options\n\n  _DDPMethod_getJob: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional\n      getLog: Match.Optional Boolean\n      getFailures: Match.Optional Boolean\n    options ?= {}\n    options.getLog ?= false\n    options.getFailures ?= false\n    single = false\n    if _validId(ids)\n      ids = [ids]\n      single = true\n    return null if ids.length is 0\n    fields = {_private:0}\n    fields.log = 0 if !options.getLog\n    fields.failures = 0 if !options.getFailures\n    docs = @find(\n      {\n        _id:\n          $in: ids\n      }\n      {\n        fields: fields\n        transform: null\n      }\n    ).fetch()\n    if docs?.length\n      if @scrub?\n        docs = (@scrub d for d in docs)\n      check docs, [_validJobDoc()]\n      if single\n        return docs[0]\n      else\n        return docs\n    return null\n\n  _DDPMethod_getWork: (type, options) ->\n    check type, Match.OneOf String, [ String ]\n    check options, Match.Optional\n      maxJobs: Match.Optional(Match.Where _validIntGTEOne)\n      workTimeout: Match.Optional(Match.Where _validIntGTEOne)\n\n    # Don't simulate getWork!\n    if @isSimulation\n      return\n\n    options ?= {}\n    options.maxJobs ?= 1\n    # Don't put out any more jobs while shutting down\n    if @stopped\n      return []\n\n    # Support string types or arrays of string types\n    if typeof type is 'string'\n      type = [ type ]\n    time = new Date()\n    docs = []\n    runId = @_makeNewID() # This is meteor internal, but it will fail hard if it goes away.\n\n    while docs.length < options.maxJobs\n\n      ids = @find(\n        {\n          type:\n            $in: type\n          status: 'ready'\n          runId: null\n        }\n        {\n          sort:\n            priority: 1\n            retryUntil: 1\n            after: 1\n          limit: options.maxJobs - docs.length # never ask for more than is needed\n          fields:\n            _id: 1\n          transform: null\n        }).map (d) -> d._id\n\n      unless ids?.length > 0\n        break  # Don't keep looping when there's no available work\n\n      mods =\n        $set:\n          status: 'running'\n          runId: runId\n          updated: time\n        $inc:\n          retries: -1\n          retried: 1\n\n      if logObj = @_logMessage.running runId\n        mods.$push =\n          log: logObj\n\n      if options.workTimeout?\n        mods.$set.workTimeout = options.workTimeout\n        mods.$set.expiresAfter = new Date(time.valueOf() + options.workTimeout)\n      else\n        mods.$unset ?= {}\n        mods.$unset.workTimeout = \"\"\n        mods.$unset.expiresAfter = \"\"\n\n      num = @update(\n        {\n          _id:\n            $in: ids\n          status: 'ready'\n          runId: null\n        }\n        mods\n        {\n          multi: true\n        }\n      )\n\n      if num > 0\n        foundDocs = @find(\n          {\n            _id:\n              $in: ids\n            runId: runId\n          }\n          {\n            fields:\n              log: 0\n              failures: 0\n              _private: 0\n            transform: null\n          }\n        ).fetch()\n\n        if foundDocs?.length > 0\n          if @scrub?\n            foundDocs = (@scrub d for d in foundDocs)\n          check docs, [ _validJobDoc() ]\n          docs = docs.concat foundDocs\n        # else\n        #   console.warn \"getWork: find after update failed\"\n    return docs\n\n  _DDPMethod_jobRemove: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional {}\n    options ?= {}\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    num = @remove(\n      {\n        _id:\n          $in: ids\n        status:\n          $in: @jobStatusRemovable\n      }\n    )\n    if num > 0\n      return true\n    else\n      console.warn \"jobRemove failed\"\n    return false\n\n  _DDPMethod_jobPause: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional {}\n    options ?= {}\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    time = new Date()\n\n    mods =\n      $set:\n        status: \"paused\"\n        updated: time\n\n    if logObj = @_logMessage.paused()\n      mods.$push =\n        log: logObj\n\n    num = @update(\n      {\n        _id:\n          $in: ids\n        status:\n          $in: @jobStatusPausable\n      }\n      mods\n      {\n        multi: true\n      }\n    )\n    if num > 0\n      return true\n    else\n      console.warn \"jobPause failed\"\n    return false\n\n  _DDPMethod_jobResume: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional {}\n    options ?= {}\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    time = new Date()\n    mods =\n      $set:\n        status: \"waiting\"\n        updated: time\n\n    if logObj = @_logMessage.resumed()\n      mods.$push =\n        log: logObj\n\n    num = @update(\n      {\n        _id:\n          $in: ids\n        status: \"paused\"\n        updated:\n          $ne: time\n      }\n      mods\n      {\n        multi: true\n      }\n    )\n    if num > 0\n      @_DDPMethod_jobReady ids\n      return true\n    else\n      console.warn \"jobResume failed\"\n    return false\n\n  _DDPMethod_jobReady: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional\n      force: Match.Optional Boolean\n      time: Match.Optional Date\n\n    # Don't simulate jobReady. It has a strong chance of causing issues with\n    # Meteor on the client, particularly if an observeChanges() is triggering\n    # a processJobs queue (which in turn sets timers.)\n    if @isSimulation\n      return\n\n    now = new Date()\n\n    options ?= {}\n    options.force ?= false\n    options.time ?= now\n\n    if _validId(ids)\n      ids = [ids]\n\n    query =\n      status: \"waiting\"\n      after:\n        $lte: options.time\n\n    mods =\n      $set:\n        status: \"ready\"\n        updated: now\n\n    if ids.length > 0\n      query._id =\n        $in: ids\n      mods.$set.after = now\n\n    logObj = []\n\n    if options.force\n      mods.$set.depends = []  # Don't move to resolved, because they weren't!\n      l = @_logMessage.forced()\n      logObj.push l if l\n    else\n      query.depends =\n        $size: 0\n\n    l = @_logMessage.readied()\n    logObj.push l if l\n\n    if logObj.length > 0\n      mods.$push =\n        log:\n          $each: logObj\n\n    num = @update(\n      query\n      mods\n      {\n        multi: true\n      }\n    )\n\n    if num > 0\n      return true\n    else\n      return false\n\n  _DDPMethod_jobCancel: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional\n      antecedents: Match.Optional Boolean\n      dependents: Match.Optional Boolean\n    options ?= {}\n    options.antecedents ?= false\n    options.dependents ?= true\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    time = new Date()\n\n    mods =\n      $set:\n        status: \"cancelled\"\n        runId: null\n        progress:\n          completed: 0\n          total: 1\n          percent: 0\n        updated: time\n\n    if logObj = @_logMessage.cancelled()\n      mods.$push =\n        log: logObj\n\n    num = @update(\n      {\n        _id:\n          $in: ids\n        status:\n          $in: @jobStatusCancellable\n      }\n      mods\n      {\n        multi: true\n      }\n    )\n    # Cancel the entire tree of dependents\n    cancelIds = @_idsOfDeps ids, options.antecedents, options.dependents, @jobStatusCancellable\n\n    depsCancelled = false\n    if cancelIds.length > 0\n      depsCancelled = @_DDPMethod_jobCancel cancelIds, options\n\n    if num > 0 or depsCancelled\n      return true\n    else\n      console.warn \"jobCancel failed\"\n    return false\n\n  _DDPMethod_jobRestart: (ids, options) ->\n    check ids, Match.OneOf(Match.Where(_validId), [ Match.Where(_validId) ])\n    check options, Match.Optional\n      retries: Match.Optional(Match.Where _validIntGTEZero)\n      until: Match.Optional Date\n      antecedents: Match.Optional Boolean\n      dependents: Match.Optional Boolean\n    options ?= {}\n    options.retries ?= 1\n    options.retries = @forever if options.retries > @forever\n    options.dependents ?= false\n    options.antecedents ?= true\n    if _validId(ids)\n      ids = [ids]\n    return false if ids.length is 0\n    time = new Date()\n\n    query =\n      _id:\n        $in: ids\n      status:\n        $in: @jobStatusRestartable\n\n    mods =\n      $set:\n        status: \"waiting\"\n        progress:\n          completed: 0\n          total: 1\n          percent: 0\n        updated: time\n      $inc:\n        retries: options.retries\n\n    if logObj = @_logMessage.restarted()\n      mods.$push =\n        log: logObj\n\n    if options.until?\n      mods.$set.retryUntil = options.until\n\n    num = @update query, mods, {multi: true}\n\n    # Restart the entire tree of dependents\n    restartIds = @_idsOfDeps ids, options.antecedents, options.dependents, @jobStatusRestartable\n\n    depsRestarted = false\n    if restartIds.length > 0\n      depsRestarted = @_DDPMethod_jobRestart restartIds, options\n\n    if num > 0 or depsRestarted\n      @_DDPMethod_jobReady ids\n      return true\n    else\n      console.warn \"jobRestart failed\"\n    return false\n\n  # Job creator methods\n\n  _DDPMethod_jobSave: (doc, options) ->\n    check doc, _validJobDoc()\n    check options, Match.Optional\n      cancelRepeats: Match.Optional Boolean\n    check doc.status, Match.Where (v) ->\n      Match.test(v, String) and v in [ 'waiting', 'paused' ]\n    options ?= {}\n    options.cancelRepeats ?= false\n    doc.repeats = @forever if doc.repeats > @forever\n    doc.retries = @forever if doc.retries > @forever\n\n    time = new Date()\n\n    # This enables the default case of \"run immediately\" to\n    # not be impacted by a client's clock\n    doc.after = time if doc.after < time\n    doc.retryUntil = time if doc.retryUntil < time\n    doc.repeatUntil = time if doc.repeatUntil < time\n\n    # If doc.repeatWait is a later.js object, then don't run before\n    # the first valid scheduled time that occurs after doc.after\n    if @later? and typeof doc.repeatWait isnt 'number'\n      unless next = @later?.schedule(doc.repeatWait).next(1, doc.after)\n        console.warn \"No valid available later.js times in schedule after #{doc.after}\"\n        return null\n      nextDate = new Date(next)\n      unless nextDate <= doc.repeatUntil\n        console.warn \"No valid available later.js times in schedule before #{doc.repeatUntil}\"\n        return null\n      doc.after = nextDate\n    else if not @later? and doc.repeatWait isnt 'number'\n      console.warn \"Later.js not loaded...\"\n      return null\n\n    if doc._id\n\n      mods =\n        $set:\n          status: 'waiting'\n          data: doc.data\n          retries: doc.retries\n          repeatRetries: if doc.repeatRetries? then doc.repeatRetries else doc.retries + doc.retried\n          retryUntil: doc.retryUntil\n          retryWait: doc.retryWait\n          retryBackoff: doc.retryBackoff\n          repeats: doc.repeats\n          repeatUntil: doc.repeatUntil\n          repeatWait: doc.repeatWait\n          depends: doc.depends\n          priority: doc.priority\n          after: doc.after\n          updated: time\n\n      if logObj = @_logMessage.resubmitted()\n        mods.$push =\n          log: logObj\n\n      num = @update(\n        {\n          _id: doc._id\n          status: 'paused'\n          runId: null\n        }\n        mods\n      )\n\n      if num\n        @_DDPMethod_jobReady doc._id\n        return doc._id\n      else\n        return null\n    else\n      if doc.repeats is @forever and options.cancelRepeats\n        # If this is unlimited repeating job, then cancel any existing jobs of the same type\n        @find(\n          {\n            type: doc.type\n            status:\n              $in: @jobStatusCancellable\n          },\n          {\n            transform: null\n          }\n        ).forEach (d) => @_DDPMethod_jobCancel d._id, {}\n      doc.created = time\n      doc.log.push @_logMessage.submitted()\n      newId = @insert doc\n      @_DDPMethod_jobReady newId\n      return newId\n\n  # Worker methods\n\n  _DDPMethod_jobProgress: (id, runId, completed, total, options) ->\n    check id, Match.Where(_validId)\n    check runId, Match.Where(_validId)\n    check completed, Match.Where _validNumGTEZero\n    check total, Match.Where _validNumGTZero\n    check options, Match.Optional {}\n    options ?= {}\n\n    # Notify the worker to stop running if we are shutting down\n    if @stopped\n      return null\n\n    progress =\n      completed: completed\n      total: total\n      percent: 100*completed/total\n\n    check progress, Match.Where (v) ->\n      v.total >= v.completed and 0 <= v.percent <= 100\n\n    time = new Date()\n\n    job = @findOne { _id: id }, { fields: { workTimeout: 1 } }\n\n    mods =\n      $set:\n        progress: progress\n        updated: time\n\n    if job?.workTimeout?\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout)\n\n    num = @update(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      mods\n    )\n\n    if num is 1\n      return true\n    else\n      console.warn \"jobProgress failed\"\n    return false\n\n  _DDPMethod_jobLog: (id, runId, message, options) ->\n    check id, Match.Where(_validId)\n    check runId, Match.OneOf(Match.Where(_validId), null)\n    check message, String\n    check options, Match.Optional\n      level: Match.Optional(Match.Where _validLogLevel)\n      data: Match.Optional Object\n    options ?= {}\n    time = new Date()\n    logObj =\n        time: time\n        runId: runId\n        level: options.level ? 'info'\n        message: message\n    logObj.data = options.data if options.data?\n\n    job = @findOne { _id: id }, { fields: { status: 1, workTimeout: 1 } }\n\n    mods =\n      $push:\n        log: logObj\n      $set:\n        updated: time\n\n    if job?.workTimeout? and job.status is 'running'\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout)\n\n    num = @update(\n      {\n        _id: id\n      }\n      mods\n    )\n    if num is 1\n      return true\n    else\n      console.warn \"jobLog failed\"\n    return false\n\n  _DDPMethod_jobRerun: (id, options) ->\n    check id, Match.Where(_validId)\n    check options, Match.Optional\n      repeats: Match.Optional(Match.Where _validIntGTEZero)\n      until: Match.Optional Date\n      wait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj))\n\n    doc = @findOne(\n      {\n        _id: id\n        status: \"completed\"\n      }\n      {\n        fields:\n          result: 0\n          failures: 0\n          log: 0\n          progress: 0\n          updated: 0\n          after: 0\n          status: 0\n        transform: null\n      }\n    )\n\n    if doc?\n      options ?= {}\n      options.repeats ?= 0\n      options.repeats = @forever if options.repeats > @forever\n      options.until ?= doc.repeatUntil\n      options.wait ?= 0\n      return @_rerun_job doc, options.repeats, options.wait, options.until\n\n    return false\n\n  _DDPMethod_jobDone: (id, runId, result, options) ->\n    check id, Match.Where(_validId)\n    check runId, Match.Where(_validId)\n    check result, Object\n    check options, Match.Optional\n      repeatId: Match.Optional Boolean\n      delayDeps: Match.Optional(Match.Where(_validIntGTEZero))\n\n    options ?= { repeatId: false }\n    time = new Date()\n    doc = @findOne(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      {\n        fields:\n          log: 0\n          failures: 0\n          progress: 0\n          updated: 0\n          after: 0\n          status: 0\n        transform: null\n      }\n    )\n    unless doc?\n      unless @isSimulation\n        console.warn \"Running job not found\", id, runId\n      return false\n\n    mods =\n      $set:\n        status: \"completed\"\n        result: result\n        progress:\n          completed: 1\n          total: 1\n          percent: 100\n        updated: time\n\n    if logObj = @_logMessage.completed runId\n      mods.$push =\n        log: logObj\n\n    num = @update(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      mods\n    )\n    if num is 1\n      if doc.repeats > 0\n        if typeof doc.repeatWait is 'number'\n          if doc.repeatUntil - doc.repeatWait >= time\n            jobId = @_rerun_job doc\n        else\n          # This code prevents a job that just ran and finished\n          # instantly from being immediately rerun on the same occurance\n          next = @later?.schedule(doc.repeatWait).next(2)\n          if next and next.length > 0\n            d = new Date(next[0])\n            if (d - time > 500) or (next.length > 1)\n              if d - time <= 500\n                d = new Date(next[1])\n              else\n              wait = d - time\n              if doc.repeatUntil - wait >= time\n                jobId = @_rerun_job doc, doc.repeats - 1, wait\n\n      # Resolve depends\n      ids = @find(\n        {\n          depends:\n            $all: [ id ]\n        },\n        {\n          transform: null\n          fields:\n            _id: 1\n        }\n      ).fetch().map (d) => d._id\n\n      if ids.length > 0\n\n        mods =\n          $pull:\n            depends: id\n          $push:\n            resolved: id\n\n        if options.delayDeps?\n          after = new Date(time.valueOf() + options.delayDeps)\n          mods.$max =\n            after: after\n\n        if logObj = @_logMessage.resolved id, runId\n          mods.$push.log = logObj\n\n        n = @update(\n          {\n            _id:\n              $in: ids\n          }\n          mods\n          {\n            multi: true\n          }\n        )\n        if n isnt ids.length\n          console.warn \"Not all dependent jobs were resolved #{ids.length} > #{n}\"\n        # Try to promote any jobs that just had a dependency resolved\n        @_DDPMethod_jobReady ids\n      if options.repeatId and jobId?\n        return jobId\n      else\n        return true\n    else\n      console.warn \"jobDone failed\"\n    return false\n\n  _DDPMethod_jobFail: (id, runId, err, options) ->\n    check id, Match.Where(_validId)\n    check runId, Match.Where(_validId)\n    check err, Object\n    check options, Match.Optional\n      fatal: Match.Optional Boolean\n\n    options ?= {}\n    options.fatal ?= false\n\n    time = new Date()\n    doc = @findOne(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      {\n        fields:\n          log: 0\n          failures: 0\n          progress: 0\n          updated: 0\n          after: 0\n          runId: 0\n          status: 0\n        transform: null\n      }\n    )\n    unless doc?\n      unless @isSimulation\n        console.warn \"Running job not found\", id, runId\n      return false\n\n    after = switch doc.retryBackoff\n      when 'exponential'\n        new Date(time.valueOf() + doc.retryWait*Math.pow(2, doc.retried-1))\n      else\n        new Date(time.valueOf() + doc.retryWait)  # 'constant'\n\n    newStatus = if (not options.fatal and\n                    doc.retries > 0 and\n                    doc.retryUntil >= after) then \"waiting\" else \"failed\"\n\n    err.runId = runId  # Link each failure to the run that generated it.\n\n    mods =\n      $set:\n        status: newStatus\n        runId: null\n        after: after\n        progress:\n          completed: 0\n          total: 1\n          percent: 0\n        updated: time\n      $push:\n        failures:\n          err\n\n    if logObj = @_logMessage.failed runId, newStatus is 'failed', err\n      mods.$push.log = logObj\n\n    num = @update(\n      {\n        _id: id\n        runId: runId\n        status: \"running\"\n      }\n      mods\n    )\n    if newStatus is \"failed\" and num is 1\n      # Cancel any dependent jobs too\n      @find(\n        {\n          depends:\n            $all: [ id ]\n        },\n        {\n          transform: null\n        }\n      ).forEach (d) => @_DDPMethod_jobCancel d._id\n    if num is 1\n      return true\n    else\n      console.warn \"jobFail failed\"\n    return false\n\n# Share these methods so they'll be available on server and client\n\nshare.JobCollectionBase = JobCollectionBase\n","var JobCollectionBase, _validId, _validIntGTEOne, _validIntGTEZero, _validJobDoc, _validLaterJSObj, _validLog, _validLogLevel, _validNumGTEOne, _validNumGTEZero, _validNumGTZero, _validProgress, _validRetryBackoff, _validStatus,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  slice = [].slice;\n\n_validNumGTEZero = function(v) {\n  return Match.test(v, Number) && v >= 0.0;\n};\n\n_validNumGTZero = function(v) {\n  return Match.test(v, Number) && v > 0.0;\n};\n\n_validNumGTEOne = function(v) {\n  return Match.test(v, Number) && v >= 1.0;\n};\n\n_validIntGTEZero = function(v) {\n  return _validNumGTEZero(v) && Math.floor(v) === v;\n};\n\n_validIntGTEOne = function(v) {\n  return _validNumGTEOne(v) && Math.floor(v) === v;\n};\n\n_validStatus = function(v) {\n  return Match.test(v, String) && indexOf.call(Job.jobStatuses, v) >= 0;\n};\n\n_validLogLevel = function(v) {\n  return Match.test(v, String) && indexOf.call(Job.jobLogLevels, v) >= 0;\n};\n\n_validRetryBackoff = function(v) {\n  return Match.test(v, String) && indexOf.call(Job.jobRetryBackoffMethods, v) >= 0;\n};\n\n_validId = function(v) {\n  return Match.test(v, Match.OneOf(String, Mongo.Collection.ObjectID));\n};\n\n_validLog = function() {\n  return [\n    {\n      time: Date,\n      runId: Match.OneOf(Match.Where(_validId), null),\n      level: Match.Where(_validLogLevel),\n      message: String,\n      data: Match.Optional(Object)\n    }\n  ];\n};\n\n_validProgress = function() {\n  return {\n    completed: Match.Where(_validNumGTEZero),\n    total: Match.Where(_validNumGTEZero),\n    percent: Match.Where(_validNumGTEZero)\n  };\n};\n\n_validLaterJSObj = function() {\n  return {\n    schedules: [Object],\n    exceptions: Match.Optional([Object])\n  };\n};\n\n_validJobDoc = function() {\n  return {\n    _id: Match.Optional(Match.OneOf(Match.Where(_validId), null)),\n    runId: Match.OneOf(Match.Where(_validId), null),\n    type: String,\n    status: Match.Where(_validStatus),\n    data: Object,\n    result: Match.Optional(Object),\n    failures: Match.Optional([Object]),\n    priority: Match.Integer,\n    depends: [Match.Where(_validId)],\n    resolved: [Match.Where(_validId)],\n    after: Date,\n    updated: Date,\n    workTimeout: Match.Optional(Match.Where(_validIntGTEOne)),\n    expiresAfter: Match.Optional(Date),\n    log: Match.Optional(_validLog()),\n    progress: _validProgress(),\n    retries: Match.Where(_validIntGTEZero),\n    retried: Match.Where(_validIntGTEZero),\n    repeatRetries: Match.Optional(Match.Where(_validIntGTEZero)),\n    retryUntil: Date,\n    retryWait: Match.Where(_validIntGTEZero),\n    retryBackoff: Match.Where(_validRetryBackoff),\n    repeats: Match.Where(_validIntGTEZero),\n    repeated: Match.Where(_validIntGTEZero),\n    repeatUntil: Date,\n    repeatWait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj)),\n    created: Date\n  };\n};\n\nJobCollectionBase = (function(superClass) {\n  extend(JobCollectionBase, superClass);\n\n  function JobCollectionBase(root, options) {\n    var collectionName;\n    this.root = root != null ? root : 'queue';\n    if (options == null) {\n      options = {};\n    }\n    if (!(this instanceof JobCollectionBase)) {\n      return new JobCollectionBase(this.root, options);\n    }\n    if (!(this instanceof Mongo.Collection)) {\n      throw new Error('The global definition of Mongo.Collection has changed since the job-collection package was loaded. Please ensure that any packages that redefine Mongo.Collection are loaded before job-collection.');\n    }\n    if (Mongo.Collection !== Mongo.Collection.prototype.constructor) {\n      throw new Meteor.Error('The global definition of Mongo.Collection has been patched by another package, and the prototype constructor has been left in an inconsistent state. Please see this link for a workaround: https://github.com/vsivsi/meteor-file-sample-app/issues/2#issuecomment-120780592');\n    }\n    this.later = later;\n    if (options.noCollectionSuffix == null) {\n      options.noCollectionSuffix = false;\n    }\n    collectionName = this.root;\n    if (!options.noCollectionSuffix) {\n      collectionName += '.jobs';\n    }\n    delete options.noCollectionSuffix;\n    Job.setDDP(options.connection, this.root);\n    this._createLogEntry = function(message, runId, level, time, data) {\n      var l;\n      if (message == null) {\n        message = '';\n      }\n      if (runId == null) {\n        runId = null;\n      }\n      if (level == null) {\n        level = 'info';\n      }\n      if (time == null) {\n        time = new Date();\n      }\n      if (data == null) {\n        data = null;\n      }\n      l = {\n        time: time,\n        runId: runId,\n        message: message,\n        level: level\n      };\n      return l;\n    };\n    this._logMessage = {\n      'readied': (function() {\n        return this._createLogEntry(\"Promoted to ready\");\n      }).bind(this),\n      'forced': (function(id) {\n        return this._createLogEntry(\"Dependencies force resolved\", null, 'warning');\n      }).bind(this),\n      'rerun': (function(id, runId) {\n        return this._createLogEntry(\"Rerunning job\", null, 'info', new Date(), {\n          previousJob: {\n            id: id,\n            runId: runId\n          }\n        });\n      }).bind(this),\n      'running': (function(runId) {\n        return this._createLogEntry(\"Job Running\", runId);\n      }).bind(this),\n      'paused': (function() {\n        return this._createLogEntry(\"Job Paused\");\n      }).bind(this),\n      'resumed': (function() {\n        return this._createLogEntry(\"Job Resumed\");\n      }).bind(this),\n      'cancelled': (function() {\n        return this._createLogEntry(\"Job Cancelled\", null, 'warning');\n      }).bind(this),\n      'restarted': (function() {\n        return this._createLogEntry(\"Job Restarted\");\n      }).bind(this),\n      'resubmitted': (function() {\n        return this._createLogEntry(\"Job Resubmitted\");\n      }).bind(this),\n      'submitted': (function() {\n        return this._createLogEntry(\"Job Submitted\");\n      }).bind(this),\n      'completed': (function(runId) {\n        return this._createLogEntry(\"Job Completed\", runId, 'success');\n      }).bind(this),\n      'resolved': (function(id, runId) {\n        return this._createLogEntry(\"Dependency resolved\", null, 'info', new Date(), {\n          dependency: {\n            id: id,\n            runId: runId\n          }\n        });\n      }).bind(this),\n      'failed': (function(runId, fatal, err) {\n        var level, msg, value;\n        value = err.value;\n        msg = \"Job Failed with\" + (fatal ? ' Fatal' : '') + \" Error\" + ((value != null) && typeof value === 'string' ? ': ' + value : '') + \".\";\n        level = fatal ? 'danger' : 'warning';\n        return this._createLogEntry(msg, runId, level);\n      }).bind(this)\n    };\n    JobCollectionBase.__super__.constructor.call(this, collectionName, options);\n  }\n\n  JobCollectionBase.prototype._validNumGTEZero = _validNumGTEZero;\n\n  JobCollectionBase.prototype._validNumGTZero = _validNumGTZero;\n\n  JobCollectionBase.prototype._validNumGTEOne = _validNumGTEOne;\n\n  JobCollectionBase.prototype._validIntGTEZero = _validIntGTEZero;\n\n  JobCollectionBase.prototype._validIntGTEOne = _validIntGTEOne;\n\n  JobCollectionBase.prototype._validStatus = _validStatus;\n\n  JobCollectionBase.prototype._validLogLevel = _validLogLevel;\n\n  JobCollectionBase.prototype._validRetryBackoff = _validRetryBackoff;\n\n  JobCollectionBase.prototype._validId = _validId;\n\n  JobCollectionBase.prototype._validLog = _validLog;\n\n  JobCollectionBase.prototype._validProgress = _validProgress;\n\n  JobCollectionBase.prototype._validJobDoc = _validJobDoc;\n\n  JobCollectionBase.prototype.jobLogLevels = Job.jobLogLevels;\n\n  JobCollectionBase.prototype.jobPriorities = Job.jobPriorities;\n\n  JobCollectionBase.prototype.jobStatuses = Job.jobStatuses;\n\n  JobCollectionBase.prototype.jobStatusCancellable = Job.jobStatusCancellable;\n\n  JobCollectionBase.prototype.jobStatusPausable = Job.jobStatusPausable;\n\n  JobCollectionBase.prototype.jobStatusRemovable = Job.jobStatusRemovable;\n\n  JobCollectionBase.prototype.jobStatusRestartable = Job.jobStatusRestartable;\n\n  JobCollectionBase.prototype.forever = Job.forever;\n\n  JobCollectionBase.prototype.foreverDate = Job.foreverDate;\n\n  JobCollectionBase.prototype.ddpMethods = Job.ddpMethods;\n\n  JobCollectionBase.prototype.ddpPermissionLevels = Job.ddpPermissionLevels;\n\n  JobCollectionBase.prototype.ddpMethodPermissions = Job.ddpMethodPermissions;\n\n  JobCollectionBase.prototype.processJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return (function(func, args, ctor) {\n      ctor.prototype = func.prototype;\n      var child = new ctor, result = func.apply(child, args);\n      return Object(result) === result ? result : child;\n    })(Job.processJobs, [this.root].concat(slice.call(params)), function(){});\n  };\n\n  JobCollectionBase.prototype.getJob = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getJob.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.getWork = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getWork.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.getJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.getJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.readyJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.readyJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.cancelJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.cancelJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.pauseJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.pauseJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.resumeJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.resumeJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.restartJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.restartJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.removeJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.removeJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.setDDP = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.setDDP.apply(Job, params);\n  };\n\n  JobCollectionBase.prototype.startJobServer = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.startJobServer.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.shutdownJobServer = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.shutdownJobServer.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.startJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.startJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.stopJobs = function() {\n    var params;\n    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return Job.stopJobs.apply(Job, [this.root].concat(slice.call(params)));\n  };\n\n  JobCollectionBase.prototype.jobDocPattern = _validJobDoc();\n\n  JobCollectionBase.prototype.allow = function() {\n    throw new Error(\"Server-only function jc.allow() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.deny = function() {\n    throw new Error(\"Server-only function jc.deny() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.promote = function() {\n    throw new Error(\"Server-only function jc.promote() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.setLogStream = function() {\n    throw new Error(\"Server-only function jc.setLogStream() invoked on client.\");\n  };\n\n  JobCollectionBase.prototype.logConsole = function() {\n    throw new Error(\"Client-only function jc.logConsole() invoked on server.\");\n  };\n\n  JobCollectionBase.prototype.makeJob = (function() {\n    var dep;\n    dep = false;\n    return function() {\n      var params;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (!dep) {\n        dep = true;\n        console.warn(\"WARNING: jc.makeJob() has been deprecated. Use new Job(jc, doc) instead.\");\n      }\n      return (function(func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor, result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      })(Job, [this.root].concat(slice.call(params)), function(){});\n    };\n  })();\n\n  JobCollectionBase.prototype.createJob = (function() {\n    var dep;\n    dep = false;\n    return function() {\n      var params;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (!dep) {\n        dep = true;\n        console.warn(\"WARNING: jc.createJob() has been deprecated. Use new Job(jc, type, data) instead.\");\n      }\n      return (function(func, args, ctor) {\n        ctor.prototype = func.prototype;\n        var child = new ctor, result = func.apply(child, args);\n        return Object(result) === result ? result : child;\n      })(Job, [this.root].concat(slice.call(params)), function(){});\n    };\n  })();\n\n  JobCollectionBase.prototype._methodWrapper = function(method, func) {\n    var ref, toLog, unblockDDPMethods;\n    toLog = this._toLog;\n    unblockDDPMethods = (ref = this._unblockDDPMethods) != null ? ref : false;\n    return function() {\n      var params, ref1, retval, user;\n      params = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      user = (ref1 = this.userId) != null ? ref1 : \"[UNAUTHENTICATED]\";\n      toLog(user, method, \"params: \" + JSON.stringify(params));\n      if (unblockDDPMethods) {\n        this.unblock();\n      }\n      retval = func.apply(null, params);\n      toLog(user, method, \"returned: \" + JSON.stringify(retval));\n      return retval;\n    };\n  };\n\n  JobCollectionBase.prototype._generateMethods = function() {\n    var baseMethodName, methodFunc, methodName, methodPrefix, methodsOut, ref;\n    methodsOut = {};\n    methodPrefix = '_DDPMethod_';\n    ref = this;\n    for (methodName in ref) {\n      methodFunc = ref[methodName];\n      if (!(methodName.slice(0, methodPrefix.length) === methodPrefix)) {\n        continue;\n      }\n      baseMethodName = methodName.slice(methodPrefix.length);\n      methodsOut[this.root + \"_\" + baseMethodName] = this._methodWrapper(baseMethodName, methodFunc.bind(this));\n    }\n    return methodsOut;\n  };\n\n  JobCollectionBase.prototype._idsOfDeps = function(ids, antecedents, dependents, jobStatuses) {\n    var antsArray, dependsIds, dependsQuery;\n    dependsQuery = [];\n    if (dependents) {\n      dependsQuery.push({\n        depends: {\n          $elemMatch: {\n            $in: ids\n          }\n        }\n      });\n    }\n    if (antecedents) {\n      antsArray = [];\n      this.find({\n        _id: {\n          $in: ids\n        }\n      }, {\n        fields: {\n          depends: 1\n        },\n        transform: null\n      }).forEach(function(d) {\n        var i, j, len, ref, results;\n        if (indexOf.call(antsArray, i) < 0) {\n          ref = d.depends;\n          results = [];\n          for (j = 0, len = ref.length; j < len; j++) {\n            i = ref[j];\n            results.push(antsArray.push(i));\n          }\n          return results;\n        }\n      });\n      if (antsArray.length > 0) {\n        dependsQuery.push({\n          _id: {\n            $in: antsArray\n          }\n        });\n      }\n    }\n    if (dependsQuery) {\n      dependsIds = [];\n      this.find({\n        status: {\n          $in: jobStatuses\n        },\n        $or: dependsQuery\n      }, {\n        fields: {\n          _id: 1\n        },\n        transform: null\n      }).forEach(function(d) {\n        var ref;\n        if (ref = d._id, indexOf.call(dependsIds, ref) < 0) {\n          return dependsIds.push(d._id);\n        }\n      });\n    }\n    return dependsIds;\n  };\n\n  JobCollectionBase.prototype._rerun_job = function(doc, repeats, wait, repeatUntil) {\n    var id, jobId, logObj, runId, time;\n    if (repeats == null) {\n      repeats = doc.repeats - 1;\n    }\n    if (wait == null) {\n      wait = doc.repeatWait;\n    }\n    if (repeatUntil == null) {\n      repeatUntil = doc.repeatUntil;\n    }\n    id = doc._id;\n    runId = doc.runId;\n    time = new Date();\n    delete doc._id;\n    delete doc.result;\n    delete doc.failures;\n    delete doc.expiresAfter;\n    delete doc.workTimeout;\n    doc.runId = null;\n    doc.status = \"waiting\";\n    doc.repeatRetries = doc.repeatRetries != null ? doc.repeatRetries : doc.retries + doc.retried;\n    doc.retries = doc.repeatRetries;\n    if (doc.retries > this.forever) {\n      doc.retries = this.forever;\n    }\n    doc.retryUntil = repeatUntil;\n    doc.retried = 0;\n    doc.repeats = repeats;\n    if (doc.repeats > this.forever) {\n      doc.repeats = this.forever;\n    }\n    doc.repeatUntil = repeatUntil;\n    doc.repeated = doc.repeated + 1;\n    doc.updated = time;\n    doc.created = time;\n    doc.progress = {\n      completed: 0,\n      total: 1,\n      percent: 0\n    };\n    if (logObj = this._logMessage.rerun(id, runId)) {\n      doc.log = [logObj];\n    } else {\n      doc.log = [];\n    }\n    doc.after = new Date(time.valueOf() + wait);\n    if (jobId = this.insert(doc)) {\n      this._DDPMethod_jobReady(jobId);\n      return jobId;\n    } else {\n      console.warn(\"Job rerun/repeat failed to reschedule!\", id, runId);\n    }\n    return null;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_startJobServer = function(options) {\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (!this.isSimulation) {\n      if (this.stopped && this.stopped !== true) {\n        Meteor.clearTimeout(this.stopped);\n      }\n      this.stopped = false;\n    }\n    return true;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_startJobs = (function() {\n    var depFlag;\n    depFlag = false;\n    return function(options) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Deprecation Warning: jc.startJobs() has been renamed to jc.startJobServer()\");\n      }\n      return this._DDPMethod_startJobServer(options);\n    };\n  })();\n\n  JobCollectionBase.prototype._DDPMethod_shutdownJobServer = function(options) {\n    check(options, Match.Optional({\n      timeout: Match.Optional(Match.Where(_validIntGTEOne))\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.timeout == null) {\n      options.timeout = 60 * 1000;\n    }\n    if (!this.isSimulation) {\n      if (this.stopped && this.stopped !== true) {\n        Meteor.clearTimeout(this.stopped);\n      }\n      this.stopped = Meteor.setTimeout((function(_this) {\n        return function() {\n          var cursor, failedJobs;\n          cursor = _this.find({\n            status: 'running'\n          }, {\n            transform: null\n          });\n          failedJobs = cursor.count();\n          if (failedJobs !== 0) {\n            console.warn(\"Failing \" + failedJobs + \" jobs on queue stop.\");\n          }\n          cursor.forEach(function(d) {\n            return _this._DDPMethod_jobFail(d._id, d.runId, \"Running at Job Server shutdown.\");\n          });\n          if (_this.logStream != null) {\n            _this.logStream.end();\n            return _this.logStream = null;\n          }\n        };\n      })(this), options.timeout);\n    }\n    return true;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_stopJobs = (function() {\n    var depFlag;\n    depFlag = false;\n    return function(options) {\n      if (!depFlag) {\n        depFlag = true;\n        console.warn(\"Deprecation Warning: jc.stopJobs() has been renamed to jc.shutdownJobServer()\");\n      }\n      return this._DDPMethod_shutdownJobServer(options);\n    };\n  })();\n\n  JobCollectionBase.prototype._DDPMethod_getJob = function(ids, options) {\n    var d, docs, fields, single;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      getLog: Match.Optional(Boolean),\n      getFailures: Match.Optional(Boolean)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.getLog == null) {\n      options.getLog = false;\n    }\n    if (options.getFailures == null) {\n      options.getFailures = false;\n    }\n    single = false;\n    if (_validId(ids)) {\n      ids = [ids];\n      single = true;\n    }\n    if (ids.length === 0) {\n      return null;\n    }\n    fields = {\n      _private: 0\n    };\n    if (!options.getLog) {\n      fields.log = 0;\n    }\n    if (!options.getFailures) {\n      fields.failures = 0;\n    }\n    docs = this.find({\n      _id: {\n        $in: ids\n      }\n    }, {\n      fields: fields,\n      transform: null\n    }).fetch();\n    if (docs != null ? docs.length : void 0) {\n      if (this.scrub != null) {\n        docs = (function() {\n          var j, len, results;\n          results = [];\n          for (j = 0, len = docs.length; j < len; j++) {\n            d = docs[j];\n            results.push(this.scrub(d));\n          }\n          return results;\n        }).call(this);\n      }\n      check(docs, [_validJobDoc()]);\n      if (single) {\n        return docs[0];\n      } else {\n        return docs;\n      }\n    }\n    return null;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_getWork = function(type, options) {\n    var d, docs, foundDocs, ids, logObj, mods, num, runId, time;\n    check(type, Match.OneOf(String, [String]));\n    check(options, Match.Optional({\n      maxJobs: Match.Optional(Match.Where(_validIntGTEOne)),\n      workTimeout: Match.Optional(Match.Where(_validIntGTEOne))\n    }));\n    if (this.isSimulation) {\n      return;\n    }\n    if (options == null) {\n      options = {};\n    }\n    if (options.maxJobs == null) {\n      options.maxJobs = 1;\n    }\n    if (this.stopped) {\n      return [];\n    }\n    if (typeof type === 'string') {\n      type = [type];\n    }\n    time = new Date();\n    docs = [];\n    runId = this._makeNewID();\n    while (docs.length < options.maxJobs) {\n      ids = this.find({\n        type: {\n          $in: type\n        },\n        status: 'ready',\n        runId: null\n      }, {\n        sort: {\n          priority: 1,\n          retryUntil: 1,\n          after: 1\n        },\n        limit: options.maxJobs - docs.length,\n        fields: {\n          _id: 1\n        },\n        transform: null\n      }).map(function(d) {\n        return d._id;\n      });\n      if (!((ids != null ? ids.length : void 0) > 0)) {\n        break;\n      }\n      mods = {\n        $set: {\n          status: 'running',\n          runId: runId,\n          updated: time\n        },\n        $inc: {\n          retries: -1,\n          retried: 1\n        }\n      };\n      if (logObj = this._logMessage.running(runId)) {\n        mods.$push = {\n          log: logObj\n        };\n      }\n      if (options.workTimeout != null) {\n        mods.$set.workTimeout = options.workTimeout;\n        mods.$set.expiresAfter = new Date(time.valueOf() + options.workTimeout);\n      } else {\n        if (mods.$unset == null) {\n          mods.$unset = {};\n        }\n        mods.$unset.workTimeout = \"\";\n        mods.$unset.expiresAfter = \"\";\n      }\n      num = this.update({\n        _id: {\n          $in: ids\n        },\n        status: 'ready',\n        runId: null\n      }, mods, {\n        multi: true\n      });\n      if (num > 0) {\n        foundDocs = this.find({\n          _id: {\n            $in: ids\n          },\n          runId: runId\n        }, {\n          fields: {\n            log: 0,\n            failures: 0,\n            _private: 0\n          },\n          transform: null\n        }).fetch();\n        if ((foundDocs != null ? foundDocs.length : void 0) > 0) {\n          if (this.scrub != null) {\n            foundDocs = (function() {\n              var j, len, results;\n              results = [];\n              for (j = 0, len = foundDocs.length; j < len; j++) {\n                d = foundDocs[j];\n                results.push(this.scrub(d));\n              }\n              return results;\n            }).call(this);\n          }\n          check(docs, [_validJobDoc()]);\n          docs = docs.concat(foundDocs);\n        }\n      }\n    }\n    return docs;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRemove = function(ids, options) {\n    var num;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    num = this.remove({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusRemovable\n      }\n    });\n    if (num > 0) {\n      return true;\n    } else {\n      console.warn(\"jobRemove failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobPause = function(ids, options) {\n    var logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"paused\",\n        updated: time\n      }\n    };\n    if (logObj = this._logMessage.paused()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusPausable\n      }\n    }, mods, {\n      multi: true\n    });\n    if (num > 0) {\n      return true;\n    } else {\n      console.warn(\"jobPause failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobResume = function(ids, options) {\n    var logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"waiting\",\n        updated: time\n      }\n    };\n    if (logObj = this._logMessage.resumed()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: \"paused\",\n      updated: {\n        $ne: time\n      }\n    }, mods, {\n      multi: true\n    });\n    if (num > 0) {\n      this._DDPMethod_jobReady(ids);\n      return true;\n    } else {\n      console.warn(\"jobResume failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobReady = function(ids, options) {\n    var l, logObj, mods, now, num, query;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      force: Match.Optional(Boolean),\n      time: Match.Optional(Date)\n    }));\n    if (this.isSimulation) {\n      return;\n    }\n    now = new Date();\n    if (options == null) {\n      options = {};\n    }\n    if (options.force == null) {\n      options.force = false;\n    }\n    if (options.time == null) {\n      options.time = now;\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    query = {\n      status: \"waiting\",\n      after: {\n        $lte: options.time\n      }\n    };\n    mods = {\n      $set: {\n        status: \"ready\",\n        updated: now\n      }\n    };\n    if (ids.length > 0) {\n      query._id = {\n        $in: ids\n      };\n      mods.$set.after = now;\n    }\n    logObj = [];\n    if (options.force) {\n      mods.$set.depends = [];\n      l = this._logMessage.forced();\n      if (l) {\n        logObj.push(l);\n      }\n    } else {\n      query.depends = {\n        $size: 0\n      };\n    }\n    l = this._logMessage.readied();\n    if (l) {\n      logObj.push(l);\n    }\n    if (logObj.length > 0) {\n      mods.$push = {\n        log: {\n          $each: logObj\n        }\n      };\n    }\n    num = this.update(query, mods, {\n      multi: true\n    });\n    if (num > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobCancel = function(ids, options) {\n    var cancelIds, depsCancelled, logObj, mods, num, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      antecedents: Match.Optional(Boolean),\n      dependents: Match.Optional(Boolean)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.antecedents == null) {\n      options.antecedents = false;\n    }\n    if (options.dependents == null) {\n      options.dependents = true;\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    time = new Date();\n    mods = {\n      $set: {\n        status: \"cancelled\",\n        runId: null,\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      }\n    };\n    if (logObj = this._logMessage.cancelled()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    num = this.update({\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusCancellable\n      }\n    }, mods, {\n      multi: true\n    });\n    cancelIds = this._idsOfDeps(ids, options.antecedents, options.dependents, this.jobStatusCancellable);\n    depsCancelled = false;\n    if (cancelIds.length > 0) {\n      depsCancelled = this._DDPMethod_jobCancel(cancelIds, options);\n    }\n    if (num > 0 || depsCancelled) {\n      return true;\n    } else {\n      console.warn(\"jobCancel failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRestart = function(ids, options) {\n    var depsRestarted, logObj, mods, num, query, restartIds, time;\n    check(ids, Match.OneOf(Match.Where(_validId), [Match.Where(_validId)]));\n    check(options, Match.Optional({\n      retries: Match.Optional(Match.Where(_validIntGTEZero)),\n      until: Match.Optional(Date),\n      antecedents: Match.Optional(Boolean),\n      dependents: Match.Optional(Boolean)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.retries == null) {\n      options.retries = 1;\n    }\n    if (options.retries > this.forever) {\n      options.retries = this.forever;\n    }\n    if (options.dependents == null) {\n      options.dependents = false;\n    }\n    if (options.antecedents == null) {\n      options.antecedents = true;\n    }\n    if (_validId(ids)) {\n      ids = [ids];\n    }\n    if (ids.length === 0) {\n      return false;\n    }\n    time = new Date();\n    query = {\n      _id: {\n        $in: ids\n      },\n      status: {\n        $in: this.jobStatusRestartable\n      }\n    };\n    mods = {\n      $set: {\n        status: \"waiting\",\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      },\n      $inc: {\n        retries: options.retries\n      }\n    };\n    if (logObj = this._logMessage.restarted()) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    if (options.until != null) {\n      mods.$set.retryUntil = options.until;\n    }\n    num = this.update(query, mods, {\n      multi: true\n    });\n    restartIds = this._idsOfDeps(ids, options.antecedents, options.dependents, this.jobStatusRestartable);\n    depsRestarted = false;\n    if (restartIds.length > 0) {\n      depsRestarted = this._DDPMethod_jobRestart(restartIds, options);\n    }\n    if (num > 0 || depsRestarted) {\n      this._DDPMethod_jobReady(ids);\n      return true;\n    } else {\n      console.warn(\"jobRestart failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobSave = function(doc, options) {\n    var logObj, mods, newId, next, nextDate, num, ref, time;\n    check(doc, _validJobDoc());\n    check(options, Match.Optional({\n      cancelRepeats: Match.Optional(Boolean)\n    }));\n    check(doc.status, Match.Where(function(v) {\n      return Match.test(v, String) && (v === 'waiting' || v === 'paused');\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.cancelRepeats == null) {\n      options.cancelRepeats = false;\n    }\n    if (doc.repeats > this.forever) {\n      doc.repeats = this.forever;\n    }\n    if (doc.retries > this.forever) {\n      doc.retries = this.forever;\n    }\n    time = new Date();\n    if (doc.after < time) {\n      doc.after = time;\n    }\n    if (doc.retryUntil < time) {\n      doc.retryUntil = time;\n    }\n    if (doc.repeatUntil < time) {\n      doc.repeatUntil = time;\n    }\n    if ((this.later != null) && typeof doc.repeatWait !== 'number') {\n      if (!(next = (ref = this.later) != null ? ref.schedule(doc.repeatWait).next(1, doc.after) : void 0)) {\n        console.warn(\"No valid available later.js times in schedule after \" + doc.after);\n        return null;\n      }\n      nextDate = new Date(next);\n      if (!(nextDate <= doc.repeatUntil)) {\n        console.warn(\"No valid available later.js times in schedule before \" + doc.repeatUntil);\n        return null;\n      }\n      doc.after = nextDate;\n    } else if ((this.later == null) && doc.repeatWait !== 'number') {\n      console.warn(\"Later.js not loaded...\");\n      return null;\n    }\n    if (doc._id) {\n      mods = {\n        $set: {\n          status: 'waiting',\n          data: doc.data,\n          retries: doc.retries,\n          repeatRetries: doc.repeatRetries != null ? doc.repeatRetries : doc.retries + doc.retried,\n          retryUntil: doc.retryUntil,\n          retryWait: doc.retryWait,\n          retryBackoff: doc.retryBackoff,\n          repeats: doc.repeats,\n          repeatUntil: doc.repeatUntil,\n          repeatWait: doc.repeatWait,\n          depends: doc.depends,\n          priority: doc.priority,\n          after: doc.after,\n          updated: time\n        }\n      };\n      if (logObj = this._logMessage.resubmitted()) {\n        mods.$push = {\n          log: logObj\n        };\n      }\n      num = this.update({\n        _id: doc._id,\n        status: 'paused',\n        runId: null\n      }, mods);\n      if (num) {\n        this._DDPMethod_jobReady(doc._id);\n        return doc._id;\n      } else {\n        return null;\n      }\n    } else {\n      if (doc.repeats === this.forever && options.cancelRepeats) {\n        this.find({\n          type: doc.type,\n          status: {\n            $in: this.jobStatusCancellable\n          }\n        }, {\n          transform: null\n        }).forEach((function(_this) {\n          return function(d) {\n            return _this._DDPMethod_jobCancel(d._id, {});\n          };\n        })(this));\n      }\n      doc.created = time;\n      doc.log.push(this._logMessage.submitted());\n      newId = this.insert(doc);\n      this._DDPMethod_jobReady(newId);\n      return newId;\n    }\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobProgress = function(id, runId, completed, total, options) {\n    var job, mods, num, progress, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(completed, Match.Where(_validNumGTEZero));\n    check(total, Match.Where(_validNumGTZero));\n    check(options, Match.Optional({}));\n    if (options == null) {\n      options = {};\n    }\n    if (this.stopped) {\n      return null;\n    }\n    progress = {\n      completed: completed,\n      total: total,\n      percent: 100 * completed / total\n    };\n    check(progress, Match.Where(function(v) {\n      var ref;\n      return v.total >= v.completed && (0 <= (ref = v.percent) && ref <= 100);\n    }));\n    time = new Date();\n    job = this.findOne({\n      _id: id\n    }, {\n      fields: {\n        workTimeout: 1\n      }\n    });\n    mods = {\n      $set: {\n        progress: progress,\n        updated: time\n      }\n    };\n    if ((job != null ? job.workTimeout : void 0) != null) {\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout);\n    }\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobProgress failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobLog = function(id, runId, message, options) {\n    var job, logObj, mods, num, ref, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.OneOf(Match.Where(_validId), null));\n    check(message, String);\n    check(options, Match.Optional({\n      level: Match.Optional(Match.Where(_validLogLevel)),\n      data: Match.Optional(Object)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    time = new Date();\n    logObj = {\n      time: time,\n      runId: runId,\n      level: (ref = options.level) != null ? ref : 'info',\n      message: message\n    };\n    if (options.data != null) {\n      logObj.data = options.data;\n    }\n    job = this.findOne({\n      _id: id\n    }, {\n      fields: {\n        status: 1,\n        workTimeout: 1\n      }\n    });\n    mods = {\n      $push: {\n        log: logObj\n      },\n      $set: {\n        updated: time\n      }\n    };\n    if (((job != null ? job.workTimeout : void 0) != null) && job.status === 'running') {\n      mods.$set.expiresAfter = new Date(time.valueOf() + job.workTimeout);\n    }\n    num = this.update({\n      _id: id\n    }, mods);\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobLog failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobRerun = function(id, options) {\n    var doc;\n    check(id, Match.Where(_validId));\n    check(options, Match.Optional({\n      repeats: Match.Optional(Match.Where(_validIntGTEZero)),\n      until: Match.Optional(Date),\n      wait: Match.OneOf(Match.Where(_validIntGTEZero), Match.Where(_validLaterJSObj))\n    }));\n    doc = this.findOne({\n      _id: id,\n      status: \"completed\"\n    }, {\n      fields: {\n        result: 0,\n        failures: 0,\n        log: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        status: 0\n      },\n      transform: null\n    });\n    if (doc != null) {\n      if (options == null) {\n        options = {};\n      }\n      if (options.repeats == null) {\n        options.repeats = 0;\n      }\n      if (options.repeats > this.forever) {\n        options.repeats = this.forever;\n      }\n      if (options.until == null) {\n        options.until = doc.repeatUntil;\n      }\n      if (options.wait == null) {\n        options.wait = 0;\n      }\n      return this._rerun_job(doc, options.repeats, options.wait, options.until);\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobDone = function(id, runId, result, options) {\n    var after, d, doc, ids, jobId, logObj, mods, n, next, num, ref, time, wait;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(result, Object);\n    check(options, Match.Optional({\n      repeatId: Match.Optional(Boolean),\n      delayDeps: Match.Optional(Match.Where(_validIntGTEZero))\n    }));\n    if (options == null) {\n      options = {\n        repeatId: false\n      };\n    }\n    time = new Date();\n    doc = this.findOne({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, {\n      fields: {\n        log: 0,\n        failures: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        status: 0\n      },\n      transform: null\n    });\n    if (doc == null) {\n      if (!this.isSimulation) {\n        console.warn(\"Running job not found\", id, runId);\n      }\n      return false;\n    }\n    mods = {\n      $set: {\n        status: \"completed\",\n        result: result,\n        progress: {\n          completed: 1,\n          total: 1,\n          percent: 100\n        },\n        updated: time\n      }\n    };\n    if (logObj = this._logMessage.completed(runId)) {\n      mods.$push = {\n        log: logObj\n      };\n    }\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n    if (num === 1) {\n      if (doc.repeats > 0) {\n        if (typeof doc.repeatWait === 'number') {\n          if (doc.repeatUntil - doc.repeatWait >= time) {\n            jobId = this._rerun_job(doc);\n          }\n        } else {\n          next = (ref = this.later) != null ? ref.schedule(doc.repeatWait).next(2) : void 0;\n          if (next && next.length > 0) {\n            d = new Date(next[0]);\n            if ((d - time > 500) || (next.length > 1)) {\n              if (d - time <= 500) {\n                d = new Date(next[1]);\n              } else {\n\n              }\n              wait = d - time;\n              if (doc.repeatUntil - wait >= time) {\n                jobId = this._rerun_job(doc, doc.repeats - 1, wait);\n              }\n            }\n          }\n        }\n      }\n      ids = this.find({\n        depends: {\n          $all: [id]\n        }\n      }, {\n        transform: null,\n        fields: {\n          _id: 1\n        }\n      }).fetch().map((function(_this) {\n        return function(d) {\n          return d._id;\n        };\n      })(this));\n      if (ids.length > 0) {\n        mods = {\n          $pull: {\n            depends: id\n          },\n          $push: {\n            resolved: id\n          }\n        };\n        if (options.delayDeps != null) {\n          after = new Date(time.valueOf() + options.delayDeps);\n          mods.$max = {\n            after: after\n          };\n        }\n        if (logObj = this._logMessage.resolved(id, runId)) {\n          mods.$push.log = logObj;\n        }\n        n = this.update({\n          _id: {\n            $in: ids\n          }\n        }, mods, {\n          multi: true\n        });\n        if (n !== ids.length) {\n          console.warn(\"Not all dependent jobs were resolved \" + ids.length + \" > \" + n);\n        }\n        this._DDPMethod_jobReady(ids);\n      }\n      if (options.repeatId && (jobId != null)) {\n        return jobId;\n      } else {\n        return true;\n      }\n    } else {\n      console.warn(\"jobDone failed\");\n    }\n    return false;\n  };\n\n  JobCollectionBase.prototype._DDPMethod_jobFail = function(id, runId, err, options) {\n    var after, doc, logObj, mods, newStatus, num, time;\n    check(id, Match.Where(_validId));\n    check(runId, Match.Where(_validId));\n    check(err, Object);\n    check(options, Match.Optional({\n      fatal: Match.Optional(Boolean)\n    }));\n    if (options == null) {\n      options = {};\n    }\n    if (options.fatal == null) {\n      options.fatal = false;\n    }\n    time = new Date();\n    doc = this.findOne({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, {\n      fields: {\n        log: 0,\n        failures: 0,\n        progress: 0,\n        updated: 0,\n        after: 0,\n        runId: 0,\n        status: 0\n      },\n      transform: null\n    });\n    if (doc == null) {\n      if (!this.isSimulation) {\n        console.warn(\"Running job not found\", id, runId);\n      }\n      return false;\n    }\n    after = (function() {\n      switch (doc.retryBackoff) {\n        case 'exponential':\n          return new Date(time.valueOf() + doc.retryWait * Math.pow(2, doc.retried - 1));\n        default:\n          return new Date(time.valueOf() + doc.retryWait);\n      }\n    })();\n    newStatus = !options.fatal && doc.retries > 0 && doc.retryUntil >= after ? \"waiting\" : \"failed\";\n    err.runId = runId;\n    mods = {\n      $set: {\n        status: newStatus,\n        runId: null,\n        after: after,\n        progress: {\n          completed: 0,\n          total: 1,\n          percent: 0\n        },\n        updated: time\n      },\n      $push: {\n        failures: err\n      }\n    };\n    if (logObj = this._logMessage.failed(runId, newStatus === 'failed', err)) {\n      mods.$push.log = logObj;\n    }\n    num = this.update({\n      _id: id,\n      runId: runId,\n      status: \"running\"\n    }, mods);\n    if (newStatus === \"failed\" && num === 1) {\n      this.find({\n        depends: {\n          $all: [id]\n        }\n      }, {\n        transform: null\n      }).forEach((function(_this) {\n        return function(d) {\n          return _this._DDPMethod_jobCancel(d._id);\n        };\n      })(this));\n    }\n    if (num === 1) {\n      return true;\n    } else {\n      console.warn(\"jobFail failed\");\n    }\n    return false;\n  };\n\n  return JobCollectionBase;\n\n})(Mongo.Collection);\n\nshare.JobCollectionBase = JobCollectionBase;\n"]}}