{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/check","imported":["check","Match"],"specifiers":[{"kind":"named","imported":"check","local":"check"},{"kind":"named","imported":"Match","local":"Match"}]},{"source":"/lib/collections","imported":["Inventory"],"specifiers":[{"kind":"named","imported":"Inventory","local":"Inventory"}]},{"source":"/lib/collections/schemas","imported":["*"],"specifiers":[{"kind":"namespace","local":"Schemas"}]},{"source":"/server/api","imported":["Logger","Reaction"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/plugins/included/inventory/server/methods/statusChanges.js","filenameRelative":"/imports/plugins/included/inventory/server/methods/statusChanges.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/included/inventory/server/methods/statusChanges.js"],"names":["Meteor","check","Match","Inventory","Schemas","Logger","Reaction","methods","cartItems","status","currentStatus","notFoundStatus","CartItem","Optional","String","unblock","reservationStatus","defaultStatus","backorderStatus","reservationCount","debug","item","existingReservations","find","productId","variantId","variants","_id","shopId","orderItemId","availableInventory","totalRequiredQty","quantity","availableInventoryQty","count","existingReservationQty","backOrderQty","Number","reservation","workflow","call","newReservedQty","i","update","$set","newStatus","oldStatus","newReservation","batch","rawCollection","initializeUnorderedBulkOp","id","_makeNewID","insert","Object","assign","execute","wrapAsync","length","inventoryBackorder","inserted","nInserted","error","product","Product","inventoryItem","hasPermission","Error","remove"],"mappings":"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","file":"/imports/plugins/included/inventory/server/methods/statusChanges.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Inventory } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n// TODO statusChanges DDP limiting Disabled for now, needs more testing.\n\n// // Define a rate limiting rule that matches update attempts by non-admin users\n// const addReserveRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"subscription\",\n//   method: \"Inventory\"\n// };\n//\n// // Define a rate limiting rule that matches backorder attempts by non-admin users\n// const addBackorderRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"method\",\n//   method: \"inventory/backorder\"\n// };\n//\n// // Add the rule, allowing up to 5 messages every 1000 milliseconds.\n// DDPRateLimiter.addRule(addReserveRule, 5, 1000);\n// DDPRateLimiter.addRule(addBackorderRule, 5, 1000);\n\n//\n// Inventory methods\n//\n\nMeteor.methods({\n  /**\n   * inventory/setStatus\n   * @summary sets status from one status to a new status. Defaults to \"new\" to \"reserved\"\n   * @param  {Array} cartItems array of objects of type Schemas.CartItems\n   * @param  {String} status optional - sets the inventory workflow status, defaults to \"reserved\"\n   * @param  {String} currentStatus - what is the current status to change \"from\"\n   * @param  {String} notFoundStatus - what to use if the status is not found\n   * @todo move this to bulkOp\n   * @return {Number} returns reservationCount\n   */\n  \"inventory/setStatus\": function (cartItems, status, currentStatus, notFoundStatus) {\n    check(cartItems, [Schemas.CartItem]);\n    check(status, Match.Optional(String));\n    check(currentStatus, Match.Optional(String));\n    check(notFoundStatus, Match.Optional(String));\n    this.unblock();\n\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n\n    // set defaults\n    const reservationStatus = status || \"reserved\"; // change status to options object\n    const defaultStatus = currentStatus || \"new\"; // default to the \"new\" status\n    const backorderStatus = notFoundStatus || \"backorder\"; // change status to options object\n    let reservationCount;\n    Logger.debug(`Moving Inventory items from ${defaultStatus} to ${reservationStatus}`);\n\n    // update inventory status for cartItems\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        productId: item.productId,\n        variantId: item.variants._id,\n        shopId: item.shopId,\n        orderItemId: item._id\n      });\n\n      // define a new reservation\n      const availableInventory = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"workflow.status\": defaultStatus\n      });\n\n      const totalRequiredQty = item.quantity;\n      const availableInventoryQty = availableInventory.count();\n      let existingReservationQty = existingReservations.count();\n\n      Logger.debug(\"totalRequiredQty\", totalRequiredQty);\n      Logger.debug(\"availableInventoryQty\", availableInventoryQty);\n\n      // if we don't have existing inventory we create backorders\n      if (totalRequiredQty > availableInventoryQty) {\n        // TODO put in a dashboard setting to allow backorder or altenate handler to be used\n        const backOrderQty = Number(totalRequiredQty - availableInventoryQty - existingReservationQty);\n        Logger.debug(`no inventory found, create ${backOrderQty} ${backorderStatus}`);\n        // define a new reservation\n        const reservation = {\n          productId: item.productId,\n          variantId: item.variants._id,\n          shopId: item.shopId,\n          orderItemId: item._id,\n          workflow: {\n            status: backorderStatus\n          }\n        };\n\n        Meteor.call(\"inventory/backorder\", reservation, backOrderQty);\n        existingReservationQty = backOrderQty;\n      }\n      // if we have inventory available, only create additional required reservations\n      Logger.debug(\"existingReservationQty\", existingReservationQty);\n      reservationCount = existingReservationQty;\n      let newReservedQty;\n      if (reservationStatus === \"reserved\" && defaultStatus === \"new\") {\n        newReservedQty = totalRequiredQty - existingReservationQty + 1;\n      } else {\n        // when moving from one \"reserved\" type status, we don't need to deal with existingReservationQty\n        newReservedQty = totalRequiredQty + 1;\n      }\n\n      let i = 1;\n      while (i < newReservedQty) {\n        // updated existing new inventory to be reserved\n        Logger.debug(\n          `updating reservation status ${i} of ${newReservedQty - 1}/${totalRequiredQty} items.`);\n        // we should be updating existing inventory here.\n        // backorder process created additional backorder inventory if there\n        // wasn't enough.\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"workflow.status\": defaultStatus\n        }, {\n          $set: {\n            \"orderItemId\": item._id,\n            \"workflow.status\": reservationStatus\n          }\n        });\n        reservationCount++;\n        i++;\n      }\n    }\n    Logger.debug(\n      `finished creating ${reservationCount} new ${reservationStatus} reservations`);\n    return reservationCount;\n  },\n  /**\n   * inventory/clearStatus\n   * @summary used to reset status on inventory item (defaults to \"new\")\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @param  {[type]} status optional reset workflow.status, defaults to \"new\"\n   * @param  {[type]} currentStatus optional matching workflow.status, defaults to \"reserved\"\n   * @return {undefined} undefined\n   */\n  \"inventory/clearStatus\": function (cartItems, status, currentStatus) {\n    check(cartItems, [Schemas.CartItem]);\n    check(status, Match.Optional(String)); // workflow status\n    check(currentStatus, Match.Optional(String));\n    this.unblock();\n\n    // // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n\n    // optional workflow status or default to \"new\"\n    const newStatus = status || \"new\";\n    const oldStatus = currentStatus || \"reserved\";\n\n    // remove each cart item in inventory\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"orderItemId\": item._id,\n        \"workflow.status\": oldStatus\n      });\n      let i = existingReservations.count();\n      // reset existing cartItem reservations\n      while (i <= item.quantity) {\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"orderItemId\": item._id,\n          \"workflow.status\": oldStatus\n        }, {\n          $set: {\n            \"orderItemId\": \"\", // clear order/cart\n            \"workflow.status\": newStatus // reset status\n          }\n        });\n        i++;\n      }\n    }\n    Logger.debug(\"inventory/clearReserve\", newStatus);\n  },\n  /**\n   * inventory/clearReserve\n   * @summary resets \"reserved\" items to \"new\"\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/clearReserve\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/clearStatus\", cartItems);\n  },\n  /**\n   * inventory/clearReserve\n   * converts new items to reserved, or backorders\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/addReserve\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems);\n  },\n  /**\n   * inventory/backorder\n   * @summary is used by the cart process to create a new Inventory\n   * backorder item, but this could be used for inserting any\n   * custom inventory.\n   *\n   * A note on DDP Limits.\n   * As these are wide open we defined some ddp limiting rules http://docs.meteor.com/#/full/ddpratelimiter\n   *\n   * @param {Object} reservation Schemas.Inventory\n   * @param {Number} backOrderQty number of backorder items to create\n   * @returns {Number} number of inserted backorder documents\n   */\n  \"inventory/backorder\": function (reservation, backOrderQty) {\n    check(reservation, Schemas.Inventory);\n    check(backOrderQty, Number);\n    this.unblock();\n\n    // this use case could happen then mergeCart is fires. We don't add anything\n    // or remove, just item owner changed. We need to add this check here\n    // because of bulk operation. It thows exception if nothing to operate.\n    if (backOrderQty === 0) {\n      return 0;\n    }\n\n    // TODO inventory/backorder need to look carefully and understand is it possible ho have a\n    // negative `backOrderQty` value here?\n\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\",\"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n\n    // set defaults\n    const newReservation = reservation;\n    if (!newReservation.workflow) {\n      newReservation.workflow = {\n        status: \"backorder\"\n      };\n    }\n\n    // insert backorder\n    let i = 0;\n    const batch = Inventory.rawCollection().initializeUnorderedBulkOp();\n    if (batch) {\n      while (i < backOrderQty) {\n        const id = Inventory._makeNewID();\n        batch.insert(Object.assign({ _id: id }, newReservation));\n        i++;\n      }\n\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n      if (batch.length) {\n        const inventoryBackorder = execute();\n        const inserted = inventoryBackorder.nInserted;\n        Logger.debug(`created ${inserted} backorder records for product ${newReservation.productId}, variant ${newReservation.variantId}`);\n        return inserted;\n      }\n    }\n    //\n    // TODO implement a backup inventory/backorder method if bulk operations fail.\n    //\n    Logger.error(\"skipped bulk operations backorder updates.\");\n    return null;\n  },\n  //\n  // send low stock warnings\n  //\n  \"inventory/lowStock\": function (product) {\n    check(product, Schemas.Product);\n    //\n    // TODO implement inventory/lowstock calculations\n    // placeholder is here to give plugins a place to hook into\n    //\n    Logger.debug(\"inventory/lowStock\");\n  },\n  /**\n   * inventory/remove\n   * delete an inventory item permanently\n   * @param  {Object} inventoryItem object type Schemas.Inventory\n   * @return {String} return remove result\n   */\n  \"inventory/remove\": function (inventoryItem) {\n    check(inventoryItem, Schemas.Inventory);\n    // user needs createProduct permission to adjust inventory\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // this.unblock();\n    // todo add bulkOp here\n\n    Logger.debug(\"inventory/remove\", inventoryItem);\n    return Inventory.remove(inventoryItem);\n  },\n  /**\n   * inventory/shipped\n   * mark inventory as shipped\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/shipped\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"shipped\", \"sold\");\n  },\n  /**\n   * inventory/sold\n   * mark inventory as sold\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/sold\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"sold\", \"reserved\");\n  },\n  /**\n   * inventory/return\n   * mark inventory as returned\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/return\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"return\");\n  },\n  /**\n   * inventory/returnToStock\n   * mark inventory as return and available for sale\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/returnToStock\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/clearStatus\", cartItems, \"new\", \"return\");\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/included/inventory/server/methods/statusChanges.js.map","sourceFileName":"/imports/plugins/included/inventory/server/methods/statusChanges.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"statusChanges"},"ignored":false,"code":"var Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar check = void 0,\n    Match = void 0;\nmodule.importSync(\"meteor/check\", {\n  check: function (v) {\n    check = v;\n  },\n  Match: function (v) {\n    Match = v;\n  }\n}, 1);\nvar Inventory = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Inventory: function (v) {\n    Inventory = v;\n  }\n}, 2);\nvar Schemas = Object.create(null);\nmodule.importSync(\"/lib/collections/schemas\", {\n  \"*\": function (v, n) {\n    Schemas[n] = v;\n  }\n}, 3);\nvar Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 4);\n// TODO statusChanges DDP limiting Disabled for now, needs more testing.\n// // Define a rate limiting rule that matches update attempts by non-admin users\n// const addReserveRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"subscription\",\n//   method: \"Inventory\"\n// };\n//\n// // Define a rate limiting rule that matches backorder attempts by non-admin users\n// const addBackorderRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"method\",\n//   method: \"inventory/backorder\"\n// };\n//\n// // Add the rule, allowing up to 5 messages every 1000 milliseconds.\n// DDPRateLimiter.addRule(addReserveRule, 5, 1000);\n// DDPRateLimiter.addRule(addBackorderRule, 5, 1000);\n//\n// Inventory methods\n//\nMeteor.methods({\n  /**\n   * inventory/setStatus\n   * @summary sets status from one status to a new status. Defaults to \"new\" to \"reserved\"\n   * @param  {Array} cartItems array of objects of type Schemas.CartItems\n   * @param  {String} status optional - sets the inventory workflow status, defaults to \"reserved\"\n   * @param  {String} currentStatus - what is the current status to change \"from\"\n   * @param  {String} notFoundStatus - what to use if the status is not found\n   * @todo move this to bulkOp\n   * @return {Number} returns reservationCount\n   */\"inventory/setStatus\": function (cartItems, status, currentStatus, notFoundStatus) {\n    check(cartItems, [Schemas.CartItem]);\n    check(status, Match.Optional(String));\n    check(currentStatus, Match.Optional(String));\n    check(notFoundStatus, Match.Optional(String));\n    this.unblock(); // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n    // set defaults\n\n    var reservationStatus = status || \"reserved\"; // change status to options object\n\n    var defaultStatus = currentStatus || \"new\"; // default to the \"new\" status\n\n    var backorderStatus = notFoundStatus || \"backorder\"; // change status to options object\n\n    var reservationCount = void 0;\n    Logger.debug(\"Moving Inventory items from \" + defaultStatus + \" to \" + reservationStatus); // update inventory status for cartItems\n\n    for (var _iterator = cartItems, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var item = _ref;\n      // check of existing reserved inventory for this cart\n      var existingReservations = Inventory.find({\n        productId: item.productId,\n        variantId: item.variants._id,\n        shopId: item.shopId,\n        orderItemId: item._id\n      }); // define a new reservation\n\n      var availableInventory = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"workflow.status\": defaultStatus\n      });\n      var totalRequiredQty = item.quantity;\n      var availableInventoryQty = availableInventory.count();\n      var existingReservationQty = existingReservations.count();\n      Logger.debug(\"totalRequiredQty\", totalRequiredQty);\n      Logger.debug(\"availableInventoryQty\", availableInventoryQty); // if we don't have existing inventory we create backorders\n\n      if (totalRequiredQty > availableInventoryQty) {\n        // TODO put in a dashboard setting to allow backorder or altenate handler to be used\n        var backOrderQty = Number(totalRequiredQty - availableInventoryQty - existingReservationQty);\n        Logger.debug(\"no inventory found, create \" + backOrderQty + \" \" + backorderStatus); // define a new reservation\n\n        var reservation = {\n          productId: item.productId,\n          variantId: item.variants._id,\n          shopId: item.shopId,\n          orderItemId: item._id,\n          workflow: {\n            status: backorderStatus\n          }\n        };\n        Meteor.call(\"inventory/backorder\", reservation, backOrderQty);\n        existingReservationQty = backOrderQty;\n      } // if we have inventory available, only create additional required reservations\n\n\n      Logger.debug(\"existingReservationQty\", existingReservationQty);\n      reservationCount = existingReservationQty;\n      var newReservedQty = void 0;\n\n      if (reservationStatus === \"reserved\" && defaultStatus === \"new\") {\n        newReservedQty = totalRequiredQty - existingReservationQty + 1;\n      } else {\n        // when moving from one \"reserved\" type status, we don't need to deal with existingReservationQty\n        newReservedQty = totalRequiredQty + 1;\n      }\n\n      var i = 1;\n\n      while (i < newReservedQty) {\n        // updated existing new inventory to be reserved\n        Logger.debug(\"updating reservation status \" + i + \" of \" + (newReservedQty - 1) + \"/\" + totalRequiredQty + \" items.\"); // we should be updating existing inventory here.\n        // backorder process created additional backorder inventory if there\n        // wasn't enough.\n\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"workflow.status\": defaultStatus\n        }, {\n          $set: {\n            \"orderItemId\": item._id,\n            \"workflow.status\": reservationStatus\n          }\n        });\n        reservationCount++;\n        i++;\n      }\n    }\n\n    Logger.debug(\"finished creating \" + reservationCount + \" new \" + reservationStatus + \" reservations\");\n    return reservationCount;\n  },\n  /**\n   * inventory/clearStatus\n   * @summary used to reset status on inventory item (defaults to \"new\")\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @param  {[type]} status optional reset workflow.status, defaults to \"new\"\n   * @param  {[type]} currentStatus optional matching workflow.status, defaults to \"reserved\"\n   * @return {undefined} undefined\n   */\"inventory/clearStatus\": function (cartItems, status, currentStatus) {\n    check(cartItems, [Schemas.CartItem]);\n    check(status, Match.Optional(String)); // workflow status\n\n    check(currentStatus, Match.Optional(String));\n    this.unblock(); // // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n    // optional workflow status or default to \"new\"\n\n    var newStatus = status || \"new\";\n    var oldStatus = currentStatus || \"reserved\"; // remove each cart item in inventory\n\n    for (var _iterator2 = cartItems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var item = _ref2;\n      // check of existing reserved inventory for this cart\n      var existingReservations = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"orderItemId\": item._id,\n        \"workflow.status\": oldStatus\n      });\n      var i = existingReservations.count(); // reset existing cartItem reservations\n\n      while (i <= item.quantity) {\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"orderItemId\": item._id,\n          \"workflow.status\": oldStatus\n        }, {\n          $set: {\n            \"orderItemId\": \"\",\n            // clear order/cart\n            \"workflow.status\": newStatus // reset status\n\n          }\n        });\n        i++;\n      }\n    }\n\n    Logger.debug(\"inventory/clearReserve\", newStatus);\n  },\n  /**\n   * inventory/clearReserve\n   * @summary resets \"reserved\" items to \"new\"\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\"inventory/clearReserve\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/clearStatus\", cartItems);\n  },\n  /**\n   * inventory/clearReserve\n   * converts new items to reserved, or backorders\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\"inventory/addReserve\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems);\n  },\n  /**\n   * inventory/backorder\n   * @summary is used by the cart process to create a new Inventory\n   * backorder item, but this could be used for inserting any\n   * custom inventory.\n   *\n   * A note on DDP Limits.\n   * As these are wide open we defined some ddp limiting rules http://docs.meteor.com/#/full/ddpratelimiter\n   *\n   * @param {Object} reservation Schemas.Inventory\n   * @param {Number} backOrderQty number of backorder items to create\n   * @returns {Number} number of inserted backorder documents\n   */\"inventory/backorder\": function (reservation, backOrderQty) {\n    check(reservation, Schemas.Inventory);\n    check(backOrderQty, Number);\n    this.unblock(); // this use case could happen then mergeCart is fires. We don't add anything\n    // or remove, just item owner changed. We need to add this check here\n    // because of bulk operation. It thows exception if nothing to operate.\n\n    if (backOrderQty === 0) {\n      return 0;\n    } // TODO inventory/backorder need to look carefully and understand is it possible ho have a\n    // negative `backOrderQty` value here?\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\",\"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n    // set defaults\n\n\n    var newReservation = reservation;\n\n    if (!newReservation.workflow) {\n      newReservation.workflow = {\n        status: \"backorder\"\n      };\n    } // insert backorder\n\n\n    var i = 0;\n    var batch = Inventory.rawCollection().initializeUnorderedBulkOp();\n\n    if (batch) {\n      while (i < backOrderQty) {\n        var id = Inventory._makeNewID();\n\n        batch.insert(Object.assign({\n          _id: id\n        }, newReservation));\n        i++;\n      }\n\n      var execute = Meteor.wrapAsync(batch.execute, batch);\n\n      if (batch.length) {\n        var inventoryBackorder = execute();\n        var inserted = inventoryBackorder.nInserted;\n        Logger.debug(\"created \" + inserted + \" backorder records for product \" + newReservation.productId + \", variant \" + newReservation.variantId);\n        return inserted;\n      }\n    } //\n    // TODO implement a backup inventory/backorder method if bulk operations fail.\n    //\n\n\n    Logger.error(\"skipped bulk operations backorder updates.\");\n    return null;\n  },\n  //\n  // send low stock warnings\n  //\n  \"inventory/lowStock\": function (product) {\n    check(product, Schemas.Product); //\n    // TODO implement inventory/lowstock calculations\n    // placeholder is here to give plugins a place to hook into\n    //\n\n    Logger.debug(\"inventory/lowStock\");\n  },\n  /**\n   * inventory/remove\n   * delete an inventory item permanently\n   * @param  {Object} inventoryItem object type Schemas.Inventory\n   * @return {String} return remove result\n   */\"inventory/remove\": function (inventoryItem) {\n    check(inventoryItem, Schemas.Inventory); // user needs createProduct permission to adjust inventory\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    } // this.unblock();\n    // todo add bulkOp here\n\n\n    Logger.debug(\"inventory/remove\", inventoryItem);\n    return Inventory.remove(inventoryItem);\n  },\n  /**\n   * inventory/shipped\n   * mark inventory as shipped\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\"inventory/shipped\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"shipped\", \"sold\");\n  },\n  /**\n   * inventory/sold\n   * mark inventory as sold\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\"inventory/sold\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"sold\", \"reserved\");\n  },\n  /**\n   * inventory/return\n   * mark inventory as returned\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\"inventory/return\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"return\");\n  },\n  /**\n   * inventory/returnToStock\n   * mark inventory as return and available for sale\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\"inventory/returnToStock\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/clearStatus\", cartItems, \"new\", \"return\");\n  }\n});","map":{"version":3,"sources":["/imports/plugins/included/inventory/server/methods/statusChanges.js"],"names":["Meteor","check","Match","Inventory","Schemas","Logger","Reaction","methods","cartItems","status","currentStatus","notFoundStatus","CartItem","Optional","String","unblock","reservationStatus","defaultStatus","backorderStatus","reservationCount","debug","item","existingReservations","find","productId","variantId","variants","_id","shopId","orderItemId","availableInventory","totalRequiredQty","quantity","availableInventoryQty","count","existingReservationQty","backOrderQty","Number","reservation","workflow","call","newReservedQty","i","update","$set","newStatus","oldStatus","newReservation","batch","rawCollection","initializeUnorderedBulkOp","id","_makeNewID","insert","Object","assign","execute","wrapAsync","length","inventoryBackorder","inserted","nInserted","error","product","Product","inventoryItem","hasPermission","Error","remove"],"mappings":"AAAA,IAAS;AAAT,OAAuB,WAAvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,AAAS,A,AAAO,AAAa,AAC7B,AAAS,AAAiB,AAC1B,AAAO,AAAK,AAAa,AACzB,AAAS,AAAQ,AAAgB,AAEjC,AAEA;AACA,AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA,AAAO,AAAQ;AACb;;;AAUA,AAAuB,AAAU,AAAW,AAAQ,AAAe,AAAgB,AACjF,AAAM,AAAW,AAAC,AAAQ,AAC1B,AAAM,AAAQ,AAAM,AAAS,AAC7B,AAAM,AAAe,AAAM,AAAS,AACpC,AAAM,AAAgB,AAAM,AAAS,AACrC;;;;;;;;;KALiF,AAKjF,AAAK,AAEL;8BAEA;iCACA;wCAEA;;SAZiF,AAajF,AAAM,AAAoB,AAAU,AAAY,UALhD,CAMA;AAdiF,AAcjF,AAAM,AAAgB,AAAiB,AAAO;AAC9C;AAfiF,AAejF,AAAM,AAAkB,AAAkB,AAAa,AACvD;AAAA,AAAI,AACJ;;QAAA,AAAO,AAAO,8BAA8B,YAjBqC,AAiBjF,AAA0D,AAAM,AAAkB,AAElF;;gDACA;;AAAK,QAAL,AAAW,AAAQ,kBAAnB,AAA8B,+BAC5B;;QACA;WAAM,AAAuB,AAAU,uCAAV,AAAe,yBAAA,AAC1C,AAAW,AAAK,AAChB,oBAF0C,AAE/B,AAAK,AAAS,AACzB;;yBAH0C;AAI1C;;;;;;;;;;;UADQ,AAAK;AAH6B,AAI7B,AAAK;AANQ,AAE5B,AAA6B,AAO7B;wBACA;AAAM,iCAAqB,AAAU,AAAK,AACxC;qBADwC,AAC3B,AAAK,AAClB;qBAAa,KAF2B,AAE3B,AAAK,AAAS,AAC3B,AAAU,AAAK,AACf,AAAmB;UAJrB,AAA2B,AAO3B;;UAAM,AAAmB,+BAAzB;AACM,0BAAN,AAA8B,AAAmB,AACjD;AAAI,mCAAJ,AAA6B,AAAqB,AAElD;AAAO,kBAAP,AAAa,KAAb,AAAiC,AACjC;AAAA,AAAO,AAAM,2BAtBe,AAsB5B,AAAsC,AAEtC,AACA,AAAI,AAAmB,AAAuB,AAC5C;AARF,OAD8B;kCAU5B;UAAM,AAAe,wBAAO,mBAA5B,AAAqB,AAAO,AAAmB,AAAwB,AACvE;UAAA,AAAO,AAAO,yBAA6B,qBAHC,AAG5C,AAAwD,AAAG,AAAgB,AAC3E,AACA;aAAM,MAAc,oBAClB;mBADkB,AACP,AAAK,yBADE,AAElB,AAAW,AAAK,AAAS,AACzB,wBAHkB,AAGV,AAAK,AACb;;UAAa,AAAK,mBAJA,uBAKlB;AAAU,AACR;YAAQ,iEADA;0EALQ,kBAApB,AAUA;;YAAA,AAAO,AAAK;0BAxCc,AAyC1B,AAAyB,AAC1B,AACD;;;4BACA;AAAA,AAAO,AAAM;oBACb,AAAmB,AACnB,AAAI,AACJ,AAAI,AAAsB,AAAc,AAAkB,AAAO,AAC/D;AAJF,AAAuC,AACvC;AALE,AAAmC,AAAa,AAChD;oBAOiB,uBAAmB,aADtC,AACE,AAAiB,AAA4C,AAC9D;AAAM,iCACL;AACA,QAAA,AAAiB,AAAmB,AACrC;;;;yBAED;UAAA,AAAI,AAAI;;uEACR;AAAO,AAAI,yBAAX,AAA2B,4CACzB;aACA;AAFyB,AAEzB,AAAO,AACJ,AAA8B,AAAE,AAAM,AAAiB,AAAE,AAAG,AAAiB,AAChF,AACA;4CACA;AACA;;cAAA,AAAU,AAAO,AACf;;iBAAa,AAAK,gBADH,AAEf;AAFe,AAEF,AAAK,AAAS,AAC3B;eAHe,AAGL,AAAK,AACf,AAAmB,iFAJJ,+BAAjB,AAKG,AACD;AAAM,AACJ;AADI,AACW,AAAK,AACpB;;;4BARJ,AAKG;qCAMH;yBACA;6BACD;AAPS,AAEe;;gCAO3B,AAAO;AAAP,AACG,+BA7GQ,AA4GX,AACuB,AAAiB,AAAO,AAAkB,AACjE,AAAO,AACR,AACD;;AALG;;;;;;;;AAaH,AAAyB,AAAU,AAAW,AAAQ,AAAe,AACnE;AADmE,AACnE,AAAM,AAAW,AAAC,AAAQ,AAC1B,AAAM,AAAQ,AAAM,AAAS,AAAU,AACvC,AAAM,AAAe,AAAM,AAAS,AACpC,AAAK,AAEL,AACA,AACA,AACA,AAEA;;;;;;;;8BACA;UAAM,QAAY,MAAU,SAA5B,UACA;;UAAM,AAAY,qBAAiB,SAbgC,AAanE,AAEA;SACA,AAAK,AAAM,AAAQ,AAAW,AAC5B,WACA;AAAM,AAAuB,AAAU,AAAK,AAC1C;AAD0C,AAC7B,AAAK,AAClB;AAF0C,AAE7B,AAAK,AAAS,AAC3B,AAAU,AAAK,AACf;AAJ0C,AAI3B,AAAK,AACpB;;oBAAmB,UALuB;AAA5C,AAA6B,qCAFD,AAS5B,AAAI,AAAI,AAAqB,AAC7B,YACA;;AAAO,0BAAP,AAAiB,AAAU;AACzB;;;;;;;;;;;UADU;AACV,AAAU,AAAO,AACf;UAAa,AAAK;qBACL,KAFE,AAEF,AAAK,AAAS,AAC3B;AAAU,qBAAK,KAHA,SAIf;uBAJe,AAIA,AAAK,AACpB;4BALe,AAKI;AALrB,AAMG,2BACD,AAAM,AACJ;AANF,OAFe;cAOT,AACW,qBAAI,SACnB;;uBAAmB,UAFf,AAEyB;;4BATjC,AAMG;qCAMH;yBACD;8BACF;;AAPW;AAQL;;AAET;;;AArKa,AAmKX,AAAa,AAA0B,AACxC;AADC;;;AAQF,AAA0B,AAAU,AAAW,AAC7C;;AAAM,iBAAN,AAAiB,AAAC,AAAQ,0BAC1B;AAAA,AAAO,AAAO,AAAK,AAAyB,AAC7C;AA9KY,AA+Kb;;;;;KAMA,0BAAwB,UAAA,AAAU,WAAW,AAC3C;UAAA,AAAM,WAAW,CAAC,QAAlB,AAAiB,AAAS,AAC1B;WAAO,OAAA,AAAO,KAAP,AAAY,AAAuB,yBAA1C,AAAO,AACR;AAxLY,AAyLb;;;;;;;;;;AAaA,AAAuB,AAAU,AAAa,AAAc,AAC1D,AAAM,AAAa,AAAQ,AAC3B,AAAM,AAAc,AACpB,AAAK,AAEL,AACA,AACA,AACA,AAAI,AAAiB,AAAG,AACtB,AAAO,AACR,AAED,AACA,AAEA;;;;;;;;;;;;;+BAEA;wBACA;SAEA;AACA;AAAA,AAAM,AAAiB;;4BACvB;AAAI,AAAC,aAAL,AAAoB,AAAU,AAC5B;AAAA,AAAe,AAAW,AACxB,AAAQ,KARZ,CAOE,AAGD;AA1ByD,AA4B1D;AACA;AAAA,AAAI,AAAI,AACR;AAAA,AAAM,AAAQ,AAAU,AAAgB;AACxC,AAAI,AAAO,AACT;AAAA,AAAO,AAAI,AAAc,AACvB;;;QAAM,AAAK,iBAAX,AAAW,AAAU;;kCACrB;AAAA,AAAM,qBAAO,AAAO;AAAc,gBAAlC,AAAa,AAAc,AAAa,AACxC;AADa,AAAc,AAAE;AAE9B,MAED;;;YAAA,AAAM,AAAU,AAAO,AAAU,AAAM,AAAS;0CAChD;;QAAI,OAAJ,AAAU,AAAQ,AAChB;aAAM,kBAAN,AAA2B,AAC3B;YAAM,KAAW,UAAjB,AAAoC,AACpC;;cAAA,AAAO,cAAiB;AAAS;SAAnB,EAAd,AAAkE,AAAe,AAAU,AAAY,AAAe,AAAU,AAChI;AAAA,AAAO,AACR;AA5CuD,AA6CzD,AACD,AACA;;oDACA;;;;0CACA;AAAO,eAAP,AAAa,mBAAb,wGACA;AAAO,eAxPI,AAwPX,AACD;AACD;AACA,MACA;AACA;AAAsB,AAAU,AAAS,AACvC;;;AAAM,iBADiC,AACvC,AAAe,AAAQ,AACvB,AACA;WACA;AACA;;AACA;AAAA,AAAO,AAAM,AACd;AApQY;oCAqQb;;;;;AAMA,iBAAoB,AAAU,AAAe,AAC3C;AAD2C,AAC3C,AAAM,AAAe,AAAQ,AAC7B;AAF2C,AAG3C,AAAI,AAAC,AAAS,AAAc,AAAkB,AAC5C,AAAM,AAAI,AAAO,AAAM,AAAK,AAC7B,AACD,AACA;;;;;;UAEA,AAAO,AAAM,uBAAb,AAAiC,AACjC,YArRW,AAqRX,AAAO,AAAU,AAAO,AACzB;;kDACD;;KAHE;;;;AASF,iBAAqB,AAAU,oBAAV,AAAqB,AACxC;AAAM,WAAN,UAAiB,AAAC,OAAlB,AAAiB,AAAS,AAC1B;AAAA,AAAO,AAAO,AAAK,AAAuB,AAAW,AAAW,AACjE;AAhSY,AAiSb;;;;;KAMA,qBAAkB,UAAA,AAAU,WAAW,AACrC;UAAA,AAAM,WAAW,CAAC,QAAlB,AAAiB,AAAS,AAC1B;WAAO,OAAA,AAAO,KAAP,AAAY,uBAAZ,AAAmC,WAAnC,AAA8C,AAAQ,WAA7D,AAAO,AACR;AA1SY,AA2Sb;AAMA,AAAoB,AAAU,AAAW,AACvC;;;;;KAAA,AAAM,kBAAW,AAAC,UAAlB,AAAiB,AAAS,WAC1B;UAAO,AAAO,YAAP,AAAY,QAnTR,AAmTX,AAAO,AAAmC,AAAW,AACtD;iEACD;;AAMA,AAA2B,AAAU,AAAW,AAC9C,AAAM,AAAW,AAAC,AAAQ,AAC1B;;;;;KAAO,AAAO,oBAAP,AAAY,qBAAnB,AAAO,AAAqC,AAAW,AAAO,AAC/D;8BA9TH,AAAe","file":"/imports/plugins/included/inventory/server/methods/statusChanges.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Inventory } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n// TODO statusChanges DDP limiting Disabled for now, needs more testing.\n\n// // Define a rate limiting rule that matches update attempts by non-admin users\n// const addReserveRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"subscription\",\n//   method: \"Inventory\"\n// };\n//\n// // Define a rate limiting rule that matches backorder attempts by non-admin users\n// const addBackorderRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"method\",\n//   method: \"inventory/backorder\"\n// };\n//\n// // Add the rule, allowing up to 5 messages every 1000 milliseconds.\n// DDPRateLimiter.addRule(addReserveRule, 5, 1000);\n// DDPRateLimiter.addRule(addBackorderRule, 5, 1000);\n\n//\n// Inventory methods\n//\n\nMeteor.methods({\n  /**\n   * inventory/setStatus\n   * @summary sets status from one status to a new status. Defaults to \"new\" to \"reserved\"\n   * @param  {Array} cartItems array of objects of type Schemas.CartItems\n   * @param  {String} status optional - sets the inventory workflow status, defaults to \"reserved\"\n   * @param  {String} currentStatus - what is the current status to change \"from\"\n   * @param  {String} notFoundStatus - what to use if the status is not found\n   * @todo move this to bulkOp\n   * @return {Number} returns reservationCount\n   */\n  \"inventory/setStatus\": function (cartItems, status, currentStatus, notFoundStatus) {\n    check(cartItems, [Schemas.CartItem]);\n    check(status, Match.Optional(String));\n    check(currentStatus, Match.Optional(String));\n    check(notFoundStatus, Match.Optional(String));\n    this.unblock();\n\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n\n    // set defaults\n    const reservationStatus = status || \"reserved\"; // change status to options object\n    const defaultStatus = currentStatus || \"new\"; // default to the \"new\" status\n    const backorderStatus = notFoundStatus || \"backorder\"; // change status to options object\n    let reservationCount;\n    Logger.debug(`Moving Inventory items from ${defaultStatus} to ${reservationStatus}`);\n\n    // update inventory status for cartItems\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        productId: item.productId,\n        variantId: item.variants._id,\n        shopId: item.shopId,\n        orderItemId: item._id\n      });\n\n      // define a new reservation\n      const availableInventory = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"workflow.status\": defaultStatus\n      });\n\n      const totalRequiredQty = item.quantity;\n      const availableInventoryQty = availableInventory.count();\n      let existingReservationQty = existingReservations.count();\n\n      Logger.debug(\"totalRequiredQty\", totalRequiredQty);\n      Logger.debug(\"availableInventoryQty\", availableInventoryQty);\n\n      // if we don't have existing inventory we create backorders\n      if (totalRequiredQty > availableInventoryQty) {\n        // TODO put in a dashboard setting to allow backorder or altenate handler to be used\n        const backOrderQty = Number(totalRequiredQty - availableInventoryQty - existingReservationQty);\n        Logger.debug(`no inventory found, create ${backOrderQty} ${backorderStatus}`);\n        // define a new reservation\n        const reservation = {\n          productId: item.productId,\n          variantId: item.variants._id,\n          shopId: item.shopId,\n          orderItemId: item._id,\n          workflow: {\n            status: backorderStatus\n          }\n        };\n\n        Meteor.call(\"inventory/backorder\", reservation, backOrderQty);\n        existingReservationQty = backOrderQty;\n      }\n      // if we have inventory available, only create additional required reservations\n      Logger.debug(\"existingReservationQty\", existingReservationQty);\n      reservationCount = existingReservationQty;\n      let newReservedQty;\n      if (reservationStatus === \"reserved\" && defaultStatus === \"new\") {\n        newReservedQty = totalRequiredQty - existingReservationQty + 1;\n      } else {\n        // when moving from one \"reserved\" type status, we don't need to deal with existingReservationQty\n        newReservedQty = totalRequiredQty + 1;\n      }\n\n      let i = 1;\n      while (i < newReservedQty) {\n        // updated existing new inventory to be reserved\n        Logger.debug(\n          `updating reservation status ${i} of ${newReservedQty - 1}/${totalRequiredQty} items.`);\n        // we should be updating existing inventory here.\n        // backorder process created additional backorder inventory if there\n        // wasn't enough.\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"workflow.status\": defaultStatus\n        }, {\n          $set: {\n            \"orderItemId\": item._id,\n            \"workflow.status\": reservationStatus\n          }\n        });\n        reservationCount++;\n        i++;\n      }\n    }\n    Logger.debug(\n      `finished creating ${reservationCount} new ${reservationStatus} reservations`);\n    return reservationCount;\n  },\n  /**\n   * inventory/clearStatus\n   * @summary used to reset status on inventory item (defaults to \"new\")\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @param  {[type]} status optional reset workflow.status, defaults to \"new\"\n   * @param  {[type]} currentStatus optional matching workflow.status, defaults to \"reserved\"\n   * @return {undefined} undefined\n   */\n  \"inventory/clearStatus\": function (cartItems, status, currentStatus) {\n    check(cartItems, [Schemas.CartItem]);\n    check(status, Match.Optional(String)); // workflow status\n    check(currentStatus, Match.Optional(String));\n    this.unblock();\n\n    // // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n\n    // optional workflow status or default to \"new\"\n    const newStatus = status || \"new\";\n    const oldStatus = currentStatus || \"reserved\";\n\n    // remove each cart item in inventory\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"orderItemId\": item._id,\n        \"workflow.status\": oldStatus\n      });\n      let i = existingReservations.count();\n      // reset existing cartItem reservations\n      while (i <= item.quantity) {\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"orderItemId\": item._id,\n          \"workflow.status\": oldStatus\n        }, {\n          $set: {\n            \"orderItemId\": \"\", // clear order/cart\n            \"workflow.status\": newStatus // reset status\n          }\n        });\n        i++;\n      }\n    }\n    Logger.debug(\"inventory/clearReserve\", newStatus);\n  },\n  /**\n   * inventory/clearReserve\n   * @summary resets \"reserved\" items to \"new\"\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/clearReserve\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/clearStatus\", cartItems);\n  },\n  /**\n   * inventory/clearReserve\n   * converts new items to reserved, or backorders\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/addReserve\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems);\n  },\n  /**\n   * inventory/backorder\n   * @summary is used by the cart process to create a new Inventory\n   * backorder item, but this could be used for inserting any\n   * custom inventory.\n   *\n   * A note on DDP Limits.\n   * As these are wide open we defined some ddp limiting rules http://docs.meteor.com/#/full/ddpratelimiter\n   *\n   * @param {Object} reservation Schemas.Inventory\n   * @param {Number} backOrderQty number of backorder items to create\n   * @returns {Number} number of inserted backorder documents\n   */\n  \"inventory/backorder\": function (reservation, backOrderQty) {\n    check(reservation, Schemas.Inventory);\n    check(backOrderQty, Number);\n    this.unblock();\n\n    // this use case could happen then mergeCart is fires. We don't add anything\n    // or remove, just item owner changed. We need to add this check here\n    // because of bulk operation. It thows exception if nothing to operate.\n    if (backOrderQty === 0) {\n      return 0;\n    }\n\n    // TODO inventory/backorder need to look carefully and understand is it possible ho have a\n    // negative `backOrderQty` value here?\n\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\",\"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n\n    // set defaults\n    const newReservation = reservation;\n    if (!newReservation.workflow) {\n      newReservation.workflow = {\n        status: \"backorder\"\n      };\n    }\n\n    // insert backorder\n    let i = 0;\n    const batch = Inventory.rawCollection().initializeUnorderedBulkOp();\n    if (batch) {\n      while (i < backOrderQty) {\n        const id = Inventory._makeNewID();\n        batch.insert(Object.assign({ _id: id }, newReservation));\n        i++;\n      }\n\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n      if (batch.length) {\n        const inventoryBackorder = execute();\n        const inserted = inventoryBackorder.nInserted;\n        Logger.debug(`created ${inserted} backorder records for product ${newReservation.productId}, variant ${newReservation.variantId}`);\n        return inserted;\n      }\n    }\n    //\n    // TODO implement a backup inventory/backorder method if bulk operations fail.\n    //\n    Logger.error(\"skipped bulk operations backorder updates.\");\n    return null;\n  },\n  //\n  // send low stock warnings\n  //\n  \"inventory/lowStock\": function (product) {\n    check(product, Schemas.Product);\n    //\n    // TODO implement inventory/lowstock calculations\n    // placeholder is here to give plugins a place to hook into\n    //\n    Logger.debug(\"inventory/lowStock\");\n  },\n  /**\n   * inventory/remove\n   * delete an inventory item permanently\n   * @param  {Object} inventoryItem object type Schemas.Inventory\n   * @return {String} return remove result\n   */\n  \"inventory/remove\": function (inventoryItem) {\n    check(inventoryItem, Schemas.Inventory);\n    // user needs createProduct permission to adjust inventory\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // this.unblock();\n    // todo add bulkOp here\n\n    Logger.debug(\"inventory/remove\", inventoryItem);\n    return Inventory.remove(inventoryItem);\n  },\n  /**\n   * inventory/shipped\n   * mark inventory as shipped\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/shipped\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"shipped\", \"sold\");\n  },\n  /**\n   * inventory/sold\n   * mark inventory as sold\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/sold\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"sold\", \"reserved\");\n  },\n  /**\n   * inventory/return\n   * mark inventory as returned\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/return\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"return\");\n  },\n  /**\n   * inventory/returnToStock\n   * mark inventory as return and available for sale\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/returnToStock\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/clearStatus\", cartItems, \"new\", \"return\");\n  }\n});\n"]},"hash":"215beb85447d2d50d28964c922cea30e12928fe1"}
