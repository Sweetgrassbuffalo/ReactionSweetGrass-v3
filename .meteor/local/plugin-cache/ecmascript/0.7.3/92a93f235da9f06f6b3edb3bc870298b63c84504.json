{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"/lib/collections","imported":["*"],"specifiers":[{"kind":"namespace","local":"Collections"}]},{"source":"/server/api","imported":["Reaction"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/security/collections.js","filenameRelative":"/server/security/collections.js","inputSourceMap":{"version":3,"sources":["/server/security/collections.js"],"names":["Collections","Reaction","Accounts","Cart","Packages","Emails","Jobs","Media","Orders","Products","Shipping","Shops","Tags","Templates","Translations","Security","defineMethod","fetch","deny","type","arg","userId","doc","shopId","getShopId","_id","metadata","sessionId","permit","collections","ifHasRole","role","group","ifShopIdMatches","exceptProps","allowInClientCode","ifFileBelongsToShop","ifShopIdMatchesThisId","ifUserIdMatches","ifSessionIdMatches","_","each","fsCollection","allow","download","insert","update","remove"],"mappings":"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","file":"/server/security/collections.js.map","sourcesContent":["import * as Collections from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nconst {\n  Accounts,\n  Cart,\n  Packages,\n  Emails,\n  Jobs,\n  Media,\n  Orders,\n  Products,\n  Shipping,\n  Shops,\n  Tags,\n  Templates,\n  Translations\n} = Collections;\n\n/**\n * security definitions\n *\n * The following security definitions use the ongoworks:security package.\n * Rules within a single chain stack with AND relationship. Multiple\n * chains for the same collection stack with OR relationship.\n * See https://github.com/ongoworks/meteor-security\n *\n * It\"s important to note that these security rules are for inserts,\n * updates, and removes initiated from untrusted (client) code.\n * Thus there may be other actions that certain roles are allowed to\n * take, but they do not necessarily need to be listed here if the\n * database operation is executed in a server method.\n */\n\nexport default function () {\n  /*\n   * Define some additional rule chain methods\n   */\n  // use this rule for collections other than Shops\n  // matches this.shopId\n  Security.defineMethod(\"ifShopIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.shopId !== Reaction.getShopId();\n    }\n  });\n  // this rule is for the Shops collection\n  // use ifShopIdMatches for match on this._id\n  Security.defineMethod(\"ifShopIdMatchesThisId\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc._id !== Reaction.getShopId();\n    }\n  });\n\n  Security.defineMethod(\"ifFileBelongsToShop\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.metadata.shopId !== Reaction.getShopId();\n    }\n  });\n\n  Security.defineMethod(\"ifUserIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return userId && doc.userId && doc.userId !== userId || doc.userId && !userId;\n    }\n  });\n\n  Security.defineMethod(\"ifUserIdMatchesProp\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc[arg] !== userId;\n    }\n  });\n\n  // todo do we need this?\n  Security.defineMethod(\"ifSessionIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.sessionId !== Reaction.sessionId;\n    }\n  });\n\n  /**\n   * Define all security rules\n   */\n\n  /**\n   * admin security\n   * Permissive security for users with the \"admin\" role\n   */\n\n  Security.permit([\"insert\", \"update\", \"remove\"]).collections([\n    Accounts,\n    Products,\n    Tags,\n    Translations,\n    Shipping,\n    Orders,\n    Packages,\n    Templates,\n    Jobs\n  ]).ifHasRole({\n    role: \"admin\",\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().exceptProps([\"shopId\"]).allowInClientCode();\n\n  /*\n   * Permissive security for users with the \"admin\" role for FS.Collections\n   */\n\n  Security.permit([\"insert\", \"update\", \"remove\"]).collections([Media]).ifHasRole({\n    role: [\"admin\", \"owner\", \"createProduct\"],\n    group: Reaction.getShopId()\n  }).ifFileBelongsToShop().allowInClientCode();\n\n  /*\n   * Users with the \"admin\" or \"owner\" role may update and\n   * remove their shop but may not insert one.\n   */\n\n  Shops.permit([\"update\", \"remove\"]).ifHasRole({\n    role: [\"admin\", \"owner\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatchesThisId().allowInClientCode();\n\n  /*\n   * Users with the \"admin\" or \"owner\" role may update and\n   * remove products, but createProduct allows just for just a product editor\n   */\n\n  Products.permit([\"insert\", \"update\", \"remove\"]).ifHasRole({\n    role: [\"createProduct\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().allowInClientCode();\n\n  /*\n   * Users with the \"owner\" role may remove orders for their shop\n   */\n\n  Orders.permit(\"remove\").ifHasRole({\n    role: [\"admin\", \"owner\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().exceptProps([\"shopId\"]).allowInClientCode();\n\n  /*\n   * Can update cart from client. Must insert/remove carts using\n   * server methods.\n   * Can update all session carts if not logged in or user cart if logged in as that user\n   * XXX should verify session match, but doesn't seem possible? Might have to move all cart updates to server methods, too?\n   */\n\n  Cart.permit([\"insert\", \"update\", \"remove\"]).ifHasRole({\n    role: [\"anonymous\", \"guest\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().ifUserIdMatches().ifSessionIdMatches().allowInClientCode();\n\n  /*\n   * Users may update their own account\n   */\n  Collections.Accounts.permit([\"insert\", \"update\"]).ifHasRole({\n    role: [\"anonymous\", \"guest\"],\n    group: Reaction.getShopId()\n  }).ifUserIdMatches().allowInClientCode();\n\n  /*\n   * apply download permissions to file collections\n   */\n  _.each([Media], function (fsCollection) {\n    return fsCollection.allow({\n      download: function () {\n        return true;\n      }\n    });\n  });\n\n  /**\n   * Emails - Deny all client side ops\n   */\n  Emails.deny({\n    insert: () => true,\n    update: () => true,\n    remove: () => true\n  });\n}\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/security/collections.js.map","sourceFileName":"/server/security/collections.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"collections"},"ignored":false,"code":"var Collections = Object.create(null);\nmodule.importSync(\"/lib/collections\", {\n  \"*\": function (v, n) {\n    Collections[n] = v;\n  }\n}, 0);\nvar Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 1);\nvar Accounts = Collections.Accounts,\n    Cart = Collections.Cart,\n    Packages = Collections.Packages,\n    Emails = Collections.Emails,\n    Jobs = Collections.Jobs,\n    Media = Collections.Media,\n    Orders = Collections.Orders,\n    Products = Collections.Products,\n    Shipping = Collections.Shipping,\n    Shops = Collections.Shops,\n    Tags = Collections.Tags,\n    Templates = Collections.Templates,\n    Translations = Collections.Translations; /**\n                                              * security definitions\n                                              *\n                                              * The following security definitions use the ongoworks:security package.\n                                              * Rules within a single chain stack with AND relationship. Multiple\n                                              * chains for the same collection stack with OR relationship.\n                                              * See https://github.com/ongoworks/meteor-security\n                                              *\n                                              * It\"s important to note that these security rules are for inserts,\n                                              * updates, and removes initiated from untrusted (client) code.\n                                              * Thus there may be other actions that certain roles are allowed to\n                                              * take, but they do not necessarily need to be listed here if the\n                                              * database operation is executed in a server method.\n                                              */\nmodule.export(\"default\", exports.default = function () {\n  /*\n   * Define some additional rule chain methods\n   */ // use this rule for collections other than Shops\n  // matches this.shopId\n  Security.defineMethod(\"ifShopIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.shopId !== Reaction.getShopId();\n    }\n  }); // this rule is for the Shops collection\n  // use ifShopIdMatches for match on this._id\n\n  Security.defineMethod(\"ifShopIdMatchesThisId\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc._id !== Reaction.getShopId();\n    }\n  });\n  Security.defineMethod(\"ifFileBelongsToShop\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.metadata.shopId !== Reaction.getShopId();\n    }\n  });\n  Security.defineMethod(\"ifUserIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return userId && doc.userId && doc.userId !== userId || doc.userId && !userId;\n    }\n  });\n  Security.defineMethod(\"ifUserIdMatchesProp\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc[arg] !== userId;\n    }\n  }); // todo do we need this?\n\n  Security.defineMethod(\"ifSessionIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.sessionId !== Reaction.sessionId;\n    }\n  }); /**\n       * Define all security rules\n       */ /**\n           * admin security\n           * Permissive security for users with the \"admin\" role\n           */\n  Security.permit([\"insert\", \"update\", \"remove\"]).collections([Accounts, Products, Tags, Translations, Shipping, Orders, Packages, Templates, Jobs]).ifHasRole({\n    role: \"admin\",\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().exceptProps([\"shopId\"]).allowInClientCode(); /*\n                                                                     * Permissive security for users with the \"admin\" role for FS.Collections\n                                                                     */\n  Security.permit([\"insert\", \"update\", \"remove\"]).collections([Media]).ifHasRole({\n    role: [\"admin\", \"owner\", \"createProduct\"],\n    group: Reaction.getShopId()\n  }).ifFileBelongsToShop().allowInClientCode(); /*\n                                                 * Users with the \"admin\" or \"owner\" role may update and\n                                                 * remove their shop but may not insert one.\n                                                 */\n  Shops.permit([\"update\", \"remove\"]).ifHasRole({\n    role: [\"admin\", \"owner\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatchesThisId().allowInClientCode(); /*\n                                                   * Users with the \"admin\" or \"owner\" role may update and\n                                                   * remove products, but createProduct allows just for just a product editor\n                                                   */\n  Products.permit([\"insert\", \"update\", \"remove\"]).ifHasRole({\n    role: [\"createProduct\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().allowInClientCode(); /*\n                                             * Users with the \"owner\" role may remove orders for their shop\n                                             */\n  Orders.permit(\"remove\").ifHasRole({\n    role: [\"admin\", \"owner\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().exceptProps([\"shopId\"]).allowInClientCode(); /*\n                                                                     * Can update cart from client. Must insert/remove carts using\n                                                                     * server methods.\n                                                                     * Can update all session carts if not logged in or user cart if logged in as that user\n                                                                     * XXX should verify session match, but doesn't seem possible? Might have to move all cart updates to server methods, too?\n                                                                     */\n  Cart.permit([\"insert\", \"update\", \"remove\"]).ifHasRole({\n    role: [\"anonymous\", \"guest\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().ifUserIdMatches().ifSessionIdMatches().allowInClientCode(); /*\n                                                                                    * Users may update their own account\n                                                                                    */\n  Collections.Accounts.permit([\"insert\", \"update\"]).ifHasRole({\n    role: [\"anonymous\", \"guest\"],\n    group: Reaction.getShopId()\n  }).ifUserIdMatches().allowInClientCode(); /*\n                                             * apply download permissions to file collections\n                                             */\n\n  _.each([Media], function (fsCollection) {\n    return fsCollection.allow({\n      download: function () {\n        return true;\n      }\n    });\n  }); /**\n       * Emails - Deny all client side ops\n       */\n\n  Emails.deny({\n    insert: function () {\n      return true;\n    },\n    update: function () {\n      return true;\n    },\n    remove: function () {\n      return true;\n    }\n  });\n});","map":{"version":3,"sources":["/server/security/collections.js"],"names":["Collections","Reaction","Accounts","Cart","Packages","Emails","Jobs","Media","Orders","Products","Shipping","Shops","Tags","Templates","Translations","Security","defineMethod","fetch","deny","type","arg","userId","doc","shopId","getShopId","_id","metadata","sessionId","permit","collections","ifHasRole","role","group","ifShopIdMatches","exceptProps","allowInClientCode","ifFileBelongsToShop","ifShopIdMatchesThisId","ifUserIdMatches","ifSessionIdMatches","_","each","fsCollection","allow","download","insert","update","remove"],"mappings":"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","file":"/server/security/collections.js.map","sourcesContent":["import * as Collections from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nconst {\n  Accounts,\n  Cart,\n  Packages,\n  Emails,\n  Jobs,\n  Media,\n  Orders,\n  Products,\n  Shipping,\n  Shops,\n  Tags,\n  Templates,\n  Translations\n} = Collections;\n\n/**\n * security definitions\n *\n * The following security definitions use the ongoworks:security package.\n * Rules within a single chain stack with AND relationship. Multiple\n * chains for the same collection stack with OR relationship.\n * See https://github.com/ongoworks/meteor-security\n *\n * It\"s important to note that these security rules are for inserts,\n * updates, and removes initiated from untrusted (client) code.\n * Thus there may be other actions that certain roles are allowed to\n * take, but they do not necessarily need to be listed here if the\n * database operation is executed in a server method.\n */\n\nexport default function () {\n  /*\n   * Define some additional rule chain methods\n   */\n  // use this rule for collections other than Shops\n  // matches this.shopId\n  Security.defineMethod(\"ifShopIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.shopId !== Reaction.getShopId();\n    }\n  });\n  // this rule is for the Shops collection\n  // use ifShopIdMatches for match on this._id\n  Security.defineMethod(\"ifShopIdMatchesThisId\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc._id !== Reaction.getShopId();\n    }\n  });\n\n  Security.defineMethod(\"ifFileBelongsToShop\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.metadata.shopId !== Reaction.getShopId();\n    }\n  });\n\n  Security.defineMethod(\"ifUserIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return userId && doc.userId && doc.userId !== userId || doc.userId && !userId;\n    }\n  });\n\n  Security.defineMethod(\"ifUserIdMatchesProp\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc[arg] !== userId;\n    }\n  });\n\n  // todo do we need this?\n  Security.defineMethod(\"ifSessionIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.sessionId !== Reaction.sessionId;\n    }\n  });\n\n  /**\n   * Define all security rules\n   */\n\n  /**\n   * admin security\n   * Permissive security for users with the \"admin\" role\n   */\n\n  Security.permit([\"insert\", \"update\", \"remove\"]).collections([\n    Accounts,\n    Products,\n    Tags,\n    Translations,\n    Shipping,\n    Orders,\n    Packages,\n    Templates,\n    Jobs\n  ]).ifHasRole({\n    role: \"admin\",\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().exceptProps([\"shopId\"]).allowInClientCode();\n\n  /*\n   * Permissive security for users with the \"admin\" role for FS.Collections\n   */\n\n  Security.permit([\"insert\", \"update\", \"remove\"]).collections([Media]).ifHasRole({\n    role: [\"admin\", \"owner\", \"createProduct\"],\n    group: Reaction.getShopId()\n  }).ifFileBelongsToShop().allowInClientCode();\n\n  /*\n   * Users with the \"admin\" or \"owner\" role may update and\n   * remove their shop but may not insert one.\n   */\n\n  Shops.permit([\"update\", \"remove\"]).ifHasRole({\n    role: [\"admin\", \"owner\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatchesThisId().allowInClientCode();\n\n  /*\n   * Users with the \"admin\" or \"owner\" role may update and\n   * remove products, but createProduct allows just for just a product editor\n   */\n\n  Products.permit([\"insert\", \"update\", \"remove\"]).ifHasRole({\n    role: [\"createProduct\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().allowInClientCode();\n\n  /*\n   * Users with the \"owner\" role may remove orders for their shop\n   */\n\n  Orders.permit(\"remove\").ifHasRole({\n    role: [\"admin\", \"owner\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().exceptProps([\"shopId\"]).allowInClientCode();\n\n  /*\n   * Can update cart from client. Must insert/remove carts using\n   * server methods.\n   * Can update all session carts if not logged in or user cart if logged in as that user\n   * XXX should verify session match, but doesn't seem possible? Might have to move all cart updates to server methods, too?\n   */\n\n  Cart.permit([\"insert\", \"update\", \"remove\"]).ifHasRole({\n    role: [\"anonymous\", \"guest\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().ifUserIdMatches().ifSessionIdMatches().allowInClientCode();\n\n  /*\n   * Users may update their own account\n   */\n  Collections.Accounts.permit([\"insert\", \"update\"]).ifHasRole({\n    role: [\"anonymous\", \"guest\"],\n    group: Reaction.getShopId()\n  }).ifUserIdMatches().allowInClientCode();\n\n  /*\n   * apply download permissions to file collections\n   */\n  _.each([Media], function (fsCollection) {\n    return fsCollection.allow({\n      download: function () {\n        return true;\n      }\n    });\n  });\n\n  /**\n   * Emails - Deny all client side ops\n   */\n  Emails.deny({\n    insert: () => true,\n    update: () => true,\n    remove: () => true\n  });\n}\n"]},"hash":"92a93f235da9f06f6b3edb3bc870298b63c84504"}
