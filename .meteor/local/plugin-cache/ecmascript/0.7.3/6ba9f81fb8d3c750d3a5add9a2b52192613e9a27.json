{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/mongo","imported":["Mongo"],"specifiers":[{"kind":"named","imported":"Mongo","local":"Mongo"}]},{"source":"meteor/ejson","imported":["EJSON"],"specifiers":[{"kind":"named","imported":"EJSON","local":"EJSON"}]},{"source":"/lib/collections","imported":["*"],"specifiers":[{"kind":"namespace","local":"Collections"}]},{"source":"../hooks","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Hooks"}]},{"source":"../logger","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Logger"}]},{"source":"./rightJoin","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"doRightJoinNoIntersection"}]}],"exports":{"exported":["Import","Fixture"],"specifiers":[{"kind":"local","local":"Import","exported":"Import"},{"kind":"local","local":"Fixture","exported":"Fixture"}]}}},"options":{"filename":"/server/api/core/import.js","filenameRelative":"/server/api/core/import.js","inputSourceMap":{"version":3,"sources":["/server/api/core/import.js"],"names":["Mongo","EJSON","Collections","Hooks","Logger","doRightJoinNoIntersection","Import","_buffers","_contexts","_count","_indications","_limit","_name","collection","_upsert","startup","load","key","object","check","Object","identify","indication","field","probability","String","Collection","Number","document","probabilities","keys","total","max","name","undefined","Error","commit","buffer","execute","error","result","nImported","nModified","nInserted","nUpserted","nTouched","nMatched","nRemoved","message","debug","writeErrors","getWriteErrors","i","length","warn","errmsg","writeConcernError","getWriteConcernError","flush","context","selector","Match","Optional","type","simpleSchema","newContext","MongoInternals","NpmModule","prototype","initializeUnorderedBulkOp","rawCollection","product","parent","Products","package","pkg","shopId","Packages","template","templateInfo","Templates","translation","modifiedKey","assign","ns","Translations","shop","Shops","layout","_id","shipping","importKey","Shipping","findOne","methods","tag","Tags","updateObject","Random","id","importObject","Events","run","cleanedObject","clean","validate","defaultValuesObject","find","upsert","update","$set","$setOnInsert","process","json","callback","Array","Function","array","parse","j","call","Fixture"],"mappings":"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","file":"/server/api/core/import.js.map","sourcesContent":["import { Mongo } from \"meteor/mongo\";\nimport { EJSON } from \"meteor/ejson\";\nimport * as Collections from \"/lib/collections\";\nimport Hooks from \"../hooks\";\nimport Logger from \"../logger\";\nimport doRightJoinNoIntersection from \"./rightJoin\";\n\n/**\n * @file Exposes the Import object implementing methods for bulk imports.\n * @author Tom De Caluwé\n */\n\nexport const Import = {};\n\nImport._buffers = {};\nImport._contexts = {};\nImport._count = {};\nImport._indications = {};\nImport._limit = 1000;\n\nImport._name = function (collection) {\n  return collection._name;\n};\n\nImport._upsert = function () {\n  return true;\n};\n\n//\n// TODO Verify if Import.startup is deprecated\n//\nImport.startup = function () {\n  return true;\n};\n\nImport.load = function (key, object) {\n  check(object, Object);\n\n  this.object(this.identify(object), key, object);\n};\n\nImport.indication = function (field, collection, probability) {\n  check(field, String);\n  check(collection, Mongo.Collection);\n  check(probability, Number);\n\n  this._indications[field] = { collection, probability };\n};\n\n/**\n * Import.identify\n * @summary Tries to identify the schema associated with a document.\n * @param {Object} document - A document with unknown schema\n * @returns {Mongo.Collection} Returns a MongoDB collection in which the\n * document can be inserted.\n * @throws {Error} Throws an error if the schema couldn't be determined.\n *\n * The algorithm initially assumes the document can be anything. It associates\n * with each field in the document a probability that it isn't following some\n * schema other than the one the field is associated with.\n *\n * Afterwards the schema with the maximal probability is selected. An error is\n * thrown if the schema cannot be determined.\n */\nImport.identify = function (document) {\n  check(document, Object);\n\n  const probabilities = {};\n\n  for (key of Object.keys(document)) {\n    if (this._indications[key]) {\n      const collection = this._name(this._indications[key].collection);\n      probabilities[collection] = probabilities[collection] || 1.0 * this._indications[\n        key].probability;\n    }\n  }\n\n  let total = 1.0;\n  for (key of Object.keys(probabilities)) {\n    total *= probabilities[key];\n  }\n\n  let max = 0.0;\n  let name;\n  for (key of Object.keys(probabilities)) {\n    const probability = total / probabilities[key];\n    if (probability > max) {\n      max = probability;\n      name = key;\n    } else if (probability === max) {\n      name = undefined;\n    }\n  }\n\n  if (name && max > 0.3) {\n    return Collections[name];\n  }\n  throw new Error(\n    \"Couldn't determine the schema associated with this document\");\n};\n\n/**\n * @summary Commit the buffer for a given collection to the database.\n * @param {Mongo.Collection} collection The target collection to be flushed to disk\n * @returns {undefined}\n */\nImport.commit = function (collection) {\n  check(collection, Mongo.Collection);\n  // Construct a collection identifier.\n  const name = this._name(collection);\n\n  // Only commit if the buffer isn't empty (otherwise it'll throw).\n  if (this._count[name]) {\n    this.buffer(collection).execute(function (error, result) {\n      // Inserted document counts don't affect the modified document count, so we\n      // throw everything together.\n      const nImported = result.nModified + result.nInserted + result.nUpserted;\n      const nTouched = result.nMatched + result.nInserted + result.nUpserted;\n      const nRemoved = result.nRemoved;\n      // Log some information about the import.\n      if (nTouched) {\n        let message = \"Modified \" + nImported + (nImported === 1 ? \" document\" : \" documents\");\n        message += \" while importing \" + nTouched + \" to \" + name;\n        Logger.debug(message);\n      }\n      if (nRemoved) {\n        let message = \"Removed \" + nRemoved + (nRemoved === 1 ? \" document\" : \" documents\");\n        message += \" from \" + name;\n        Logger.debug(message);\n      }\n      // Log any errors returned.\n      const message = \"Error while importing to \" + name;\n      const writeErrors = result.getWriteErrors();\n      for (let i = 0; i < writeErrors.length; i++) {\n        Logger.warn(message + \": \" + writeErrors[i].errmsg);\n      }\n      const writeConcernError = result.getWriteConcernError();\n      if (writeConcernError) {\n        Logger.warn(message + \": \" + writeConcernError.errmsg);\n      }\n    });\n    // Reset the buffer.\n    delete this._buffers[name];\n    this._count[name] = 0;\n  }\n};\n\n/**\n * @summary Process the buffer for a given collection and commit the database.\n * @param {Mongo.Collection} collection optional - supply a Mongo collection, or leave empty to commit all buffer entries\n * @returns {undefined}\n */\nImport.flush = function (collection) {\n  if (!collection) {\n    for (const name of Object.keys(this._buffers)) {\n      this.commit(Collections[name]);\n    }\n    return;\n  }\n  this.commit(collection);\n};\n\n/**\n * @summary Get a validation context for a given collection.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} [selector] A selector object to retrieve the correct schema.\n * @returns {SimpleSchemaValidationContext} A validation context.\n *\n * The validation context is requested from the schema associated with the\n * collection.\n */\nImport.context = function (collection, selector) {\n  check(collection, Mongo.Collection);\n  check(selector, Match.Optional(Object));\n\n  // Construct a context identifier.\n  let name = this._name(collection);\n  if (selector && selector.type) {\n    name = `${name}_${selector.type}`;\n  }\n  // Construct a new validation context if necessary.\n  if (this._contexts[name]) {\n    return this._contexts[name];\n  }\n  this._contexts[name] = collection.simpleSchema(selector).newContext();\n  return this._contexts[name];\n};\n\n/**\n * @summary Get an import buffer for a given collection.\n * @param {Object} collection The target collection\n * @returns {Object} return buffer\n * If no buffer is presented, a new one will be constructed.\n */\nImport.buffer = function (collection) {\n  check(collection, Mongo.Collection);\n\n  if (!MongoInternals.NpmModule.Collection.prototype.initializeUnorderedBulkOp) {\n    throw Error(\"Couldn't detect the MongoDB bulk API, are you using MongoDB 2.6 or above?\");\n  }\n\n  // Construct a buffer identifier.\n  const name = this._name(collection);\n\n  // Construct a new buffer if necessary.\n  if (this._buffers[name]) {\n    return this._buffers[name];\n  }\n  this._count[name] = 0;\n  this._buffers[name] = collection.rawCollection().initializeUnorderedBulkOp();\n  return this._buffers[name];\n};\n\n/**\n * @summary Store a product in the import buffer.\n * @param {Object} key A key to look up the product\n * @param {Object} product The product data to be updated\n * @param {Object} parent A key to identify the parent product\n * @returns {Object}\n * Importing a variant currently consists of the following steps:\n *\n * * Pull the variant from non-matching parent products.\n * * Push the variant if it doesn't exist.\n * * Update the variant.\n */\nImport.product = function (key, product, parent) {\n  check(parent, Object);\n\n  return this.object(Collections.Products, key, product);\n};\n\n/**\n * @summary Store a package in the import buffer.\n * @param {Object} pkg The package data to be updated\n * @param {String} shopId The package data to be updated\n * @returns {undefined}\n */\nImport.package = function (pkg, shopId) {\n  check(pkg, Object);\n  check(shopId, String);\n  const key = {\n    name: pkg.name,\n    shopId: shopId\n  };\n  return this.object(Collections.Packages, key, pkg);\n};\n\n//\n// Import.translation\n// server/startup/i18n.js\n//\n\n/**\n * @summary Store a template in the import buffer.\n * @param {Object} templateInfo The template data to be updated\n * @param {String} shopId The package data to be updated\n * @returns {undefined}\n */\nImport.template = function (templateInfo) {\n  check(templateInfo, Object);\n\n  const key = {\n    name: templateInfo.name,\n    type: templateInfo.type || \"template\"\n  };\n\n  return this.object(Collections.Templates, key, templateInfo);\n};\n\n/**\n * @summary Store a translation in the import buffer.\n * @param {Object} key A key to look up the translation\n * @param {Object} translation The translation data to be updated\n * @returns {Object} updated translation buffer\n */\nImport.translation = function (key, translation) {\n  const modifiedKey = Object.assign(key, { ns: translation.ns });\n  return this.object(Collections.Translations, modifiedKey, translation);\n};\n\n/**\n * @summary Store a shop in the import buffer.\n * @param {Object} key A key to look up the shop\n * @param {Object} shop The shop data to be updated\n * @returns {Object} this shop\n */\nImport.shop = function (key, shop) {\n  return this.object(Collections.Shops, key, shop);\n};\n\n/**\n * @summary store a shop layout in the import buffer\n * @param {Array} layout - an array of layouts to be added to shop\n * @param {String} shopId shopId\n * @returns {Object} this shop\n */\nImport.layout = function (layout, shopId) {\n  const key = {\n    _id: shopId\n  };\n  return this.object(Collections.Shops, key, {\n    _id: shopId,\n    layout: layout\n  });\n};\n\n/**\n * @summary Store shipping in the import buffer.\n * @param {Object} key A shipping service key used in combination with provider\n * @param {Object} shipping The shipping data to be updated\n * @returns {Object} this shipping\n */\nImport.shipping = function (key, shipping) {\n  let importKey = {};\n  //\n  // we have a bit of a strange structure in Shipping\n  // and don't really have a key that is good for\n  // determining if we imported this before\n  // so we're just saying that if this service\n  // already exists then we're not going to import\n  //\n  const result = Collections.Shipping.findOne(key);\n  if (result) {\n    importKey = {\n      _id: result._id,\n      shopId: result.shopId\n    };\n    delete shipping.methods;\n  }\n  const modifiedKey = Object.assign({}, key, importKey);\n  return this.object(Collections.Shipping, modifiedKey, shipping);\n};\n\n/**\n * @summary Store a tag in the import buffer.\n * @param {Object} key A key to look up the tag\n * @param {Object} tag The tag data to be updated\n * @returns {Object} this tag\n */\nImport.tag = function (key, tag) {\n  return this.object(Collections.Tags, key, tag);\n};\n\n/**\n * @summary Push a new upsert document to the import buffer.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} key A key to look up the object\n * @param {Object} object The object data to be updated\n * @returns {undefined}\n */\nImport.object = function (collection, key, object) {\n  check(collection, Mongo.Collection);\n  check(key, Object);\n  check(object, Object);\n  const updateObject = object;\n\n  // enforce strings instead of Mongo.ObjectId\n  if (!collection.findOne(key) && !object._id) key._id = Random.id();\n\n  // hooks for additional import manipulation.\n  const importObject = Hooks.Events.run(`onImport${this._name(collection)}`, object);\n\n  // Clone object for cleaning\n  const cleanedObject = Object.assign({}, importObject);\n\n  // Cleaning the object adds default values from schema, if value doesn't exist\n  collection.simpleSchema(importObject).clean(cleanedObject);\n\n  // And validate the object against the schema\n  this.context(collection, updateObject).validate(cleanedObject, {});\n\n  // Disjoint importObject and cleanedObject again\n  // to prevent `Cannot update '<field>' and '<field>' at the same time` errors\n  const defaultValuesObject = doRightJoinNoIntersection(importObject, cleanedObject);\n\n  // Upsert the object.\n  const find = this.buffer(collection).find(key);\n\n  // With the upsert option set to true, if no matching documents exist for the Bulk.find() condition,\n  // then the update or the replacement operation performs an insert.\n  // https://docs.mongodb.com/manual/reference/method/Bulk.find.upsert/\n  if (Object.keys(defaultValuesObject).length === 0) {\n    find.upsert().update({\n      $set: importObject\n    });\n  } else {\n    find.upsert().update({\n      $set: importObject,\n      $setOnInsert: defaultValuesObject\n    });\n  }\n  if (this._count[this._name(collection)]++ >= this._limit) {\n    this.flush(collection);\n  }\n};\n\n/**\n * @summary Process a json array of import documents using a callback.\n * @param {Object[]} json An array containing the import documents\n * @param {string[]} keys Fields that should be used as the import key.\n * @param {Function} callback A callback accepting two parameters.\n * The callback should accept a key document to consult the database as a first\n * parameter and an update document as the second parameter.\n * @returns {undefined}\n */\nImport.process = function (json, keys, callback) {\n  check(json, String);\n  check(keys, Array);\n  check(callback, Function);\n\n  const array = EJSON.parse(json);\n\n  for (let i = 0; i < array.length; i++) {\n    const key = {};\n    for (let j = 0; j < keys.length; j++) {\n      key[keys[j]] = array[i][keys[j]];\n    }\n    callback.call(this, key, array[i]);\n  }\n};\n\nImport.indication(\"i18n\", Collections.Translations, 0.2);\nImport.indication(\"hashtags\", Collections.Products, 0.5);\nImport.indication(\"barcode\", Collections.Products, 0.5);\nImport.indication(\"price\", Collections.Products, 0.5);\nImport.indication(\"ancestors\", Collections.Products, 0.5);\nImport.indication(\"languages\", Collections.Shops, 0.5);\nImport.indication(\"currencies\", Collections.Shops, 0.5);\nImport.indication(\"timezone\", Collections.Shops, 0.5);\nImport.indication(\"isTopLevel\", Collections.Tags, 0.4);\nImport.indication(\"slug\", Collections.Tags, 0.5);\nImport.indication(\"provider\", Collections.Shipping, 0.2);\n\n//\n// exporting Fixture\n// use this instead of Import if you want\n// Bulk.find.upsert() to equal false\n//\nexport const Fixture = Object.assign({}, Import, {\n  _upsert: () => { return false; }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/api/core/import.js.map","sourceFileName":"/server/api/core/import.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"import"},"ignored":false,"code":"module.export({\n  Import: function () {\n    return Import;\n  },\n  Fixture: function () {\n    return Fixture;\n  }\n});\nvar Mongo = void 0;\nmodule.importSync(\"meteor/mongo\", {\n  Mongo: function (v) {\n    Mongo = v;\n  }\n}, 0);\nvar EJSON = void 0;\nmodule.importSync(\"meteor/ejson\", {\n  EJSON: function (v) {\n    EJSON = v;\n  }\n}, 1);\nvar Collections = Object.create(null);\nmodule.importSync(\"/lib/collections\", {\n  \"*\": function (v, n) {\n    Collections[n] = v;\n  }\n}, 2);\nvar Hooks = void 0;\nmodule.importSync(\"../hooks\", {\n  \"default\": function (v) {\n    Hooks = v;\n  }\n}, 3);\nvar Logger = void 0;\nmodule.importSync(\"../logger\", {\n  \"default\": function (v) {\n    Logger = v;\n  }\n}, 4);\nvar doRightJoinNoIntersection = void 0;\nmodule.importSync(\"./rightJoin\", {\n  \"default\": function (v) {\n    doRightJoinNoIntersection = v;\n  }\n}, 5);\nvar Import = {};\nImport._buffers = {};\nImport._contexts = {};\nImport._count = {};\nImport._indications = {};\nImport._limit = 1000;\n\nImport._name = function (collection) {\n  return collection._name;\n};\n\nImport._upsert = function () {\n  return true;\n}; //\n// TODO Verify if Import.startup is deprecated\n//\n\n\nImport.startup = function () {\n  return true;\n};\n\nImport.load = function (key, object) {\n  check(object, Object);\n  this.object(this.identify(object), key, object);\n};\n\nImport.indication = function (field, collection, probability) {\n  check(field, String);\n  check(collection, Mongo.Collection);\n  check(probability, Number);\n  this._indications[field] = {\n    collection: collection,\n    probability: probability\n  };\n}; /**\n    * Import.identify\n    * @summary Tries to identify the schema associated with a document.\n    * @param {Object} document - A document with unknown schema\n    * @returns {Mongo.Collection} Returns a MongoDB collection in which the\n    * document can be inserted.\n    * @throws {Error} Throws an error if the schema couldn't be determined.\n    *\n    * The algorithm initially assumes the document can be anything. It associates\n    * with each field in the document a probability that it isn't following some\n    * schema other than the one the field is associated with.\n    *\n    * Afterwards the schema with the maximal probability is selected. An error is\n    * thrown if the schema cannot be determined.\n    */\n\nImport.identify = function (document) {\n  check(document, Object);\n  var probabilities = {};\n\n  for (var _iterator = Object.keys(document), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      key = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      key = _i.value;\n    }\n\n    if (this._indications[key]) {\n      var collection = this._name(this._indications[key].collection);\n\n      probabilities[collection] = probabilities[collection] || 1.0 * this._indications[key].probability;\n    }\n  }\n\n  var total = 1.0;\n\n  for (var _iterator2 = Object.keys(probabilities), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      key = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      key = _i2.value;\n    }\n\n    total *= probabilities[key];\n  }\n\n  var max = 0.0;\n  var name = void 0;\n\n  for (var _iterator3 = Object.keys(probabilities), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      key = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      key = _i3.value;\n    }\n\n    var probability = total / probabilities[key];\n\n    if (probability > max) {\n      max = probability;\n      name = key;\n    } else if (probability === max) {\n      name = undefined;\n    }\n  }\n\n  if (name && max > 0.3) {\n    return Collections[name];\n  }\n\n  throw new Error(\"Couldn't determine the schema associated with this document\");\n}; /**\n    * @summary Commit the buffer for a given collection to the database.\n    * @param {Mongo.Collection} collection The target collection to be flushed to disk\n    * @returns {undefined}\n    */\n\nImport.commit = function (collection) {\n  check(collection, Mongo.Collection); // Construct a collection identifier.\n\n  var name = this._name(collection); // Only commit if the buffer isn't empty (otherwise it'll throw).\n\n\n  if (this._count[name]) {\n    this.buffer(collection).execute(function (error, result) {\n      // Inserted document counts don't affect the modified document count, so we\n      // throw everything together.\n      var nImported = result.nModified + result.nInserted + result.nUpserted;\n      var nTouched = result.nMatched + result.nInserted + result.nUpserted;\n      var nRemoved = result.nRemoved; // Log some information about the import.\n\n      if (nTouched) {\n        var _message = \"Modified \" + nImported + (nImported === 1 ? \" document\" : \" documents\");\n\n        _message += \" while importing \" + nTouched + \" to \" + name;\n        Logger.debug(_message);\n      }\n\n      if (nRemoved) {\n        var _message2 = \"Removed \" + nRemoved + (nRemoved === 1 ? \" document\" : \" documents\");\n\n        _message2 += \" from \" + name;\n        Logger.debug(_message2);\n      } // Log any errors returned.\n\n\n      var message = \"Error while importing to \" + name;\n      var writeErrors = result.getWriteErrors();\n\n      for (var i = 0; i < writeErrors.length; i++) {\n        Logger.warn(message + \": \" + writeErrors[i].errmsg);\n      }\n\n      var writeConcernError = result.getWriteConcernError();\n\n      if (writeConcernError) {\n        Logger.warn(message + \": \" + writeConcernError.errmsg);\n      }\n    }); // Reset the buffer.\n\n    delete this._buffers[name];\n    this._count[name] = 0;\n  }\n}; /**\n    * @summary Process the buffer for a given collection and commit the database.\n    * @param {Mongo.Collection} collection optional - supply a Mongo collection, or leave empty to commit all buffer entries\n    * @returns {undefined}\n    */\n\nImport.flush = function (collection) {\n  if (!collection) {\n    for (var _iterator4 = Object.keys(this._buffers), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref = _i4.value;\n      }\n\n      var name = _ref;\n      this.commit(Collections[name]);\n    }\n\n    return;\n  }\n\n  this.commit(collection);\n}; /**\n    * @summary Get a validation context for a given collection.\n    * @param {Mongo.Collection} collection The target collection\n    * @param {Object} [selector] A selector object to retrieve the correct schema.\n    * @returns {SimpleSchemaValidationContext} A validation context.\n    *\n    * The validation context is requested from the schema associated with the\n    * collection.\n    */\n\nImport.context = function (collection, selector) {\n  check(collection, Mongo.Collection);\n  check(selector, Match.Optional(Object)); // Construct a context identifier.\n\n  var name = this._name(collection);\n\n  if (selector && selector.type) {\n    name = name + \"_\" + selector.type;\n  } // Construct a new validation context if necessary.\n\n\n  if (this._contexts[name]) {\n    return this._contexts[name];\n  }\n\n  this._contexts[name] = collection.simpleSchema(selector).newContext();\n  return this._contexts[name];\n}; /**\n    * @summary Get an import buffer for a given collection.\n    * @param {Object} collection The target collection\n    * @returns {Object} return buffer\n    * If no buffer is presented, a new one will be constructed.\n    */\n\nImport.buffer = function (collection) {\n  check(collection, Mongo.Collection);\n\n  if (!MongoInternals.NpmModule.Collection.prototype.initializeUnorderedBulkOp) {\n    throw Error(\"Couldn't detect the MongoDB bulk API, are you using MongoDB 2.6 or above?\");\n  } // Construct a buffer identifier.\n\n\n  var name = this._name(collection); // Construct a new buffer if necessary.\n\n\n  if (this._buffers[name]) {\n    return this._buffers[name];\n  }\n\n  this._count[name] = 0;\n  this._buffers[name] = collection.rawCollection().initializeUnorderedBulkOp();\n  return this._buffers[name];\n}; /**\n    * @summary Store a product in the import buffer.\n    * @param {Object} key A key to look up the product\n    * @param {Object} product The product data to be updated\n    * @param {Object} parent A key to identify the parent product\n    * @returns {Object}\n    * Importing a variant currently consists of the following steps:\n    *\n    * * Pull the variant from non-matching parent products.\n    * * Push the variant if it doesn't exist.\n    * * Update the variant.\n    */\n\nImport.product = function (key, product, parent) {\n  check(parent, Object);\n  return this.object(Collections.Products, key, product);\n}; /**\n    * @summary Store a package in the import buffer.\n    * @param {Object} pkg The package data to be updated\n    * @param {String} shopId The package data to be updated\n    * @returns {undefined}\n    */\n\nImport.package = function (pkg, shopId) {\n  check(pkg, Object);\n  check(shopId, String);\n  var key = {\n    name: pkg.name,\n    shopId: shopId\n  };\n  return this.object(Collections.Packages, key, pkg);\n}; //\n// Import.translation\n// server/startup/i18n.js\n//\n/**\n * @summary Store a template in the import buffer.\n * @param {Object} templateInfo The template data to be updated\n * @param {String} shopId The package data to be updated\n * @returns {undefined}\n */\n\nImport.template = function (templateInfo) {\n  check(templateInfo, Object);\n  var key = {\n    name: templateInfo.name,\n    type: templateInfo.type || \"template\"\n  };\n  return this.object(Collections.Templates, key, templateInfo);\n}; /**\n    * @summary Store a translation in the import buffer.\n    * @param {Object} key A key to look up the translation\n    * @param {Object} translation The translation data to be updated\n    * @returns {Object} updated translation buffer\n    */\n\nImport.translation = function (key, translation) {\n  var modifiedKey = Object.assign(key, {\n    ns: translation.ns\n  });\n  return this.object(Collections.Translations, modifiedKey, translation);\n}; /**\n    * @summary Store a shop in the import buffer.\n    * @param {Object} key A key to look up the shop\n    * @param {Object} shop The shop data to be updated\n    * @returns {Object} this shop\n    */\n\nImport.shop = function (key, shop) {\n  return this.object(Collections.Shops, key, shop);\n}; /**\n    * @summary store a shop layout in the import buffer\n    * @param {Array} layout - an array of layouts to be added to shop\n    * @param {String} shopId shopId\n    * @returns {Object} this shop\n    */\n\nImport.layout = function (layout, shopId) {\n  var key = {\n    _id: shopId\n  };\n  return this.object(Collections.Shops, key, {\n    _id: shopId,\n    layout: layout\n  });\n}; /**\n    * @summary Store shipping in the import buffer.\n    * @param {Object} key A shipping service key used in combination with provider\n    * @param {Object} shipping The shipping data to be updated\n    * @returns {Object} this shipping\n    */\n\nImport.shipping = function (key, shipping) {\n  var importKey = {}; //\n  // we have a bit of a strange structure in Shipping\n  // and don't really have a key that is good for\n  // determining if we imported this before\n  // so we're just saying that if this service\n  // already exists then we're not going to import\n  //\n\n  var result = Collections.Shipping.findOne(key);\n\n  if (result) {\n    importKey = {\n      _id: result._id,\n      shopId: result.shopId\n    };\n    delete shipping.methods;\n  }\n\n  var modifiedKey = Object.assign({}, key, importKey);\n  return this.object(Collections.Shipping, modifiedKey, shipping);\n}; /**\n    * @summary Store a tag in the import buffer.\n    * @param {Object} key A key to look up the tag\n    * @param {Object} tag The tag data to be updated\n    * @returns {Object} this tag\n    */\n\nImport.tag = function (key, tag) {\n  return this.object(Collections.Tags, key, tag);\n}; /**\n    * @summary Push a new upsert document to the import buffer.\n    * @param {Mongo.Collection} collection The target collection\n    * @param {Object} key A key to look up the object\n    * @param {Object} object The object data to be updated\n    * @returns {undefined}\n    */\n\nImport.object = function (collection, key, object) {\n  check(collection, Mongo.Collection);\n  check(key, Object);\n  check(object, Object);\n  var updateObject = object; // enforce strings instead of Mongo.ObjectId\n\n  if (!collection.findOne(key) && !object._id) key._id = Random.id(); // hooks for additional import manipulation.\n\n  var importObject = Hooks.Events.run(\"onImport\" + this._name(collection), object); // Clone object for cleaning\n\n  var cleanedObject = Object.assign({}, importObject); // Cleaning the object adds default values from schema, if value doesn't exist\n\n  collection.simpleSchema(importObject).clean(cleanedObject); // And validate the object against the schema\n\n  this.context(collection, updateObject).validate(cleanedObject, {}); // Disjoint importObject and cleanedObject again\n  // to prevent `Cannot update '<field>' and '<field>' at the same time` errors\n\n  var defaultValuesObject = doRightJoinNoIntersection(importObject, cleanedObject); // Upsert the object.\n\n  var find = this.buffer(collection).find(key); // With the upsert option set to true, if no matching documents exist for the Bulk.find() condition,\n  // then the update or the replacement operation performs an insert.\n  // https://docs.mongodb.com/manual/reference/method/Bulk.find.upsert/\n\n  if (Object.keys(defaultValuesObject).length === 0) {\n    find.upsert().update({\n      $set: importObject\n    });\n  } else {\n    find.upsert().update({\n      $set: importObject,\n      $setOnInsert: defaultValuesObject\n    });\n  }\n\n  if (this._count[this._name(collection)]++ >= this._limit) {\n    this.flush(collection);\n  }\n}; /**\n    * @summary Process a json array of import documents using a callback.\n    * @param {Object[]} json An array containing the import documents\n    * @param {string[]} keys Fields that should be used as the import key.\n    * @param {Function} callback A callback accepting two parameters.\n    * The callback should accept a key document to consult the database as a first\n    * parameter and an update document as the second parameter.\n    * @returns {undefined}\n    */\n\nImport.process = function (json, keys, callback) {\n  check(json, String);\n  check(keys, Array);\n  check(callback, Function);\n  var array = EJSON.parse(json);\n\n  for (var i = 0; i < array.length; i++) {\n    var _key = {};\n\n    for (var j = 0; j < keys.length; j++) {\n      _key[keys[j]] = array[i][keys[j]];\n    }\n\n    callback.call(this, _key, array[i]);\n  }\n};\n\nImport.indication(\"i18n\", Collections.Translations, 0.2);\nImport.indication(\"hashtags\", Collections.Products, 0.5);\nImport.indication(\"barcode\", Collections.Products, 0.5);\nImport.indication(\"price\", Collections.Products, 0.5);\nImport.indication(\"ancestors\", Collections.Products, 0.5);\nImport.indication(\"languages\", Collections.Shops, 0.5);\nImport.indication(\"currencies\", Collections.Shops, 0.5);\nImport.indication(\"timezone\", Collections.Shops, 0.5);\nImport.indication(\"isTopLevel\", Collections.Tags, 0.4);\nImport.indication(\"slug\", Collections.Tags, 0.5);\nImport.indication(\"provider\", Collections.Shipping, 0.2); //\n// exporting Fixture\n// use this instead of Import if you want\n// Bulk.find.upsert() to equal false\n//\n\nvar Fixture = Object.assign({}, Import, {\n  _upsert: function () {\n    return false;\n  }\n});","map":{"version":3,"sources":["/server/api/core/import.js"],"names":["Mongo","EJSON","Collections","Hooks","Logger","doRightJoinNoIntersection","Import","_buffers","_contexts","_count","_indications","_limit","_name","collection","_upsert","startup","load","key","object","check","Object","identify","indication","field","probability","String","Collection","Number","document","probabilities","keys","total","max","name","undefined","Error","commit","buffer","execute","error","result","nImported","nModified","nInserted","nUpserted","nTouched","nMatched","nRemoved","message","debug","writeErrors","getWriteErrors","i","length","warn","errmsg","writeConcernError","getWriteConcernError","flush","context","selector","Match","Optional","type","simpleSchema","newContext","MongoInternals","NpmModule","prototype","initializeUnorderedBulkOp","rawCollection","product","parent","Products","package","pkg","shopId","Packages","template","templateInfo","Templates","translation","modifiedKey","assign","ns","Translations","shop","Shops","layout","_id","shipping","importKey","Shipping","findOne","methods","tag","Tags","updateObject","Random","id","importObject","Events","run","cleanedObject","clean","validate","defaultValuesObject","find","upsert","update","$set","$setOnInsert","process","json","callback","Array","Function","array","parse","j","call","Fixture"],"mappings":"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","file":"/server/api/core/import.js.map","sourcesContent":["import { Mongo } from \"meteor/mongo\";\nimport { EJSON } from \"meteor/ejson\";\nimport * as Collections from \"/lib/collections\";\nimport Hooks from \"../hooks\";\nimport Logger from \"../logger\";\nimport doRightJoinNoIntersection from \"./rightJoin\";\n\n/**\n * @file Exposes the Import object implementing methods for bulk imports.\n * @author Tom De Caluwé\n */\n\nexport const Import = {};\n\nImport._buffers = {};\nImport._contexts = {};\nImport._count = {};\nImport._indications = {};\nImport._limit = 1000;\n\nImport._name = function (collection) {\n  return collection._name;\n};\n\nImport._upsert = function () {\n  return true;\n};\n\n//\n// TODO Verify if Import.startup is deprecated\n//\nImport.startup = function () {\n  return true;\n};\n\nImport.load = function (key, object) {\n  check(object, Object);\n\n  this.object(this.identify(object), key, object);\n};\n\nImport.indication = function (field, collection, probability) {\n  check(field, String);\n  check(collection, Mongo.Collection);\n  check(probability, Number);\n\n  this._indications[field] = { collection, probability };\n};\n\n/**\n * Import.identify\n * @summary Tries to identify the schema associated with a document.\n * @param {Object} document - A document with unknown schema\n * @returns {Mongo.Collection} Returns a MongoDB collection in which the\n * document can be inserted.\n * @throws {Error} Throws an error if the schema couldn't be determined.\n *\n * The algorithm initially assumes the document can be anything. It associates\n * with each field in the document a probability that it isn't following some\n * schema other than the one the field is associated with.\n *\n * Afterwards the schema with the maximal probability is selected. An error is\n * thrown if the schema cannot be determined.\n */\nImport.identify = function (document) {\n  check(document, Object);\n\n  const probabilities = {};\n\n  for (key of Object.keys(document)) {\n    if (this._indications[key]) {\n      const collection = this._name(this._indications[key].collection);\n      probabilities[collection] = probabilities[collection] || 1.0 * this._indications[\n        key].probability;\n    }\n  }\n\n  let total = 1.0;\n  for (key of Object.keys(probabilities)) {\n    total *= probabilities[key];\n  }\n\n  let max = 0.0;\n  let name;\n  for (key of Object.keys(probabilities)) {\n    const probability = total / probabilities[key];\n    if (probability > max) {\n      max = probability;\n      name = key;\n    } else if (probability === max) {\n      name = undefined;\n    }\n  }\n\n  if (name && max > 0.3) {\n    return Collections[name];\n  }\n  throw new Error(\n    \"Couldn't determine the schema associated with this document\");\n};\n\n/**\n * @summary Commit the buffer for a given collection to the database.\n * @param {Mongo.Collection} collection The target collection to be flushed to disk\n * @returns {undefined}\n */\nImport.commit = function (collection) {\n  check(collection, Mongo.Collection);\n  // Construct a collection identifier.\n  const name = this._name(collection);\n\n  // Only commit if the buffer isn't empty (otherwise it'll throw).\n  if (this._count[name]) {\n    this.buffer(collection).execute(function (error, result) {\n      // Inserted document counts don't affect the modified document count, so we\n      // throw everything together.\n      const nImported = result.nModified + result.nInserted + result.nUpserted;\n      const nTouched = result.nMatched + result.nInserted + result.nUpserted;\n      const nRemoved = result.nRemoved;\n      // Log some information about the import.\n      if (nTouched) {\n        let message = \"Modified \" + nImported + (nImported === 1 ? \" document\" : \" documents\");\n        message += \" while importing \" + nTouched + \" to \" + name;\n        Logger.debug(message);\n      }\n      if (nRemoved) {\n        let message = \"Removed \" + nRemoved + (nRemoved === 1 ? \" document\" : \" documents\");\n        message += \" from \" + name;\n        Logger.debug(message);\n      }\n      // Log any errors returned.\n      const message = \"Error while importing to \" + name;\n      const writeErrors = result.getWriteErrors();\n      for (let i = 0; i < writeErrors.length; i++) {\n        Logger.warn(message + \": \" + writeErrors[i].errmsg);\n      }\n      const writeConcernError = result.getWriteConcernError();\n      if (writeConcernError) {\n        Logger.warn(message + \": \" + writeConcernError.errmsg);\n      }\n    });\n    // Reset the buffer.\n    delete this._buffers[name];\n    this._count[name] = 0;\n  }\n};\n\n/**\n * @summary Process the buffer for a given collection and commit the database.\n * @param {Mongo.Collection} collection optional - supply a Mongo collection, or leave empty to commit all buffer entries\n * @returns {undefined}\n */\nImport.flush = function (collection) {\n  if (!collection) {\n    for (const name of Object.keys(this._buffers)) {\n      this.commit(Collections[name]);\n    }\n    return;\n  }\n  this.commit(collection);\n};\n\n/**\n * @summary Get a validation context for a given collection.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} [selector] A selector object to retrieve the correct schema.\n * @returns {SimpleSchemaValidationContext} A validation context.\n *\n * The validation context is requested from the schema associated with the\n * collection.\n */\nImport.context = function (collection, selector) {\n  check(collection, Mongo.Collection);\n  check(selector, Match.Optional(Object));\n\n  // Construct a context identifier.\n  let name = this._name(collection);\n  if (selector && selector.type) {\n    name = `${name}_${selector.type}`;\n  }\n  // Construct a new validation context if necessary.\n  if (this._contexts[name]) {\n    return this._contexts[name];\n  }\n  this._contexts[name] = collection.simpleSchema(selector).newContext();\n  return this._contexts[name];\n};\n\n/**\n * @summary Get an import buffer for a given collection.\n * @param {Object} collection The target collection\n * @returns {Object} return buffer\n * If no buffer is presented, a new one will be constructed.\n */\nImport.buffer = function (collection) {\n  check(collection, Mongo.Collection);\n\n  if (!MongoInternals.NpmModule.Collection.prototype.initializeUnorderedBulkOp) {\n    throw Error(\"Couldn't detect the MongoDB bulk API, are you using MongoDB 2.6 or above?\");\n  }\n\n  // Construct a buffer identifier.\n  const name = this._name(collection);\n\n  // Construct a new buffer if necessary.\n  if (this._buffers[name]) {\n    return this._buffers[name];\n  }\n  this._count[name] = 0;\n  this._buffers[name] = collection.rawCollection().initializeUnorderedBulkOp();\n  return this._buffers[name];\n};\n\n/**\n * @summary Store a product in the import buffer.\n * @param {Object} key A key to look up the product\n * @param {Object} product The product data to be updated\n * @param {Object} parent A key to identify the parent product\n * @returns {Object}\n * Importing a variant currently consists of the following steps:\n *\n * * Pull the variant from non-matching parent products.\n * * Push the variant if it doesn't exist.\n * * Update the variant.\n */\nImport.product = function (key, product, parent) {\n  check(parent, Object);\n\n  return this.object(Collections.Products, key, product);\n};\n\n/**\n * @summary Store a package in the import buffer.\n * @param {Object} pkg The package data to be updated\n * @param {String} shopId The package data to be updated\n * @returns {undefined}\n */\nImport.package = function (pkg, shopId) {\n  check(pkg, Object);\n  check(shopId, String);\n  const key = {\n    name: pkg.name,\n    shopId: shopId\n  };\n  return this.object(Collections.Packages, key, pkg);\n};\n\n//\n// Import.translation\n// server/startup/i18n.js\n//\n\n/**\n * @summary Store a template in the import buffer.\n * @param {Object} templateInfo The template data to be updated\n * @param {String} shopId The package data to be updated\n * @returns {undefined}\n */\nImport.template = function (templateInfo) {\n  check(templateInfo, Object);\n\n  const key = {\n    name: templateInfo.name,\n    type: templateInfo.type || \"template\"\n  };\n\n  return this.object(Collections.Templates, key, templateInfo);\n};\n\n/**\n * @summary Store a translation in the import buffer.\n * @param {Object} key A key to look up the translation\n * @param {Object} translation The translation data to be updated\n * @returns {Object} updated translation buffer\n */\nImport.translation = function (key, translation) {\n  const modifiedKey = Object.assign(key, { ns: translation.ns });\n  return this.object(Collections.Translations, modifiedKey, translation);\n};\n\n/**\n * @summary Store a shop in the import buffer.\n * @param {Object} key A key to look up the shop\n * @param {Object} shop The shop data to be updated\n * @returns {Object} this shop\n */\nImport.shop = function (key, shop) {\n  return this.object(Collections.Shops, key, shop);\n};\n\n/**\n * @summary store a shop layout in the import buffer\n * @param {Array} layout - an array of layouts to be added to shop\n * @param {String} shopId shopId\n * @returns {Object} this shop\n */\nImport.layout = function (layout, shopId) {\n  const key = {\n    _id: shopId\n  };\n  return this.object(Collections.Shops, key, {\n    _id: shopId,\n    layout: layout\n  });\n};\n\n/**\n * @summary Store shipping in the import buffer.\n * @param {Object} key A shipping service key used in combination with provider\n * @param {Object} shipping The shipping data to be updated\n * @returns {Object} this shipping\n */\nImport.shipping = function (key, shipping) {\n  let importKey = {};\n  //\n  // we have a bit of a strange structure in Shipping\n  // and don't really have a key that is good for\n  // determining if we imported this before\n  // so we're just saying that if this service\n  // already exists then we're not going to import\n  //\n  const result = Collections.Shipping.findOne(key);\n  if (result) {\n    importKey = {\n      _id: result._id,\n      shopId: result.shopId\n    };\n    delete shipping.methods;\n  }\n  const modifiedKey = Object.assign({}, key, importKey);\n  return this.object(Collections.Shipping, modifiedKey, shipping);\n};\n\n/**\n * @summary Store a tag in the import buffer.\n * @param {Object} key A key to look up the tag\n * @param {Object} tag The tag data to be updated\n * @returns {Object} this tag\n */\nImport.tag = function (key, tag) {\n  return this.object(Collections.Tags, key, tag);\n};\n\n/**\n * @summary Push a new upsert document to the import buffer.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} key A key to look up the object\n * @param {Object} object The object data to be updated\n * @returns {undefined}\n */\nImport.object = function (collection, key, object) {\n  check(collection, Mongo.Collection);\n  check(key, Object);\n  check(object, Object);\n  const updateObject = object;\n\n  // enforce strings instead of Mongo.ObjectId\n  if (!collection.findOne(key) && !object._id) key._id = Random.id();\n\n  // hooks for additional import manipulation.\n  const importObject = Hooks.Events.run(`onImport${this._name(collection)}`, object);\n\n  // Clone object for cleaning\n  const cleanedObject = Object.assign({}, importObject);\n\n  // Cleaning the object adds default values from schema, if value doesn't exist\n  collection.simpleSchema(importObject).clean(cleanedObject);\n\n  // And validate the object against the schema\n  this.context(collection, updateObject).validate(cleanedObject, {});\n\n  // Disjoint importObject and cleanedObject again\n  // to prevent `Cannot update '<field>' and '<field>' at the same time` errors\n  const defaultValuesObject = doRightJoinNoIntersection(importObject, cleanedObject);\n\n  // Upsert the object.\n  const find = this.buffer(collection).find(key);\n\n  // With the upsert option set to true, if no matching documents exist for the Bulk.find() condition,\n  // then the update or the replacement operation performs an insert.\n  // https://docs.mongodb.com/manual/reference/method/Bulk.find.upsert/\n  if (Object.keys(defaultValuesObject).length === 0) {\n    find.upsert().update({\n      $set: importObject\n    });\n  } else {\n    find.upsert().update({\n      $set: importObject,\n      $setOnInsert: defaultValuesObject\n    });\n  }\n  if (this._count[this._name(collection)]++ >= this._limit) {\n    this.flush(collection);\n  }\n};\n\n/**\n * @summary Process a json array of import documents using a callback.\n * @param {Object[]} json An array containing the import documents\n * @param {string[]} keys Fields that should be used as the import key.\n * @param {Function} callback A callback accepting two parameters.\n * The callback should accept a key document to consult the database as a first\n * parameter and an update document as the second parameter.\n * @returns {undefined}\n */\nImport.process = function (json, keys, callback) {\n  check(json, String);\n  check(keys, Array);\n  check(callback, Function);\n\n  const array = EJSON.parse(json);\n\n  for (let i = 0; i < array.length; i++) {\n    const key = {};\n    for (let j = 0; j < keys.length; j++) {\n      key[keys[j]] = array[i][keys[j]];\n    }\n    callback.call(this, key, array[i]);\n  }\n};\n\nImport.indication(\"i18n\", Collections.Translations, 0.2);\nImport.indication(\"hashtags\", Collections.Products, 0.5);\nImport.indication(\"barcode\", Collections.Products, 0.5);\nImport.indication(\"price\", Collections.Products, 0.5);\nImport.indication(\"ancestors\", Collections.Products, 0.5);\nImport.indication(\"languages\", Collections.Shops, 0.5);\nImport.indication(\"currencies\", Collections.Shops, 0.5);\nImport.indication(\"timezone\", Collections.Shops, 0.5);\nImport.indication(\"isTopLevel\", Collections.Tags, 0.4);\nImport.indication(\"slug\", Collections.Tags, 0.5);\nImport.indication(\"provider\", Collections.Shipping, 0.2);\n\n//\n// exporting Fixture\n// use this instead of Import if you want\n// Bulk.find.upsert() to equal false\n//\nexport const Fixture = Object.assign({}, Import, {\n  _upsert: () => { return false; }\n});\n"]},"hash":"6ba9f81fb8d3c750d3a5add9a2b52192613e9a27"}
