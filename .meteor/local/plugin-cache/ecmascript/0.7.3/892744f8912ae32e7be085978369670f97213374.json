{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"/lib/collections","imported":["Packages"],"specifiers":[{"kind":"named","imported":"Packages","local":"Packages"}]},{"source":"/server/api","imported":["Reaction"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"}]},{"source":"/lib/api","imported":["translateRegistry"],"specifiers":[{"kind":"named","imported":"translateRegistry","local":"translateRegistry"}]},{"source":"meteor/alanning:roles","imported":["Roles"],"specifiers":[{"kind":"named","imported":"Roles","local":"Roles"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/publications/collections/packages.js","filenameRelative":"/server/publications/collections/packages.js","inputSourceMap":{"version":3,"sources":["/server/publications/collections/packages.js"],"names":["Packages","Reaction","translateRegistry","Roles","transform","doc","userId","registrySettings","packageSettings","permissions","name","registry","item","push","permission","_","uniq","hasAdmin","userIsInRole","shopId","packageId","_id","packageName","settingsKey","split","splice","route","template","settings","enabled","public","Object","assign","Meteor","publish","shopCursor","check","Match","Optional","self","shop","getCurrentShop","options","fields","layout","icon","audience","getShopId","GLOBAL_GROUP","observer","find","observe","added","changed","newDoc","origDoc","removed","onStop","stop","ready"],"mappings":"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","file":"/server/publications/collections/packages.js.map","sourcesContent":["import { Packages } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport { translateRegistry } from \"/lib/api\";\nimport { Roles } from \"meteor/alanning:roles\";\n\n/**\n * Packages contains user specific configuration\n * @summary  package publication settings, filtered by permissions\n * @param {Object} shopCursor - current shop object\n * @returns {Object} packagesCursor - current packages for shop\n */\n\n// for transforming packages before publication sets some defaults for the client and adds i18n while checking\n// privileged settings for enabled status.\nfunction transform(doc, userId) {\n  const registrySettings = {};\n  const packageSettings = {};\n  let permissions = [\"admin\", \"owner\", doc.name];\n\n  // Get all permissions, add them to an array\n  if (doc.registry && doc.registry.permissions) {\n    for (const item of doc.registry.permissions) {\n      permissions.push(item.permission);\n    }\n  }\n  permissions = _.uniq(permissions);\n\n  // check for admin,owner or package permissions to view settings\n  const hasAdmin = Roles.userIsInRole(userId, permissions, doc.shopId);\n\n  if (doc.registry) {\n    for (let registry of doc.registry) {\n      // add some normalized defaults\n      registry.packageId = doc._id;\n      registry.shopId = doc.shopId;\n      registry.packageName = registry.packageName || doc.name;\n      registry.settingsKey = (registry.name || doc.name).split(\"/\").splice(-1)[0];\n      // check and set package enabled state\n      registry.permissions = [...permissions];\n      if (registry.route) {\n        registry.permissions.push(registry.name || doc.name + \"/\" + registry.template);\n      }\n      if (doc.settings && doc.settings[registry.settingsKey]) {\n        registry.enabled = !!doc.settings[registry.settingsKey].enabled;\n      } else {\n        registry.enabled = !!doc.enabled;\n      }\n      // define export settings\n      registrySettings[registry.settingsKey] = {\n        enabled: registry.enabled\n      };\n\n      // add i18n keys\n      registry = translateRegistry(registry, doc);\n    }\n  }\n  // admin users get all settings the intent of this it so block publication of settings without limiting the use settings\n  // in this transform. non admin users should get public setting\n  if (hasAdmin === false && doc.settings) {\n    registrySettings.public = doc.settings.public;\n    delete doc.settings;\n    Object.assign(packageSettings, registrySettings);\n    doc.settings = packageSettings;\n  }\n\n  return doc;\n}\n\n//\n//  Packages Publication\n//\nMeteor.publish(\"Packages\", function (shopCursor) {\n  check(shopCursor, Match.Optional(Object));\n  const self = this;\n  const shop = shopCursor || Reaction.getCurrentShop();\n\n  // user is required.\n  if (self.userId) {\n    // default options, we're limiting fields here that we don't want to publish unless admin user. in particular, settings\n    // should not be published but we need to use settings in the transform everything except settings.public and\n    // settings.*.enabled are removed in transform\n    let options = {\n      fields: {\n        shopId: 1,\n        name: 1,\n        enabled: 1,\n        registry: 1,\n        layout: 1,\n        icon: 1,\n        settings: 1,\n        audience: 1\n      }\n    };\n\n    // we should always have a shop\n    if (shop) {\n      // if admin user, return all shop properties\n      if (Roles.userIsInRole(self.userId, [\n        \"dashboard\", \"owner\", \"admin\"\n      ], Reaction.getShopId() || Roles.userIsInRole(self.userId, [\n        \"owner\", \"admin\"\n      ], Roles.GLOBAL_GROUP))) {\n        options = {};\n      }\n      // observe and transform Package registry adds i18n and other meta data\n      const observer = Packages.find({\n        shopId: shop._id\n      }, options).observe({\n        added: function (doc) {\n          self.added(\"Packages\", doc._id, transform(doc, self.userId));\n        },\n        changed: function (newDoc, origDoc) {\n          self.changed(\"Packages\", origDoc._id, transform(newDoc, self.userId));\n        },\n        removed: function (origDoc) {\n          self.removed(\"Packages\", origDoc._id);\n        }\n      });\n\n      self.onStop(function () {\n        observer.stop();\n      });\n    }\n    return self.ready();\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/publications/collections/packages.js.map","sourceFileName":"/server/publications/collections/packages.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"packages"},"ignored":false,"code":"function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Packages = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Packages: function (v) {\n    Packages = v;\n  }\n}, 0);\nvar Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 1);\nvar translateRegistry = void 0;\nmodule.importSync(\"/lib/api\", {\n  translateRegistry: function (v) {\n    translateRegistry = v;\n  }\n}, 2);\nvar Roles = void 0;\nmodule.importSync(\"meteor/alanning:roles\", {\n  Roles: function (v) {\n    Roles = v;\n  }\n}, 3);\n\n/**\n * Packages contains user specific configuration\n * @summary  package publication settings, filtered by permissions\n * @param {Object} shopCursor - current shop object\n * @returns {Object} packagesCursor - current packages for shop\n */ // for transforming packages before publication sets some defaults for the client and adds i18n while checking\n// privileged settings for enabled status.\nfunction transform(doc, userId) {\n  var registrySettings = {};\n  var packageSettings = {};\n  var permissions = [\"admin\", \"owner\", doc.name]; // Get all permissions, add them to an array\n\n  if (doc.registry && doc.registry.permissions) {\n    for (var _iterator = doc.registry.permissions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var item = _ref;\n      permissions.push(item.permission);\n    }\n  }\n\n  permissions = _.uniq(permissions); // check for admin,owner or package permissions to view settings\n\n  var hasAdmin = Roles.userIsInRole(userId, permissions, doc.shopId);\n\n  if (doc.registry) {\n    for (var _iterator2 = doc.registry, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var registry = _ref2;\n      // add some normalized defaults\n      registry.packageId = doc._id;\n      registry.shopId = doc.shopId;\n      registry.packageName = registry.packageName || doc.name;\n      registry.settingsKey = (registry.name || doc.name).split(\"/\").splice(-1)[0]; // check and set package enabled state\n\n      registry.permissions = [].concat(_toConsumableArray(permissions));\n\n      if (registry.route) {\n        registry.permissions.push(registry.name || doc.name + \"/\" + registry.template);\n      }\n\n      if (doc.settings && doc.settings[registry.settingsKey]) {\n        registry.enabled = !!doc.settings[registry.settingsKey].enabled;\n      } else {\n        registry.enabled = !!doc.enabled;\n      } // define export settings\n\n\n      registrySettings[registry.settingsKey] = {\n        enabled: registry.enabled\n      }; // add i18n keys\n\n      registry = translateRegistry(registry, doc);\n    }\n  } // admin users get all settings the intent of this it so block publication of settings without limiting the use settings\n  // in this transform. non admin users should get public setting\n\n\n  if (hasAdmin === false && doc.settings) {\n    registrySettings.public = doc.settings.public;\n    delete doc.settings;\n    Object.assign(packageSettings, registrySettings);\n    doc.settings = packageSettings;\n  }\n\n  return doc;\n} //\n//  Packages Publication\n//\n\n\nMeteor.publish(\"Packages\", function (shopCursor) {\n  check(shopCursor, Match.Optional(Object));\n  var self = this;\n  var shop = shopCursor || Reaction.getCurrentShop(); // user is required.\n\n  if (self.userId) {\n    // default options, we're limiting fields here that we don't want to publish unless admin user. in particular, settings\n    // should not be published but we need to use settings in the transform everything except settings.public and\n    // settings.*.enabled are removed in transform\n    var options = {\n      fields: {\n        shopId: 1,\n        name: 1,\n        enabled: 1,\n        registry: 1,\n        layout: 1,\n        icon: 1,\n        settings: 1,\n        audience: 1\n      }\n    }; // we should always have a shop\n\n    if (shop) {\n      // if admin user, return all shop properties\n      if (Roles.userIsInRole(self.userId, [\"dashboard\", \"owner\", \"admin\"], Reaction.getShopId() || Roles.userIsInRole(self.userId, [\"owner\", \"admin\"], Roles.GLOBAL_GROUP))) {\n        options = {};\n      } // observe and transform Package registry adds i18n and other meta data\n\n\n      var observer = Packages.find({\n        shopId: shop._id\n      }, options).observe({\n        added: function (doc) {\n          self.added(\"Packages\", doc._id, transform(doc, self.userId));\n        },\n        changed: function (newDoc, origDoc) {\n          self.changed(\"Packages\", origDoc._id, transform(newDoc, self.userId));\n        },\n        removed: function (origDoc) {\n          self.removed(\"Packages\", origDoc._id);\n        }\n      });\n      self.onStop(function () {\n        observer.stop();\n      });\n    }\n\n    return self.ready();\n  }\n});","map":{"version":3,"sources":["/server/publications/collections/packages.js"],"names":["Packages","Reaction","translateRegistry","Roles","transform","doc","userId","registrySettings","packageSettings","permissions","name","registry","item","push","permission","_","uniq","hasAdmin","userIsInRole","shopId","packageId","_id","packageName","settingsKey","split","splice","route","template","settings","enabled","public","Object","assign","Meteor","publish","shopCursor","check","Match","Optional","self","shop","getCurrentShop","options","fields","layout","icon","audience","getShopId","GLOBAL_GROUP","observer","find","observe","added","changed","newDoc","origDoc","removed","onStop","stop","ready"],"mappings":"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","file":"/server/publications/collections/packages.js.map","sourcesContent":["import { Packages } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport { translateRegistry } from \"/lib/api\";\nimport { Roles } from \"meteor/alanning:roles\";\n\n/**\n * Packages contains user specific configuration\n * @summary  package publication settings, filtered by permissions\n * @param {Object} shopCursor - current shop object\n * @returns {Object} packagesCursor - current packages for shop\n */\n\n// for transforming packages before publication sets some defaults for the client and adds i18n while checking\n// privileged settings for enabled status.\nfunction transform(doc, userId) {\n  const registrySettings = {};\n  const packageSettings = {};\n  let permissions = [\"admin\", \"owner\", doc.name];\n\n  // Get all permissions, add them to an array\n  if (doc.registry && doc.registry.permissions) {\n    for (const item of doc.registry.permissions) {\n      permissions.push(item.permission);\n    }\n  }\n  permissions = _.uniq(permissions);\n\n  // check for admin,owner or package permissions to view settings\n  const hasAdmin = Roles.userIsInRole(userId, permissions, doc.shopId);\n\n  if (doc.registry) {\n    for (let registry of doc.registry) {\n      // add some normalized defaults\n      registry.packageId = doc._id;\n      registry.shopId = doc.shopId;\n      registry.packageName = registry.packageName || doc.name;\n      registry.settingsKey = (registry.name || doc.name).split(\"/\").splice(-1)[0];\n      // check and set package enabled state\n      registry.permissions = [...permissions];\n      if (registry.route) {\n        registry.permissions.push(registry.name || doc.name + \"/\" + registry.template);\n      }\n      if (doc.settings && doc.settings[registry.settingsKey]) {\n        registry.enabled = !!doc.settings[registry.settingsKey].enabled;\n      } else {\n        registry.enabled = !!doc.enabled;\n      }\n      // define export settings\n      registrySettings[registry.settingsKey] = {\n        enabled: registry.enabled\n      };\n\n      // add i18n keys\n      registry = translateRegistry(registry, doc);\n    }\n  }\n  // admin users get all settings the intent of this it so block publication of settings without limiting the use settings\n  // in this transform. non admin users should get public setting\n  if (hasAdmin === false && doc.settings) {\n    registrySettings.public = doc.settings.public;\n    delete doc.settings;\n    Object.assign(packageSettings, registrySettings);\n    doc.settings = packageSettings;\n  }\n\n  return doc;\n}\n\n//\n//  Packages Publication\n//\nMeteor.publish(\"Packages\", function (shopCursor) {\n  check(shopCursor, Match.Optional(Object));\n  const self = this;\n  const shop = shopCursor || Reaction.getCurrentShop();\n\n  // user is required.\n  if (self.userId) {\n    // default options, we're limiting fields here that we don't want to publish unless admin user. in particular, settings\n    // should not be published but we need to use settings in the transform everything except settings.public and\n    // settings.*.enabled are removed in transform\n    let options = {\n      fields: {\n        shopId: 1,\n        name: 1,\n        enabled: 1,\n        registry: 1,\n        layout: 1,\n        icon: 1,\n        settings: 1,\n        audience: 1\n      }\n    };\n\n    // we should always have a shop\n    if (shop) {\n      // if admin user, return all shop properties\n      if (Roles.userIsInRole(self.userId, [\n        \"dashboard\", \"owner\", \"admin\"\n      ], Reaction.getShopId() || Roles.userIsInRole(self.userId, [\n        \"owner\", \"admin\"\n      ], Roles.GLOBAL_GROUP))) {\n        options = {};\n      }\n      // observe and transform Package registry adds i18n and other meta data\n      const observer = Packages.find({\n        shopId: shop._id\n      }, options).observe({\n        added: function (doc) {\n          self.added(\"Packages\", doc._id, transform(doc, self.userId));\n        },\n        changed: function (newDoc, origDoc) {\n          self.changed(\"Packages\", origDoc._id, transform(newDoc, self.userId));\n        },\n        removed: function (origDoc) {\n          self.removed(\"Packages\", origDoc._id);\n        }\n      });\n\n      self.onStop(function () {\n        observer.stop();\n      });\n    }\n    return self.ready();\n  }\n});\n"]},"hash":"892744f8912ae32e7be085978369670f97213374"}
