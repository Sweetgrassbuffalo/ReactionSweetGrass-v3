{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"/lib/collections","imported":["Cart","Media"],"specifiers":[{"kind":"named","imported":"Cart","local":"Cart"},{"kind":"named","imported":"Media","local":"Media"}]},{"source":"/server/api","imported":["Reaction"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/publications/collections/cart.js","filenameRelative":"/server/publications/collections/cart.js","inputSourceMap":{"version":3,"sources":["/server/publications/collections/cart.js"],"names":["Cart","Media","Reaction","Meteor","publish","sessionId","userId","check","Match","OneOf","String","OptionalOrNull","ready","shopId","getShopId","fields","taxes","cart","find","count","cartId","call","cartItem","Optional","Object","productId","$nin"],"mappings":"AAAA;IAAA,AAAS;AAAT,AAAe,OAAa,WAA5B;;;;;;;;;;;;;GACA,A,AAAA,AAAS,AAAgB,AAEzB;AAIA,AAAO,AAAQ,AAAQ,AAAU,AAAW,AAAQ,AAClD,AAAM,AAAW,AAAM,AAAM,AAAQ,AACrC,AAAM,AAAQ,AAAM,AAAe,AACnC;;;;qCAGA,UAAA,AAAI,AAAK,AAAW,AAAQ,AAAc,AAAM,AAC9C;AAAA,AAAO,AAAK,AACb;AARiD,AASlD,AACA;;;;AACA,GANA,CAMA,AAAI,AAAO,AAAW,AAAY,AAAK,AAAW,AAAQ,AACxD;AAAA,AAAO,AAAK,AACb;;;AAbiD,AAclD,4DACA;gBACA;AACA,IACA;AACA;AACA;AACA;AAEA;;;AACA,AAAM,AAAS,AAAS;AACxB;;;AAAI,AAAC,MAAL,AAAa,kBACX;;OAAO,QA1ByC,AA0BhD,AAAO,AAAK,AACb;AAED,gBACA;IACA;AAAM,AAAS,AACb;;;MAAO;AAhCyC,AAmClD,WACA,AAAM,AAAO,AAAK,AAAK,AACrB;AANF,AAAe,KAKQ,AACb,AAAK,AACb;;MAAQ;AACP,iBACD;YAJF,AAAa,AAGV,AACO;AAJG,AAAU;YAOvB,AAAI,AAAK,AAAS,AAChB,AACA;;;oBACA;AACA;AA/CgD,AA+ChD,AAAO,AACR;AACD;;AACA,IAAA,AAAM,AAAS,AAAO,AAAK,AAAmB,AAAK,AAAQ,AAE3D;;;MAAO,AAAK,SAAL,AAAU,OAAjB,AAAO,qCApDT,AAqDC,AAED;AAAO,cAAP,AAAe,KAAf,AAAgC,AAAU,AAAU,AAClD;AAAA,AAAM,AAAU,AAAM,AAAS,AAC/B,AAAM,AAAY,AAAS,CArD3B;AAuDA,OAAO,QAAA,AAAM,AAAK,qCAChB;wBAAsB,SADN,AAEhB;kBAAqB,SAAA,AAAE,AAAM,AAAC,AAAY;;AAF5C,0BAJF,AAQC;;;;AAJQ,AAAW","file":"/server/publications/collections/cart.js.map","sourcesContent":["import { Cart, Media } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * cart\n */\n\nMeteor.publish(\"Cart\", function (sessionId, userId) {\n  check(sessionId, Match.OneOf(String, null));\n  check(userId, Match.OptionalOrNull(String));\n  // sessionId is required, not for selecting the cart, (userId), but as a key\n  // in merging anonymous user carts into authenticated existing user carts.\n  // we won't create carts unless we've got sessionId\n  if (this.userId === null || sessionId === null) {\n    return this.ready();\n  }\n  // use case happens between switching from anonymous to registered user. and\n  // vice versa\n  if (typeof userId === \"string\" && this.userId !== userId) {\n    return this.ready();\n  }\n  // we have a very rare case when cart has not been created for an anonymous\n  // and because of that, for some reason, he is considered as not logged in.\n  // in that case he doesn't have `userId`. Only way for him to get userId is\n  // to flush browser's session or log in as normal user. We could detect this\n  // case from here by comparing this.userId is string and this.userId !==\n  // Meteor.userId(). If this case will happens someday, we could try to send\n  // some logout call to accounts. This is it: https://github.com/meteor/meteor/\n  // issues/5103\n\n  // shopId is also required.\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  // exclude these fields\n  // from the client cart\n  const fields = {\n    taxes: 0\n  };\n\n  // select user cart\n  const cart = Cart.find({\n    userId: this.userId,\n    shopId: shopId\n  }, {\n    fields: fields\n  });\n\n  if (cart.count()) {\n    // we could keep `sessionId` of normal user up to date from here, but with\n    // current session logic we don't need this. That's why we just return\n    // cursor as is with whatever `sessionId`.\n    return cart;\n  }\n  // we may create a cart if we didn't find one.\n  const cartId = Meteor.call(\"cart/createCart\", this.userId, sessionId);\n\n  return Cart.find(cartId);\n});\n\nMeteor.publish(\"CartItemImage\", function (cartItem) {\n  check(cartItem, Match.Optional(Object));\n  const productId = cartItem.productId;\n\n  return Media.find({\n    \"metadata.productId\": productId,\n    \"metadata.workflow\": { $nin: [\"archived\", \"unpublished\"] }\n  });\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/publications/collections/cart.js.map","sourceFileName":"/server/publications/collections/cart.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cart"},"ignored":false,"code":"var Cart = void 0,\n    Media = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Cart: function (v) {\n    Cart = v;\n  },\n  Media: function (v) {\n    Media = v;\n  }\n}, 0);\nvar Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 1);\n/**\n * cart\n */Meteor.publish(\"Cart\", function (sessionId, userId) {\n  check(sessionId, Match.OneOf(String, null));\n  check(userId, Match.OptionalOrNull(String)); // sessionId is required, not for selecting the cart, (userId), but as a key\n  // in merging anonymous user carts into authenticated existing user carts.\n  // we won't create carts unless we've got sessionId\n\n  if (this.userId === null || sessionId === null) {\n    return this.ready();\n  } // use case happens between switching from anonymous to registered user. and\n  // vice versa\n\n\n  if (typeof userId === \"string\" && this.userId !== userId) {\n    return this.ready();\n  } // we have a very rare case when cart has not been created for an anonymous\n  // and because of that, for some reason, he is considered as not logged in.\n  // in that case he doesn't have `userId`. Only way for him to get userId is\n  // to flush browser's session or log in as normal user. We could detect this\n  // case from here by comparing this.userId is string and this.userId !==\n  // Meteor.userId(). If this case will happens someday, we could try to send\n  // some logout call to accounts. This is it: https://github.com/meteor/meteor/\n  // issues/5103\n  // shopId is also required.\n\n\n  var shopId = Reaction.getShopId();\n\n  if (!shopId) {\n    return this.ready();\n  } // exclude these fields\n  // from the client cart\n\n\n  var fields = {\n    taxes: 0\n  }; // select user cart\n\n  var cart = Cart.find({\n    userId: this.userId,\n    shopId: shopId\n  }, {\n    fields: fields\n  });\n\n  if (cart.count()) {\n    // we could keep `sessionId` of normal user up to date from here, but with\n    // current session logic we don't need this. That's why we just return\n    // cursor as is with whatever `sessionId`.\n    return cart;\n  } // we may create a cart if we didn't find one.\n\n\n  var cartId = Meteor.call(\"cart/createCart\", this.userId, sessionId);\n  return Cart.find(cartId);\n});\nMeteor.publish(\"CartItemImage\", function (cartItem) {\n  check(cartItem, Match.Optional(Object));\n  var productId = cartItem.productId;\n  return Media.find({\n    \"metadata.productId\": productId,\n    \"metadata.workflow\": {\n      $nin: [\"archived\", \"unpublished\"]\n    }\n  });\n});","map":{"version":3,"sources":["/server/publications/collections/cart.js"],"names":["Cart","Media","Reaction","Meteor","publish","sessionId","userId","check","Match","OneOf","String","OptionalOrNull","ready","shopId","getShopId","fields","taxes","cart","find","count","cartId","call","cartItem","Optional","Object","productId","$nin"],"mappings":"AAAA;IAAA,AAAS;AAAT,AAAe,OAAa,WAA5B;;;;;;;;;;;;;GACA,A,AAAA,AAAS,AAAgB,AAEzB;AAIA,AAAO,AAAQ,AAAQ,AAAU,AAAW,AAAQ,AAClD,AAAM,AAAW,AAAM,AAAM,AAAQ,AACrC,AAAM,AAAQ,AAAM,AAAe,AACnC;;;;qCAGA,UAAA,AAAI,AAAK,AAAW,AAAQ,AAAc,AAAM,AAC9C;AAAA,AAAO,AAAK,AACb;AARiD,AASlD,AACA;;;;AACA,GANA,CAMA,AAAI,AAAO,AAAW,AAAY,AAAK,AAAW,AAAQ,AACxD;AAAA,AAAO,AAAK,AACb;;;AAbiD,AAclD,4DACA;gBACA;AACA,IACA;AACA;AACA;AACA;AAEA;;;AACA,AAAM,AAAS,AAAS;AACxB;;;AAAI,AAAC,MAAL,AAAa,kBACX;;OAAO,QA1ByC,AA0BhD,AAAO,AAAK,AACb;AAED,gBACA;IACA;AAAM,AAAS,AACb;;;MAAO;AAhCyC,AAmClD,WACA,AAAM,AAAO,AAAK,AAAK,AACrB;AANF,AAAe,KAKQ,AACb,AAAK,AACb;;MAAQ;AACP,iBACD;YAJF,AAAa,AAGV,AACO;AAJG,AAAU;YAOvB,AAAI,AAAK,AAAS,AAChB,AACA;;;oBACA;AACA;AA/CgD,AA+ChD,AAAO,AACR;AACD;;AACA,IAAA,AAAM,AAAS,AAAO,AAAK,AAAmB,AAAK,AAAQ,AAE3D;;;MAAO,AAAK,SAAL,AAAU,OAAjB,AAAO,qCApDT,AAqDC,AAED;AAAO,cAAP,AAAe,KAAf,AAAgC,AAAU,AAAU,AAClD;AAAA,AAAM,AAAU,AAAM,AAAS,AAC/B,AAAM,AAAY,AAAS,CArD3B;AAuDA,OAAO,QAAA,AAAM,AAAK,qCAChB;wBAAsB,SADN,AAEhB;kBAAqB,SAAA,AAAE,AAAM,AAAC,AAAY;;AAF5C,0BAJF,AAQC;;;;AAJQ,AAAW","file":"/server/publications/collections/cart.js.map","sourcesContent":["import { Cart, Media } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * cart\n */\n\nMeteor.publish(\"Cart\", function (sessionId, userId) {\n  check(sessionId, Match.OneOf(String, null));\n  check(userId, Match.OptionalOrNull(String));\n  // sessionId is required, not for selecting the cart, (userId), but as a key\n  // in merging anonymous user carts into authenticated existing user carts.\n  // we won't create carts unless we've got sessionId\n  if (this.userId === null || sessionId === null) {\n    return this.ready();\n  }\n  // use case happens between switching from anonymous to registered user. and\n  // vice versa\n  if (typeof userId === \"string\" && this.userId !== userId) {\n    return this.ready();\n  }\n  // we have a very rare case when cart has not been created for an anonymous\n  // and because of that, for some reason, he is considered as not logged in.\n  // in that case he doesn't have `userId`. Only way for him to get userId is\n  // to flush browser's session or log in as normal user. We could detect this\n  // case from here by comparing this.userId is string and this.userId !==\n  // Meteor.userId(). If this case will happens someday, we could try to send\n  // some logout call to accounts. This is it: https://github.com/meteor/meteor/\n  // issues/5103\n\n  // shopId is also required.\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  // exclude these fields\n  // from the client cart\n  const fields = {\n    taxes: 0\n  };\n\n  // select user cart\n  const cart = Cart.find({\n    userId: this.userId,\n    shopId: shopId\n  }, {\n    fields: fields\n  });\n\n  if (cart.count()) {\n    // we could keep `sessionId` of normal user up to date from here, but with\n    // current session logic we don't need this. That's why we just return\n    // cursor as is with whatever `sessionId`.\n    return cart;\n  }\n  // we may create a cart if we didn't find one.\n  const cartId = Meteor.call(\"cart/createCart\", this.userId, sessionId);\n\n  return Cart.find(cartId);\n});\n\nMeteor.publish(\"CartItemImage\", function (cartItem) {\n  check(cartItem, Match.Optional(Object));\n  const productId = cartItem.productId;\n\n  return Media.find({\n    \"metadata.productId\": productId,\n    \"metadata.workflow\": { $nin: [\"archived\", \"unpublished\"] }\n  });\n});\n"]},"hash":"e157758b70ae1f0a46e7d71e0481eb3f1dedc6c4"}
