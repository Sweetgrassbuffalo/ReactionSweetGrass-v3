{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"lodash/sortBy","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_sortBy"}]},{"source":"meteor/ejson","imported":["EJSON"],"specifiers":[{"kind":"named","imported":"EJSON","local":"EJSON"}]},{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"/lib/api","imported":["copyFile","ReactionProduct"],"specifiers":[{"kind":"named","imported":"copyFile","local":"copyFile"},{"kind":"named","imported":"ReactionProduct","local":"ReactionProduct"}]},{"source":"/imports/plugins/core/revisions/server/hooks","imported":["ProductRevision"],"specifiers":[{"kind":"named","imported":"ProductRevision","local":"Catalog"}]},{"source":"/lib/collections","imported":["Media","Products","Revisions","Tags"],"specifiers":[{"kind":"named","imported":"Media","local":"Media"},{"kind":"named","imported":"Products","local":"Products"},{"kind":"named","imported":"Revisions","local":"Revisions"},{"kind":"named","imported":"Tags","local":"Tags"}]},{"source":"/server/api","imported":["Logger","Reaction"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/methods/catalog.js","filenameRelative":"/server/methods/catalog.js","inputSourceMap":{"version":3,"sources":["/server/methods/catalog.js"],"names":["EJSON","check","Meteor","copyFile","ReactionProduct","ProductRevision","Catalog","Media","Products","Revisions","Tags","Logger","Reaction","updateVariantProductField","variants","field","value","map","variant","call","_id","toDenormalize","createTitle","newTitle","productId","title","titleCount","find","$nin","count","titleNumberSuffix","titleString","copySuffix","match","String","replace","createHandle","productHandle","handle","handleCount","handleNumberSuffix","handleString","copyMedia","newId","variantOldId","variantNewId","forEach","fileObj","variantId","denormalize","id","doc","findOne","type","getTopVariants","ancestors","length","getVariants","update","Object","assign","isSoldOut","isLowQuantity","isBackorder","priceObject","getProductPriceRange","price","$set","selector","every","inventoryManagement","inventoryPolicy","getVariantQuantity","some","quantity","lowInventoryWarningThreshold","inventoryQuantity","flushQuantity","methods","hasPermission","Error","isAncestorDeleted","$or","$in","fetch","Random","sortedVariants","sortedVariant","oldId","clone","parentIndex","indexOf","ancestorsClone","slice","splice","updatedAt","createdAt","insert","validate","error","result","debug","parentId","newVariant","Match","Optional","newVariantId","product","Array","isArray","push","assembledVariant","currentVariant","isDeleted","undefined","toDelete","deleted","remove","productOrArray","OneOf","products","results","pool","getIds","filter","pair","setId","ids","buildAncestors","newAncestors","productNewId","newProduct","publishedAt","positions","isVisible","getSlug","hasAdminAccess","productIds","productsWithVariants","fields","numRemoved","Boolean","Number","parse","stringValue","stringify","e","message","tagName","tagId","unblock","newTag","slug","name","existingTag","productCount","hashtags","$push","newTagId","$pull","getSet","tag","existingHandles","currentProduct","currentProductHandle","positionData","position","pinned","weight","Date","sortedVariantIds","index","updatedMeta","meta","metafields","$addToSet","variantValidator","optionTitle","res","updateId","updatedPriceRange"],"mappings":"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","file":"/server/methods/catalog.js.map","sourcesContent":["import _ from  \"lodash\";\nimport { EJSON } from \"meteor/ejson\";\nimport { check } from \"meteor/check\";\nimport { Meteor } from \"meteor/meteor\";\nimport { copyFile, ReactionProduct } from \"/lib/api\";\nimport { ProductRevision as Catalog } from \"/imports/plugins/core/revisions/server/hooks\";\nimport { Media, Products, Revisions, Tags } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * Reaction Product Methods\n */\n/* eslint new-cap: 0 */\n/* eslint no-loop-func: 0 */\n/* eslint quotes: 0 */\n\n/**\n * updateVariantProductField\n * @summary updates the variant\n * @param {Array} variants - the array of variants\n * @param {String} field - the field to update\n * @param {String} value - the value to add\n * @return {Array} - return an array\n */\nfunction updateVariantProductField(variants, field, value) {\n  return variants.map(variant => {\n    Meteor.call(\"products/updateProductField\", variant._id, field, value);\n  });\n}\n\n/**\n * @array toDenormalize\n * @summary contains a list of fields, which should be denormalized\n * @type {string[]}\n */\nconst toDenormalize = [\n  \"price\",\n  \"inventoryQuantity\",\n  \"lowInventoryWarningThreshold\",\n  \"inventoryPolicy\",\n  \"inventoryManagement\"\n];\n\n/**\n * @function createTitle\n * @description Recursive method which trying to find a new `title`, given the\n * existing copies\n * @param {String} newTitle - product `title`\n * @param {String} productId - current product `_id`\n * @return {String} title - modified `title`\n */\nfunction createTitle(newTitle, productId) {\n  // exception product._id needed for cases then double triggering happens\n  let title = newTitle || \"\";\n  const titleCount = Products.find({\n    title: title,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n  // current product \"copy\" number\n  let titleNumberSuffix = 0;\n  // product handle prefix\n  let titleString = title;\n  // copySuffix \"-copy-number\" suffix of product\n  const copySuffix = titleString.match(/-copy-\\d+$/) || titleString.match(/-copy$/);\n  // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    titleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1;\n    // removing last numbers and last \"-\" if it presents\n    titleString = title.replace(/\\d+$/, '').replace(/-$/, '');\n  }\n\n  // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n  if (titleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (titleNumberSuffix > 0) {\n      title = `${titleString}-${titleNumberSuffix + titleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      title = `${titleString}-copy${ titleCount > 1 ? \"-\" + titleCount : \"\"}`;\n    }\n  }\n\n  // we should check again if there are any new matches with DB\n  if (Products.find({\n    title: title\n  }).count() !== 0) {\n    title = createTitle(title, productId);\n  }\n  return title;\n}\n\n/**\n * @function createHandle\n * @description Recursive method which trying to find a new `handle`, given the\n * existing copies\n * @param {String} productHandle - product `handle`\n * @param {String} productId - current product `_id`\n * @return {String} handle - modified `handle`\n */\nfunction createHandle(productHandle, productId) {\n  let handle = productHandle || \"\";\n  // exception product._id needed for cases then double triggering happens\n  const handleCount = Products.find({\n    handle: handle,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n  // current product \"copy\" number\n  let handleNumberSuffix = 0;\n  // product handle prefix\n  let handleString = handle;\n  // copySuffix \"-copy-number\" suffix of product\n  const copySuffix = handleString.match(/-copy-\\d+$/) || handleString.match(/-copy$/);\n\n  // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    handleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1;\n    // removing last numbers and last \"-\" if it presents\n    handleString = handle.replace(/\\d+$/, '').replace(/-$/, '');\n  }\n\n  // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n  if (handleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (handleNumberSuffix > 0) {\n      handle = `${handleString}-${handleNumberSuffix + handleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      handle = `${handleString}-copy${ handleCount > 1\n        ? '-' + handleCount : ''}`;\n    }\n  }\n\n  // we should check again if there are any new matches with DB\n  if (Products.find({\n    handle: handle\n  }).count() !== 0) {\n    handle = createHandle(handle, productId);\n  }\n\n  return handle;\n}\n\n/**\n * @function copyMedia\n * @description copy images links to cloned variant from original\n * @param {String} newId - [cloned|original] product _id\n * @param {String} variantOldId - old variant _id\n * @param {String} variantNewId - - cloned variant _id\n * @return {Number} Media#update result\n */\nfunction copyMedia(newId, variantOldId, variantNewId) {\n  Media.find({\n    \"metadata.variantId\": variantOldId\n  }).forEach(function (fileObj) {\n    // Copy File and insert directly, bypasing revision control\n    copyFile(fileObj, {\n      productId: newId,\n      variantId: variantNewId\n    });\n  });\n}\n\n/**\n * @function denormalize\n * @description With flattened model we do not want to get variant docs in\n * `products` publication, but we need some data from variants to display price,\n * quantity, etc. That's why we are denormalizing these properties into product\n * doc. Also, this way should have a speed benefit comparing the way where we\n * could dynamically build denormalization inside `products` publication.\n * @summary update product denormalized properties if variant was updated or\n * removed\n * @param {String} id - product _id\n * @param {String} field - type of field. Could be:\n * \"price\",\n * \"inventoryQuantity\",\n * \"inventoryManagement\",\n * \"inventoryPolicy\",\n * \"lowInventoryWarningThreshold\"\n * @since 0.11.0\n * @return {Number} - number of successful update operations. Should be \"1\".\n */\nfunction denormalize(id, field) {\n  const doc = Products.findOne(id);\n  let variants;\n  if (doc.type === \"simple\") {\n    variants = Catalog.getTopVariants(id);\n  } else if (doc.type === \"variant\" && doc.ancestors.length === 1) {\n    variants = Catalog.getVariants(id);\n  }\n  const update = {};\n\n  switch (field) {\n    case \"inventoryPolicy\":\n    case \"inventoryQuantity\":\n    case \"inventoryManagement\":\n      Object.assign(update, {\n        isSoldOut: isSoldOut(variants),\n        isLowQuantity: isLowQuantity(variants),\n        isBackorder: isBackorder(variants)\n      });\n      break;\n    case \"lowInventoryWarningThreshold\":\n      Object.assign(update, {\n        isLowQuantity: isLowQuantity(variants)\n      });\n      break;\n    default: // \"price\" is object with range, min, max\n      const priceObject = Catalog.getProductPriceRange(id);\n      Object.assign(update, {\n        price: priceObject\n      });\n  }\n  Products.update(id, {\n    $set: update\n  }, {\n    selector: {\n      type: \"simple\"\n    }\n  });\n}\n\n/**\n * isSoldOut\n * @description We are stop accepting new orders if product marked as\n * `isSoldOut`.\n * @param {Array} variants - Array with top-level variants\n * @return {Boolean} true if summary product quantity is zero.\n */\nfunction isSoldOut(variants) {\n  return variants.every(variant => {\n    if (variant.inventoryManagement && variant.inventoryPolicy) {\n      return Catalog.getVariantQuantity(variant) <= 0;\n    }\n    return false;\n  });\n}\n\n/**\n * isLowQuantity\n * @description If at least one of the variants is less than the threshold,\n * then function returns `true`\n * @param {Array} variants - array of child variants\n * @return {boolean} low quantity or not\n */\nfunction isLowQuantity(variants) {\n  return variants.some(variant => {\n    const quantity = Catalog.getVariantQuantity(variant);\n    // we need to keep an eye on `inventoryPolicy` too and qty > 0\n    if (variant.inventoryManagement && variant.inventoryPolicy && quantity) {\n      return quantity <= variant.lowInventoryWarningThreshold;\n    }\n    // TODO: need to test this function with real data\n    return false;\n  });\n}\n\n/**\n * isBackorder\n * @description Is products variants is still available to be ordered after\n * summary variants quantity is zero\n * @param {Array} variants - array with variant objects\n * @return {boolean} is backorder allowed or now for a product\n */\nfunction isBackorder(variants) {\n  return variants.every(variant => {\n    return !variant.inventoryPolicy && variant.inventoryManagement &&\n      variant.inventoryQuantity === 0;\n  });\n}\n\n/**\n * flushQuantity\n * @description if variant `inventoryQuantity` not zero, function update it to\n * zero. This needed in case then option with it's own `inventoryQuantity`\n * creates to top-level variant. In that case top-level variant should display\n * sum of his options `inventoryQuantity` fields.\n * @param {String} id - variant _id\n * @return {Number} - collection update results\n */\nfunction flushQuantity(id) {\n  const variant = Products.findOne(id);\n  // if variant already have descendants, quantity should be 0, and we don't\n  // need to do all next actions\n  if (variant.inventoryQuantity === 0) {\n    return 1; // let them think that we have one successful operation here\n  }\n\n  return Products.update({\n    _id: id\n  }, {\n    $set: {\n      inventoryQuantity: 0\n    }\n  }, {\n    selector: {\n      type: \"variant\"\n    }\n  });\n}\n\nMeteor.methods({\n  /**\n   * products/cloneVariant\n   * @summary clones a product variant into a new variant\n   * @description the method copies variants, but will also create and clone\n   * child variants (options)\n   * @param {String} productId - the productId we're whose variant we're\n   * cloning\n   * @param {String} variantId - the variantId that we're cloning\n   * @todo rewrite @description\n   * @return {Array} - list with cloned variants _ids\n   */\n  \"products/cloneVariant\": function (productId, variantId) {\n    check(productId, String);\n    check(variantId, String);\n    // user needs createProduct permission to clone\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const variant = Products.findOne(variantId);\n\n    // Verify that this variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n    if (ReactionProduct.isAncestorDeleted(variant, true)) {\n      throw new Meteor.Error(403, \"Unable to create product variant\");\n    }\n\n    const variants = Products.find({\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }],\n      type: \"variant\"\n    }).fetch();\n    // exit if we're trying to clone a ghost\n    if (variants.length === 0) {\n      return;\n    }\n    const variantNewId = Random.id(); // for the parent variant\n    // we need to make sure that top level variant will be cloned first, his\n    // descendants later.\n    // we could use this way in future: http://stackoverflow.com/questions/\n    // 9040161/mongo-order-by-length-of-array, by now following are allowed\n    // @link https://lodash.com/docs#sortBy\n    const sortedVariants = _.sortBy(variants, doc => doc.ancestors.length);\n\n    return sortedVariants.map(sortedVariant => {\n      const oldId = sortedVariant._id;\n      let type = \"child\";\n      const clone = {};\n      if (variantId === sortedVariant._id) {\n        type = \"parent\";\n        Object.assign(clone, sortedVariant, {\n          _id: variantNewId,\n          title: `${sortedVariant.title} - copy`\n        });\n      } else {\n        const parentIndex = sortedVariant.ancestors.indexOf(variantId);\n        const ancestorsClone = sortedVariant.ancestors.slice(0);\n        // if variantId exists in ancestors, we override it by new _id\n        !!~parentIndex && ancestorsClone.splice(parentIndex, 1, variantNewId);\n        Object.assign(clone, variant, {\n          _id: Random.id(),\n          ancestors: ancestorsClone\n        });\n      }\n      delete clone.updatedAt;\n      delete clone.createdAt;\n      delete clone.inventoryQuantity;\n      copyMedia(productId, oldId, clone._id);\n      return Products.insert(clone, {\n        validate: false\n      }, (error, result) => {\n        if (result) {\n          if (type === \"child\") {\n            Logger.debug(\n              `products/cloneVariant: created sub child clone: ${\n                clone._id} from ${variantId}`\n            );\n          } else {\n            Logger.debug(\n              `products/cloneVariant: created clone: ${\n                clone._id} from ${variantId}`\n            );\n          }\n        }\n        if (error) {\n          Logger.error(\n            `products/cloneVariant: cloning of ${variantId} was failed: ${error}`\n          );\n        }\n      });\n    });\n  },\n\n  /**\n   * products/createVariant\n   * @summary initializes empty variant template\n   * @param {String} parentId - the product _id or top level variant _id where\n   * we create variant\n   * @param {Object} [newVariant] - variant object\n   * @return {String} new variantId\n   */\n  \"products/createVariant\": function (parentId, newVariant) {\n    check(parentId, String);\n    check(newVariant, Match.Optional(Object));\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const newVariantId = Random.id();\n    // get parent ancestors to build new ancestors array\n    const product = Products.findOne(parentId);\n    const { ancestors } = product;\n\n    // Verify that the parent variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n    if (ReactionProduct.isAncestorDeleted(product, true)) {\n      throw new Meteor.Error(403, \"Unable to create product variant\");\n    }\n\n    Array.isArray(ancestors) && ancestors.push(parentId);\n    const assembledVariant = Object.assign(newVariant || {}, {\n      _id: newVariantId,\n      ancestors: ancestors,\n      type: \"variant\"\n    });\n\n    if (!newVariant) {\n      Object.assign(assembledVariant, {\n        title: \"\",\n        price: 0.00\n      });\n    }\n\n    // if we are inserting child variant to top-level variant, we need to remove\n    // all top-level's variant inventory records and flush it's quantity,\n    // because it will be hold sum of all it descendants quantities.\n    if (ancestors.length === 2) {\n      flushQuantity(parentId);\n    }\n\n    Products.insert(assembledVariant,\n      (error, result) => {\n        if (result) {\n          Logger.debug(\n            `products/createVariant: created variant: ${\n              newVariantId} for ${parentId}`\n          );\n        }\n      }\n    );\n\n    return newVariantId;\n  },\n\n  /**\n   * products/updateVariant\n   * @summary update individual variant with new values, merges into original\n   * only need to supply updated information. Currently used for a one use case\n   * - to manage top-level variant autoform.\n   * @param {Object} variant - current variant object\n   * @todo some use cases of this method was moved to \"products/\n   * updateProductField\", but it still used\n   * @return {Number} returns update result\n   */\n  \"products/updateVariant\": function (variant) {\n    check(variant, Object);\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const currentVariant = Products.findOne(variant._id);\n    // update variants\n    if (typeof currentVariant === \"object\") {\n      const newVariant = Object.assign({}, currentVariant, variant);\n\n      return Products.update({\n        _id: variant._id\n      }, {\n        $set: newVariant // newVariant already contain `type` property, so we\n          // do not need to pass it explicitly\n      }, {\n        validate: false\n      }, (error, result) => {\n        if (result) {\n          const productId = currentVariant.ancestors[0];\n          // we need manually check is these fields were updated?\n          // we can't stop after successful denormalization, because we have a\n          // case when several fields could be changed in top-level variant\n          // before form will be submitted.\n          toDenormalize.forEach(field => {\n            if (currentVariant[field] !== variant[field]) {\n              denormalize(productId, field);\n            }\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * products/deleteVariant\n   * @summary delete variant, which should also delete child variants\n   * @param {String} variantId - variantId to delete\n   * @returns {Boolean} returns update results: `true` - if at least one variant\n   * was removed or `false` if nothing was removed\n   */\n  \"products/deleteVariant\": function (variantId) {\n    check(variantId, String);\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const selector = {\n      // Don't \"archive\" variants that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }]\n    };\n    const toDelete = Products.find(selector).fetch();\n    // out if nothing to delete\n    if (!Array.isArray(toDelete) || toDelete.length === 0) return false;\n\n    const deleted = Products.remove(selector);\n\n    // after variant were removed from product, we need to recalculate all\n    // denormalized fields\n    const productId = toDelete[0].ancestors[0];\n    toDenormalize.forEach(field => denormalize(productId, field));\n\n    return typeof deleted === \"number\" && deleted > 0;\n  },\n\n  /**\n   * products/cloneProduct\n   * @summary clone a whole product, defaulting visibility, etc\n   * in the future we are going to do an inheritance product\n   * that maintains relationships with the cloned product tree\n   * @param {Array} productOrArray - products array to clone\n   * @returns {Array} returns insert results\n   */\n  \"products/cloneProduct\": function (productOrArray) {\n    check(productOrArray, Match.OneOf(Array, Object));\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // this.unblock();\n\n    let result;\n    let products;\n    const results = [];\n    const pool = []; // pool of id pairs: { oldId, newId }\n\n    function getIds(id) {\n      return pool.filter(function (pair) {\n        return pair.oldId === this.id;\n      }, {\n        id: id\n      });\n    }\n\n    function setId(ids) {\n      return pool.push(ids);\n    }\n\n    function buildAncestors(ancestors) {\n      const newAncestors = [];\n      ancestors.map(oldId => {\n        const pair = getIds(oldId);\n        // TODO do we always have newId on this step?\n        newAncestors.push(pair[0].newId);\n      });\n      return newAncestors;\n    }\n\n    if (!Array.isArray(productOrArray)) {\n      products = [productOrArray];\n    } else {\n      products = productOrArray;\n    }\n\n    for (const product of products) {\n      // cloning product\n      const productNewId = Random.id();\n      setId({\n        oldId: product._id,\n        newId: productNewId\n      });\n\n      const newProduct = Object.assign({}, product, {\n        _id: productNewId\n          // ancestors: product.ancestors.push(product._id)\n      });\n      delete newProduct.updatedAt;\n      delete newProduct.createdAt;\n      delete newProduct.publishedAt;\n      delete newProduct.positions;\n      delete newProduct.handle;\n      newProduct.isVisible = false;\n      if (newProduct.title) {\n        // todo test this\n        newProduct.title = createTitle(newProduct.title, newProduct._id);\n        newProduct.handle = createHandle(\n          Reaction.getSlug(newProduct.title),\n          newProduct._id\n        );\n      }\n      result = Products.insert(newProduct, {\n        validate: false\n      });\n      results.push(result);\n\n      // cloning variants\n      const variants = Products.find({\n        ancestors: {\n          $in: [product._id]\n        },\n        type: \"variant\"\n      }).fetch();\n      // why we are using `_.sortBy` described in `products/cloneVariant`\n      const sortedVariants = _.sortBy(variants, doc => doc.ancestors.length);\n      for (const variant of sortedVariants) {\n        const variantNewId = Random.id();\n        setId({\n          oldId: variant._id,\n          newId: variantNewId\n        });\n        const ancestors = buildAncestors(variant.ancestors);\n        const newVariant = Object.assign({}, variant, {\n          _id: variantNewId,\n          ancestors: ancestors\n        });\n        delete newVariant.updatedAt;\n        delete newVariant.createdAt;\n        delete newVariant.publishedAt; // TODO can variant have this param?\n\n        result = Products.insert(\n          newVariant, {\n            validate: false\n          }\n        );\n        copyMedia(productNewId, variant._id, variantNewId);\n        results.push(result);\n      }\n    }\n    return results;\n  },\n\n  /**\n   * products/createProduct\n   * @summary when we create a new product, we create it with an empty variant.\n   * all products have a variant with pricing and details\n   * @param {Object} [product] - optional product object\n   * @return {String} return insert result\n   */\n  \"products/createProduct\": function (product) {\n    check(product, Match.Optional(Object));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    // if a product object was provided\n    if (product) {\n      return Products.insert(product);\n    }\n\n    return Products.insert({\n      type: \"simple\" // needed for multi-schema\n    }, {\n      validate: false\n    }, (error, result) => {\n      // additionally, we want to create a variant to a new product\n      if (result) {\n        Products.insert({\n          ancestors: [result],\n          price: 0.00,\n          title: \"\",\n          type: \"variant\" // needed for multi-schema\n        });\n      }\n    });\n  },\n\n  /**\n   * products/archiveProduct\n   * @summary archive a product and unlink it from all media\n   * @param {String} productId - productId to delete\n   * @returns {Number} returns number of removed products\n   */\n  \"products/archiveProduct\": function (productId) {\n    check(productId, Match.OneOf(Array, String));\n    // must have admin permission to delete\n    if (!Reaction.hasPermission(\"createProduct\") && !Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    let productIds;\n\n    if (!Array.isArray(productId)) {\n      productIds = [productId];\n    } else {\n      productIds = productId;\n    }\n    const productsWithVariants = Products.find({\n      // Don't \"archive\" products that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: {\n          $in: productIds\n        }\n      }, {\n        ancestors: {\n          $in: productIds\n        }\n      }]\n    }, {\n      fields: {\n        type: 1\n      }\n    }).fetch();\n\n    const ids = [];\n    productsWithVariants.map(doc => {\n      ids.push(doc._id);\n    });\n\n    Products.remove({\n      _id: {\n        $in: ids\n      }\n    });\n\n    const numRemoved = Revisions.find({\n      \"documentId\": {\n        $in: ids\n      },\n      \"documentData.isDeleted\": true\n    }).count();\n\n    if (numRemoved > 0) {\n      // we can get removes results only in async way\n      Media.update({\n        \"metadata.productId\": {\n          $in: ids\n        },\n        \"metadata.variantId\": {\n          $in: ids\n        }\n      }, {\n        $set: {\n          \"metadata.isDeleted\": true\n        }\n      });\n      return numRemoved;\n    }\n    throw new Meteor.Error(304, \"Something went wrong, nothing was deleted\");\n  },\n\n  /**\n   * products/updateProductField\n   * @summary update single product or variant field\n   * @param {String} _id - product._id or variant._id to update\n   * @param {String} field - key to update\n   * @param {*} value - update property value\n   * @todo rename it to something like \"products/updateField\" to  reflect\n   * @todo we need to know which type of entity field belongs. For that we could\n   * do something like: const type = Products.findOne(_id).type or transmit type\n   * as param if it possible\n   * latest changes. its used for products and variants\n   * @return {Number} returns update result\n   */\n  \"products/updateProductField\": function (_id, field, value) {\n    check(_id, String);\n    check(field, String);\n    check(value, Match.OneOf(String, Object, Array, Boolean, Number));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const doc = Products.findOne(_id);\n    const type = doc.type;\n    let update;\n    // handle booleans with correct typing\n    if (value === \"false\" || value === \"true\") {\n      update = EJSON.parse(`{${field}:${value}}`);\n    } else {\n      const stringValue = EJSON.stringify(value);\n      update = EJSON.parse(\"{\\\"\" + field + \"\\\":\" + stringValue + \"}\");\n    }\n\n    // we need to use sync mode here, to return correct error and result to UI\n    let result;\n\n    try {\n      result = Products.update(_id, {\n        $set: update\n      }, {\n        selector: {\n          type: type\n        }\n      });\n    } catch (e) {\n      throw new Meteor.Error(e.message);\n    }\n\n    // If we get a result from the product update,\n    // meaning the update went past revision control,\n    // denormalize and attach results to top-level product\n    if (result === 1) {\n      if (type === \"variant\" && ~toDenormalize.indexOf(field)) {\n        denormalize(doc.ancestors[0], field);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * products/updateProductTags\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} productId - productId\n   * @param {String} tagName - tagName\n   * @param {String} tagId - tagId\n   * @return {Number} return result\n   */\n  \"products/updateProductTags\": function (productId, tagName, tagId) {\n    check(productId, String);\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n\n    const existingTag = Tags.findOne({\n      slug: Reaction.getSlug(tagName)\n    });\n\n    if (existingTag) {\n      const productCount = Products.find({\n        _id: productId,\n        hashtags: {\n          $in: [existingTag._id]\n        }\n      }).count();\n      if (productCount > 0) {\n        throw new Meteor.Error(403, \"Existing Tag, Update Denied\");\n      }\n      return Products.update(productId, {\n        $push: {\n          hashtags: existingTag._id\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } else if (tagId) {\n      return Tags.update(tagId, {\n        $set: newTag\n      });\n    }\n\n    const newTagId = Meteor.call(\"shop/createTag\", tagName, false);\n\n    // if result is an Error object, we return it immediately\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    return Products.update(productId, {\n      $push: {\n        hashtags: newTagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * products/removeProductTag\n   * @summary method to remove tag from product\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/removeProductTag\": function (productId, tagId) {\n    check(productId, String);\n    check(tagId, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    Products.update(productId, {\n      $pull: {\n        hashtags: tagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * products/setHandle\n   * @summary copy of \"products/setHandleTag\", but without tag\n   * @param {String} productId - productId\n   * @returns {String} handle - product handle\n   */\n  \"products/setHandle\": function (productId) {\n    check(productId, String);\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const product = Products.findOne(productId);\n    let handle = Reaction.getSlug(product.title);\n    handle = createHandle(handle, product._id);\n    Products.update(product._id, {\n      $set: {\n        handle: handle,\n        type: \"simple\"\n      }\n    });\n\n    return handle;\n  },\n\n  /**\n   * products/setHandleTag\n   * @summary set or toggle product handle\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/setHandleTag\": function (productId, tagId) {\n    check(productId, String);\n    check(tagId, String);\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    function getSet(handle) {\n      return {\n        $set: {\n          handle: handle,\n          type: \"simple\"\n        }\n      };\n    }\n\n    const product = Products.findOne(productId);\n    const tag = Tags.findOne(tagId);\n    // set handle\n    if (product.handle === tag.slug) {\n      let handle = Reaction.getSlug(product.title);\n      handle = createHandle(handle, product._id);\n      Products.update(product._id, getSet(handle));\n\n      return handle;\n    }\n    // toggle handle\n    const existingHandles = Products.find({\n      handle: tag.slug\n    }).fetch();\n    // this is needed to take care about product's handle which(product) was\n    // previously tagged.\n    for (const currentProduct of existingHandles) {\n      const currentProductHandle = createHandle(\n        Reaction.getSlug(currentProduct.title),\n        currentProduct._id);\n      Products.update(currentProduct._id,\n        getSet(currentProductHandle));\n    }\n    Products.update(product._id, getSet(tag.slug));\n\n    return tag.slug;\n  },\n\n  /**\n   * products/updateProductPosition\n   * @summary update product grid positions\n   * @param {String} productId - productId\n   * @param {Object} positionData -  an object with position,dimensions\n   * @param {String} tag - current route name. If it is not tag, then we using\n   * shop name as base `positions` name. Could be useful for multi-shopping.\n   * @return {Number} collection update returns\n   */\n  \"products/updateProductPosition\": function (productId, positionData, tag) {\n    check(productId, String);\n    check(positionData, Object);\n    check(tag, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const position = `positions.${tag}.position`;\n    const pinned = `positions.${tag}.pinned`;\n    const weight = `positions.${tag}.weight`;\n    const updatedAt = `positions.${tag}.updatedAt`;\n\n    return Products.update({\n      _id: productId\n    }, {\n      $set: {\n        [position]: positionData.position,\n        [pinned]: positionData.pinned,\n        [weight]: positionData.weight,\n        [updatedAt]: new Date(),\n        type: \"simple\" // for multi-schema\n      }\n    });\n  },\n\n  /**\n   * products/updateVariantsPosition\n   * @description updates top level variant position index\n   * @param {Array} sortedVariantIds - array of top level variant `_id`s\n   * @since 0.11.0\n   * @return {Number} Products.update result\n   */\n  \"products/updateVariantsPosition\": function (sortedVariantIds) {\n    check(sortedVariantIds, [String]);\n    // TODO: to make this work we need to remove auditArgumentsCheck I suppose\n    // new SimpleSchema({\n    //   sortedVariantIds: { type: [String] }\n    // }).validate({ sortedVariantIds });\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    sortedVariantIds.forEach((id, index) => {\n      Products.update(id, {\n        $set: {\n          index: index\n        }\n      }, {\n        selector: {\n          type: \"variant\"\n        }\n      }, (error, result) => {\n        if (result) {\n          Logger.debug(\n            `Variant ${id} position was updated to index ${index}`\n          );\n        }\n      });\n    });\n  },\n\n  /**\n   * products/updateMetaFields\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} updatedMeta - update object with metadata\n   * @param {Object|Number|undefined|null} meta - current meta object, or a number index\n   * @todo should this method works for variants also?\n   * @return {Number} collection update result\n   */\n  \"products/updateMetaFields\": function (productId, updatedMeta, meta) {\n    check(productId, String);\n    check(updatedMeta, Object);\n    check(meta, Match.OneOf(Object, Number, undefined, null));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    // update existing metadata\n    if (typeof meta === \"object\") {\n      return Products.update({\n        _id: productId,\n        metafields: meta\n      }, {\n        $set: {\n          \"metafields.$\": updatedMeta\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } else if (typeof meta === \"number\") {\n      return Products.update({\n        _id: productId\n      }, {\n        $set: {\n          [`metafields.${meta}`]: updatedMeta\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    }\n\n    // adds metadata\n    return Products.update({\n      _id: productId\n    }, {\n      $addToSet: {\n        metafields: updatedMeta\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * products/removeMetaFields\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} metafields - metadata object to remove\n   * @param {Object} type - optional product type for schema selection\n   * @return {Number} collection update result\n   */\n  \"products/removeMetaFields\": function (productId, metafields, type = \"simple\") {\n    check(productId, String);\n    check(metafields, Object);\n    check(type, String);\n\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Products.update({\n      _id: productId,\n      type: type\n    }, {\n      $pull: {\n        metafields: metafields\n      }\n    });\n  },\n\n  /**\n   * products/publishProduct\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/publishProduct\": function (productId) {\n    check(productId, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const product = Products.findOne(productId);\n    const variants = Products.find({\n      ancestors: {\n        $in: [productId]\n      }\n    }).fetch();\n    let variantValidator = true;\n\n    if (typeof product === \"object\" && product.title.length > 1) {\n      if (variants.length > 0) {\n        variants.forEach(variant => {\n          // if this is a top variant with children, we avoid it to check price\n          // because we using price of its children\n          if (variant.ancestors.length === 1 &&\n            !Catalog.getVariants(variant._id, \"variant\").length ||\n            variant.ancestors.length !== 1) {\n            if (!(typeof variant.price === \"number\" && variant.price > 0)) {\n              variantValidator = false;\n            }\n          }\n          // if variant has no title\n          if (typeof variant.title === \"string\" && !variant.title.length) {\n            variantValidator = false;\n          }\n          if (typeof optionTitle === \"string\" && !optionTitle.length) {\n            variantValidator = false;\n          }\n        });\n      } else {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(403, \"Forbidden\", \"Variant is required\");\n      }\n\n      if (!variantValidator) {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(403, \"Forbidden\",\n          \"Some properties are missing.\");\n      }\n\n      // update product visibility\n      Logger.debug(\"toggle product visibility \", product._id, !product.isVisible);\n\n      const res = Products.update(product._id, {\n        $set: {\n          isVisible: !product.isVisible\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n      // update product variants visibility\n      updateVariantProductField(variants, \"isVisible\", !product.isVisible);\n      // if collection updated we return new `isVisible` state\n      return res === 1 && !product.isVisible;\n    }\n    Logger.debug(\"invalid product visibility \", productId);\n    throw new Meteor.Error(400, \"Bad Request\");\n  },\n  /**\n   * products/publishProduct\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/toggleVisibility\": function (productId) {\n    check(productId, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const product = Products.findOne(productId);\n    const res = Products.update(productId, {\n      $set: {\n        isVisible: !product.isVisible\n      }\n    }, {\n      selector: {\n        type: product.type\n      }\n    });\n\n    if (Array.isArray(product.ancestors) && product.ancestors.length) {\n      const updateId = product.ancestors[0] || product._id;\n      const updatedPriceRange = ReactionProduct.getProductPriceRange(updateId);\n\n      Meteor.call(\"products/updateProductField\", updateId, \"price\", updatedPriceRange);\n    }\n\n    // if collection updated we return new `isVisible` state\n    return res === 1 && !product.isVisible;\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/methods/catalog.js.map","sourceFileName":"/server/methods/catalog.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"catalog"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _sortBy = void 0;\n\nmodule.importSync(\"lodash/sortBy\", {\n  \"default\": function (v) {\n    _sortBy = v;\n  }\n}, 0);\nvar EJSON = void 0;\nmodule.importSync(\"meteor/ejson\", {\n  EJSON: function (v) {\n    EJSON = v;\n  }\n}, 1);\nvar check = void 0;\nmodule.importSync(\"meteor/check\", {\n  check: function (v) {\n    check = v;\n  }\n}, 2);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 3);\nvar copyFile = void 0,\n    ReactionProduct = void 0;\nmodule.importSync(\"/lib/api\", {\n  copyFile: function (v) {\n    copyFile = v;\n  },\n  ReactionProduct: function (v) {\n    ReactionProduct = v;\n  }\n}, 4);\nvar Catalog = void 0;\nmodule.importSync(\"/imports/plugins/core/revisions/server/hooks\", {\n  ProductRevision: function (v) {\n    Catalog = v;\n  }\n}, 5);\nvar Media = void 0,\n    Products = void 0,\n    Revisions = void 0,\n    Tags = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Media: function (v) {\n    Media = v;\n  },\n  Products: function (v) {\n    Products = v;\n  },\n  Revisions: function (v) {\n    Revisions = v;\n  },\n  Tags: function (v) {\n    Tags = v;\n  }\n}, 6);\nvar Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 7);\n\n/**\n * Reaction Product Methods\n */ /* eslint new-cap: 0 */ /* eslint no-loop-func: 0 */ /* eslint quotes: 0 */ /**\n                                                                                 * updateVariantProductField\n                                                                                 * @summary updates the variant\n                                                                                 * @param {Array} variants - the array of variants\n                                                                                 * @param {String} field - the field to update\n                                                                                 * @param {String} value - the value to add\n                                                                                 * @return {Array} - return an array\n                                                                                 */function updateVariantProductField(variants, field, value) {\n  return variants.map(function (variant) {\n    Meteor.call(\"products/updateProductField\", variant._id, field, value);\n  });\n} /**\n   * @array toDenormalize\n   * @summary contains a list of fields, which should be denormalized\n   * @type {string[]}\n   */\n\nvar toDenormalize = [\"price\", \"inventoryQuantity\", \"lowInventoryWarningThreshold\", \"inventoryPolicy\", \"inventoryManagement\"]; /**\n                                                                                                                               * @function createTitle\n                                                                                                                               * @description Recursive method which trying to find a new `title`, given the\n                                                                                                                               * existing copies\n                                                                                                                               * @param {String} newTitle - product `title`\n                                                                                                                               * @param {String} productId - current product `_id`\n                                                                                                                               * @return {String} title - modified `title`\n                                                                                                                               */\n\nfunction createTitle(newTitle, productId) {\n  // exception product._id needed for cases then double triggering happens\n  var title = newTitle || \"\";\n  var titleCount = Products.find({\n    title: title,\n    _id: {\n      $nin: [productId]\n    }\n  }).count(); // current product \"copy\" number\n\n  var titleNumberSuffix = 0; // product handle prefix\n\n  var titleString = title; // copySuffix \"-copy-number\" suffix of product\n\n  var copySuffix = titleString.match(/-copy-\\d+$/) || titleString.match(/-copy$/); // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    titleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1; // removing last numbers and last \"-\" if it presents\n\n    titleString = title.replace(/\\d+$/, '').replace(/-$/, '');\n  } // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n\n\n  if (titleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (titleNumberSuffix > 0) {\n      title = titleString + \"-\" + (titleNumberSuffix + titleCount);\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      title = titleString + \"-copy\" + (titleCount > 1 ? \"-\" + titleCount : \"\");\n    }\n  } // we should check again if there are any new matches with DB\n\n\n  if (Products.find({\n    title: title\n  }).count() !== 0) {\n    title = createTitle(title, productId);\n  }\n\n  return title;\n} /**\n   * @function createHandle\n   * @description Recursive method which trying to find a new `handle`, given the\n   * existing copies\n   * @param {String} productHandle - product `handle`\n   * @param {String} productId - current product `_id`\n   * @return {String} handle - modified `handle`\n   */\n\nfunction createHandle(productHandle, productId) {\n  var handle = productHandle || \"\"; // exception product._id needed for cases then double triggering happens\n\n  var handleCount = Products.find({\n    handle: handle,\n    _id: {\n      $nin: [productId]\n    }\n  }).count(); // current product \"copy\" number\n\n  var handleNumberSuffix = 0; // product handle prefix\n\n  var handleString = handle; // copySuffix \"-copy-number\" suffix of product\n\n  var copySuffix = handleString.match(/-copy-\\d+$/) || handleString.match(/-copy$/); // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    handleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1; // removing last numbers and last \"-\" if it presents\n\n    handleString = handle.replace(/\\d+$/, '').replace(/-$/, '');\n  } // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n\n\n  if (handleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (handleNumberSuffix > 0) {\n      handle = handleString + \"-\" + (handleNumberSuffix + handleCount);\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      handle = handleString + \"-copy\" + (handleCount > 1 ? '-' + handleCount : '');\n    }\n  } // we should check again if there are any new matches with DB\n\n\n  if (Products.find({\n    handle: handle\n  }).count() !== 0) {\n    handle = createHandle(handle, productId);\n  }\n\n  return handle;\n} /**\n   * @function copyMedia\n   * @description copy images links to cloned variant from original\n   * @param {String} newId - [cloned|original] product _id\n   * @param {String} variantOldId - old variant _id\n   * @param {String} variantNewId - - cloned variant _id\n   * @return {Number} Media#update result\n   */\n\nfunction copyMedia(newId, variantOldId, variantNewId) {\n  Media.find({\n    \"metadata.variantId\": variantOldId\n  }).forEach(function (fileObj) {\n    // Copy File and insert directly, bypasing revision control\n    copyFile(fileObj, {\n      productId: newId,\n      variantId: variantNewId\n    });\n  });\n} /**\n   * @function denormalize\n   * @description With flattened model we do not want to get variant docs in\n   * `products` publication, but we need some data from variants to display price,\n   * quantity, etc. That's why we are denormalizing these properties into product\n   * doc. Also, this way should have a speed benefit comparing the way where we\n   * could dynamically build denormalization inside `products` publication.\n   * @summary update product denormalized properties if variant was updated or\n   * removed\n   * @param {String} id - product _id\n   * @param {String} field - type of field. Could be:\n   * \"price\",\n   * \"inventoryQuantity\",\n   * \"inventoryManagement\",\n   * \"inventoryPolicy\",\n   * \"lowInventoryWarningThreshold\"\n   * @since 0.11.0\n   * @return {Number} - number of successful update operations. Should be \"1\".\n   */\n\nfunction denormalize(id, field) {\n  var doc = Products.findOne(id);\n  var variants = void 0;\n\n  if (doc.type === \"simple\") {\n    variants = Catalog.getTopVariants(id);\n  } else if (doc.type === \"variant\" && doc.ancestors.length === 1) {\n    variants = Catalog.getVariants(id);\n  }\n\n  var update = {};\n\n  switch (field) {\n    case \"inventoryPolicy\":\n    case \"inventoryQuantity\":\n    case \"inventoryManagement\":\n      Object.assign(update, {\n        isSoldOut: isSoldOut(variants),\n        isLowQuantity: isLowQuantity(variants),\n        isBackorder: isBackorder(variants)\n      });\n      break;\n\n    case \"lowInventoryWarningThreshold\":\n      Object.assign(update, {\n        isLowQuantity: isLowQuantity(variants)\n      });\n      break;\n\n    default:\n      // \"price\" is object with range, min, max\n      var priceObject = Catalog.getProductPriceRange(id);\n      Object.assign(update, {\n        price: priceObject\n      });\n  }\n\n  Products.update(id, {\n    $set: update\n  }, {\n    selector: {\n      type: \"simple\"\n    }\n  });\n} /**\n   * isSoldOut\n   * @description We are stop accepting new orders if product marked as\n   * `isSoldOut`.\n   * @param {Array} variants - Array with top-level variants\n   * @return {Boolean} true if summary product quantity is zero.\n   */\n\nfunction isSoldOut(variants) {\n  return variants.every(function (variant) {\n    if (variant.inventoryManagement && variant.inventoryPolicy) {\n      return Catalog.getVariantQuantity(variant) <= 0;\n    }\n\n    return false;\n  });\n} /**\n   * isLowQuantity\n   * @description If at least one of the variants is less than the threshold,\n   * then function returns `true`\n   * @param {Array} variants - array of child variants\n   * @return {boolean} low quantity or not\n   */\n\nfunction isLowQuantity(variants) {\n  return variants.some(function (variant) {\n    var quantity = Catalog.getVariantQuantity(variant); // we need to keep an eye on `inventoryPolicy` too and qty > 0\n\n    if (variant.inventoryManagement && variant.inventoryPolicy && quantity) {\n      return quantity <= variant.lowInventoryWarningThreshold;\n    } // TODO: need to test this function with real data\n\n\n    return false;\n  });\n} /**\n   * isBackorder\n   * @description Is products variants is still available to be ordered after\n   * summary variants quantity is zero\n   * @param {Array} variants - array with variant objects\n   * @return {boolean} is backorder allowed or now for a product\n   */\n\nfunction isBackorder(variants) {\n  return variants.every(function (variant) {\n    return !variant.inventoryPolicy && variant.inventoryManagement && variant.inventoryQuantity === 0;\n  });\n} /**\n   * flushQuantity\n   * @description if variant `inventoryQuantity` not zero, function update it to\n   * zero. This needed in case then option with it's own `inventoryQuantity`\n   * creates to top-level variant. In that case top-level variant should display\n   * sum of his options `inventoryQuantity` fields.\n   * @param {String} id - variant _id\n   * @return {Number} - collection update results\n   */\n\nfunction flushQuantity(id) {\n  var variant = Products.findOne(id); // if variant already have descendants, quantity should be 0, and we don't\n  // need to do all next actions\n\n  if (variant.inventoryQuantity === 0) {\n    return 1; // let them think that we have one successful operation here\n  }\n\n  return Products.update({\n    _id: id\n  }, {\n    $set: {\n      inventoryQuantity: 0\n    }\n  }, {\n    selector: {\n      type: \"variant\"\n    }\n  });\n}\n\nMeteor.methods({\n  /**\n   * products/cloneVariant\n   * @summary clones a product variant into a new variant\n   * @description the method copies variants, but will also create and clone\n   * child variants (options)\n   * @param {String} productId - the productId we're whose variant we're\n   * cloning\n   * @param {String} variantId - the variantId that we're cloning\n   * @todo rewrite @description\n   * @return {Array} - list with cloned variants _ids\n   */\"products/cloneVariant\": function (productId, variantId) {\n    check(productId, String);\n    check(variantId, String); // user needs createProduct permission to clone\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var variant = Products.findOne(variantId); // Verify that this variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n\n    if (ReactionProduct.isAncestorDeleted(variant, true)) {\n      throw new Meteor.Error(403, \"Unable to create product variant\");\n    }\n\n    var variants = Products.find({\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }],\n      type: \"variant\"\n    }).fetch(); // exit if we're trying to clone a ghost\n\n    if (variants.length === 0) {\n      return;\n    }\n\n    var variantNewId = Random.id(); // for the parent variant\n    // we need to make sure that top level variant will be cloned first, his\n    // descendants later.\n    // we could use this way in future: http://stackoverflow.com/questions/\n    // 9040161/mongo-order-by-length-of-array, by now following are allowed\n    // @link https://lodash.com/docs#sortBy\n\n    var sortedVariants = _sortBy(variants, function (doc) {\n      return doc.ancestors.length;\n    });\n\n    return sortedVariants.map(function (sortedVariant) {\n      var oldId = sortedVariant._id;\n      var type = \"child\";\n      var clone = {};\n\n      if (variantId === sortedVariant._id) {\n        type = \"parent\";\n        Object.assign(clone, sortedVariant, {\n          _id: variantNewId,\n          title: sortedVariant.title + \" - copy\"\n        });\n      } else {\n        var parentIndex = sortedVariant.ancestors.indexOf(variantId);\n        var ancestorsClone = sortedVariant.ancestors.slice(0); // if variantId exists in ancestors, we override it by new _id\n\n        !!~parentIndex && ancestorsClone.splice(parentIndex, 1, variantNewId);\n        Object.assign(clone, variant, {\n          _id: Random.id(),\n          ancestors: ancestorsClone\n        });\n      }\n\n      delete clone.updatedAt;\n      delete clone.createdAt;\n      delete clone.inventoryQuantity;\n      copyMedia(productId, oldId, clone._id);\n      return Products.insert(clone, {\n        validate: false\n      }, function (error, result) {\n        if (result) {\n          if (type === \"child\") {\n            Logger.debug(\"products/cloneVariant: created sub child clone: \" + clone._id + \" from \" + variantId);\n          } else {\n            Logger.debug(\"products/cloneVariant: created clone: \" + clone._id + \" from \" + variantId);\n          }\n        }\n\n        if (error) {\n          Logger.error(\"products/cloneVariant: cloning of \" + variantId + \" was failed: \" + error);\n        }\n      });\n    });\n  },\n  /**\n   * products/createVariant\n   * @summary initializes empty variant template\n   * @param {String} parentId - the product _id or top level variant _id where\n   * we create variant\n   * @param {Object} [newVariant] - variant object\n   * @return {String} new variantId\n   */\"products/createVariant\": function (parentId, newVariant) {\n    check(parentId, String);\n    check(newVariant, Match.Optional(Object)); // must have createProduct permissions\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var newVariantId = Random.id(); // get parent ancestors to build new ancestors array\n\n    var product = Products.findOne(parentId);\n    var ancestors = product.ancestors; // Verify that the parent variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n\n    if (ReactionProduct.isAncestorDeleted(product, true)) {\n      throw new Meteor.Error(403, \"Unable to create product variant\");\n    }\n\n    Array.isArray(ancestors) && ancestors.push(parentId);\n    var assembledVariant = Object.assign(newVariant || {}, {\n      _id: newVariantId,\n      ancestors: ancestors,\n      type: \"variant\"\n    });\n\n    if (!newVariant) {\n      Object.assign(assembledVariant, {\n        title: \"\",\n        price: 0.00\n      });\n    } // if we are inserting child variant to top-level variant, we need to remove\n    // all top-level's variant inventory records and flush it's quantity,\n    // because it will be hold sum of all it descendants quantities.\n\n\n    if (ancestors.length === 2) {\n      flushQuantity(parentId);\n    }\n\n    Products.insert(assembledVariant, function (error, result) {\n      if (result) {\n        Logger.debug(\"products/createVariant: created variant: \" + newVariantId + \" for \" + parentId);\n      }\n    });\n    return newVariantId;\n  },\n  /**\n   * products/updateVariant\n   * @summary update individual variant with new values, merges into original\n   * only need to supply updated information. Currently used for a one use case\n   * - to manage top-level variant autoform.\n   * @param {Object} variant - current variant object\n   * @todo some use cases of this method was moved to \"products/\n   * updateProductField\", but it still used\n   * @return {Number} returns update result\n   */\"products/updateVariant\": function (variant) {\n    check(variant, Object); // must have createProduct permissions\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var currentVariant = Products.findOne(variant._id); // update variants\n\n    if ((typeof currentVariant === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(currentVariant)) === \"object\") {\n      var newVariant = Object.assign({}, currentVariant, variant);\n      return Products.update({\n        _id: variant._id\n      }, {\n        $set: newVariant // newVariant already contain `type` property, so we\n        // do not need to pass it explicitly\n\n      }, {\n        validate: false\n      }, function (error, result) {\n        if (result) {\n          var productId = currentVariant.ancestors[0]; // we need manually check is these fields were updated?\n          // we can't stop after successful denormalization, because we have a\n          // case when several fields could be changed in top-level variant\n          // before form will be submitted.\n\n          toDenormalize.forEach(function (field) {\n            if (currentVariant[field] !== variant[field]) {\n              denormalize(productId, field);\n            }\n          });\n        }\n      });\n    }\n  },\n  /**\n   * products/deleteVariant\n   * @summary delete variant, which should also delete child variants\n   * @param {String} variantId - variantId to delete\n   * @returns {Boolean} returns update results: `true` - if at least one variant\n   * was removed or `false` if nothing was removed\n   */\"products/deleteVariant\": function (variantId) {\n    check(variantId, String); // must have createProduct permissions\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var selector = {\n      // Don't \"archive\" variants that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }]\n    };\n    var toDelete = Products.find(selector).fetch(); // out if nothing to delete\n\n    if (!Array.isArray(toDelete) || toDelete.length === 0) return false;\n    var deleted = Products.remove(selector); // after variant were removed from product, we need to recalculate all\n    // denormalized fields\n\n    var productId = toDelete[0].ancestors[0];\n    toDenormalize.forEach(function (field) {\n      return denormalize(productId, field);\n    });\n    return typeof deleted === \"number\" && deleted > 0;\n  },\n  /**\n   * products/cloneProduct\n   * @summary clone a whole product, defaulting visibility, etc\n   * in the future we are going to do an inheritance product\n   * that maintains relationships with the cloned product tree\n   * @param {Array} productOrArray - products array to clone\n   * @returns {Array} returns insert results\n   */\"products/cloneProduct\": function (productOrArray) {\n    check(productOrArray, Match.OneOf(Array, Object)); // must have createProduct permissions\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    } // this.unblock();\n\n\n    var result = void 0;\n    var products = void 0;\n    var results = [];\n    var pool = []; // pool of id pairs: { oldId, newId }\n\n    function getIds(id) {\n      return pool.filter(function (pair) {\n        return pair.oldId === this.id;\n      }, {\n        id: id\n      });\n    }\n\n    function setId(ids) {\n      return pool.push(ids);\n    }\n\n    function buildAncestors(ancestors) {\n      var newAncestors = [];\n      ancestors.map(function (oldId) {\n        var pair = getIds(oldId); // TODO do we always have newId on this step?\n\n        newAncestors.push(pair[0].newId);\n      });\n      return newAncestors;\n    }\n\n    if (!Array.isArray(productOrArray)) {\n      products = [productOrArray];\n    } else {\n      products = productOrArray;\n    }\n\n    for (var _iterator = products, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var product = _ref;\n      // cloning product\n      var productNewId = Random.id();\n      setId({\n        oldId: product._id,\n        newId: productNewId\n      });\n      var newProduct = Object.assign({}, product, {\n        _id: productNewId // ancestors: product.ancestors.push(product._id)\n\n      });\n      delete newProduct.updatedAt;\n      delete newProduct.createdAt;\n      delete newProduct.publishedAt;\n      delete newProduct.positions;\n      delete newProduct.handle;\n      newProduct.isVisible = false;\n\n      if (newProduct.title) {\n        // todo test this\n        newProduct.title = createTitle(newProduct.title, newProduct._id);\n        newProduct.handle = createHandle(Reaction.getSlug(newProduct.title), newProduct._id);\n      }\n\n      result = Products.insert(newProduct, {\n        validate: false\n      });\n      results.push(result); // cloning variants\n\n      var variants = Products.find({\n        ancestors: {\n          $in: [product._id]\n        },\n        type: \"variant\"\n      }).fetch(); // why we are using `_.sortBy` described in `products/cloneVariant`\n\n      var sortedVariants = _sortBy(variants, function (doc) {\n        return doc.ancestors.length;\n      });\n\n      for (var _iterator2 = sortedVariants, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var variant = _ref2;\n        var variantNewId = Random.id();\n        setId({\n          oldId: variant._id,\n          newId: variantNewId\n        });\n        var ancestors = buildAncestors(variant.ancestors);\n        var newVariant = Object.assign({}, variant, {\n          _id: variantNewId,\n          ancestors: ancestors\n        });\n        delete newVariant.updatedAt;\n        delete newVariant.createdAt;\n        delete newVariant.publishedAt; // TODO can variant have this param?\n\n        result = Products.insert(newVariant, {\n          validate: false\n        });\n        copyMedia(productNewId, variant._id, variantNewId);\n        results.push(result);\n      }\n    }\n\n    return results;\n  },\n  /**\n   * products/createProduct\n   * @summary when we create a new product, we create it with an empty variant.\n   * all products have a variant with pricing and details\n   * @param {Object} [product] - optional product object\n   * @return {String} return insert result\n   */\"products/createProduct\": function (product) {\n    check(product, Match.Optional(Object)); // must have createProduct permission\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    } // if a product object was provided\n\n\n    if (product) {\n      return Products.insert(product);\n    }\n\n    return Products.insert({\n      type: \"simple\" // needed for multi-schema\n\n    }, {\n      validate: false\n    }, function (error, result) {\n      // additionally, we want to create a variant to a new product\n      if (result) {\n        Products.insert({\n          ancestors: [result],\n          price: 0.00,\n          title: \"\",\n          type: \"variant\" // needed for multi-schema\n\n        });\n      }\n    });\n  },\n  /**\n   * products/archiveProduct\n   * @summary archive a product and unlink it from all media\n   * @param {String} productId - productId to delete\n   * @returns {Number} returns number of removed products\n   */\"products/archiveProduct\": function (productId) {\n    check(productId, Match.OneOf(Array, String)); // must have admin permission to delete\n\n    if (!Reaction.hasPermission(\"createProduct\") && !Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var productIds = void 0;\n\n    if (!Array.isArray(productId)) {\n      productIds = [productId];\n    } else {\n      productIds = productId;\n    }\n\n    var productsWithVariants = Products.find({\n      // Don't \"archive\" products that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: {\n          $in: productIds\n        }\n      }, {\n        ancestors: {\n          $in: productIds\n        }\n      }]\n    }, {\n      fields: {\n        type: 1\n      }\n    }).fetch();\n    var ids = [];\n    productsWithVariants.map(function (doc) {\n      ids.push(doc._id);\n    });\n    Products.remove({\n      _id: {\n        $in: ids\n      }\n    });\n    var numRemoved = Revisions.find({\n      \"documentId\": {\n        $in: ids\n      },\n      \"documentData.isDeleted\": true\n    }).count();\n\n    if (numRemoved > 0) {\n      // we can get removes results only in async way\n      Media.update({\n        \"metadata.productId\": {\n          $in: ids\n        },\n        \"metadata.variantId\": {\n          $in: ids\n        }\n      }, {\n        $set: {\n          \"metadata.isDeleted\": true\n        }\n      });\n      return numRemoved;\n    }\n\n    throw new Meteor.Error(304, \"Something went wrong, nothing was deleted\");\n  },\n  /**\n   * products/updateProductField\n   * @summary update single product or variant field\n   * @param {String} _id - product._id or variant._id to update\n   * @param {String} field - key to update\n   * @param {*} value - update property value\n   * @todo rename it to something like \"products/updateField\" to  reflect\n   * @todo we need to know which type of entity field belongs. For that we could\n   * do something like: const type = Products.findOne(_id).type or transmit type\n   * as param if it possible\n   * latest changes. its used for products and variants\n   * @return {Number} returns update result\n   */\"products/updateProductField\": function (_id, field, value) {\n    check(_id, String);\n    check(field, String);\n    check(value, Match.OneOf(String, Object, Array, Boolean, Number)); // must have createProduct permission\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var doc = Products.findOne(_id);\n    var type = doc.type;\n    var update = void 0; // handle booleans with correct typing\n\n    if (value === \"false\" || value === \"true\") {\n      update = EJSON.parse(\"{\" + field + \":\" + value + \"}\");\n    } else {\n      var stringValue = EJSON.stringify(value);\n      update = EJSON.parse(\"{\\\"\" + field + \"\\\":\" + stringValue + \"}\");\n    } // we need to use sync mode here, to return correct error and result to UI\n\n\n    var result = void 0;\n\n    try {\n      result = Products.update(_id, {\n        $set: update\n      }, {\n        selector: {\n          type: type\n        }\n      });\n    } catch (e) {\n      throw new Meteor.Error(e.message);\n    } // If we get a result from the product update,\n    // meaning the update went past revision control,\n    // denormalize and attach results to top-level product\n\n\n    if (result === 1) {\n      if (type === \"variant\" && ~toDenormalize.indexOf(field)) {\n        denormalize(doc.ancestors[0], field);\n      }\n    }\n\n    return result;\n  },\n  /**\n   * products/updateProductTags\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} productId - productId\n   * @param {String} tagName - tagName\n   * @param {String} tagId - tagId\n   * @return {Number} return result\n   */\"products/updateProductTags\": function (productId, tagName, tagId) {\n    check(productId, String);\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null)); // must have createProduct permission\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n    var newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n    var existingTag = Tags.findOne({\n      slug: Reaction.getSlug(tagName)\n    });\n\n    if (existingTag) {\n      var productCount = Products.find({\n        _id: productId,\n        hashtags: {\n          $in: [existingTag._id]\n        }\n      }).count();\n\n      if (productCount > 0) {\n        throw new Meteor.Error(403, \"Existing Tag, Update Denied\");\n      }\n\n      return Products.update(productId, {\n        $push: {\n          hashtags: existingTag._id\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } else if (tagId) {\n      return Tags.update(tagId, {\n        $set: newTag\n      });\n    }\n\n    var newTagId = Meteor.call(\"shop/createTag\", tagName, false); // if result is an Error object, we return it immediately\n\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    return Products.update(productId, {\n      $push: {\n        hashtags: newTagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n  /**\n   * products/removeProductTag\n   * @summary method to remove tag from product\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\"products/removeProductTag\": function (productId, tagId) {\n    check(productId, String);\n    check(tagId, String);\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    Products.update(productId, {\n      $pull: {\n        hashtags: tagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n  /**\n   * products/setHandle\n   * @summary copy of \"products/setHandleTag\", but without tag\n   * @param {String} productId - productId\n   * @returns {String} handle - product handle\n   */\"products/setHandle\": function (productId) {\n    check(productId, String); // must have createProduct permission\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var product = Products.findOne(productId);\n    var handle = Reaction.getSlug(product.title);\n    handle = createHandle(handle, product._id);\n    Products.update(product._id, {\n      $set: {\n        handle: handle,\n        type: \"simple\"\n      }\n    });\n    return handle;\n  },\n  /**\n   * products/setHandleTag\n   * @summary set or toggle product handle\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\"products/setHandleTag\": function (productId, tagId) {\n    check(productId, String);\n    check(tagId, String); // must have createProduct permission\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    function getSet(handle) {\n      return {\n        $set: {\n          handle: handle,\n          type: \"simple\"\n        }\n      };\n    }\n\n    var product = Products.findOne(productId);\n    var tag = Tags.findOne(tagId); // set handle\n\n    if (product.handle === tag.slug) {\n      var handle = Reaction.getSlug(product.title);\n      handle = createHandle(handle, product._id);\n      Products.update(product._id, getSet(handle));\n      return handle;\n    } // toggle handle\n\n\n    var existingHandles = Products.find({\n      handle: tag.slug\n    }).fetch(); // this is needed to take care about product's handle which(product) was\n    // previously tagged.\n\n    for (var _iterator3 = existingHandles, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var currentProduct = _ref3;\n      var currentProductHandle = createHandle(Reaction.getSlug(currentProduct.title), currentProduct._id);\n      Products.update(currentProduct._id, getSet(currentProductHandle));\n    }\n\n    Products.update(product._id, getSet(tag.slug));\n    return tag.slug;\n  },\n  /**\n   * products/updateProductPosition\n   * @summary update product grid positions\n   * @param {String} productId - productId\n   * @param {Object} positionData -  an object with position,dimensions\n   * @param {String} tag - current route name. If it is not tag, then we using\n   * shop name as base `positions` name. Could be useful for multi-shopping.\n   * @return {Number} collection update returns\n   */\"products/updateProductPosition\": function (productId, positionData, tag) {\n    var _$set;\n\n    check(productId, String);\n    check(positionData, Object);\n    check(tag, String);\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n    var position = \"positions.\" + tag + \".position\";\n    var pinned = \"positions.\" + tag + \".pinned\";\n    var weight = \"positions.\" + tag + \".weight\";\n    var updatedAt = \"positions.\" + tag + \".updatedAt\";\n    return Products.update({\n      _id: productId\n    }, {\n      $set: (_$set = {}, _$set[position] = positionData.position, _$set[pinned] = positionData.pinned, _$set[weight] = positionData.weight, _$set[updatedAt] = new Date(), _$set.type = \"simple\", _$set)\n    });\n  },\n  /**\n   * products/updateVariantsPosition\n   * @description updates top level variant position index\n   * @param {Array} sortedVariantIds - array of top level variant `_id`s\n   * @since 0.11.0\n   * @return {Number} Products.update result\n   */\"products/updateVariantsPosition\": function (sortedVariantIds) {\n    check(sortedVariantIds, [String]); // TODO: to make this work we need to remove auditArgumentsCheck I suppose\n    // new SimpleSchema({\n    //   sortedVariantIds: { type: [String] }\n    // }).validate({ sortedVariantIds });\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    sortedVariantIds.forEach(function (id, index) {\n      Products.update(id, {\n        $set: {\n          index: index\n        }\n      }, {\n        selector: {\n          type: \"variant\"\n        }\n      }, function (error, result) {\n        if (result) {\n          Logger.debug(\"Variant \" + id + \" position was updated to index \" + index);\n        }\n      });\n    });\n  },\n  /**\n   * products/updateMetaFields\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} updatedMeta - update object with metadata\n   * @param {Object|Number|undefined|null} meta - current meta object, or a number index\n   * @todo should this method works for variants also?\n   * @return {Number} collection update result\n   */\"products/updateMetaFields\": function (productId, updatedMeta, meta) {\n    check(productId, String);\n    check(updatedMeta, Object);\n    check(meta, Match.OneOf(Object, Number, undefined, null)); // must have createProduct permission\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    } // update existing metadata\n\n\n    if ((typeof meta === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(meta)) === \"object\") {\n      return Products.update({\n        _id: productId,\n        metafields: meta\n      }, {\n        $set: {\n          \"metafields.$\": updatedMeta\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } else if (typeof meta === \"number\") {\n      var _$set2;\n\n      return Products.update({\n        _id: productId\n      }, {\n        $set: (_$set2 = {}, _$set2[\"metafields.\" + meta] = updatedMeta, _$set2)\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } // adds metadata\n\n\n    return Products.update({\n      _id: productId\n    }, {\n      $addToSet: {\n        metafields: updatedMeta\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n  /**\n   * products/removeMetaFields\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} metafields - metadata object to remove\n   * @param {Object} type - optional product type for schema selection\n   * @return {Number} collection update result\n   */\"products/removeMetaFields\": function (productId, metafields) {\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"simple\";\n    check(productId, String);\n    check(metafields, Object);\n    check(type, String); // must have createProduct permission\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Products.update({\n      _id: productId,\n      type: type\n    }, {\n      $pull: {\n        metafields: metafields\n      }\n    });\n  },\n  /**\n   * products/publishProduct\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\"products/publishProduct\": function (productId) {\n    check(productId, String);\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var product = Products.findOne(productId);\n    var variants = Products.find({\n      ancestors: {\n        $in: [productId]\n      }\n    }).fetch();\n    var variantValidator = true;\n\n    if ((typeof product === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(product)) === \"object\" && product.title.length > 1) {\n      if (variants.length > 0) {\n        variants.forEach(function (variant) {\n          // if this is a top variant with children, we avoid it to check price\n          // because we using price of its children\n          if (variant.ancestors.length === 1 && !Catalog.getVariants(variant._id, \"variant\").length || variant.ancestors.length !== 1) {\n            if (!(typeof variant.price === \"number\" && variant.price > 0)) {\n              variantValidator = false;\n            }\n          } // if variant has no title\n\n\n          if (typeof variant.title === \"string\" && !variant.title.length) {\n            variantValidator = false;\n          }\n\n          if (typeof optionTitle === \"string\" && !optionTitle.length) {\n            variantValidator = false;\n          }\n        });\n      } else {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(403, \"Forbidden\", \"Variant is required\");\n      }\n\n      if (!variantValidator) {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(403, \"Forbidden\", \"Some properties are missing.\");\n      } // update product visibility\n\n\n      Logger.debug(\"toggle product visibility \", product._id, !product.isVisible);\n      var res = Products.update(product._id, {\n        $set: {\n          isVisible: !product.isVisible\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      }); // update product variants visibility\n\n      updateVariantProductField(variants, \"isVisible\", !product.isVisible); // if collection updated we return new `isVisible` state\n\n      return res === 1 && !product.isVisible;\n    }\n\n    Logger.debug(\"invalid product visibility \", productId);\n    throw new Meteor.Error(400, \"Bad Request\");\n  },\n  /**\n   * products/publishProduct\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\"products/toggleVisibility\": function (productId) {\n    check(productId, String);\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var product = Products.findOne(productId);\n    var res = Products.update(productId, {\n      $set: {\n        isVisible: !product.isVisible\n      }\n    }, {\n      selector: {\n        type: product.type\n      }\n    });\n\n    if (Array.isArray(product.ancestors) && product.ancestors.length) {\n      var updateId = product.ancestors[0] || product._id;\n      var updatedPriceRange = ReactionProduct.getProductPriceRange(updateId);\n      Meteor.call(\"products/updateProductField\", updateId, \"price\", updatedPriceRange);\n    } // if collection updated we return new `isVisible` state\n\n\n    return res === 1 && !product.isVisible;\n  }\n});","map":{"version":3,"sources":["/server/methods/catalog.js"],"names":["EJSON","check","Meteor","copyFile","ReactionProduct","ProductRevision","Catalog","Media","Products","Revisions","Tags","Logger","Reaction","updateVariantProductField","variants","field","value","map","variant","call","_id","toDenormalize","createTitle","newTitle","productId","title","titleCount","find","$nin","count","titleNumberSuffix","titleString","copySuffix","match","String","replace","createHandle","productHandle","handle","handleCount","handleNumberSuffix","handleString","copyMedia","newId","variantOldId","variantNewId","forEach","fileObj","variantId","denormalize","id","doc","findOne","type","getTopVariants","ancestors","length","getVariants","update","Object","assign","isSoldOut","isLowQuantity","isBackorder","priceObject","getProductPriceRange","price","$set","selector","every","inventoryManagement","inventoryPolicy","getVariantQuantity","some","quantity","lowInventoryWarningThreshold","inventoryQuantity","flushQuantity","methods","hasPermission","Error","isAncestorDeleted","$or","$in","fetch","Random","sortedVariants","sortedVariant","oldId","clone","parentIndex","indexOf","ancestorsClone","slice","splice","updatedAt","createdAt","insert","validate","error","result","debug","parentId","newVariant","Match","Optional","newVariantId","product","Array","isArray","push","assembledVariant","currentVariant","isDeleted","undefined","toDelete","deleted","remove","productOrArray","OneOf","products","results","pool","getIds","filter","pair","setId","ids","buildAncestors","newAncestors","productNewId","newProduct","publishedAt","positions","isVisible","getSlug","hasAdminAccess","productIds","productsWithVariants","fields","numRemoved","Boolean","Number","parse","stringValue","stringify","e","message","tagName","tagId","unblock","newTag","slug","name","existingTag","productCount","hashtags","$push","newTagId","$pull","getSet","tag","existingHandles","currentProduct","currentProductHandle","positionData","position","pinned","weight","Date","sortedVariantIds","index","updatedMeta","meta","metafields","$addToSet","variantValidator","optionTitle","res","updateId","updatedPriceRange"],"mappings":"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","file":"/server/methods/catalog.js.map","sourcesContent":["import _ from  \"lodash\";\nimport { EJSON } from \"meteor/ejson\";\nimport { check } from \"meteor/check\";\nimport { Meteor } from \"meteor/meteor\";\nimport { copyFile, ReactionProduct } from \"/lib/api\";\nimport { ProductRevision as Catalog } from \"/imports/plugins/core/revisions/server/hooks\";\nimport { Media, Products, Revisions, Tags } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * Reaction Product Methods\n */\n/* eslint new-cap: 0 */\n/* eslint no-loop-func: 0 */\n/* eslint quotes: 0 */\n\n/**\n * updateVariantProductField\n * @summary updates the variant\n * @param {Array} variants - the array of variants\n * @param {String} field - the field to update\n * @param {String} value - the value to add\n * @return {Array} - return an array\n */\nfunction updateVariantProductField(variants, field, value) {\n  return variants.map(variant => {\n    Meteor.call(\"products/updateProductField\", variant._id, field, value);\n  });\n}\n\n/**\n * @array toDenormalize\n * @summary contains a list of fields, which should be denormalized\n * @type {string[]}\n */\nconst toDenormalize = [\n  \"price\",\n  \"inventoryQuantity\",\n  \"lowInventoryWarningThreshold\",\n  \"inventoryPolicy\",\n  \"inventoryManagement\"\n];\n\n/**\n * @function createTitle\n * @description Recursive method which trying to find a new `title`, given the\n * existing copies\n * @param {String} newTitle - product `title`\n * @param {String} productId - current product `_id`\n * @return {String} title - modified `title`\n */\nfunction createTitle(newTitle, productId) {\n  // exception product._id needed for cases then double triggering happens\n  let title = newTitle || \"\";\n  const titleCount = Products.find({\n    title: title,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n  // current product \"copy\" number\n  let titleNumberSuffix = 0;\n  // product handle prefix\n  let titleString = title;\n  // copySuffix \"-copy-number\" suffix of product\n  const copySuffix = titleString.match(/-copy-\\d+$/) || titleString.match(/-copy$/);\n  // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    titleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1;\n    // removing last numbers and last \"-\" if it presents\n    titleString = title.replace(/\\d+$/, '').replace(/-$/, '');\n  }\n\n  // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n  if (titleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (titleNumberSuffix > 0) {\n      title = `${titleString}-${titleNumberSuffix + titleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      title = `${titleString}-copy${ titleCount > 1 ? \"-\" + titleCount : \"\"}`;\n    }\n  }\n\n  // we should check again if there are any new matches with DB\n  if (Products.find({\n    title: title\n  }).count() !== 0) {\n    title = createTitle(title, productId);\n  }\n  return title;\n}\n\n/**\n * @function createHandle\n * @description Recursive method which trying to find a new `handle`, given the\n * existing copies\n * @param {String} productHandle - product `handle`\n * @param {String} productId - current product `_id`\n * @return {String} handle - modified `handle`\n */\nfunction createHandle(productHandle, productId) {\n  let handle = productHandle || \"\";\n  // exception product._id needed for cases then double triggering happens\n  const handleCount = Products.find({\n    handle: handle,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n  // current product \"copy\" number\n  let handleNumberSuffix = 0;\n  // product handle prefix\n  let handleString = handle;\n  // copySuffix \"-copy-number\" suffix of product\n  const copySuffix = handleString.match(/-copy-\\d+$/) || handleString.match(/-copy$/);\n\n  // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    handleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1;\n    // removing last numbers and last \"-\" if it presents\n    handleString = handle.replace(/\\d+$/, '').replace(/-$/, '');\n  }\n\n  // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n  if (handleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (handleNumberSuffix > 0) {\n      handle = `${handleString}-${handleNumberSuffix + handleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      handle = `${handleString}-copy${ handleCount > 1\n        ? '-' + handleCount : ''}`;\n    }\n  }\n\n  // we should check again if there are any new matches with DB\n  if (Products.find({\n    handle: handle\n  }).count() !== 0) {\n    handle = createHandle(handle, productId);\n  }\n\n  return handle;\n}\n\n/**\n * @function copyMedia\n * @description copy images links to cloned variant from original\n * @param {String} newId - [cloned|original] product _id\n * @param {String} variantOldId - old variant _id\n * @param {String} variantNewId - - cloned variant _id\n * @return {Number} Media#update result\n */\nfunction copyMedia(newId, variantOldId, variantNewId) {\n  Media.find({\n    \"metadata.variantId\": variantOldId\n  }).forEach(function (fileObj) {\n    // Copy File and insert directly, bypasing revision control\n    copyFile(fileObj, {\n      productId: newId,\n      variantId: variantNewId\n    });\n  });\n}\n\n/**\n * @function denormalize\n * @description With flattened model we do not want to get variant docs in\n * `products` publication, but we need some data from variants to display price,\n * quantity, etc. That's why we are denormalizing these properties into product\n * doc. Also, this way should have a speed benefit comparing the way where we\n * could dynamically build denormalization inside `products` publication.\n * @summary update product denormalized properties if variant was updated or\n * removed\n * @param {String} id - product _id\n * @param {String} field - type of field. Could be:\n * \"price\",\n * \"inventoryQuantity\",\n * \"inventoryManagement\",\n * \"inventoryPolicy\",\n * \"lowInventoryWarningThreshold\"\n * @since 0.11.0\n * @return {Number} - number of successful update operations. Should be \"1\".\n */\nfunction denormalize(id, field) {\n  const doc = Products.findOne(id);\n  let variants;\n  if (doc.type === \"simple\") {\n    variants = Catalog.getTopVariants(id);\n  } else if (doc.type === \"variant\" && doc.ancestors.length === 1) {\n    variants = Catalog.getVariants(id);\n  }\n  const update = {};\n\n  switch (field) {\n    case \"inventoryPolicy\":\n    case \"inventoryQuantity\":\n    case \"inventoryManagement\":\n      Object.assign(update, {\n        isSoldOut: isSoldOut(variants),\n        isLowQuantity: isLowQuantity(variants),\n        isBackorder: isBackorder(variants)\n      });\n      break;\n    case \"lowInventoryWarningThreshold\":\n      Object.assign(update, {\n        isLowQuantity: isLowQuantity(variants)\n      });\n      break;\n    default: // \"price\" is object with range, min, max\n      const priceObject = Catalog.getProductPriceRange(id);\n      Object.assign(update, {\n        price: priceObject\n      });\n  }\n  Products.update(id, {\n    $set: update\n  }, {\n    selector: {\n      type: \"simple\"\n    }\n  });\n}\n\n/**\n * isSoldOut\n * @description We are stop accepting new orders if product marked as\n * `isSoldOut`.\n * @param {Array} variants - Array with top-level variants\n * @return {Boolean} true if summary product quantity is zero.\n */\nfunction isSoldOut(variants) {\n  return variants.every(variant => {\n    if (variant.inventoryManagement && variant.inventoryPolicy) {\n      return Catalog.getVariantQuantity(variant) <= 0;\n    }\n    return false;\n  });\n}\n\n/**\n * isLowQuantity\n * @description If at least one of the variants is less than the threshold,\n * then function returns `true`\n * @param {Array} variants - array of child variants\n * @return {boolean} low quantity or not\n */\nfunction isLowQuantity(variants) {\n  return variants.some(variant => {\n    const quantity = Catalog.getVariantQuantity(variant);\n    // we need to keep an eye on `inventoryPolicy` too and qty > 0\n    if (variant.inventoryManagement && variant.inventoryPolicy && quantity) {\n      return quantity <= variant.lowInventoryWarningThreshold;\n    }\n    // TODO: need to test this function with real data\n    return false;\n  });\n}\n\n/**\n * isBackorder\n * @description Is products variants is still available to be ordered after\n * summary variants quantity is zero\n * @param {Array} variants - array with variant objects\n * @return {boolean} is backorder allowed or now for a product\n */\nfunction isBackorder(variants) {\n  return variants.every(variant => {\n    return !variant.inventoryPolicy && variant.inventoryManagement &&\n      variant.inventoryQuantity === 0;\n  });\n}\n\n/**\n * flushQuantity\n * @description if variant `inventoryQuantity` not zero, function update it to\n * zero. This needed in case then option with it's own `inventoryQuantity`\n * creates to top-level variant. In that case top-level variant should display\n * sum of his options `inventoryQuantity` fields.\n * @param {String} id - variant _id\n * @return {Number} - collection update results\n */\nfunction flushQuantity(id) {\n  const variant = Products.findOne(id);\n  // if variant already have descendants, quantity should be 0, and we don't\n  // need to do all next actions\n  if (variant.inventoryQuantity === 0) {\n    return 1; // let them think that we have one successful operation here\n  }\n\n  return Products.update({\n    _id: id\n  }, {\n    $set: {\n      inventoryQuantity: 0\n    }\n  }, {\n    selector: {\n      type: \"variant\"\n    }\n  });\n}\n\nMeteor.methods({\n  /**\n   * products/cloneVariant\n   * @summary clones a product variant into a new variant\n   * @description the method copies variants, but will also create and clone\n   * child variants (options)\n   * @param {String} productId - the productId we're whose variant we're\n   * cloning\n   * @param {String} variantId - the variantId that we're cloning\n   * @todo rewrite @description\n   * @return {Array} - list with cloned variants _ids\n   */\n  \"products/cloneVariant\": function (productId, variantId) {\n    check(productId, String);\n    check(variantId, String);\n    // user needs createProduct permission to clone\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const variant = Products.findOne(variantId);\n\n    // Verify that this variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n    if (ReactionProduct.isAncestorDeleted(variant, true)) {\n      throw new Meteor.Error(403, \"Unable to create product variant\");\n    }\n\n    const variants = Products.find({\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }],\n      type: \"variant\"\n    }).fetch();\n    // exit if we're trying to clone a ghost\n    if (variants.length === 0) {\n      return;\n    }\n    const variantNewId = Random.id(); // for the parent variant\n    // we need to make sure that top level variant will be cloned first, his\n    // descendants later.\n    // we could use this way in future: http://stackoverflow.com/questions/\n    // 9040161/mongo-order-by-length-of-array, by now following are allowed\n    // @link https://lodash.com/docs#sortBy\n    const sortedVariants = _.sortBy(variants, doc => doc.ancestors.length);\n\n    return sortedVariants.map(sortedVariant => {\n      const oldId = sortedVariant._id;\n      let type = \"child\";\n      const clone = {};\n      if (variantId === sortedVariant._id) {\n        type = \"parent\";\n        Object.assign(clone, sortedVariant, {\n          _id: variantNewId,\n          title: `${sortedVariant.title} - copy`\n        });\n      } else {\n        const parentIndex = sortedVariant.ancestors.indexOf(variantId);\n        const ancestorsClone = sortedVariant.ancestors.slice(0);\n        // if variantId exists in ancestors, we override it by new _id\n        !!~parentIndex && ancestorsClone.splice(parentIndex, 1, variantNewId);\n        Object.assign(clone, variant, {\n          _id: Random.id(),\n          ancestors: ancestorsClone\n        });\n      }\n      delete clone.updatedAt;\n      delete clone.createdAt;\n      delete clone.inventoryQuantity;\n      copyMedia(productId, oldId, clone._id);\n      return Products.insert(clone, {\n        validate: false\n      }, (error, result) => {\n        if (result) {\n          if (type === \"child\") {\n            Logger.debug(\n              `products/cloneVariant: created sub child clone: ${\n                clone._id} from ${variantId}`\n            );\n          } else {\n            Logger.debug(\n              `products/cloneVariant: created clone: ${\n                clone._id} from ${variantId}`\n            );\n          }\n        }\n        if (error) {\n          Logger.error(\n            `products/cloneVariant: cloning of ${variantId} was failed: ${error}`\n          );\n        }\n      });\n    });\n  },\n\n  /**\n   * products/createVariant\n   * @summary initializes empty variant template\n   * @param {String} parentId - the product _id or top level variant _id where\n   * we create variant\n   * @param {Object} [newVariant] - variant object\n   * @return {String} new variantId\n   */\n  \"products/createVariant\": function (parentId, newVariant) {\n    check(parentId, String);\n    check(newVariant, Match.Optional(Object));\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const newVariantId = Random.id();\n    // get parent ancestors to build new ancestors array\n    const product = Products.findOne(parentId);\n    const { ancestors } = product;\n\n    // Verify that the parent variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n    if (ReactionProduct.isAncestorDeleted(product, true)) {\n      throw new Meteor.Error(403, \"Unable to create product variant\");\n    }\n\n    Array.isArray(ancestors) && ancestors.push(parentId);\n    const assembledVariant = Object.assign(newVariant || {}, {\n      _id: newVariantId,\n      ancestors: ancestors,\n      type: \"variant\"\n    });\n\n    if (!newVariant) {\n      Object.assign(assembledVariant, {\n        title: \"\",\n        price: 0.00\n      });\n    }\n\n    // if we are inserting child variant to top-level variant, we need to remove\n    // all top-level's variant inventory records and flush it's quantity,\n    // because it will be hold sum of all it descendants quantities.\n    if (ancestors.length === 2) {\n      flushQuantity(parentId);\n    }\n\n    Products.insert(assembledVariant,\n      (error, result) => {\n        if (result) {\n          Logger.debug(\n            `products/createVariant: created variant: ${\n              newVariantId} for ${parentId}`\n          );\n        }\n      }\n    );\n\n    return newVariantId;\n  },\n\n  /**\n   * products/updateVariant\n   * @summary update individual variant with new values, merges into original\n   * only need to supply updated information. Currently used for a one use case\n   * - to manage top-level variant autoform.\n   * @param {Object} variant - current variant object\n   * @todo some use cases of this method was moved to \"products/\n   * updateProductField\", but it still used\n   * @return {Number} returns update result\n   */\n  \"products/updateVariant\": function (variant) {\n    check(variant, Object);\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const currentVariant = Products.findOne(variant._id);\n    // update variants\n    if (typeof currentVariant === \"object\") {\n      const newVariant = Object.assign({}, currentVariant, variant);\n\n      return Products.update({\n        _id: variant._id\n      }, {\n        $set: newVariant // newVariant already contain `type` property, so we\n          // do not need to pass it explicitly\n      }, {\n        validate: false\n      }, (error, result) => {\n        if (result) {\n          const productId = currentVariant.ancestors[0];\n          // we need manually check is these fields were updated?\n          // we can't stop after successful denormalization, because we have a\n          // case when several fields could be changed in top-level variant\n          // before form will be submitted.\n          toDenormalize.forEach(field => {\n            if (currentVariant[field] !== variant[field]) {\n              denormalize(productId, field);\n            }\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * products/deleteVariant\n   * @summary delete variant, which should also delete child variants\n   * @param {String} variantId - variantId to delete\n   * @returns {Boolean} returns update results: `true` - if at least one variant\n   * was removed or `false` if nothing was removed\n   */\n  \"products/deleteVariant\": function (variantId) {\n    check(variantId, String);\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const selector = {\n      // Don't \"archive\" variants that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }]\n    };\n    const toDelete = Products.find(selector).fetch();\n    // out if nothing to delete\n    if (!Array.isArray(toDelete) || toDelete.length === 0) return false;\n\n    const deleted = Products.remove(selector);\n\n    // after variant were removed from product, we need to recalculate all\n    // denormalized fields\n    const productId = toDelete[0].ancestors[0];\n    toDenormalize.forEach(field => denormalize(productId, field));\n\n    return typeof deleted === \"number\" && deleted > 0;\n  },\n\n  /**\n   * products/cloneProduct\n   * @summary clone a whole product, defaulting visibility, etc\n   * in the future we are going to do an inheritance product\n   * that maintains relationships with the cloned product tree\n   * @param {Array} productOrArray - products array to clone\n   * @returns {Array} returns insert results\n   */\n  \"products/cloneProduct\": function (productOrArray) {\n    check(productOrArray, Match.OneOf(Array, Object));\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // this.unblock();\n\n    let result;\n    let products;\n    const results = [];\n    const pool = []; // pool of id pairs: { oldId, newId }\n\n    function getIds(id) {\n      return pool.filter(function (pair) {\n        return pair.oldId === this.id;\n      }, {\n        id: id\n      });\n    }\n\n    function setId(ids) {\n      return pool.push(ids);\n    }\n\n    function buildAncestors(ancestors) {\n      const newAncestors = [];\n      ancestors.map(oldId => {\n        const pair = getIds(oldId);\n        // TODO do we always have newId on this step?\n        newAncestors.push(pair[0].newId);\n      });\n      return newAncestors;\n    }\n\n    if (!Array.isArray(productOrArray)) {\n      products = [productOrArray];\n    } else {\n      products = productOrArray;\n    }\n\n    for (const product of products) {\n      // cloning product\n      const productNewId = Random.id();\n      setId({\n        oldId: product._id,\n        newId: productNewId\n      });\n\n      const newProduct = Object.assign({}, product, {\n        _id: productNewId\n          // ancestors: product.ancestors.push(product._id)\n      });\n      delete newProduct.updatedAt;\n      delete newProduct.createdAt;\n      delete newProduct.publishedAt;\n      delete newProduct.positions;\n      delete newProduct.handle;\n      newProduct.isVisible = false;\n      if (newProduct.title) {\n        // todo test this\n        newProduct.title = createTitle(newProduct.title, newProduct._id);\n        newProduct.handle = createHandle(\n          Reaction.getSlug(newProduct.title),\n          newProduct._id\n        );\n      }\n      result = Products.insert(newProduct, {\n        validate: false\n      });\n      results.push(result);\n\n      // cloning variants\n      const variants = Products.find({\n        ancestors: {\n          $in: [product._id]\n        },\n        type: \"variant\"\n      }).fetch();\n      // why we are using `_.sortBy` described in `products/cloneVariant`\n      const sortedVariants = _.sortBy(variants, doc => doc.ancestors.length);\n      for (const variant of sortedVariants) {\n        const variantNewId = Random.id();\n        setId({\n          oldId: variant._id,\n          newId: variantNewId\n        });\n        const ancestors = buildAncestors(variant.ancestors);\n        const newVariant = Object.assign({}, variant, {\n          _id: variantNewId,\n          ancestors: ancestors\n        });\n        delete newVariant.updatedAt;\n        delete newVariant.createdAt;\n        delete newVariant.publishedAt; // TODO can variant have this param?\n\n        result = Products.insert(\n          newVariant, {\n            validate: false\n          }\n        );\n        copyMedia(productNewId, variant._id, variantNewId);\n        results.push(result);\n      }\n    }\n    return results;\n  },\n\n  /**\n   * products/createProduct\n   * @summary when we create a new product, we create it with an empty variant.\n   * all products have a variant with pricing and details\n   * @param {Object} [product] - optional product object\n   * @return {String} return insert result\n   */\n  \"products/createProduct\": function (product) {\n    check(product, Match.Optional(Object));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    // if a product object was provided\n    if (product) {\n      return Products.insert(product);\n    }\n\n    return Products.insert({\n      type: \"simple\" // needed for multi-schema\n    }, {\n      validate: false\n    }, (error, result) => {\n      // additionally, we want to create a variant to a new product\n      if (result) {\n        Products.insert({\n          ancestors: [result],\n          price: 0.00,\n          title: \"\",\n          type: \"variant\" // needed for multi-schema\n        });\n      }\n    });\n  },\n\n  /**\n   * products/archiveProduct\n   * @summary archive a product and unlink it from all media\n   * @param {String} productId - productId to delete\n   * @returns {Number} returns number of removed products\n   */\n  \"products/archiveProduct\": function (productId) {\n    check(productId, Match.OneOf(Array, String));\n    // must have admin permission to delete\n    if (!Reaction.hasPermission(\"createProduct\") && !Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    let productIds;\n\n    if (!Array.isArray(productId)) {\n      productIds = [productId];\n    } else {\n      productIds = productId;\n    }\n    const productsWithVariants = Products.find({\n      // Don't \"archive\" products that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: {\n          $in: productIds\n        }\n      }, {\n        ancestors: {\n          $in: productIds\n        }\n      }]\n    }, {\n      fields: {\n        type: 1\n      }\n    }).fetch();\n\n    const ids = [];\n    productsWithVariants.map(doc => {\n      ids.push(doc._id);\n    });\n\n    Products.remove({\n      _id: {\n        $in: ids\n      }\n    });\n\n    const numRemoved = Revisions.find({\n      \"documentId\": {\n        $in: ids\n      },\n      \"documentData.isDeleted\": true\n    }).count();\n\n    if (numRemoved > 0) {\n      // we can get removes results only in async way\n      Media.update({\n        \"metadata.productId\": {\n          $in: ids\n        },\n        \"metadata.variantId\": {\n          $in: ids\n        }\n      }, {\n        $set: {\n          \"metadata.isDeleted\": true\n        }\n      });\n      return numRemoved;\n    }\n    throw new Meteor.Error(304, \"Something went wrong, nothing was deleted\");\n  },\n\n  /**\n   * products/updateProductField\n   * @summary update single product or variant field\n   * @param {String} _id - product._id or variant._id to update\n   * @param {String} field - key to update\n   * @param {*} value - update property value\n   * @todo rename it to something like \"products/updateField\" to  reflect\n   * @todo we need to know which type of entity field belongs. For that we could\n   * do something like: const type = Products.findOne(_id).type or transmit type\n   * as param if it possible\n   * latest changes. its used for products and variants\n   * @return {Number} returns update result\n   */\n  \"products/updateProductField\": function (_id, field, value) {\n    check(_id, String);\n    check(field, String);\n    check(value, Match.OneOf(String, Object, Array, Boolean, Number));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const doc = Products.findOne(_id);\n    const type = doc.type;\n    let update;\n    // handle booleans with correct typing\n    if (value === \"false\" || value === \"true\") {\n      update = EJSON.parse(`{${field}:${value}}`);\n    } else {\n      const stringValue = EJSON.stringify(value);\n      update = EJSON.parse(\"{\\\"\" + field + \"\\\":\" + stringValue + \"}\");\n    }\n\n    // we need to use sync mode here, to return correct error and result to UI\n    let result;\n\n    try {\n      result = Products.update(_id, {\n        $set: update\n      }, {\n        selector: {\n          type: type\n        }\n      });\n    } catch (e) {\n      throw new Meteor.Error(e.message);\n    }\n\n    // If we get a result from the product update,\n    // meaning the update went past revision control,\n    // denormalize and attach results to top-level product\n    if (result === 1) {\n      if (type === \"variant\" && ~toDenormalize.indexOf(field)) {\n        denormalize(doc.ancestors[0], field);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * products/updateProductTags\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} productId - productId\n   * @param {String} tagName - tagName\n   * @param {String} tagId - tagId\n   * @return {Number} return result\n   */\n  \"products/updateProductTags\": function (productId, tagName, tagId) {\n    check(productId, String);\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n\n    const existingTag = Tags.findOne({\n      slug: Reaction.getSlug(tagName)\n    });\n\n    if (existingTag) {\n      const productCount = Products.find({\n        _id: productId,\n        hashtags: {\n          $in: [existingTag._id]\n        }\n      }).count();\n      if (productCount > 0) {\n        throw new Meteor.Error(403, \"Existing Tag, Update Denied\");\n      }\n      return Products.update(productId, {\n        $push: {\n          hashtags: existingTag._id\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } else if (tagId) {\n      return Tags.update(tagId, {\n        $set: newTag\n      });\n    }\n\n    const newTagId = Meteor.call(\"shop/createTag\", tagName, false);\n\n    // if result is an Error object, we return it immediately\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    return Products.update(productId, {\n      $push: {\n        hashtags: newTagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * products/removeProductTag\n   * @summary method to remove tag from product\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/removeProductTag\": function (productId, tagId) {\n    check(productId, String);\n    check(tagId, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    Products.update(productId, {\n      $pull: {\n        hashtags: tagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * products/setHandle\n   * @summary copy of \"products/setHandleTag\", but without tag\n   * @param {String} productId - productId\n   * @returns {String} handle - product handle\n   */\n  \"products/setHandle\": function (productId) {\n    check(productId, String);\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const product = Products.findOne(productId);\n    let handle = Reaction.getSlug(product.title);\n    handle = createHandle(handle, product._id);\n    Products.update(product._id, {\n      $set: {\n        handle: handle,\n        type: \"simple\"\n      }\n    });\n\n    return handle;\n  },\n\n  /**\n   * products/setHandleTag\n   * @summary set or toggle product handle\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/setHandleTag\": function (productId, tagId) {\n    check(productId, String);\n    check(tagId, String);\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    function getSet(handle) {\n      return {\n        $set: {\n          handle: handle,\n          type: \"simple\"\n        }\n      };\n    }\n\n    const product = Products.findOne(productId);\n    const tag = Tags.findOne(tagId);\n    // set handle\n    if (product.handle === tag.slug) {\n      let handle = Reaction.getSlug(product.title);\n      handle = createHandle(handle, product._id);\n      Products.update(product._id, getSet(handle));\n\n      return handle;\n    }\n    // toggle handle\n    const existingHandles = Products.find({\n      handle: tag.slug\n    }).fetch();\n    // this is needed to take care about product's handle which(product) was\n    // previously tagged.\n    for (const currentProduct of existingHandles) {\n      const currentProductHandle = createHandle(\n        Reaction.getSlug(currentProduct.title),\n        currentProduct._id);\n      Products.update(currentProduct._id,\n        getSet(currentProductHandle));\n    }\n    Products.update(product._id, getSet(tag.slug));\n\n    return tag.slug;\n  },\n\n  /**\n   * products/updateProductPosition\n   * @summary update product grid positions\n   * @param {String} productId - productId\n   * @param {Object} positionData -  an object with position,dimensions\n   * @param {String} tag - current route name. If it is not tag, then we using\n   * shop name as base `positions` name. Could be useful for multi-shopping.\n   * @return {Number} collection update returns\n   */\n  \"products/updateProductPosition\": function (productId, positionData, tag) {\n    check(productId, String);\n    check(positionData, Object);\n    check(tag, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const position = `positions.${tag}.position`;\n    const pinned = `positions.${tag}.pinned`;\n    const weight = `positions.${tag}.weight`;\n    const updatedAt = `positions.${tag}.updatedAt`;\n\n    return Products.update({\n      _id: productId\n    }, {\n      $set: {\n        [position]: positionData.position,\n        [pinned]: positionData.pinned,\n        [weight]: positionData.weight,\n        [updatedAt]: new Date(),\n        type: \"simple\" // for multi-schema\n      }\n    });\n  },\n\n  /**\n   * products/updateVariantsPosition\n   * @description updates top level variant position index\n   * @param {Array} sortedVariantIds - array of top level variant `_id`s\n   * @since 0.11.0\n   * @return {Number} Products.update result\n   */\n  \"products/updateVariantsPosition\": function (sortedVariantIds) {\n    check(sortedVariantIds, [String]);\n    // TODO: to make this work we need to remove auditArgumentsCheck I suppose\n    // new SimpleSchema({\n    //   sortedVariantIds: { type: [String] }\n    // }).validate({ sortedVariantIds });\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    sortedVariantIds.forEach((id, index) => {\n      Products.update(id, {\n        $set: {\n          index: index\n        }\n      }, {\n        selector: {\n          type: \"variant\"\n        }\n      }, (error, result) => {\n        if (result) {\n          Logger.debug(\n            `Variant ${id} position was updated to index ${index}`\n          );\n        }\n      });\n    });\n  },\n\n  /**\n   * products/updateMetaFields\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} updatedMeta - update object with metadata\n   * @param {Object|Number|undefined|null} meta - current meta object, or a number index\n   * @todo should this method works for variants also?\n   * @return {Number} collection update result\n   */\n  \"products/updateMetaFields\": function (productId, updatedMeta, meta) {\n    check(productId, String);\n    check(updatedMeta, Object);\n    check(meta, Match.OneOf(Object, Number, undefined, null));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    // update existing metadata\n    if (typeof meta === \"object\") {\n      return Products.update({\n        _id: productId,\n        metafields: meta\n      }, {\n        $set: {\n          \"metafields.$\": updatedMeta\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } else if (typeof meta === \"number\") {\n      return Products.update({\n        _id: productId\n      }, {\n        $set: {\n          [`metafields.${meta}`]: updatedMeta\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    }\n\n    // adds metadata\n    return Products.update({\n      _id: productId\n    }, {\n      $addToSet: {\n        metafields: updatedMeta\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * products/removeMetaFields\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} metafields - metadata object to remove\n   * @param {Object} type - optional product type for schema selection\n   * @return {Number} collection update result\n   */\n  \"products/removeMetaFields\": function (productId, metafields, type = \"simple\") {\n    check(productId, String);\n    check(metafields, Object);\n    check(type, String);\n\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Products.update({\n      _id: productId,\n      type: type\n    }, {\n      $pull: {\n        metafields: metafields\n      }\n    });\n  },\n\n  /**\n   * products/publishProduct\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/publishProduct\": function (productId) {\n    check(productId, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const product = Products.findOne(productId);\n    const variants = Products.find({\n      ancestors: {\n        $in: [productId]\n      }\n    }).fetch();\n    let variantValidator = true;\n\n    if (typeof product === \"object\" && product.title.length > 1) {\n      if (variants.length > 0) {\n        variants.forEach(variant => {\n          // if this is a top variant with children, we avoid it to check price\n          // because we using price of its children\n          if (variant.ancestors.length === 1 &&\n            !Catalog.getVariants(variant._id, \"variant\").length ||\n            variant.ancestors.length !== 1) {\n            if (!(typeof variant.price === \"number\" && variant.price > 0)) {\n              variantValidator = false;\n            }\n          }\n          // if variant has no title\n          if (typeof variant.title === \"string\" && !variant.title.length) {\n            variantValidator = false;\n          }\n          if (typeof optionTitle === \"string\" && !optionTitle.length) {\n            variantValidator = false;\n          }\n        });\n      } else {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(403, \"Forbidden\", \"Variant is required\");\n      }\n\n      if (!variantValidator) {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(403, \"Forbidden\",\n          \"Some properties are missing.\");\n      }\n\n      // update product visibility\n      Logger.debug(\"toggle product visibility \", product._id, !product.isVisible);\n\n      const res = Products.update(product._id, {\n        $set: {\n          isVisible: !product.isVisible\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n      // update product variants visibility\n      updateVariantProductField(variants, \"isVisible\", !product.isVisible);\n      // if collection updated we return new `isVisible` state\n      return res === 1 && !product.isVisible;\n    }\n    Logger.debug(\"invalid product visibility \", productId);\n    throw new Meteor.Error(400, \"Bad Request\");\n  },\n  /**\n   * products/publishProduct\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/toggleVisibility\": function (productId) {\n    check(productId, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const product = Products.findOne(productId);\n    const res = Products.update(productId, {\n      $set: {\n        isVisible: !product.isVisible\n      }\n    }, {\n      selector: {\n        type: product.type\n      }\n    });\n\n    if (Array.isArray(product.ancestors) && product.ancestors.length) {\n      const updateId = product.ancestors[0] || product._id;\n      const updatedPriceRange = ReactionProduct.getProductPriceRange(updateId);\n\n      Meteor.call(\"products/updateProductField\", updateId, \"price\", updatedPriceRange);\n    }\n\n    // if collection updated we return new `isVisible` state\n    return res === 1 && !product.isVisible;\n  }\n});\n"]},"hash":"0fa5f9370154176124f181eb2307ea83dc64dda2"}
