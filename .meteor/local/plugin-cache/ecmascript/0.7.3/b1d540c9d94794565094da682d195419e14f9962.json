{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash/isMatch","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_isMatch"}]},{"source":"lodash/cloneDeep","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_cloneDeep"}]},{"source":"lodash/filter","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_filter"}]},{"source":"/client/api","imported":["Reaction"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"}]},{"source":"/lib/collections","imported":["Packages"],"specifiers":[{"kind":"named","imported":"Packages","local":"Packages"}]},{"source":"meteor/templating","imported":["Template"],"specifiers":[{"kind":"named","imported":"Template","local":"Template"}]}],"exports":{"exported":["Apps","optionHash"],"specifiers":[{"kind":"local","local":"Apps","exported":"Apps"},{"kind":"local","local":"optionHash","exported":"optionHash"}]}}},"options":{"filename":"/client/modules/core/helpers/apps.js","filenameRelative":"/client/modules/core/helpers/apps.js","inputSourceMap":{"version":3,"sources":["/client/modules/core/helpers/apps.js"],"names":["Reaction","Packages","Template","Apps","optionHash","filter","registryFilter","key","reactionApps","options","hash","shopId","getShopId","hasOwnerAccess","audience","hasOwnProperty","call","value","Array","isArray","$in","find","forEach","app","matchingRegistry","registry","item","itemFilter","permissions","hasAccess","permission","hasPermissionToRegistryItem","indexOf","hasRoleAccessForShop","Roles","userIsInRole","Meteor","userId","push","sortedApps","sort","a","b","priority","slice","registerHelper"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,A,AAAS,AAAgB,AACzB,AAAS,AAAgB,AACzB,AAAS,AAAgB,AAEzB,AAqCA,AAAO,AAAS,AAAK,AAAY,AAC/B;;AAAM,SAAN,AAAe;MACT,SAAN,AAAuB,AACvB;AAAI,MAAJ,iBACA;MAAA,AAAM,AAAe,AACrB;AAAI,MAL2B,AAK/B,AAAc,AAEd;gBACA,AAAI,AAAY,AACd,IAAA,AAAI,AAAW,AAAM,AACnB;;MAAU,YAAV,AAAqB,AACtB;AAFD,QAEO,iBACL;gBAAA,AAAU,WACX;WAb4B,AAc9B,AAED;;;AACA,AAAI,AAAC,AAAQ,AAAQ,AACnB,GAhBF,CAgBE,AAAQ,AAAS,AAAS,AAC3B;;;AAnB8B,AAqB/B;;AACA,AAAI,AAAS,AAAoB,AAAQ,AAAU,AACjD,IAAA,AAAO,AAAQ,AAChB;;;AAxB8B,AA0B/B,qDACA;mBACA;IACA;AAAA,AAAK,AAAO,AAAS,AACnB;AAAA,AAAI,AAAG,AAAe,AAAK,AAAS,AAAM,AACxC;;;OAAM,8CAAQ,UAAd,AAAc,AAAQ;8CACtB;AAAI,UAAJ,AAAW,gBACT;;UAAI,AAAE,OAAN,AAAI,AAAE,AAAQ,AAAa,AAAQ,AAAU,AAAQ,AAAW,AAC9D;cAAO,QAAP,AAAqB,aAAO,QAAA,AAAM,AAAQ,UAAQ,QAAtB,AAAc,AAAgB,WAAE;iBAAK;;cAAP;AAA1D,AAA4B,AAA+C,gCAC3E;eAFF,AAEE,AAAe,AAAO,AACvB;AAAM,AACL;0CACA;AAAI,AAAC,wBAAS,UAAd,AAAK,AAA2B,AAC9B;AAAI,AAAQ,6BAAZ,AAAsB,OACpB;AAAA,AAAe,AAAO,AACvB;AACF;;;AACD;AAAA,AAAO,AAAO,AACf;AACF;AACF,AACF;;sCAED;AAjD+B,AAiD/B,AAAO,AAAO,AAAsB,AAEpC;AACA;AACA;AACA;AACA;;;;AACS,UAAT,AAAc,AAAQ,aAAtB,AAA8B,AAAC,WAAQ,AACrC,AAAM,AAAmB,AAAS,AAAI,AAAU,AAAU,AAAM,AAC9D,gBAFJ,CACkE,AAC9D,AAAM,AAAa,AAAY,AAE/B,AACA;AACA;;;;;YACA,AAAI,AAAC,AAAS,AAAoB,AAAK,AAAe,AAAe,AAAU,AAC7E;;AAAI;;;;;;;;;;;;cAAJ;AAEA;AAAK,cAAL,AAAW,AAAc,8BAAe,KAAxC,AAAkD,mCAChD,GACA;;cAAM,6BAA8B,AAAK,aAAL,AAAiB,OAAjB,AAAyB,UAAzB,AAAuC,AAAC,YAF5B,AAEhD,AACA,SACA,cAJgD,AAIhD,AAAM,AAAuB,AAAM,AAAa,AAAO,AAAU,AAAY,AAAS,AAEtF;;mEACA;AAAI,wBAAJ,AAAmC,AAAsB,AACvD;AAAA,AAAY,AACZ;AACD;AACF;;wBAED;AAAI,AAAC,iBAAL,AAAgB,AACd;AAjB2E,AAiB3E,AAAO,AACR,AAED;;;0BACA;AAAA,AAAO,AAAW,AACnB;;4BAED;AA9BF,AAAyB,AA8BvB,AAAO,AAAU,AAAM,AACxB;;;AAED;;;;;;;;;;;;AAAK,AAAM,mBAAX,KAAA,AAAuB,AAAkB,AACvC;AAAA,AAAa,AAAK,AACnB;AA5F4B,AAwD/B,AAqCC,AAED,MACA;;MAAM,0BAAa,AAAa,eAAK,AAAC,GAAD,AAAI;AAAJ,WAAU,EAAA,AAAE,WAAW,EAAzC,AAA2C;GAA3C,EAAnB,AAAmB,AAAqD,AAExE,AAAO,AACR,A;AAED;AACA,AAAS,AAAe,AAAgB,AAAC,AAAe;;AACtD,AAAO,AAAS,AAAK;AADvB,AAEC","file":"/client/modules/core/helpers/apps.js.map","sourcesContent":["import _ from \"lodash\";\nimport { Reaction } from \"/client/api\";\nimport { Packages } from \"/lib/collections\";\nimport { Template } from \"meteor/templating\";\n\n/**\n *\n * reactionApps\n *   provides=\"<where matching registry provides is this >\"\n *   enabled=true <false for disabled packages>\n *   context= true filter templates to current route\n *   returns matching package registry objects\n *   @example {{#each reactionApps provides=\"settings\" name=packageName container=container}}\n *   @example {{#each reactionApps provides=\"userAccountDropdown\" enabled=true}}\n *   @example\n *     {{#each reactionApps provides=\"social\" name=\"reaction-social\"}}\n *         {{> Template.dynamic template=template data=customSocialSettings }}\n *     {{/each}}\n *\n *   @typedef optionHash\n *   @type {object}\n *   @property {string} name - name of a package.\n *   @property {string} provides -purpose of this package as identified to the registry\n *   @property {string} container - filter registry entries for matching container.\n *   @property {string} shopId - filter to only display results matching shopId, not returned\n *   @property {string} template - filter registry entries for matching template\n *   @type {optionHash}\n *\n *  @return {optionHash} returns an array of filtered, structure reactionApps\n *  [{\n *  \tenabled: true\n *   label: \"Stripe\"\n *   name: \"reaction-stripe\"\n *   packageId: \"QqkGsQCDRhg2LSn8J\"\n *   priority: 1\n *   provides: \"paymentMethod\"\n *   template: \"stripePaymentForm\"\n *   etc: \"additional properties as defined in Packages.registry\"\n *   ...\n *  }]\n */\n\nexport function Apps(optionHash) {\n  const filter = {};\n  const registryFilter = {};\n  let key;\n  const reactionApps = [];\n  let options = {};\n\n  // allow for object or option.hash\n  if (optionHash) {\n    if (optionHash.hash) {\n      options = optionHash.hash;\n    } else {\n      options = optionHash;\n    }\n  }\n\n  // you could provide a shopId in optionHash\n  if (!options.shopId) {\n    options.shopId = Reaction.getShopId();\n  }\n\n  // remove audience permissions for owner (still needed here for older/legacy calls)\n  if (Reaction.hasOwnerAccess() && options.audience) {\n    delete options.audience;\n  }\n\n  //\n  // build filter to only get matching registry elements\n  //\n  for (key in options) {\n    if ({}.hasOwnProperty.call(options, key)) {\n      const value = options[key];\n      if (value) {\n        if (!(key === \"enabled\" || key === \"name\" || key === \"shopId\")) {\n          filter[\"registry.\" + key] = Array.isArray(options[key]) ? { $in: value } : value;\n          registryFilter[key] = value;\n        } else {\n          // perhaps not the best way to check but lets admin see all packages\n          if (!Reaction.hasOwnerAccess()) {\n            if (key !== \"shopId\") {\n              registryFilter[key] = value;\n            }\n          }\n          filter[key] = value;\n        }\n      }\n    }\n  }\n\n  delete filter[\"registry.audience\"]; // Temporarily remove \"audience\" key (see comment below)\n\n  // TODO: Review fix for filter on Packages.find(filter)\n  // The current \"filter\" setup uses \"audience\" field which is not present in the registry array in most (if not all) docs\n  // in the Packages coll.\n  // For now, the audience checks (after the Package.find call) filters out the registry items based on permissions. But\n  // part of the filtering should have been handled by the Package.find call, if the \"audience\" filter works as it should.\n  Packages.find(filter).forEach((app) => {\n    const matchingRegistry = _.filter(app.registry, function (item) {\n      const itemFilter = _.cloneDeep(registryFilter);\n\n      // check audience permissions only if they exist as part of optionHash and are part of the registry item\n      // ideally all routes should use it, safe for backwards compatibility though\n      // owner bypasses permissions\n      if (!Reaction.hasOwnerAccess() && item.permissions && registryFilter.audience) {\n        let hasAccess;\n\n        for (const permission of registryFilter.audience) {\n          // This checks that the registry item contains a permissions matches with the user's permission for the shop\n          const hasPermissionToRegistryItem = item.permissions.indexOf(permission) > -1;\n          // This checks that the user's permission set have the right value that is on the registry item\n          const hasRoleAccessForShop = Roles.userIsInRole(Meteor.userId(), permission, Reaction.getShopId());\n\n          // both checks must pass for access to be granted\n          if (hasPermissionToRegistryItem && hasRoleAccessForShop) {\n            hasAccess = true;\n            break;\n          }\n        }\n\n        if (!hasAccess) {\n          return false;\n        }\n\n        // safe to clean up now, and isMatch can ignore audience\n        delete itemFilter.audience;\n      }\n\n      return _.isMatch(item, itemFilter);\n    });\n\n    for (const registry of matchingRegistry) {\n      reactionApps.push(registry);\n    }\n  });\n\n  // Sort apps by priority (registry.priority)\n  const sortedApps = reactionApps.sort((a, b) => a.priority - b.priority).slice();\n\n  return sortedApps;\n}\n\n// Register global template helper\nTemplate.registerHelper(\"reactionApps\", (optionHash) => {\n  return Reaction.Apps(optionHash);\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/client/modules/core/helpers/apps.js.map","sourceFileName":"/client/modules/core/helpers/apps.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"apps"},"ignored":false,"code":"module.export({\n  Apps: function () {\n    return Apps;\n  }\n});\n\nvar _isMatch = void 0;\n\nmodule.importSync(\"lodash/isMatch\", {\n  \"default\": function (v) {\n    _isMatch = v;\n  }\n}, 0);\n\nvar _cloneDeep = void 0;\n\nmodule.importSync(\"lodash/cloneDeep\", {\n  \"default\": function (v) {\n    _cloneDeep = v;\n  }\n}, 1);\n\nvar _filter = void 0;\n\nmodule.importSync(\"lodash/filter\", {\n  \"default\": function (v) {\n    _filter = v;\n  }\n}, 2);\nvar Reaction = void 0;\nmodule.importSync(\"/client/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 3);\nvar Packages = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Packages: function (v) {\n    Packages = v;\n  }\n}, 4);\nvar Template = void 0;\nmodule.importSync(\"meteor/templating\", {\n  Template: function (v) {\n    Template = v;\n  }\n}, 5);\n\nfunction Apps(optionHash) {\n  var filter = {};\n  var registryFilter = {};\n  var key = void 0;\n  var reactionApps = [];\n  var options = {}; // allow for object or option.hash\n\n  if (optionHash) {\n    if (optionHash.hash) {\n      options = optionHash.hash;\n    } else {\n      options = optionHash;\n    }\n  } // you could provide a shopId in optionHash\n\n\n  if (!options.shopId) {\n    options.shopId = Reaction.getShopId();\n  } // remove audience permissions for owner (still needed here for older/legacy calls)\n\n\n  if (Reaction.hasOwnerAccess() && options.audience) {\n    delete options.audience;\n  } //\n  // build filter to only get matching registry elements\n  //\n\n\n  for (key in meteorBabelHelpers.sanitizeForInObject(options)) {\n    if ({}.hasOwnProperty.call(options, key)) {\n      var value = options[key];\n\n      if (value) {\n        if (!(key === \"enabled\" || key === \"name\" || key === \"shopId\")) {\n          filter[\"registry.\" + key] = Array.isArray(options[key]) ? {\n            $in: value\n          } : value;\n          registryFilter[key] = value;\n        } else {\n          // perhaps not the best way to check but lets admin see all packages\n          if (!Reaction.hasOwnerAccess()) {\n            if (key !== \"shopId\") {\n              registryFilter[key] = value;\n            }\n          }\n\n          filter[key] = value;\n        }\n      }\n    }\n  }\n\n  delete filter[\"registry.audience\"]; // Temporarily remove \"audience\" key (see comment below)\n  // TODO: Review fix for filter on Packages.find(filter)\n  // The current \"filter\" setup uses \"audience\" field which is not present in the registry array in most (if not all) docs\n  // in the Packages coll.\n  // For now, the audience checks (after the Package.find call) filters out the registry items based on permissions. But\n  // part of the filtering should have been handled by the Package.find call, if the \"audience\" filter works as it should.\n\n  Packages.find(filter).forEach(function (app) {\n    var matchingRegistry = _filter(app.registry, function (item) {\n      var itemFilter = _cloneDeep(registryFilter); // check audience permissions only if they exist as part of optionHash and are part of the registry item\n      // ideally all routes should use it, safe for backwards compatibility though\n      // owner bypasses permissions\n\n\n      if (!Reaction.hasOwnerAccess() && item.permissions && registryFilter.audience) {\n        var hasAccess = void 0;\n\n        for (var _iterator = registryFilter.audience, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var permission = _ref;\n          // This checks that the registry item contains a permissions matches with the user's permission for the shop\n          var hasPermissionToRegistryItem = item.permissions.indexOf(permission) > -1; // This checks that the user's permission set have the right value that is on the registry item\n\n          var hasRoleAccessForShop = Roles.userIsInRole(Meteor.userId(), permission, Reaction.getShopId()); // both checks must pass for access to be granted\n\n          if (hasPermissionToRegistryItem && hasRoleAccessForShop) {\n            hasAccess = true;\n            break;\n          }\n        }\n\n        if (!hasAccess) {\n          return false;\n        } // safe to clean up now, and isMatch can ignore audience\n\n\n        delete itemFilter.audience;\n      }\n\n      return _isMatch(item, itemFilter);\n    });\n\n    for (var _iterator2 = matchingRegistry, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var registry = _ref2;\n      reactionApps.push(registry);\n    }\n  }); // Sort apps by priority (registry.priority)\n\n  var sortedApps = reactionApps.sort(function (a, b) {\n    return a.priority - b.priority;\n  }).slice();\n  return sortedApps;\n}\n\n// Register global template helper\nTemplate.registerHelper(\"reactionApps\", function (optionHash) {\n  return Reaction.Apps(optionHash);\n});","map":{"version":3,"sources":["/client/modules/core/helpers/apps.js"],"names":["Reaction","Packages","Template","Apps","optionHash","filter","registryFilter","key","reactionApps","options","hash","shopId","getShopId","hasOwnerAccess","audience","hasOwnProperty","call","value","Array","isArray","$in","find","forEach","app","matchingRegistry","registry","item","itemFilter","permissions","hasAccess","permission","hasPermissionToRegistryItem","indexOf","hasRoleAccessForShop","Roles","userIsInRole","Meteor","userId","push","sortedApps","sort","a","b","priority","slice","registerHelper"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,A,AAAS,AAAgB,AACzB,AAAS,AAAgB,AACzB,AAAS,AAAgB,AAEzB,AAqCA,AAAO,AAAS,AAAK,AAAY,AAC/B;;AAAM,SAAN,AAAe;MACT,SAAN,AAAuB,AACvB;AAAI,MAAJ,iBACA;MAAA,AAAM,AAAe,AACrB;AAAI,MAL2B,AAK/B,AAAc,AAEd;gBACA,AAAI,AAAY,AACd,IAAA,AAAI,AAAW,AAAM,AACnB;;MAAU,YAAV,AAAqB,AACtB;AAFD,QAEO,iBACL;gBAAA,AAAU,WACX;WAb4B,AAc9B,AAED;;;AACA,AAAI,AAAC,AAAQ,AAAQ,AACnB,GAhBF,CAgBE,AAAQ,AAAS,AAAS,AAC3B;;;AAnB8B,AAqB/B;;AACA,AAAI,AAAS,AAAoB,AAAQ,AAAU,AACjD,IAAA,AAAO,AAAQ,AAChB;;;AAxB8B,AA0B/B,qDACA;mBACA;IACA;AAAA,AAAK,AAAO,AAAS,AACnB;AAAA,AAAI,AAAG,AAAe,AAAK,AAAS,AAAM,AACxC;;;OAAM,8CAAQ,UAAd,AAAc,AAAQ;8CACtB;AAAI,UAAJ,AAAW,gBACT;;UAAI,AAAE,OAAN,AAAI,AAAE,AAAQ,AAAa,AAAQ,AAAU,AAAQ,AAAW,AAC9D;cAAO,QAAP,AAAqB,aAAO,QAAA,AAAM,AAAQ,UAAQ,QAAtB,AAAc,AAAgB,WAAE;iBAAK;;cAAP;AAA1D,AAA4B,AAA+C,gCAC3E;eAFF,AAEE,AAAe,AAAO,AACvB;AAAM,AACL;0CACA;AAAI,AAAC,wBAAS,UAAd,AAAK,AAA2B,AAC9B;AAAI,AAAQ,6BAAZ,AAAsB,OACpB;AAAA,AAAe,AAAO,AACvB;AACF;;;AACD;AAAA,AAAO,AAAO,AACf;AACF;AACF,AACF;;sCAED;AAjD+B,AAiD/B,AAAO,AAAO,AAAsB,AAEpC;AACA;AACA;AACA;AACA;;;;AACS,UAAT,AAAc,AAAQ,aAAtB,AAA8B,AAAC,WAAQ,AACrC,AAAM,AAAmB,AAAS,AAAI,AAAU,AAAU,AAAM,AAC9D,gBAFJ,CACkE,AAC9D,AAAM,AAAa,AAAY,AAE/B,AACA;AACA;;;;;YACA,AAAI,AAAC,AAAS,AAAoB,AAAK,AAAe,AAAe,AAAU,AAC7E;;AAAI;;;;;;;;;;;;cAAJ;AAEA;AAAK,cAAL,AAAW,AAAc,8BAAe,KAAxC,AAAkD,mCAChD,GACA;;cAAM,6BAA8B,AAAK,aAAL,AAAiB,OAAjB,AAAyB,UAAzB,AAAuC,AAAC,YAF5B,AAEhD,AACA,SACA,cAJgD,AAIhD,AAAM,AAAuB,AAAM,AAAa,AAAO,AAAU,AAAY,AAAS,AAEtF;;mEACA;AAAI,wBAAJ,AAAmC,AAAsB,AACvD;AAAA,AAAY,AACZ;AACD;AACF;;wBAED;AAAI,AAAC,iBAAL,AAAgB,AACd;AAjB2E,AAiB3E,AAAO,AACR,AAED;;;0BACA;AAAA,AAAO,AAAW,AACnB;;4BAED;AA9BF,AAAyB,AA8BvB,AAAO,AAAU,AAAM,AACxB;;;AAED;;;;;;;;;;;;AAAK,AAAM,mBAAX,KAAA,AAAuB,AAAkB,AACvC;AAAA,AAAa,AAAK,AACnB;AA5F4B,AAwD/B,AAqCC,AAED,MACA;;MAAM,0BAAa,AAAa,eAAK,AAAC,GAAD,AAAI;AAAJ,WAAU,EAAA,AAAE,WAAW,EAAzC,AAA2C;GAA3C,EAAnB,AAAmB,AAAqD,AAExE,AAAO,AACR,A;AAED;AACA,AAAS,AAAe,AAAgB,AAAC,AAAe;;AACtD,AAAO,AAAS,AAAK;AADvB,AAEC","file":"/client/modules/core/helpers/apps.js.map","sourcesContent":["import _ from \"lodash\";\nimport { Reaction } from \"/client/api\";\nimport { Packages } from \"/lib/collections\";\nimport { Template } from \"meteor/templating\";\n\n/**\n *\n * reactionApps\n *   provides=\"<where matching registry provides is this >\"\n *   enabled=true <false for disabled packages>\n *   context= true filter templates to current route\n *   returns matching package registry objects\n *   @example {{#each reactionApps provides=\"settings\" name=packageName container=container}}\n *   @example {{#each reactionApps provides=\"userAccountDropdown\" enabled=true}}\n *   @example\n *     {{#each reactionApps provides=\"social\" name=\"reaction-social\"}}\n *         {{> Template.dynamic template=template data=customSocialSettings }}\n *     {{/each}}\n *\n *   @typedef optionHash\n *   @type {object}\n *   @property {string} name - name of a package.\n *   @property {string} provides -purpose of this package as identified to the registry\n *   @property {string} container - filter registry entries for matching container.\n *   @property {string} shopId - filter to only display results matching shopId, not returned\n *   @property {string} template - filter registry entries for matching template\n *   @type {optionHash}\n *\n *  @return {optionHash} returns an array of filtered, structure reactionApps\n *  [{\n *  \tenabled: true\n *   label: \"Stripe\"\n *   name: \"reaction-stripe\"\n *   packageId: \"QqkGsQCDRhg2LSn8J\"\n *   priority: 1\n *   provides: \"paymentMethod\"\n *   template: \"stripePaymentForm\"\n *   etc: \"additional properties as defined in Packages.registry\"\n *   ...\n *  }]\n */\n\nexport function Apps(optionHash) {\n  const filter = {};\n  const registryFilter = {};\n  let key;\n  const reactionApps = [];\n  let options = {};\n\n  // allow for object or option.hash\n  if (optionHash) {\n    if (optionHash.hash) {\n      options = optionHash.hash;\n    } else {\n      options = optionHash;\n    }\n  }\n\n  // you could provide a shopId in optionHash\n  if (!options.shopId) {\n    options.shopId = Reaction.getShopId();\n  }\n\n  // remove audience permissions for owner (still needed here for older/legacy calls)\n  if (Reaction.hasOwnerAccess() && options.audience) {\n    delete options.audience;\n  }\n\n  //\n  // build filter to only get matching registry elements\n  //\n  for (key in options) {\n    if ({}.hasOwnProperty.call(options, key)) {\n      const value = options[key];\n      if (value) {\n        if (!(key === \"enabled\" || key === \"name\" || key === \"shopId\")) {\n          filter[\"registry.\" + key] = Array.isArray(options[key]) ? { $in: value } : value;\n          registryFilter[key] = value;\n        } else {\n          // perhaps not the best way to check but lets admin see all packages\n          if (!Reaction.hasOwnerAccess()) {\n            if (key !== \"shopId\") {\n              registryFilter[key] = value;\n            }\n          }\n          filter[key] = value;\n        }\n      }\n    }\n  }\n\n  delete filter[\"registry.audience\"]; // Temporarily remove \"audience\" key (see comment below)\n\n  // TODO: Review fix for filter on Packages.find(filter)\n  // The current \"filter\" setup uses \"audience\" field which is not present in the registry array in most (if not all) docs\n  // in the Packages coll.\n  // For now, the audience checks (after the Package.find call) filters out the registry items based on permissions. But\n  // part of the filtering should have been handled by the Package.find call, if the \"audience\" filter works as it should.\n  Packages.find(filter).forEach((app) => {\n    const matchingRegistry = _.filter(app.registry, function (item) {\n      const itemFilter = _.cloneDeep(registryFilter);\n\n      // check audience permissions only if they exist as part of optionHash and are part of the registry item\n      // ideally all routes should use it, safe for backwards compatibility though\n      // owner bypasses permissions\n      if (!Reaction.hasOwnerAccess() && item.permissions && registryFilter.audience) {\n        let hasAccess;\n\n        for (const permission of registryFilter.audience) {\n          // This checks that the registry item contains a permissions matches with the user's permission for the shop\n          const hasPermissionToRegistryItem = item.permissions.indexOf(permission) > -1;\n          // This checks that the user's permission set have the right value that is on the registry item\n          const hasRoleAccessForShop = Roles.userIsInRole(Meteor.userId(), permission, Reaction.getShopId());\n\n          // both checks must pass for access to be granted\n          if (hasPermissionToRegistryItem && hasRoleAccessForShop) {\n            hasAccess = true;\n            break;\n          }\n        }\n\n        if (!hasAccess) {\n          return false;\n        }\n\n        // safe to clean up now, and isMatch can ignore audience\n        delete itemFilter.audience;\n      }\n\n      return _.isMatch(item, itemFilter);\n    });\n\n    for (const registry of matchingRegistry) {\n      reactionApps.push(registry);\n    }\n  });\n\n  // Sort apps by priority (registry.priority)\n  const sortedApps = reactionApps.sort((a, b) => a.priority - b.priority).slice();\n\n  return sortedApps;\n}\n\n// Register global template helper\nTemplate.registerHelper(\"reactionApps\", (optionHash) => {\n  return Reaction.Apps(optionHash);\n});\n"]},"hash":"b1d540c9d94794565094da682d195419e14f9962"}
