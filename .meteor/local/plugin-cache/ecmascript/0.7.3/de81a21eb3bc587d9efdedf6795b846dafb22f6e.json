{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"/lib/collections","imported":["Cart"],"specifiers":[{"kind":"named","imported":"Cart","local":"Cart"}]},{"source":"/server/api","imported":["Logger","MethodHooks"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"MethodHooks","local":"MethodHooks"}]},{"source":"../cart","imported":[],"specifiers":[]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/methods/core/hooks/cart.js","filenameRelative":"/server/methods/core/hooks/cart.js","inputSourceMap":{"version":3,"sources":["/server/methods/core/hooks/cart.js"],"names":["Meteor","Cart","Logger","MethodHooks","after","options","debug","result","error","cart","findOne","userId","call","billing","items","paymentMethod","orderId","_id","Error"],"mappings":"AAAA,IAAS;AAAT,OAAuB,WAAvB;;;;;;;;;;;;;;;;;;;;;kBACA,A,AAAA,AAAS,A,AAAT,AAAqB,AACrB,AAAS,AAAQ,AAAmB,AACpC,AACA,AAAO,AAEP;AACA,AAAY,AAAM,AAAsB,AAAU,AAAS;AACzD,2DACA;AACA;AAHyD,AAGzD,AAAO,AAAM,AAAwC,AACrD,AACA;iEACA;AAAA,AAAM,AAAS,AAAQ,AAAU;;iCACjC;;MAAI,OAAO,QAAP,AAAe,UAAnB,AAA6B;QACrB,YAAO,AAAK;cACR,OAF8B,AACxC,AAAa,AAAa,AAChB,AAAO,AAGjB,AACA;AAL0B,AACxB,KADW,EAD2B,AACxC,CADwC,AAMxC,AAAO,AAAK,AAA6B,AAAoB,AAE7D;;iEACA,AAAI,AAAM,AACR,qBAAA,AAAI,AAAC,AAAK,AAAS,AACjB;;cAAA,AAAO,AAAM,AAAmF,AAAO,AAAU,AAAY,AAC9H;;qIAED;AAAA,AAAI,AAAK,AAAS,AAAK,AAAW,AAAK,AAAQ,AAAG,AAAe,AAC/D,AAAM,AAAU,AAAO,AAAK,AAAwB,AAAK,AACzD,AACA;;;+DACA,MAJF,AAIE,AAAO,AAAU,AAClB;AAAM,AACL;;AAAM,eAAI,UAAV,AAAM,AAAW,AACf,AAEH;aACF;yBACF,MACD;AAjCF,AAiCE,AAAO,AACR","file":"/server/methods/core/hooks/cart.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { Cart } from \"/lib/collections\";\nimport { Logger, MethodHooks } from \"/server/api\";\n// this needed to keep correct loading order. Methods should be loaded before hooks\nimport \"../cart\";\n\n// // Meteor.after to call after\nMethodHooks.after(\"cart/submitPayment\", function (options) {\n  // if cart/submit had an error we won't copy cart to Order\n  // and we'll throw an error.\n  Logger.debug(\"MethodHooks after cart/submitPayment\", options);\n  // Default return value is the return value of previous call in method chain\n  // or an empty object if there's no result yet.\n  const result = options.result || {};\n  if (typeof options.error === \"undefined\") {\n    const cart = Cart.findOne({\n      userId: Meteor.userId()\n    });\n\n    // update workflow\n    Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"paymentSubmitted\");\n\n    // create order\n    if (cart) {\n      if (!cart.billing) {\n        Logger.debug(\"MethodHooks after cart/submitPayment. No billing address after payment! userId:\", Meteor.userId(), \"options:\", options);\n      }\n\n      if (cart.items && cart.billing && cart.billing[0].paymentMethod) {\n        const orderId = Meteor.call(\"cart/copyCartToOrder\", cart._id);\n        // Return orderId as result from this after hook call.\n        // This is done by extending the existing result.\n        result.orderId = orderId;\n      } else {\n        throw new Meteor.Error(\n          \"An error occurred verifing payment method. Failed to save order.\"\n        );\n      }\n    }\n  }\n  return result;\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/methods/core/hooks/cart.js.map","sourceFileName":"/server/methods/core/hooks/cart.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cart"},"ignored":false,"code":"var Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar Cart = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Cart: function (v) {\n    Cart = v;\n  }\n}, 1);\nvar Logger = void 0,\n    MethodHooks = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  },\n  MethodHooks: function (v) {\n    MethodHooks = v;\n  }\n}, 2);\nmodule.importSync(\"../cart\");\n// // Meteor.after to call after\nMethodHooks.after(\"cart/submitPayment\", function (options) {\n  // if cart/submit had an error we won't copy cart to Order\n  // and we'll throw an error.\n  Logger.debug(\"MethodHooks after cart/submitPayment\", options); // Default return value is the return value of previous call in method chain\n  // or an empty object if there's no result yet.\n\n  var result = options.result || {};\n\n  if (typeof options.error === \"undefined\") {\n    var cart = Cart.findOne({\n      userId: Meteor.userId()\n    }); // update workflow\n\n    Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"paymentSubmitted\"); // create order\n\n    if (cart) {\n      if (!cart.billing) {\n        Logger.debug(\"MethodHooks after cart/submitPayment. No billing address after payment! userId:\", Meteor.userId(), \"options:\", options);\n      }\n\n      if (cart.items && cart.billing && cart.billing[0].paymentMethod) {\n        var orderId = Meteor.call(\"cart/copyCartToOrder\", cart._id); // Return orderId as result from this after hook call.\n        // This is done by extending the existing result.\n\n        result.orderId = orderId;\n      } else {\n        throw new Meteor.Error(\"An error occurred verifing payment method. Failed to save order.\");\n      }\n    }\n  }\n\n  return result;\n});","map":{"version":3,"sources":["/server/methods/core/hooks/cart.js"],"names":["Meteor","Cart","Logger","MethodHooks","after","options","debug","result","error","cart","findOne","userId","call","billing","items","paymentMethod","orderId","_id","Error"],"mappings":"AAAA,IAAS;AAAT,OAAuB,WAAvB;;;;;;;;;;;;;;;;;;;;;kBACA,A,AAAA,AAAS,A,AAAT,AAAqB,AACrB,AAAS,AAAQ,AAAmB,AACpC,AACA,AAAO,AAEP;AACA,AAAY,AAAM,AAAsB,AAAU,AAAS;AACzD,2DACA;AACA;AAHyD,AAGzD,AAAO,AAAM,AAAwC,AACrD,AACA;iEACA;AAAA,AAAM,AAAS,AAAQ,AAAU;;iCACjC;;MAAI,OAAO,QAAP,AAAe,UAAnB,AAA6B;QACrB,YAAO,AAAK;cACR,OAF8B,AACxC,AAAa,AAAa,AAChB,AAAO,AAGjB,AACA;AAL0B,AACxB,KADW,EAD2B,AACxC,CADwC,AAMxC,AAAO,AAAK,AAA6B,AAAoB,AAE7D;;iEACA,AAAI,AAAM,AACR,qBAAA,AAAI,AAAC,AAAK,AAAS,AACjB;;cAAA,AAAO,AAAM,AAAmF,AAAO,AAAU,AAAY,AAC9H;;qIAED;AAAA,AAAI,AAAK,AAAS,AAAK,AAAW,AAAK,AAAQ,AAAG,AAAe,AAC/D,AAAM,AAAU,AAAO,AAAK,AAAwB,AAAK,AACzD,AACA;;;+DACA,MAJF,AAIE,AAAO,AAAU,AAClB;AAAM,AACL;;AAAM,eAAI,UAAV,AAAM,AAAW,AACf,AAEH;aACF;yBACF,MACD;AAjCF,AAiCE,AAAO,AACR","file":"/server/methods/core/hooks/cart.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { Cart } from \"/lib/collections\";\nimport { Logger, MethodHooks } from \"/server/api\";\n// this needed to keep correct loading order. Methods should be loaded before hooks\nimport \"../cart\";\n\n// // Meteor.after to call after\nMethodHooks.after(\"cart/submitPayment\", function (options) {\n  // if cart/submit had an error we won't copy cart to Order\n  // and we'll throw an error.\n  Logger.debug(\"MethodHooks after cart/submitPayment\", options);\n  // Default return value is the return value of previous call in method chain\n  // or an empty object if there's no result yet.\n  const result = options.result || {};\n  if (typeof options.error === \"undefined\") {\n    const cart = Cart.findOne({\n      userId: Meteor.userId()\n    });\n\n    // update workflow\n    Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"paymentSubmitted\");\n\n    // create order\n    if (cart) {\n      if (!cart.billing) {\n        Logger.debug(\"MethodHooks after cart/submitPayment. No billing address after payment! userId:\", Meteor.userId(), \"options:\", options);\n      }\n\n      if (cart.items && cart.billing && cart.billing[0].paymentMethod) {\n        const orderId = Meteor.call(\"cart/copyCartToOrder\", cart._id);\n        // Return orderId as result from this after hook call.\n        // This is done by extending the existing result.\n        result.orderId = orderId;\n      } else {\n        throw new Meteor.Error(\n          \"An error occurred verifing payment method. Failed to save order.\"\n        );\n      }\n    }\n  }\n  return result;\n});\n"]},"hash":"de81a21eb3bc587d9efdedf6795b846dafb22f6e"}
