{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash/isUndefined","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_isUndefined"}]},{"source":"lodash/each","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_each"}]},{"source":"lodash/toArray","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_toArray"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]}],"exports":{"exported":["MethodHooks"],"specifiers":[{"kind":"local","local":"MethodHooks","exported":"MethodHooks"}]}}},"options":{"filename":"/server/api/method-hooks.js","filenameRelative":"/server/api/method-hooks.js","inputSourceMap":{"version":3,"sources":["/server/api/method-hooks.js"],"names":["Meteor","MethodHooks","_afterHooks","_beforeHooks","_handlers","isClient","connection","_methodHandlers","server","method_handlers","_originalMethodHandlers","_wrappers","_initializeHook","mapping","methodName","hookFunction","push","method","args","arguments","beforeResult","beforeHooks","beforeHook","hooksProcessed","call","result","undefined","error","methodResult","methodError","apply","afterHooks","afterHook","hookResult","_debug","before","beforeFunction","after","afterFunction","beforeMethods","dict","v","k","afterMethods"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,A,AAAA,AAAS,AAAc,AAEvB,AAKA;AAAO,IAAM,cAAN,AAAoB,AAE3B,A;AAgBA;;;;;;;;;;;;;;IAKA,A,AAAA,AAAY,AAAc,AAE1B;;;;iC,AAKA,AAAY,AAAe,AAE3B,IAIA,AAAY,AAAY,A,AAAxB,AAAwB,AAAO,AAAW,AAAO,AAAW,AAC1D,AAAO,AAAO,AAEhB;;;;;+B,AAKA,AAAY,AAA0B,AAEtC;;;;4F,AAKA,AAAY,AAAY,AAExB;;;;;0CASA,AAAY,AAAkB,AAAU,AAAS,AAAY,AAAc,AACzE,AAAQ,AAAc,AAAQ,AAAe,AAC7C,AAAQ,AAAY,AAAK,AAEzB;;;;;wBAJyE,AAKzE,AAAM,AAAS,AAAY,AAAU,AACrC,IANyE,AAOzE,AAAI,AAAC,AAAU,AAAY,AAAU,AAAa,AAChD,AACD,AAED,AACA,AAAY,AAAwB,AAAc,AAElD,AAAY,AAAU,AAAc,AAAY;;;;;;;;;;AAC9C;UACM,AAAO,cAAU,QAAvB,AAAa;2BAFiC,AAG9C,AAAI,AACJ,eAEA;;MAAM,SAAc,YAAY,UAAhC,AAAoB,AAAyB,aAC7C;;OAAO,UAAP,AAAoB,AAAC,YAAD,AAAa,UAAb,aAAgC,AAClD;AAAe,AAAW,AAAK,AAAM,AACnC;AADmC,AAC3B,AACR,AAAO,AACP,GATJ,CAMuC,AAGxB,AACX;;;cAAgB,sCAJlB,AAAe,AAAsB;;;AAOrC;;AAAA,AAAI,AAAiB,AAAO,AAC1B;QAAO,OAAP,SACD;;QACF,uBAXD,AAaA;;AAAI,sBAAJ,AAAqB,AAAO,yBAC1B;;UAAA,AAAO,mDACR;;gBACD;AAAI,eAAJ,AACA;AAAI,mBAxB0C,AAwB9C,AAEA,AACA;wBACA,AAAI,AACF;;;UAAe,iBAAY,OAD7B,AACE,AAAe,AAAoC,AAAY,AAAM,AAAM,AAC5E,AAAC;AAAO,eAAP,AAAc,AACd;AAAA,AAAc,AACf;AAhC6C,AAkC9C;;gCACA;AAAM,aAAN,AAAmB,AAAY,AAAY;AAC3C;;QAAA,AAAO,AAAY,AAAC,AAAW,AAAmB,AAChD;QAAM,AAAa,AAAU,AAAK,AAAM,AACtC,AAAQ,AACR,sBAFsC,AAE/B,AACP;AAHsC,AAG3B,AACX;;QAJsC,AAItB;AAL8B,AAChD,AAAmB,AAMnB;oBACA;AAAI,oBAAJ,AAAI,AAAc,AAAe,AAAC,AAAc,AAAe,AAC7D;AADF,AACE,AAAO,AAAO,AACf,AAAM,AACL,MAAA,AAAe,AAChB;;;6CACF;;AAjD6C,AAoC9C,AAeA;;gBACA;AAAI,eAAJ,AAAiB,AACf;AAAM,mBArDsC,AAqD5C,AACD,AAED;;UACA;;UAAA,AAAO,yDAvEgE,AAczE,AA0DC,AAED;;;uBACA;A,AA3EF,AA2EE,AAAY,AAAU,AAAc,AAAY,AAC9C,AACH,AAED;;;;;;MAOA;;;WAAA,AAAY,AAAS,AAAU,AAAY,AAAgB,AACzD;A,AADF,AACE,AAAY,AAAgB,AAAY,AACtC,AAAY,AACf,AAED;;;;G,AAOA,AAAY,AAAQ,AAAU,AAAY,AAAe,AACvD,AAAY,AAAgB,AAAY,AACtC,AAAY,AACf,AAED;;;;;;;;;;AAMA,AAAY,AAAgB,AAAU,AAAM,GAA5C,A,AACE,AAAO,AAAM,AAAU,AAAG,AAAG,AAC3B,AAAY,AAAO,AAAG,AACvB,AACF,AAED;;;;;;;;;0CAKA,aAAY,YAAZ,AAA2B,AAAU,AAAM,AACzC;AAAA,AAAO,AAAM,AAAU,AAAG,AAAG,AAC3B,AAAY,AAAM,AAAG,GAFzB,AACE,AAEC,AACF","file":"/server/api/method-hooks.js.map","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\n\n/*\n *  Blatant reuse of Meteor method hooks from\n *  @see https://github.com/hitchcott/meteor-method-hooks\n *  @see https://github.com/Workpop/meteor-method-hooks\n */\nexport const MethodHooks = {};\n\n/**\n * A hook to be run before or after a method.\n * @name Hook\n * @function\n * @return {*} The result of the method. Ignored for before hooks, passed as the methodResult to subsequent method hooks.\n * You can mutate the return value in after hooks.\n * @param {{result: *, error: *, arguments: Array, hooksProcessed: Number}} An options parameter that has the result and\n * error from calling the method and the arguments used to call that method. `result` and `error` are null for before\n * hooks, since the method has not yet been called. On the client, after hooks are called when the method returns from\n * the server, but before the callback is invoked. `hooksProcessed` gives you the number of hooks processed so far,\n * since previous hooks may have mutated the arguments.\n *\n * After hooks can change the result values. Use `hooksProcessed` to keep track of how many modifications have been\n * made.\n */\n\n/**\n * A collection of after hooks\n * @type {Object.<String, [Hook]>} A mapping from method names to arrays of hooks\n * @private\n */\nMethodHooks._afterHooks = {};\n\n/**\n * A collection of before hooks\n * @type {Object.<String, [Hook]>} A mapping from method names to arrays of hooks\n * @private\n */\nMethodHooks._beforeHooks = {};\n\n/**\n * handlers\n * The method handler definitions appropriate to the environment\n */\nMethodHooks._handlers = Meteor.isClient ? Meteor.connection._methodHandlers :\n  Meteor.server.method_handlers;\n\n/**\n * The original method handlers\n * @type {Object.<String, Function>} Method handler mapping\n * @private\n */\nMethodHooks._originalMethodHandlers = {};\n\n/**\n * Wrappers\n * @type {Object.<String, Function>} A mapping from method names to method functions\n * @private\n */\nMethodHooks._wrappers = {};\n\n/**\n *  initializeHook\n * @summary Initializes a new hook\n * @param {String} mapping - map hook: a is  place to store the mapping\n * @param {String} methodName - The name of the method\n * @param {Function} hookFunction - The hook function\n * @private\n * @return {String} - returns transformed data\n */\nMethodHooks._initializeHook = function (mapping, methodName, hookFunction) {\n  mapping[methodName] = mapping[methodName] || [];\n  mapping[methodName].push(hookFunction);\n\n  // Initialize a wrapper for the given method name. Idempotent, it will not erase existing handlers.\n  const method = MethodHooks._handlers[methodName];\n  // If no method is found, or a wrapper already exists, return\n  if (!method || MethodHooks._wrappers[methodName]) {\n    return;\n  }\n\n  // Get a reference to the original handler\n  MethodHooks._originalMethodHandlers[methodName] = method;\n\n  MethodHooks._wrappers[methodName] = function () {\n    // Get arguments you can mutate\n    const args = _.toArray(arguments);\n    let beforeResult;\n    // Call the before hooks\n\n    const beforeHooks = MethodHooks._beforeHooks[methodName];\n    _.each(beforeHooks, (beforeHook, hooksProcessed) => {\n      beforeResult = beforeHook.call(this, {\n        result: undefined,\n        error: undefined,\n        arguments: args,\n        hooksProcessed: hooksProcessed\n      });\n\n      if (beforeResult === false) {\n        return false;\n      }\n    });\n\n    if (beforeResult === false) {\n      return false;\n    }\n    let methodResult;\n    let methodError;\n\n    // Call the main method body\n    // check(args, Match.Any);\n    try {\n      methodResult = MethodHooks._originalMethodHandlers[methodName].apply(this, args);\n    } catch (error) {\n      methodError = error;\n    }\n\n    // Call after hooks, providing the result and the original arguments\n    const afterHooks = MethodHooks._afterHooks[methodName];\n    _.each(afterHooks, (afterHook, hooksProcessed) => {\n      const hookResult = afterHook.call(this, {\n        result: methodResult,\n        error: methodError,\n        arguments: args,\n        hooksProcessed: hooksProcessed\n      });\n      // If the after hook did not return a value and the methodResult is not undefined, warn and fix\n      if (_.isUndefined(hookResult) && !_.isUndefined(methodResult)) {\n        Meteor._debug(\"Expected the after hook to return a value.\");\n      } else {\n        methodResult = hookResult;\n      }\n    });\n\n    // If an error was thrown, throw it after the after hooks. Ought to include the correct stack information\n    if (methodError) {\n      throw methodError;\n    }\n\n    // Return the method result, possibly modified by the after hook\n    return methodResult;\n  };\n\n  // Assign to a new handler\n  MethodHooks._handlers[methodName] = MethodHooks._wrappers[\n    methodName];\n};\n\n/**\n * Reaction MethodHooks before\n * @summary Add a function to call before the specified method\n * @param {String} methodName - methodName\n * @param {String} beforeFunction - beforeFunction\n * @return {String} - returns transformed data\n */\nMethodHooks.before = function (methodName, beforeFunction) {\n  MethodHooks._initializeHook(MethodHooks._beforeHooks,\n    methodName, beforeFunction);\n};\n\n/**\n * MethodHooks.after\n * Add a function to call after the specified method\n * @param {String} methodName - methodName\n * @param {String} afterFunction - afterFunction\n * @return {String} - returns transformed data\n */\nMethodHooks.after = function (methodName, afterFunction) {\n  MethodHooks._initializeHook(MethodHooks._afterHooks,\n    methodName, afterFunction);\n};\n\n/**\n * MethodHooks.beforeMethods\n * Call the provided hook in values for the key'd method names\n * @param {Object.<string, Hook>} dict - dict\n * @return {String} - returns transformed data\n */\nMethodHooks.beforeMethods = function (dict) {\n  _.each(dict, function (v, k) {\n    MethodHooks.before(k, v);\n  });\n};\n\n/**\n * Call the provided hook in values for the key'd method names\n * @param {Object.<string, Hook>} dict - dict\n * @return {String} - returns transformed data\n */\nMethodHooks.afterMethods = function (dict) {\n  _.each(dict, function (v, k) {\n    MethodHooks.after(k, v);\n  });\n};\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/api/method-hooks.js.map","sourceFileName":"/server/api/method-hooks.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"method-hooks"},"ignored":false,"code":"module.export({\n  MethodHooks: function () {\n    return MethodHooks;\n  }\n});\n\nvar _isUndefined = void 0;\n\nmodule.importSync(\"lodash/isUndefined\", {\n  \"default\": function (v) {\n    _isUndefined = v;\n  }\n}, 0);\n\nvar _each = void 0;\n\nmodule.importSync(\"lodash/each\", {\n  \"default\": function (v) {\n    _each = v;\n  }\n}, 1);\n\nvar _toArray = void 0;\n\nmodule.importSync(\"lodash/toArray\", {\n  \"default\": function (v) {\n    _toArray = v;\n  }\n}, 2);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 3);\nvar MethodHooks = {};\n/**\n * A hook to be run before or after a method.\n * @name Hook\n * @function\n * @return {*} The result of the method. Ignored for before hooks, passed as the methodResult to subsequent method hooks.\n * You can mutate the return value in after hooks.\n * @param {{result: *, error: *, arguments: Array, hooksProcessed: Number}} An options parameter that has the result and\n * error from calling the method and the arguments used to call that method. `result` and `error` are null for before\n * hooks, since the method has not yet been called. On the client, after hooks are called when the method returns from\n * the server, but before the callback is invoked. `hooksProcessed` gives you the number of hooks processed so far,\n * since previous hooks may have mutated the arguments.\n *\n * After hooks can change the result values. Use `hooksProcessed` to keep track of how many modifications have been\n * made.\n */ /**\n     * A collection of after hooks\n     * @type {Object.<String, [Hook]>} A mapping from method names to arrays of hooks\n     * @private\n     */MethodHooks._afterHooks = {}; /**\n                                      * A collection of before hooks\n                                      * @type {Object.<String, [Hook]>} A mapping from method names to arrays of hooks\n                                      * @private\n                                      */\nMethodHooks._beforeHooks = {}; /**\n                                * handlers\n                                * The method handler definitions appropriate to the environment\n                                */\nMethodHooks._handlers = Meteor.isClient ? Meteor.connection._methodHandlers : Meteor.server.method_handlers; /**\n                                                                                                              * The original method handlers\n                                                                                                              * @type {Object.<String, Function>} Method handler mapping\n                                                                                                              * @private\n                                                                                                              */\nMethodHooks._originalMethodHandlers = {}; /**\n                                           * Wrappers\n                                           * @type {Object.<String, Function>} A mapping from method names to method functions\n                                           * @private\n                                           */\nMethodHooks._wrappers = {}; /**\n                             *  initializeHook\n                             * @summary Initializes a new hook\n                             * @param {String} mapping - map hook: a is  place to store the mapping\n                             * @param {String} methodName - The name of the method\n                             * @param {Function} hookFunction - The hook function\n                             * @private\n                             * @return {String} - returns transformed data\n                             */\n\nMethodHooks._initializeHook = function (mapping, methodName, hookFunction) {\n  mapping[methodName] = mapping[methodName] || [];\n  mapping[methodName].push(hookFunction); // Initialize a wrapper for the given method name. Idempotent, it will not erase existing handlers.\n\n  var method = MethodHooks._handlers[methodName]; // If no method is found, or a wrapper already exists, return\n\n  if (!method || MethodHooks._wrappers[methodName]) {\n    return;\n  } // Get a reference to the original handler\n\n\n  MethodHooks._originalMethodHandlers[methodName] = method;\n\n  MethodHooks._wrappers[methodName] = function () {\n    var _this = this;\n\n    // Get arguments you can mutate\n    var args = _toArray(arguments);\n\n    var beforeResult = void 0; // Call the before hooks\n\n    var beforeHooks = MethodHooks._beforeHooks[methodName];\n\n    _each(beforeHooks, function (beforeHook, hooksProcessed) {\n      beforeResult = beforeHook.call(_this, {\n        result: undefined,\n        error: undefined,\n        arguments: args,\n        hooksProcessed: hooksProcessed\n      });\n\n      if (beforeResult === false) {\n        return false;\n      }\n    });\n\n    if (beforeResult === false) {\n      return false;\n    }\n\n    var methodResult = void 0;\n    var methodError = void 0; // Call the main method body\n    // check(args, Match.Any);\n\n    try {\n      methodResult = MethodHooks._originalMethodHandlers[methodName].apply(this, args);\n    } catch (error) {\n      methodError = error;\n    } // Call after hooks, providing the result and the original arguments\n\n\n    var afterHooks = MethodHooks._afterHooks[methodName];\n\n    _each(afterHooks, function (afterHook, hooksProcessed) {\n      var hookResult = afterHook.call(_this, {\n        result: methodResult,\n        error: methodError,\n        arguments: args,\n        hooksProcessed: hooksProcessed\n      }); // If the after hook did not return a value and the methodResult is not undefined, warn and fix\n\n      if (_isUndefined(hookResult) && !_isUndefined(methodResult)) {\n        Meteor._debug(\"Expected the after hook to return a value.\");\n      } else {\n        methodResult = hookResult;\n      }\n    }); // If an error was thrown, throw it after the after hooks. Ought to include the correct stack information\n\n\n    if (methodError) {\n      throw methodError;\n    } // Return the method result, possibly modified by the after hook\n\n\n    return methodResult;\n  }; // Assign to a new handler\n\n\n  MethodHooks._handlers[methodName] = MethodHooks._wrappers[methodName];\n}; /**\n    * Reaction MethodHooks before\n    * @summary Add a function to call before the specified method\n    * @param {String} methodName - methodName\n    * @param {String} beforeFunction - beforeFunction\n    * @return {String} - returns transformed data\n    */\n\nMethodHooks.before = function (methodName, beforeFunction) {\n  MethodHooks._initializeHook(MethodHooks._beforeHooks, methodName, beforeFunction);\n}; /**\n    * MethodHooks.after\n    * Add a function to call after the specified method\n    * @param {String} methodName - methodName\n    * @param {String} afterFunction - afterFunction\n    * @return {String} - returns transformed data\n    */\n\nMethodHooks.after = function (methodName, afterFunction) {\n  MethodHooks._initializeHook(MethodHooks._afterHooks, methodName, afterFunction);\n}; /**\n    * MethodHooks.beforeMethods\n    * Call the provided hook in values for the key'd method names\n    * @param {Object.<string, Hook>} dict - dict\n    * @return {String} - returns transformed data\n    */\n\nMethodHooks.beforeMethods = function (dict) {\n  _each(dict, function (v, k) {\n    MethodHooks.before(k, v);\n  });\n}; /**\n    * Call the provided hook in values for the key'd method names\n    * @param {Object.<string, Hook>} dict - dict\n    * @return {String} - returns transformed data\n    */\n\nMethodHooks.afterMethods = function (dict) {\n  _each(dict, function (v, k) {\n    MethodHooks.after(k, v);\n  });\n};","map":{"version":3,"sources":["/server/api/method-hooks.js"],"names":["Meteor","MethodHooks","_afterHooks","_beforeHooks","_handlers","isClient","connection","_methodHandlers","server","method_handlers","_originalMethodHandlers","_wrappers","_initializeHook","mapping","methodName","hookFunction","push","method","args","arguments","beforeResult","beforeHooks","beforeHook","hooksProcessed","call","result","undefined","error","methodResult","methodError","apply","afterHooks","afterHook","hookResult","_debug","before","beforeFunction","after","afterFunction","beforeMethods","dict","v","k","afterMethods"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,A,AAAA,AAAS,AAAc,AAEvB,AAKA;AAAO,IAAM,cAAN,AAAoB,AAE3B,A;AAgBA;;;;;;;;;;;;;;IAKA,A,AAAA,AAAY,AAAc,AAE1B;;;;iC,AAKA,AAAY,AAAe,AAE3B,IAIA,AAAY,AAAY,A,AAAxB,AAAwB,AAAO,AAAW,AAAO,AAAW,AAC1D,AAAO,AAAO,AAEhB;;;;;+B,AAKA,AAAY,AAA0B,AAEtC;;;;4F,AAKA,AAAY,AAAY,AAExB;;;;;0CASA,AAAY,AAAkB,AAAU,AAAS,AAAY,AAAc,AACzE,AAAQ,AAAc,AAAQ,AAAe,AAC7C,AAAQ,AAAY,AAAK,AAEzB;;;;;wBAJyE,AAKzE,AAAM,AAAS,AAAY,AAAU,AACrC,IANyE,AAOzE,AAAI,AAAC,AAAU,AAAY,AAAU,AAAa,AAChD,AACD,AAED,AACA,AAAY,AAAwB,AAAc,AAElD,AAAY,AAAU,AAAc,AAAY;;;;;;;;;;AAC9C;UACM,AAAO,cAAU,QAAvB,AAAa;2BAFiC,AAG9C,AAAI,AACJ,eAEA;;MAAM,SAAc,YAAY,UAAhC,AAAoB,AAAyB,aAC7C;;OAAO,UAAP,AAAoB,AAAC,YAAD,AAAa,UAAb,aAAgC,AAClD;AAAe,AAAW,AAAK,AAAM,AACnC;AADmC,AAC3B,AACR,AAAO,AACP,GATJ,CAMuC,AAGxB,AACX;;;cAAgB,sCAJlB,AAAe,AAAsB;;;AAOrC;;AAAA,AAAI,AAAiB,AAAO,AAC1B;QAAO,OAAP,SACD;;QACF,uBAXD,AAaA;;AAAI,sBAAJ,AAAqB,AAAO,yBAC1B;;UAAA,AAAO,mDACR;;gBACD;AAAI,eAAJ,AACA;AAAI,mBAxB0C,AAwB9C,AAEA,AACA;wBACA,AAAI,AACF;;;UAAe,iBAAY,OAD7B,AACE,AAAe,AAAoC,AAAY,AAAM,AAAM,AAC5E,AAAC;AAAO,eAAP,AAAc,AACd;AAAA,AAAc,AACf;AAhC6C,AAkC9C;;gCACA;AAAM,aAAN,AAAmB,AAAY,AAAY;AAC3C;;QAAA,AAAO,AAAY,AAAC,AAAW,AAAmB,AAChD;QAAM,AAAa,AAAU,AAAK,AAAM,AACtC,AAAQ,AACR,sBAFsC,AAE/B,AACP;AAHsC,AAG3B,AACX;;QAJsC,AAItB;AAL8B,AAChD,AAAmB,AAMnB;oBACA;AAAI,oBAAJ,AAAI,AAAc,AAAe,AAAC,AAAc,AAAe,AAC7D;AADF,AACE,AAAO,AAAO,AACf,AAAM,AACL,MAAA,AAAe,AAChB;;;6CACF;;AAjD6C,AAoC9C,AAeA;;gBACA;AAAI,eAAJ,AAAiB,AACf;AAAM,mBArDsC,AAqD5C,AACD,AAED;;UACA;;UAAA,AAAO,yDAvEgE,AAczE,AA0DC,AAED;;;uBACA;A,AA3EF,AA2EE,AAAY,AAAU,AAAc,AAAY,AAC9C,AACH,AAED;;;;;;MAOA;;;WAAA,AAAY,AAAS,AAAU,AAAY,AAAgB,AACzD;A,AADF,AACE,AAAY,AAAgB,AAAY,AACtC,AAAY,AACf,AAED;;;;G,AAOA,AAAY,AAAQ,AAAU,AAAY,AAAe,AACvD,AAAY,AAAgB,AAAY,AACtC,AAAY,AACf,AAED;;;;;;;;;;AAMA,AAAY,AAAgB,AAAU,AAAM,GAA5C,A,AACE,AAAO,AAAM,AAAU,AAAG,AAAG,AAC3B,AAAY,AAAO,AAAG,AACvB,AACF,AAED;;;;;;;;;0CAKA,aAAY,YAAZ,AAA2B,AAAU,AAAM,AACzC;AAAA,AAAO,AAAM,AAAU,AAAG,AAAG,AAC3B,AAAY,AAAM,AAAG,GAFzB,AACE,AAEC,AACF","file":"/server/api/method-hooks.js.map","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\n\n/*\n *  Blatant reuse of Meteor method hooks from\n *  @see https://github.com/hitchcott/meteor-method-hooks\n *  @see https://github.com/Workpop/meteor-method-hooks\n */\nexport const MethodHooks = {};\n\n/**\n * A hook to be run before or after a method.\n * @name Hook\n * @function\n * @return {*} The result of the method. Ignored for before hooks, passed as the methodResult to subsequent method hooks.\n * You can mutate the return value in after hooks.\n * @param {{result: *, error: *, arguments: Array, hooksProcessed: Number}} An options parameter that has the result and\n * error from calling the method and the arguments used to call that method. `result` and `error` are null for before\n * hooks, since the method has not yet been called. On the client, after hooks are called when the method returns from\n * the server, but before the callback is invoked. `hooksProcessed` gives you the number of hooks processed so far,\n * since previous hooks may have mutated the arguments.\n *\n * After hooks can change the result values. Use `hooksProcessed` to keep track of how many modifications have been\n * made.\n */\n\n/**\n * A collection of after hooks\n * @type {Object.<String, [Hook]>} A mapping from method names to arrays of hooks\n * @private\n */\nMethodHooks._afterHooks = {};\n\n/**\n * A collection of before hooks\n * @type {Object.<String, [Hook]>} A mapping from method names to arrays of hooks\n * @private\n */\nMethodHooks._beforeHooks = {};\n\n/**\n * handlers\n * The method handler definitions appropriate to the environment\n */\nMethodHooks._handlers = Meteor.isClient ? Meteor.connection._methodHandlers :\n  Meteor.server.method_handlers;\n\n/**\n * The original method handlers\n * @type {Object.<String, Function>} Method handler mapping\n * @private\n */\nMethodHooks._originalMethodHandlers = {};\n\n/**\n * Wrappers\n * @type {Object.<String, Function>} A mapping from method names to method functions\n * @private\n */\nMethodHooks._wrappers = {};\n\n/**\n *  initializeHook\n * @summary Initializes a new hook\n * @param {String} mapping - map hook: a is  place to store the mapping\n * @param {String} methodName - The name of the method\n * @param {Function} hookFunction - The hook function\n * @private\n * @return {String} - returns transformed data\n */\nMethodHooks._initializeHook = function (mapping, methodName, hookFunction) {\n  mapping[methodName] = mapping[methodName] || [];\n  mapping[methodName].push(hookFunction);\n\n  // Initialize a wrapper for the given method name. Idempotent, it will not erase existing handlers.\n  const method = MethodHooks._handlers[methodName];\n  // If no method is found, or a wrapper already exists, return\n  if (!method || MethodHooks._wrappers[methodName]) {\n    return;\n  }\n\n  // Get a reference to the original handler\n  MethodHooks._originalMethodHandlers[methodName] = method;\n\n  MethodHooks._wrappers[methodName] = function () {\n    // Get arguments you can mutate\n    const args = _.toArray(arguments);\n    let beforeResult;\n    // Call the before hooks\n\n    const beforeHooks = MethodHooks._beforeHooks[methodName];\n    _.each(beforeHooks, (beforeHook, hooksProcessed) => {\n      beforeResult = beforeHook.call(this, {\n        result: undefined,\n        error: undefined,\n        arguments: args,\n        hooksProcessed: hooksProcessed\n      });\n\n      if (beforeResult === false) {\n        return false;\n      }\n    });\n\n    if (beforeResult === false) {\n      return false;\n    }\n    let methodResult;\n    let methodError;\n\n    // Call the main method body\n    // check(args, Match.Any);\n    try {\n      methodResult = MethodHooks._originalMethodHandlers[methodName].apply(this, args);\n    } catch (error) {\n      methodError = error;\n    }\n\n    // Call after hooks, providing the result and the original arguments\n    const afterHooks = MethodHooks._afterHooks[methodName];\n    _.each(afterHooks, (afterHook, hooksProcessed) => {\n      const hookResult = afterHook.call(this, {\n        result: methodResult,\n        error: methodError,\n        arguments: args,\n        hooksProcessed: hooksProcessed\n      });\n      // If the after hook did not return a value and the methodResult is not undefined, warn and fix\n      if (_.isUndefined(hookResult) && !_.isUndefined(methodResult)) {\n        Meteor._debug(\"Expected the after hook to return a value.\");\n      } else {\n        methodResult = hookResult;\n      }\n    });\n\n    // If an error was thrown, throw it after the after hooks. Ought to include the correct stack information\n    if (methodError) {\n      throw methodError;\n    }\n\n    // Return the method result, possibly modified by the after hook\n    return methodResult;\n  };\n\n  // Assign to a new handler\n  MethodHooks._handlers[methodName] = MethodHooks._wrappers[\n    methodName];\n};\n\n/**\n * Reaction MethodHooks before\n * @summary Add a function to call before the specified method\n * @param {String} methodName - methodName\n * @param {String} beforeFunction - beforeFunction\n * @return {String} - returns transformed data\n */\nMethodHooks.before = function (methodName, beforeFunction) {\n  MethodHooks._initializeHook(MethodHooks._beforeHooks,\n    methodName, beforeFunction);\n};\n\n/**\n * MethodHooks.after\n * Add a function to call after the specified method\n * @param {String} methodName - methodName\n * @param {String} afterFunction - afterFunction\n * @return {String} - returns transformed data\n */\nMethodHooks.after = function (methodName, afterFunction) {\n  MethodHooks._initializeHook(MethodHooks._afterHooks,\n    methodName, afterFunction);\n};\n\n/**\n * MethodHooks.beforeMethods\n * Call the provided hook in values for the key'd method names\n * @param {Object.<string, Hook>} dict - dict\n * @return {String} - returns transformed data\n */\nMethodHooks.beforeMethods = function (dict) {\n  _.each(dict, function (v, k) {\n    MethodHooks.before(k, v);\n  });\n};\n\n/**\n * Call the provided hook in values for the key'd method names\n * @param {Object.<string, Hook>} dict - dict\n * @return {String} - returns transformed data\n */\nMethodHooks.afterMethods = function (dict) {\n  _.each(dict, function (v, k) {\n    MethodHooks.after(k, v);\n  });\n};\n"]},"hash":"161425a738f4ada05701aedfa3281c5e249e4b48"}
