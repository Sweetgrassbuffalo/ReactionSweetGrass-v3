{"metadata":{"usedHelpers":["typeof","inherits","possibleConstructorReturn","createClass","classCallCheck","extends","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"react","imported":["default","Component","PropTypes"],"specifiers":[{"kind":"named","imported":"default","local":"React"},{"kind":"named","imported":"Component","local":"Component"},{"kind":"named","imported":"PropTypes","local":"PropTypes"}]},{"source":"react-measure","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Measure"}]},{"source":"react/lib/update","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"update"}]},{"source":"/lib/api/compose","imported":["composeWithTracker"],"specifiers":[{"kind":"named","imported":"composeWithTracker","local":"composeWithTracker"}]},{"source":"../components","imported":["MediaGallery"],"specifiers":[{"kind":"named","imported":"MediaGallery","local":"MediaGallery"}]},{"source":"/client/api","imported":["Reaction"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"}]},{"source":"/lib/api","imported":["ReactionProduct"],"specifiers":[{"kind":"named","imported":"ReactionProduct","local":"ReactionProduct"}]},{"source":"/lib/collections","imported":["Media","Revisions"],"specifiers":[{"kind":"named","imported":"Media","local":"Media"},{"kind":"named","imported":"Revisions","local":"Revisions"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/plugins/core/ui/client/containers/mediaGalleryContainer.js","filenameRelative":"/imports/plugins/core/ui/client/containers/mediaGalleryContainer.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/core/ui/client/containers/mediaGalleryContainer.js"],"names":["React","Component","PropTypes","Measure","update","composeWithTracker","MediaGallery","Reaction","ReactionProduct","Media","Revisions","uploadHandler","files","productId","selectedProductId","variant","selectedVariant","Alerts","add","autoHide","variantId","_id","shopId","selectedProduct","getShopId","userId","Meteor","count","find","toGrid","ancestors","length","file","fileObj","FS","File","metadata","ownerId","priority","insert","MediaGalleryContainer","constructor","props","state","featuredMedia","media","dimensions","width","height","componentWillReceiveProps","nextProps","setState","handleDrop","handleRemoveMedia","imageUrl","url","mediaId","alert","title","type","showCancelButton","imageHeight","isConfirm","remove","error","toast","reason","allowFeaturedMediaHover","handleMouseEnterMedia","event","handleMouseLeaveMedia","undefined","handleMoveMedia","dragIndex","hoverIndex","newMediaOrder","$splice","defer","forEach","mediaItem","index","$set","render","fetchMediaRevisions","mediaRevisions","$nin","fetch","sortMedia","sortedMedia","_","sortBy","m","appendRevisionsToMedia","hasPermission","permission","newMedia","image","revision","documentId","documentData","push","composer","onData","editable","viewAs","getUserPreferences","propTypes","bool","id","string","arrayOf","object","placement"],"mappings":"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","file":"/imports/plugins/core/ui/client/containers/mediaGalleryContainer.js.map","sourcesContent":["import React, { Component, PropTypes } from \"react\";\nimport Measure from \"react-measure\";\nimport update from \"react/lib/update\";\nimport { composeWithTracker } from \"/lib/api/compose\";\nimport { MediaGallery } from \"../components\";\nimport { Reaction } from \"/client/api\";\nimport { ReactionProduct } from \"/lib/api\";\nimport { Media, Revisions } from \"/lib/collections\";\n\nfunction uploadHandler(files) {\n  // TODO: It would be cool to move this logic to common ValidatedMethod, but\n  // I can't find a way to do this, because of browser's `FileList` collection\n  // and it `Blob`s which is our event.target.files.\n  // There is a way to do this: http://stackoverflow.com/a/24003932. but it's too\n  // tricky\n  const productId = ReactionProduct.selectedProductId();\n  const variant = ReactionProduct.selectedVariant();\n  if (typeof variant !== \"object\") {\n    return Alerts.add(\"Please, create new Variant first.\", \"danger\", {\n      autoHide: true\n    });\n  }\n  const variantId = variant._id;\n  const shopId = ReactionProduct.selectedProduct().shopId || Reaction.getShopId();\n  const userId = Meteor.userId();\n  let count = Media.find({\n    \"metadata.variantId\": variantId\n  }).count();\n  // TODO: we need to mark the first variant images somehow for productGrid.\n  // But how do we know that this is the first, not second or other variant?\n  // Question is open. For now if product has more than 1 top variant, everyone\n  // will have a chance to be displayed\n  const toGrid = variant.ancestors.length === 1;\n\n  for (const file of files) {\n    const fileObj = new FS.File(file);\n\n    fileObj.metadata = {\n      ownerId: userId,\n      productId: productId,\n      variantId: variantId,\n      shopId: shopId,\n      priority: count,\n      toGrid: +toGrid // we need number\n    };\n\n    Media.insert(fileObj);\n    count++;\n  }\n\n  return true;\n}\n\nclass MediaGalleryContainer extends Component {\n  // Load first image as featuredImage\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      featuredMedia: props.media[0],\n      dimensions: {\n        width: -1,\n        height: -1\n      }\n    };\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setState({\n      featuredMedia: nextProps.media[0],\n      media: nextProps.media\n    });\n  }\n\n  handleDrop = (files) => {\n    uploadHandler(files);\n  }\n\n  handleRemoveMedia = (media) => {\n    const imageUrl = media.url();\n    const mediaId = media._id;\n\n    Alerts.alert({\n      title: \"Remove Media?\",\n      type: \"warning\",\n      showCancelButton: true,\n      imageUrl,\n      imageHeight: 150\n    }, (isConfirm) => {\n      if (isConfirm) {\n        Media.remove({ _id: mediaId }, (error) => {\n          if (error) {\n            Alerts.toast(error.reason, \"warning\", {\n              autoHide: 10000\n            });\n          }\n\n          // updateImagePriorities();\n        });\n      }\n      // show media as removed (since it will not disappear until changes are published\n    });\n  }\n\n  get allowFeaturedMediaHover() {\n    if (this.state.featuredMedia) {\n      return true;\n    }\n    return false;\n  }\n\n  get media() {\n    return (this.state && this.state.media) || this.props.media;\n  }\n\n  handleMouseEnterMedia = (event, media) => {\n    this.setState({\n      featuredMedia: media\n    });\n  }\n\n  handleMouseLeaveMedia = () => {\n    this.setState({\n      featuredMedia: undefined\n    });\n  }\n\n  handleMoveMedia = (dragIndex, hoverIndex) => {\n    const media = this.props.media[dragIndex];\n\n    // Apply new sort order to variant list\n    const newMediaOrder = update(this.props.media, {\n      $splice: [\n        [dragIndex, 1],\n        [hoverIndex, 0, media]\n      ]\n    });\n\n    // Set local state so the component does't have to wait for a round-trip\n    // to the server to get the updated list of variants\n    this.setState({\n      media: newMediaOrder\n    });\n\n    // Save the updated positions\n    Meteor.defer(() => {\n      newMediaOrder.forEach((mediaItem, index) => {\n        Media.update(mediaItem._id, {\n          $set: {\n            \"metadata.priority\": index\n          }\n        });\n      });\n    });\n  }\n\n  render() {\n    const { width, height } = this.state.dimensions;\n\n    return (\n      <Measure\n        onMeasure={(dimensions) => {\n          this.setState({ dimensions });\n        }}\n      >\n        <MediaGallery\n          allowFeaturedMediaHover={this.allowFeaturedMediaHover}\n          featuredMedia={this.state.featuredMedia}\n          onDrop={this.handleDrop}\n          onMouseEnterMedia={this.handleMouseEnterMedia}\n          onMouseLeaveMedia={this.handleMouseLeaveMedia}\n          onMoveMedia={this.handleMoveMedia}\n          onRemoveMedia={this.handleRemoveMedia}\n          {...this.props}\n          media={this.media}\n          mediaGalleryHeight={height}\n          mediaGalleryWidth={width}\n        />\n      </Measure>\n    );\n  }\n}\n\nfunction fetchMediaRevisions() {\n  const productId = ReactionProduct.selectedProductId();\n  const mediaRevisions = Revisions.find({\n    \"parentDocument\": productId,\n    \"documentType\": \"image\",\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }).fetch();\n  return mediaRevisions;\n}\n\n// resort the media in\nfunction sortMedia(media) {\n  const sortedMedia = _.sortBy(media, function (m) { return m.metadata.priority;});\n  return sortedMedia;\n}\n\n// Search through revisions and if we find one for the image, stick it on the object\nfunction appendRevisionsToMedia(props, media) {\n  if (!Reaction.hasPermission(props.permission || [\"createProduct\"])) {\n    return media;\n  }\n  const mediaRevisions = fetchMediaRevisions();\n  const newMedia = [];\n  for (const image of media) {\n    image.revision = undefined;\n    for (const revision of mediaRevisions) {\n      if (revision.documentId === image._id) {\n        image.revision = revision;\n        image.metadata.priority = revision.documentData.priority;\n      }\n    }\n    newMedia.push(image);\n  }\n  return sortMedia(newMedia);\n}\n\nfunction composer(props, onData) {\n  let media;\n  let editable;\n  const viewAs = Reaction.getUserPreferences(\"reaction-dashboard\", \"viewAs\", \"administrator\");\n\n  if (!props.media) {\n    // Fetch media based on props\n  } else {\n    media = appendRevisionsToMedia(props, props.media);\n  }\n\n  if (viewAs === \"customer\") {\n    editable = false;\n  } else {\n    editable = Reaction.hasPermission(props.permission || [\"createProduct\"]);\n  }\n\n  onData(null, {\n    editable,\n    media\n  });\n}\n\nMediaGalleryContainer.propTypes = {\n  editable: PropTypes.bool,\n  id: PropTypes.string,\n  media: PropTypes.arrayOf(PropTypes.object),\n  placement: PropTypes.string\n};\n\nexport default composeWithTracker(composer)(MediaGalleryContainer);\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/core/ui/client/containers/mediaGalleryContainer.js.map","sourceFileName":"/imports/plugins/core/ui/client/containers/mediaGalleryContainer.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"mediaGalleryContainer"},"ignored":false,"code":"var _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar React = void 0,\n    Component = void 0,\n    PropTypes = void 0;\nmodule.importSync(\"react\", {\n  \"default\": function (v) {\n    React = v;\n  },\n  Component: function (v) {\n    Component = v;\n  },\n  PropTypes: function (v) {\n    PropTypes = v;\n  }\n}, 0);\nvar Measure = void 0;\nmodule.importSync(\"react-measure\", {\n  \"default\": function (v) {\n    Measure = v;\n  }\n}, 1);\nvar update = void 0;\nmodule.importSync(\"react/lib/update\", {\n  \"default\": function (v) {\n    update = v;\n  }\n}, 2);\nvar composeWithTracker = void 0;\nmodule.importSync(\"/lib/api/compose\", {\n  composeWithTracker: function (v) {\n    composeWithTracker = v;\n  }\n}, 3);\nvar MediaGallery = void 0;\nmodule.importSync(\"../components\", {\n  MediaGallery: function (v) {\n    MediaGallery = v;\n  }\n}, 4);\nvar Reaction = void 0;\nmodule.importSync(\"/client/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 5);\nvar ReactionProduct = void 0;\nmodule.importSync(\"/lib/api\", {\n  ReactionProduct: function (v) {\n    ReactionProduct = v;\n  }\n}, 6);\nvar Media = void 0,\n    Revisions = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Media: function (v) {\n    Media = v;\n  },\n  Revisions: function (v) {\n    Revisions = v;\n  }\n}, 7);\n\nfunction uploadHandler(files) {\n  // TODO: It would be cool to move this logic to common ValidatedMethod, but\n  // I can't find a way to do this, because of browser's `FileList` collection\n  // and it `Blob`s which is our event.target.files.\n  // There is a way to do this: http://stackoverflow.com/a/24003932. but it's too\n  // tricky\n  var productId = ReactionProduct.selectedProductId();\n  var variant = ReactionProduct.selectedVariant();\n\n  if ((typeof variant === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(variant)) !== \"object\") {\n    return Alerts.add(\"Please, create new Variant first.\", \"danger\", {\n      autoHide: true\n    });\n  }\n\n  var variantId = variant._id;\n  var shopId = ReactionProduct.selectedProduct().shopId || Reaction.getShopId();\n  var userId = Meteor.userId();\n  var count = Media.find({\n    \"metadata.variantId\": variantId\n  }).count(); // TODO: we need to mark the first variant images somehow for productGrid.\n  // But how do we know that this is the first, not second or other variant?\n  // Question is open. For now if product has more than 1 top variant, everyone\n  // will have a chance to be displayed\n\n  var toGrid = variant.ancestors.length === 1;\n\n  for (var _iterator = files, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var file = _ref;\n    var fileObj = new FS.File(file);\n    fileObj.metadata = {\n      ownerId: userId,\n      productId: productId,\n      variantId: variantId,\n      shopId: shopId,\n      priority: count,\n      toGrid: +toGrid // we need number\n\n    };\n    Media.insert(fileObj);\n    count++;\n  }\n\n  return true;\n}\n\nvar MediaGalleryContainer = function (_Component) {\n  (0, _inherits3.default)(MediaGalleryContainer, _Component);\n\n  // Load first image as featuredImage\n  function MediaGalleryContainer(props) {\n    (0, _classCallCheck3.default)(this, MediaGalleryContainer);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, _Component.call(this, props));\n\n    _this.handleDrop = function (files) {\n      uploadHandler(files);\n    };\n\n    _this.handleRemoveMedia = function (media) {\n      var imageUrl = media.url();\n      var mediaId = media._id;\n      Alerts.alert({\n        title: \"Remove Media?\",\n        type: \"warning\",\n        showCancelButton: true,\n        imageUrl: imageUrl,\n        imageHeight: 150\n      }, function (isConfirm) {\n        if (isConfirm) {\n          Media.remove({\n            _id: mediaId\n          }, function (error) {\n            if (error) {\n              Alerts.toast(error.reason, \"warning\", {\n                autoHide: 10000\n              });\n            } // updateImagePriorities();\n\n          });\n        } // show media as removed (since it will not disappear until changes are published\n\n      });\n    };\n\n    _this.handleMouseEnterMedia = function (event, media) {\n      _this.setState({\n        featuredMedia: media\n      });\n    };\n\n    _this.handleMouseLeaveMedia = function () {\n      _this.setState({\n        featuredMedia: undefined\n      });\n    };\n\n    _this.handleMoveMedia = function (dragIndex, hoverIndex) {\n      var media = _this.props.media[dragIndex]; // Apply new sort order to variant list\n\n      var newMediaOrder = update(_this.props.media, {\n        $splice: [[dragIndex, 1], [hoverIndex, 0, media]]\n      }); // Set local state so the component does't have to wait for a round-trip\n      // to the server to get the updated list of variants\n\n      _this.setState({\n        media: newMediaOrder\n      }); // Save the updated positions\n\n\n      Meteor.defer(function () {\n        newMediaOrder.forEach(function (mediaItem, index) {\n          Media.update(mediaItem._id, {\n            $set: {\n              \"metadata.priority\": index\n            }\n          });\n        });\n      });\n    };\n\n    _this.state = {\n      featuredMedia: props.media[0],\n      dimensions: {\n        width: -1,\n        height: -1\n      }\n    };\n    return _this;\n  }\n\n  MediaGalleryContainer.prototype.componentWillReceiveProps = function () {\n    function componentWillReceiveProps(nextProps) {\n      this.setState({\n        featuredMedia: nextProps.media[0],\n        media: nextProps.media\n      });\n    }\n\n    return componentWillReceiveProps;\n  }();\n\n  MediaGalleryContainer.prototype.render = function () {\n    function render() {\n      var _this2 = this;\n\n      var _state$dimensions = this.state.dimensions,\n          width = _state$dimensions.width,\n          height = _state$dimensions.height;\n      return React.createElement(\n        Measure,\n        {\n          onMeasure: function (dimensions) {\n            _this2.setState({\n              dimensions: dimensions\n            });\n          }\n        },\n        React.createElement(MediaGallery, (0, _extends3.default)({\n          allowFeaturedMediaHover: this.allowFeaturedMediaHover,\n          featuredMedia: this.state.featuredMedia,\n          onDrop: this.handleDrop,\n          onMouseEnterMedia: this.handleMouseEnterMedia,\n          onMouseLeaveMedia: this.handleMouseLeaveMedia,\n          onMoveMedia: this.handleMoveMedia,\n          onRemoveMedia: this.handleRemoveMedia\n        }, this.props, {\n          media: this.media,\n          mediaGalleryHeight: height,\n          mediaGalleryWidth: width\n        }))\n      );\n    }\n\n    return render;\n  }();\n\n  (0, _createClass3.default)(MediaGalleryContainer, [{\n    key: \"allowFeaturedMediaHover\",\n    get: function () {\n      if (this.state.featuredMedia) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"media\",\n    get: function () {\n      return this.state && this.state.media || this.props.media;\n    }\n  }]);\n  return MediaGalleryContainer;\n}(Component);\n\nfunction fetchMediaRevisions() {\n  var productId = ReactionProduct.selectedProductId();\n  var mediaRevisions = Revisions.find({\n    \"parentDocument\": productId,\n    \"documentType\": \"image\",\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }).fetch();\n  return mediaRevisions;\n} // resort the media in\n\n\nfunction sortMedia(media) {\n  var sortedMedia = _.sortBy(media, function (m) {\n    return m.metadata.priority;\n  });\n\n  return sortedMedia;\n} // Search through revisions and if we find one for the image, stick it on the object\n\n\nfunction appendRevisionsToMedia(props, media) {\n  if (!Reaction.hasPermission(props.permission || [\"createProduct\"])) {\n    return media;\n  }\n\n  var mediaRevisions = fetchMediaRevisions();\n  var newMedia = [];\n\n  for (var _iterator2 = media, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref2 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref2 = _i2.value;\n    }\n\n    var image = _ref2;\n    image.revision = undefined;\n\n    for (var _iterator3 = mediaRevisions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var revision = _ref3;\n\n      if (revision.documentId === image._id) {\n        image.revision = revision;\n        image.metadata.priority = revision.documentData.priority;\n      }\n    }\n\n    newMedia.push(image);\n  }\n\n  return sortMedia(newMedia);\n}\n\nfunction composer(props, onData) {\n  var media = void 0;\n  var editable = void 0;\n  var viewAs = Reaction.getUserPreferences(\"reaction-dashboard\", \"viewAs\", \"administrator\");\n\n  if (!props.media) {// Fetch media based on props\n  } else {\n    media = appendRevisionsToMedia(props, props.media);\n  }\n\n  if (viewAs === \"customer\") {\n    editable = false;\n  } else {\n    editable = Reaction.hasPermission(props.permission || [\"createProduct\"]);\n  }\n\n  onData(null, {\n    editable: editable,\n    media: media\n  });\n}\n\nMediaGalleryContainer.propTypes = {\n  editable: PropTypes.bool,\n  id: PropTypes.string,\n  media: PropTypes.arrayOf(PropTypes.object),\n  placement: PropTypes.string\n};\nmodule.export(\"default\", exports.default = composeWithTracker(composer)(MediaGalleryContainer));","map":{"version":3,"sources":["/imports/plugins/core/ui/client/containers/mediaGalleryContainer.js"],"names":["React","Component","PropTypes","Measure","update","composeWithTracker","MediaGallery","Reaction","ReactionProduct","Media","Revisions","uploadHandler","files","productId","selectedProductId","variant","selectedVariant","Alerts","add","autoHide","variantId","_id","shopId","selectedProduct","getShopId","userId","Meteor","count","find","toGrid","ancestors","length","file","fileObj","FS","File","metadata","ownerId","priority","insert","MediaGalleryContainer","constructor","props","state","featuredMedia","media","dimensions","width","height","componentWillReceiveProps","nextProps","setState","handleDrop","handleRemoveMedia","imageUrl","url","mediaId","alert","title","type","showCancelButton","imageHeight","isConfirm","remove","error","toast","reason","allowFeaturedMediaHover","handleMouseEnterMedia","event","handleMouseLeaveMedia","undefined","handleMoveMedia","dragIndex","hoverIndex","newMediaOrder","$splice","defer","forEach","mediaItem","index","$set","render","fetchMediaRevisions","mediaRevisions","$nin","fetch","sortMedia","sortedMedia","_","sortBy","m","appendRevisionsToMedia","hasPermission","permission","newMedia","image","revision","documentId","documentData","push","composer","onData","editable","viewAs","getUserPreferences","propTypes","bool","id","string","arrayOf","object","placement"],"mappings":"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","file":"/imports/plugins/core/ui/client/containers/mediaGalleryContainer.js.map","sourcesContent":["import React, { Component, PropTypes } from \"react\";\nimport Measure from \"react-measure\";\nimport update from \"react/lib/update\";\nimport { composeWithTracker } from \"/lib/api/compose\";\nimport { MediaGallery } from \"../components\";\nimport { Reaction } from \"/client/api\";\nimport { ReactionProduct } from \"/lib/api\";\nimport { Media, Revisions } from \"/lib/collections\";\n\nfunction uploadHandler(files) {\n  // TODO: It would be cool to move this logic to common ValidatedMethod, but\n  // I can't find a way to do this, because of browser's `FileList` collection\n  // and it `Blob`s which is our event.target.files.\n  // There is a way to do this: http://stackoverflow.com/a/24003932. but it's too\n  // tricky\n  const productId = ReactionProduct.selectedProductId();\n  const variant = ReactionProduct.selectedVariant();\n  if (typeof variant !== \"object\") {\n    return Alerts.add(\"Please, create new Variant first.\", \"danger\", {\n      autoHide: true\n    });\n  }\n  const variantId = variant._id;\n  const shopId = ReactionProduct.selectedProduct().shopId || Reaction.getShopId();\n  const userId = Meteor.userId();\n  let count = Media.find({\n    \"metadata.variantId\": variantId\n  }).count();\n  // TODO: we need to mark the first variant images somehow for productGrid.\n  // But how do we know that this is the first, not second or other variant?\n  // Question is open. For now if product has more than 1 top variant, everyone\n  // will have a chance to be displayed\n  const toGrid = variant.ancestors.length === 1;\n\n  for (const file of files) {\n    const fileObj = new FS.File(file);\n\n    fileObj.metadata = {\n      ownerId: userId,\n      productId: productId,\n      variantId: variantId,\n      shopId: shopId,\n      priority: count,\n      toGrid: +toGrid // we need number\n    };\n\n    Media.insert(fileObj);\n    count++;\n  }\n\n  return true;\n}\n\nclass MediaGalleryContainer extends Component {\n  // Load first image as featuredImage\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      featuredMedia: props.media[0],\n      dimensions: {\n        width: -1,\n        height: -1\n      }\n    };\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setState({\n      featuredMedia: nextProps.media[0],\n      media: nextProps.media\n    });\n  }\n\n  handleDrop = (files) => {\n    uploadHandler(files);\n  }\n\n  handleRemoveMedia = (media) => {\n    const imageUrl = media.url();\n    const mediaId = media._id;\n\n    Alerts.alert({\n      title: \"Remove Media?\",\n      type: \"warning\",\n      showCancelButton: true,\n      imageUrl,\n      imageHeight: 150\n    }, (isConfirm) => {\n      if (isConfirm) {\n        Media.remove({ _id: mediaId }, (error) => {\n          if (error) {\n            Alerts.toast(error.reason, \"warning\", {\n              autoHide: 10000\n            });\n          }\n\n          // updateImagePriorities();\n        });\n      }\n      // show media as removed (since it will not disappear until changes are published\n    });\n  }\n\n  get allowFeaturedMediaHover() {\n    if (this.state.featuredMedia) {\n      return true;\n    }\n    return false;\n  }\n\n  get media() {\n    return (this.state && this.state.media) || this.props.media;\n  }\n\n  handleMouseEnterMedia = (event, media) => {\n    this.setState({\n      featuredMedia: media\n    });\n  }\n\n  handleMouseLeaveMedia = () => {\n    this.setState({\n      featuredMedia: undefined\n    });\n  }\n\n  handleMoveMedia = (dragIndex, hoverIndex) => {\n    const media = this.props.media[dragIndex];\n\n    // Apply new sort order to variant list\n    const newMediaOrder = update(this.props.media, {\n      $splice: [\n        [dragIndex, 1],\n        [hoverIndex, 0, media]\n      ]\n    });\n\n    // Set local state so the component does't have to wait for a round-trip\n    // to the server to get the updated list of variants\n    this.setState({\n      media: newMediaOrder\n    });\n\n    // Save the updated positions\n    Meteor.defer(() => {\n      newMediaOrder.forEach((mediaItem, index) => {\n        Media.update(mediaItem._id, {\n          $set: {\n            \"metadata.priority\": index\n          }\n        });\n      });\n    });\n  }\n\n  render() {\n    const { width, height } = this.state.dimensions;\n\n    return (\n      <Measure\n        onMeasure={(dimensions) => {\n          this.setState({ dimensions });\n        }}\n      >\n        <MediaGallery\n          allowFeaturedMediaHover={this.allowFeaturedMediaHover}\n          featuredMedia={this.state.featuredMedia}\n          onDrop={this.handleDrop}\n          onMouseEnterMedia={this.handleMouseEnterMedia}\n          onMouseLeaveMedia={this.handleMouseLeaveMedia}\n          onMoveMedia={this.handleMoveMedia}\n          onRemoveMedia={this.handleRemoveMedia}\n          {...this.props}\n          media={this.media}\n          mediaGalleryHeight={height}\n          mediaGalleryWidth={width}\n        />\n      </Measure>\n    );\n  }\n}\n\nfunction fetchMediaRevisions() {\n  const productId = ReactionProduct.selectedProductId();\n  const mediaRevisions = Revisions.find({\n    \"parentDocument\": productId,\n    \"documentType\": \"image\",\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }).fetch();\n  return mediaRevisions;\n}\n\n// resort the media in\nfunction sortMedia(media) {\n  const sortedMedia = _.sortBy(media, function (m) { return m.metadata.priority;});\n  return sortedMedia;\n}\n\n// Search through revisions and if we find one for the image, stick it on the object\nfunction appendRevisionsToMedia(props, media) {\n  if (!Reaction.hasPermission(props.permission || [\"createProduct\"])) {\n    return media;\n  }\n  const mediaRevisions = fetchMediaRevisions();\n  const newMedia = [];\n  for (const image of media) {\n    image.revision = undefined;\n    for (const revision of mediaRevisions) {\n      if (revision.documentId === image._id) {\n        image.revision = revision;\n        image.metadata.priority = revision.documentData.priority;\n      }\n    }\n    newMedia.push(image);\n  }\n  return sortMedia(newMedia);\n}\n\nfunction composer(props, onData) {\n  let media;\n  let editable;\n  const viewAs = Reaction.getUserPreferences(\"reaction-dashboard\", \"viewAs\", \"administrator\");\n\n  if (!props.media) {\n    // Fetch media based on props\n  } else {\n    media = appendRevisionsToMedia(props, props.media);\n  }\n\n  if (viewAs === \"customer\") {\n    editable = false;\n  } else {\n    editable = Reaction.hasPermission(props.permission || [\"createProduct\"]);\n  }\n\n  onData(null, {\n    editable,\n    media\n  });\n}\n\nMediaGalleryContainer.propTypes = {\n  editable: PropTypes.bool,\n  id: PropTypes.string,\n  media: PropTypes.arrayOf(PropTypes.object),\n  placement: PropTypes.string\n};\n\nexport default composeWithTracker(composer)(MediaGalleryContainer);\n"]},"hash":"39c39dfc351318ef9f0505b24e4be6f815382fc1"}
