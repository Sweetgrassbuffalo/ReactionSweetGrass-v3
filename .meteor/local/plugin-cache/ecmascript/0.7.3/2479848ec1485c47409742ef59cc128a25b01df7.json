{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash/omit","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_omit"}]},{"source":"lodash/each","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_each"}]},{"source":"lodash/find","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_find"}]},{"source":"lodash/includes","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_includes"}]},{"source":"lodash/every","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_every"}]},{"source":"path","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"path"}]},{"source":"moment","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"moment"}]},{"source":"accounting-js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"accounting"}]},{"source":"fibers/future","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Future"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]},{"source":"/lib/api","imported":["getSlug"],"specifiers":[{"kind":"named","imported":"getSlug","local":"getSlug"}]},{"source":"/lib/collections","imported":["Media","Orders","Products","Shops","Packages"],"specifiers":[{"kind":"named","imported":"Media","local":"Media"},{"kind":"named","imported":"Orders","local":"Orders"},{"kind":"named","imported":"Products","local":"Products"},{"kind":"named","imported":"Shops","local":"Shops"},{"kind":"named","imported":"Packages","local":"Packages"}]},{"source":"/lib/collections/schemas","imported":["*"],"specifiers":[{"kind":"namespace","local":"Schemas"}]},{"source":"/server/api","imported":["Logger","Hooks","Reaction"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Hooks","local":"Hooks"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":["orderCreditMethod","order","orderDebitMethod","order","ordersInventoryAdjust","orderId","methods"],"specifiers":[{"kind":"local","local":"orderCreditMethod","exported":"orderCreditMethod"},{"kind":"local","local":"order","exported":"order"},{"kind":"local","local":"orderDebitMethod","exported":"orderDebitMethod"},{"kind":"local","local":"order","exported":"order"},{"kind":"local","local":"ordersInventoryAdjust","exported":"ordersInventoryAdjust"},{"kind":"local","local":"orderId","exported":"orderId"},{"kind":"local","local":"methods","exported":"methods"}]}}},"options":{"filename":"/server/methods/core/orders.js","filenameRelative":"/server/methods/core/orders.js","inputSourceMap":{"version":3,"sources":["/server/methods/core/orders.js"],"names":["path","moment","accounting","Future","Meteor","check","getSlug","Media","Orders","Products","Shops","Packages","Schemas","Logger","Hooks","Reaction","orderCreditMethod","order","billing","filter","value","paymentMethod","method","orderDebitMethod","ordersInventoryAdjust","orderId","String","hasPermission","Error","findOne","items","forEach","item","update","_id","variants","$inc","inventoryQuantity","quantity","publish","selector","type","methods","shipment","packed","Object","Boolean","$set","itemIds","map","result","call","unblock","invoice","subTotal","subtotal","shipping","taxes","discount","discounts","discountTotal","Math","max","total","toFixed","Number","returnToStock","assign","amount","invoiceTotal","prefix","getShopPrefix","url","sms","userId","err","error","$push","processPayment","completedItemsResult","completedOrderResult","Events","run","workflowResult","email","warn","completedItems","completedOrder","isCompleted","workflow","action","Match","OneOf","undefined","shop","shopId","emailLogo","Array","isArray","brandAssets","brandAsset","asset","mediaId","join","absoluteUrl","refundResult","refundTotal","parseFloat","userCurrencyFormatting","currencies","currency","userCurrency","userCurrencyExchangeRate","exchangeRate","combinedItems","orderItem","foundItem","find","combinedItem","displayPrice","formatMoney","price","push","placeholderImage","variantImage","productId","productImage","dataForEmail","contactEmail","emails","address","homepage","copyrightDate","format","legalName","addressBook","company","physicalAddress","address1","address2","city","region","postal","shopName","name","socialLinks","display","facebook","icon","link","googlePlus","twitter","storedCard","processor","refunds","adjustedTotal","orderDate","createdAt","orderUrl","cartId","tracking","carrier","shipmentMethod","debug","status","msg","subject","tpl","SSR","compileTemplate","Email","getTemplate","getSubject","send","to","from","render","html","event","Optional","$addToSet","history","updatedAt","Date","transactionId","mode","toLowerCase","saved","metadata","fatal","future","return","Refund","wait","PaymentMethod","packageId","paymentPackageId","settingsKey","paymentSettingsKey","checkSupportedMethods","getShopId","settings","support","orderStatus","orderMode","query"],"mappings":"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","file":"/server/methods/core/orders.js.map","sourcesContent":["import _ from \"lodash\";\nimport path from \"path\";\nimport moment from \"moment\";\nimport accounting from \"accounting-js\";\nimport Future from \"fibers/future\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { getSlug } from \"/lib/api\";\nimport { Media, Orders, Products, Shops, Packages } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Hooks, Reaction } from \"/server/api\";\n\n\n// helper to return the order credit object\n// the first credit paymentMethod on the order\n// returns entire payment method\nexport function orderCreditMethod(order) {\n  return order.billing.filter(value => value.paymentMethod.method ===  \"credit\")[0];\n}\n// helper to return the order debit object\nexport function orderDebitMethod(order) {\n  return order.billing.filter(value => value.paymentMethod.method ===  \"debit\")[0];\n}\n\n/**\n * ordersInventoryAdjust\n * adjust inventory when an order is placed\n * @param {String} orderId - add tracking to orderId\n * @return {null} no return value\n */\nexport function ordersInventoryAdjust(orderId) {\n  check(orderId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  }\n\n  const order = Orders.findOne(orderId);\n  order.items.forEach(item => {\n    Products.update({\n      _id: item.variants._id\n    }, {\n      $inc: {\n        inventoryQuantity: -item.quantity\n      }\n    }, {\n      publish: true,\n      selector: {\n        type: \"variant\"\n      }\n    });\n  });\n}\n\n\n/**\n * Reaction Order Methods\n */\nexport const methods = {\n  /**\n   * orders/shipmentPacked\n   *\n   * @summary update packing status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @param {Boolean} packed - packed status\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentPacked\": function (order, shipment, packed) {\n    check(order, Object);\n    check(shipment, Object);\n    check(packed, Boolean);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    if (order) {\n      Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.packed\": packed\n        }\n      });\n\n      // Set the status of the items as packed\n      const itemIds = shipment.items.map((item) => {\n        return item._id;\n      });\n\n      const result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/packed\", order, itemIds);\n      if (result === 1) {\n        return Orders.update({\n          \"_id\": order._id,\n          \"shipping._id\": shipment._id\n        }, {\n          $set: {\n            \"shipping.$.packed\": packed\n          }\n        });\n      }\n      return result;\n    }\n  },\n\n  /**\n   * orders/makeAdjustmentsToInvoice\n   *\n   * @summary Update the status of an invoice to allow adjustments to be made\n   * @param {Object} order - order object\n   * @return {Object} Mongo update\n   */\n  \"orders/makeAdjustmentsToInvoice\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"adjustments\"\n      }\n    });\n  },\n\n  /**\n   * orders/approvePayment\n   *\n   * @summary Approve payment and apply any adjustments\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/approvePayment\": function (order) {\n    check(order, Object);\n    const invoice = orderCreditMethod(order).invoice;\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    // this is server side check to verify\n    // that the math all still adds up.\n    const subTotal = invoice.subtotal;\n    const shipping = invoice.shipping;\n    const taxes = invoice.taxes;\n    const discount = invoice.discounts;\n    const discountTotal = Math.max(0, subTotal - discount); // ensure no discounting below 0.\n    const total = accounting.toFixed(discountTotal + shipping + taxes, 2);\n\n    // Updates flattened inventory count on variants in Products collection\n    ordersInventoryAdjust(order._id);\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.amount\": total,\n        \"billing.$.paymentMethod.status\": \"approved\",\n        \"billing.$.paymentMethod.mode\": \"capture\",\n        \"billing.$.invoice.discounts\": discount,\n        \"billing.$.invoice.total\": Number(total)\n      }\n    });\n  },\n\n  /**\n   * orders/cancelOrder\n   *\n   * @summary Start the cancel order process\n   * @param {Object} order - order object\n   * @param {Boolean} returnToStock - condition to return product to stock\n   * @return {Object} ret\n   */\n  \"orders/cancelOrder\": function (order, returnToStock) {\n    check(order, Object);\n    check(returnToStock, Boolean);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    if (!returnToStock) {\n      ordersInventoryAdjust(order._id);\n    }\n\n    let paymentMethod = orderCreditMethod(order).paymentMethod;\n    paymentMethod = Object.assign(paymentMethod, { amount: Number(paymentMethod.amount) });\n    const invoiceTotal = order.billing[0].invoice.total;\n    const shipment = order.shipping[0];\n    const itemIds = shipment.items.map((item) => {\n      return item._id;\n    });\n\n    // refund payment to customer\n    Meteor.call(\"orders/refunds/create\", order._id, paymentMethod, Number(invoiceTotal));\n\n    // send notification to user\n    const prefix = Reaction.getShopPrefix();\n    const url = `${prefix}/notifications`;\n    const sms = true;\n    Meteor.call(\"notification/send\", order.userId, \"orderCancelled\", url, sms, (err) => {\n      if (err) Logger.error(err);\n    });\n\n    // update item workflow\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/canceled\", order, itemIds);\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"workflow.status\": \"coreOrderWorkflow/canceled\",\n        \"billing.$.paymentMethod.mode\": \"cancel\"\n      },\n      $push: {\n        \"workflow.workflow\": \"coreOrderWorkflow/canceled\"\n      }\n    });\n  },\n\n  /**\n   * orders/processPayment\n   *\n   * @summary trigger processPayment and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/processPayment\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    return Meteor.call(\"orders/processPayments\", order._id, function (error, result) {\n      if (result) {\n        Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"coreProcessPayment\", order._id);\n\n        // Set the status of the items as shipped\n        const itemIds = order.shipping[0].items.map((item) => {\n          return item._id;\n        });\n\n        Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n\n        return this.processPayment(order);\n      }\n      return false;\n    });\n  },\n  /**\n   * orders/shipmentShipped\n   *\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return results of several operations\n   */\n  \"orders/shipmentShipped\": function (order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      Logger.error(\"User does not have 'orders' permissions\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    let completedItemsResult;\n    let completedOrderResult;\n\n    const itemIds = shipment.items.map((item) => {\n      return item._id;\n    });\n\n    // TODO: In the future, this could be handled by shipping delivery status\n    Hooks.Events.run(\"onOrderShipmentShipped\", order, itemIds);\n    const workflowResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/shipped\", order, itemIds);\n\n    if (workflowResult === 1) {\n      // Move to completed status for items\n      completedItemsResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n      if (completedItemsResult === 1) {\n        // Then try to mark order as completed.\n        completedOrderResult = Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      }\n    }\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, \"shipped\");\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.shipped\": true\n      }\n    });\n\n    return {\n      workflowResult: workflowResult,\n      completedItems: completedItemsResult,\n      completedOrder: completedOrderResult\n    };\n  },\n\n  /**\n   * orders/shipmentDelivered\n   *\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentDelivered\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    const shipment = order.shipping[0];\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, (err) => {\n        if (err) {\n          Logger.error(err, \"orders/shipmentDelivered: Failed to send notification\");\n        }\n      });\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    const itemIds = shipment.items.map((item) => {\n      return item._id;\n    });\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/delivered\", order, itemIds);\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n    const isCompleted = _.every(order.items, (item) => {\n      return _.includes(item.workflow.workflow, \"coreOrderItemWorkflow/completed\");\n    });\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.delivered\": true\n      }\n    });\n\n    if (isCompleted === true) {\n      Hooks.Events.run(\"onOrderShipmentDelivered\", order._id);\n      Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      return true;\n    }\n\n    Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n\n    return false;\n  },\n\n  /**\n   * orders/sendNotification\n   *\n   * @summary send order notification email\n   * @param {Object} order - order object\n   * @param {Object} action - send notification action\n   * @return {Boolean} email sent or not\n   */\n  \"orders/sendNotification\": function (order, action) {\n    check(order, Object);\n    check(action, Match.OneOf(String, undefined));\n\n    if (!this.userId) {\n      Logger.error(\"orders/sendNotification: Access denied\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    // Get Shop information\n    const shop = Shops.findOne(order.shopId);\n\n    // Get shop logo, if available\n    let emailLogo;\n    if (Array.isArray(shop.brandAssets)) {\n      const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n      const mediaId = Media.findOne(brandAsset.mediaId);\n      emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n    } else {\n      emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n    }\n\n    const billing = orderCreditMethod(order);\n    const refundResult = Meteor.call(\"orders/refunds/list\", order);\n    let refundTotal = 0;\n\n    _.each(refundResult, function (item) {\n      refundTotal += parseFloat(item.amount);\n    });\n\n    // Get user currency formatting from shops collection, remove saved rate\n    const userCurrencyFormatting = _.omit(shop.currencies[billing.currency.userCurrency], [\"enabled\", \"rate\"]);\n\n    // Get user currency exchange rate at time of transaction\n    const userCurrencyExchangeRate = billing.currency.exchangeRate;\n\n    // Combine same products into single \"product\" for display purposes\n    const combinedItems = [];\n    if (order) {\n      // Loop through all items in the order. The items are split into indivital items\n      for (const orderItem of order.items) {\n        // Find an exising item in the combinedItems array\n        const foundItem = combinedItems.find((combinedItem) => {\n          // If and item variant exists, then we return true\n          if (combinedItem.variants) {\n            return combinedItem.variants._id === orderItem.variants._id;\n          }\n\n          return false;\n        });\n\n        // Increment the quantity count for the duplicate product variants\n        if (foundItem) {\n          foundItem.quantity++;\n        } else {\n          // Otherwise push the unique item into the combinedItems array\n\n          // Add displayPrice to match user currency settings\n          orderItem.variants.displayPrice = accounting.formatMoney(\n            orderItem.variants.price * userCurrencyExchangeRate, userCurrencyFormatting\n          );\n\n          combinedItems.push(orderItem);\n\n          // Placeholder image if there is no product image\n          orderItem.placeholderImage = Meteor.absoluteUrl() + \"resources/placeholder.gif\";\n\n          const variantImage = Media.findOne({\n            \"metadata.productId\": orderItem.productId,\n            \"metadata.variantId\": orderItem.variants._id\n          });\n          // variant image\n          if (variantImage) {\n            orderItem.variantImage = path.join(Meteor.absoluteUrl(), variantImage.url());\n          }\n          // find a default image\n          const productImage = Media.findOne({ \"metadata.productId\": orderItem.productId });\n          if (productImage) {\n            orderItem.productImage = path.join(Meteor.absoluteUrl(), productImage.url());\n          }\n        }\n      }\n\n      // Merge data into single object to pass to email template\n      const dataForEmail = {\n        // Shop Data\n        shop: shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo: emailLogo,\n        copyrightDate: moment().format(\"YYYY\"),\n        legalName: shop.addressBook[0].company,\n        physicalAddress: {\n          address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n          city: shop.addressBook[0].city,\n          region: shop.addressBook[0].region,\n          postal: shop.addressBook[0].postal\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Order Data\n        order: order,\n        billing: {\n          address: {\n            address: billing.address.address1,\n            city: billing.address.city,\n            region: billing.address.region,\n            postal: billing.address.postal\n          },\n          paymentMethod: billing.paymentMethod.storedCard || billing.paymentMethod.processor,\n          subtotal: accounting.formatMoney(\n            billing.invoice.subtotal * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          shipping: accounting.formatMoney(\n            billing.invoice.shipping * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          taxes: accounting.formatMoney(\n            billing.invoice.taxes * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          discounts: accounting.formatMoney(\n            billing.invoice.discounts * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          refunds: accounting.formatMoney(\n            refundTotal * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          total: accounting.formatMoney(\n            billing.invoice.total * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          adjustedTotal: accounting.formatMoney(\n            (billing.paymentMethod.amount - refundTotal) * userCurrencyExchangeRate, userCurrencyFormatting\n          )\n        },\n        combinedItems: combinedItems,\n        orderDate: moment(order.createdAt).format(\"MM/DD/YYYY\"),\n        orderUrl: getSlug(shop.name) + \"/cart/completed?_id=\" + order.cartId,\n        shipping: {\n          tracking: order.shipping[0].tracking,\n          carrier: order.shipping[0].shipmentMethod.carrier,\n          address: {\n            address: order.shipping[0].address.address1,\n            city: order.shipping[0].address.city,\n            region: order.shipping[0].address.region,\n            postal: order.shipping[0].address.postal\n          }\n        }\n      };\n\n      Logger.debug(`orders/sendNotification status: ${order.workflow.status}`);\n\n\n      // handle missing root shop email\n      if (!shop.emails[0].address) {\n        shop.emails[0].address = \"no-reply@reactioncommerce.com\";\n        Logger.warn(\"No shop email configured. Using no-reply to send mail\");\n      }\n\n      // anonymous users without emails.\n      if (!order.email) {\n        const msg = \"No order email found. No notification sent.\";\n        Logger.warn(msg);\n        throw new Meteor.Error(\"email-error\", msg);\n      }\n\n      // Compile Email with SSR\n      let subject;\n      let tpl;\n\n      if (action === \"shipped\") {\n        tpl = \"orders/shipped\";\n        subject = \"orders/shipped/subject\";\n      } else if (action === \"refunded\") {\n        tpl = \"orders/refunded\";\n        subject = \"orders/refunded/subject\";\n      } else {\n        tpl = `orders/${order.workflow.status}`;\n        subject = `orders/${order.workflow.status}/subject`;\n      }\n\n      SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n      SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n      Reaction.Email.send({\n        to: order.email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * orders/updateShipmentTracking\n   * @summary Adds tracking information to order without workflow update.\n   * Call after any tracking code is generated\n   * @param {Object} order - An Order object\n   * @param {Object} shipment - A Shipment object\n   * @param {String} tracking - tracking id\n   * @return {String} returns order update result\n   */\n  \"orders/updateShipmentTracking\": function (order, shipment, tracking) {\n    check(order, Object);\n    check(shipment, Object);\n    check(tracking, String);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        [\"shipping.$.tracking\"]: tracking\n      }\n    });\n  },\n\n  /**\n   * orders/addOrderEmail\n   * @summary Adds email to order, used for guest users\n   * @param {String} cartId - add tracking to orderId\n   * @param {String} email - valid email address\n   * @return {String} returns order update result\n   */\n  \"orders/addOrderEmail\": function (cartId, email) {\n    check(cartId, String);\n    check(email, String);\n    /**\n    *Instead of checking the Orders permission, we should check if user is\n    *connected.This is only needed for guest where email is\n    *provided for tracking order progress.\n    */\n\n    if (!Meteor.userId()) {\n      throw new Meteor.Error(403, \"Access Denied. You are not connected.\");\n    }\n\n    return Orders.update({\n      cartId: cartId\n    }, {\n      $set: {\n        email: email\n      }\n    });\n  },\n\n  /**\n   * orders/updateHistory\n   * @summary adds order history item for tracking and logging order updates\n   * @param {String} orderId - add tracking to orderId\n   * @param {String} event - workflow event\n   * @param {String} value - event value\n   * @return {String} returns order update result\n   */\n  \"orders/updateHistory\": function (orderId, event, value) {\n    check(orderId, String);\n    check(event, String);\n    check(value, Match.Optional(String));\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Orders.update(orderId, {\n      $addToSet: {\n        history: {\n          event: event,\n          value: value,\n          userId: Meteor.userId(),\n          updatedAt: new Date()\n        }\n      }\n    });\n  },\n\n\n  /**\n   * orders/capturePayments\n   * @summary Finalize any payment where mode is \"authorize\"\n   * and status is \"approved\", reprocess as \"capture\"\n   * @todo: add tests working with new payment methods\n   * @todo: refactor to use non Meteor.namespace\n   * @param {String} orderId - add tracking to orderId\n   * @return {null} no return value\n   */\n  \"orders/capturePayments\": (orderId) => {\n    check(orderId, String);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const order = Orders.findOne(orderId);\n    const itemIds = order.shipping[0].items.map((item) => {\n      return item._id;\n    });\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n\n    // process order..payment.paymentMethod\n    _.each(order.billing, function (billing) {\n      const paymentMethod = billing.paymentMethod;\n      const transactionId = paymentMethod.transactionId;\n\n      if (paymentMethod.mode === \"capture\" && paymentMethod.status === \"approved\" && paymentMethod.processor) {\n        // Grab the amount from the shipment, otherwise use the original amount\n        const processor = paymentMethod.processor.toLowerCase();\n\n        Meteor.call(`${processor}/payment/capture`, paymentMethod, (error, result) => {\n          if (result && result.saved === true) {\n            const metadata = Object.assign(billing.paymentMethod.metadata || {}, result.metadata || {});\n\n            Orders.update({\n              \"_id\": orderId,\n              \"billing.paymentMethod.transactionId\": transactionId\n            }, {\n              $set: {\n                \"billing.$.paymentMethod.mode\": \"capture\",\n                \"billing.$.paymentMethod.status\": \"completed\",\n                \"billing.$.paymentMethod.metadata\": metadata\n              },\n              $push: {\n                \"billing.$.paymentMethod.transactions\": result\n              }\n            });\n\n            // event onOrderPaymentCaptured used for confirmation hooks\n            // ie: confirmShippingMethodForOrder is triggered here\n            Hooks.Events.run(\"onOrderPaymentCaptured\", orderId);\n          } else {\n            if (result && result.error) {\n              Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, result.error);\n            } else {\n              Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, error);\n            }\n\n            Orders.update({\n              \"_id\": orderId,\n              \"billing.paymentMethod.transactionId\": transactionId\n            }, {\n              $set: {\n                \"billing.$.paymentMethod.mode\": \"capture\",\n                \"billing.$.paymentMethod.status\": \"error\"\n              },\n              $push: {\n                \"billing.$.paymentMethod.transactions\": result\n              }\n            });\n\n            return { error: \"orders/capturePayments: Failed to capture transaction\" };\n          }\n          return { error, result };\n        });\n      }\n    });\n  },\n\n  /**\n   * orders/refund/list\n   * loop through order's payments and find existing refunds.\n   * @summary Get a list of refunds for a particular payment method.\n   * @param {Object} order - order object\n   * @return {null} no return value\n   */\n  \"orders/refunds/list\": function (order) {\n    check(order, Object);\n    const paymentMethod = orderCreditMethod(order).paymentMethod;\n\n    if (!this.userId === order.userId && !Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    const future = new Future();\n    const processor = paymentMethod.processor.toLowerCase();\n\n    Meteor.call(`${processor}/refund/list`, paymentMethod, (error, result) => {\n      if (error) {\n        future.return(error);\n      } else {\n        check(result, [Schemas.Refund]);\n        future.return(result);\n      }\n    });\n\n    return future.wait();\n  },\n\n  /**\n   * orders/refund/create\n   *\n   * @summary Apply a refund to an already captured order\n   * @param {String} orderId - order object\n   * @param {Object} paymentMethod - paymentMethod object\n   * @param {Number} amount - Amount of the refund, as a positive number\n   * @return {null} no return value\n   */\n  \"orders/refunds/create\": function (orderId, paymentMethod, amount) {\n    check(orderId, String);\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const processor = paymentMethod.processor.toLowerCase();\n    const order = Orders.findOne(orderId);\n    const transactionId = paymentMethod.transactionId;\n\n    const packageId = paymentMethod.paymentPackageId;\n    const settingsKey = paymentMethod.paymentSettingsKey;\n    // check if payment provider supports de-authorize\n    const checkSupportedMethods = Packages.findOne({\n      _id: packageId,\n      shopId: Reaction.getShopId()\n    }).settings[settingsKey].support;\n\n    const orderStatus = paymentMethod.status;\n    const orderMode = paymentMethod.mode;\n\n    let result;\n    let query = {};\n    if (_.includes(checkSupportedMethods, \"De-authorize\")) {\n      result = Meteor.call(`${processor}/payment/deAuthorize`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n      // Send email to notify cuustomer of a refund\n      Meteor.call(\"orders/sendNotification\", order);\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for de-authorize transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to de-authorize transaction failed\", result.error);\n      }\n    } else if (orderStatus === \"completed\" && orderMode === \"capture\") {\n      result = Meteor.call(`${processor}/refund/create`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n      // Send email to notify cuustomer of a refund\n      Meteor.call(\"orders/sendNotification\", order, \"refunded\");\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for refund transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to refund transaction failed\", result.error);\n      }\n    }\n\n    Orders.update({\n      \"_id\": orderId,\n      \"billing.paymentMethod.transactionId\": transactionId\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"refunded\"\n      },\n      query\n    });\n\n    Hooks.Events.run(\"onOrderRefundCreated\", orderId);\n  }\n};\n\nMeteor.methods(methods);\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/methods/core/orders.js.map","sourceFileName":"/server/methods/core/orders.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"orders"},"ignored":false,"code":"module.export({\n  orderCreditMethod: function () {\n    return orderCreditMethod;\n  },\n  orderDebitMethod: function () {\n    return orderDebitMethod;\n  },\n  ordersInventoryAdjust: function () {\n    return ordersInventoryAdjust;\n  },\n  methods: function () {\n    return methods;\n  }\n});\n\nvar _omit = void 0;\n\nmodule.importSync(\"lodash/omit\", {\n  \"default\": function (v) {\n    _omit = v;\n  }\n}, 0);\n\nvar _each = void 0;\n\nmodule.importSync(\"lodash/each\", {\n  \"default\": function (v) {\n    _each = v;\n  }\n}, 1);\n\nvar _find = void 0;\n\nmodule.importSync(\"lodash/find\", {\n  \"default\": function (v) {\n    _find = v;\n  }\n}, 2);\n\nvar _includes = void 0;\n\nmodule.importSync(\"lodash/includes\", {\n  \"default\": function (v) {\n    _includes = v;\n  }\n}, 3);\n\nvar _every = void 0;\n\nmodule.importSync(\"lodash/every\", {\n  \"default\": function (v) {\n    _every = v;\n  }\n}, 4);\nvar path = void 0;\nmodule.importSync(\"path\", {\n  \"default\": function (v) {\n    path = v;\n  }\n}, 5);\nvar moment = void 0;\nmodule.importSync(\"moment\", {\n  \"default\": function (v) {\n    moment = v;\n  }\n}, 6);\nvar accounting = void 0;\nmodule.importSync(\"accounting-js\", {\n  \"default\": function (v) {\n    accounting = v;\n  }\n}, 7);\nvar Future = void 0;\nmodule.importSync(\"fibers/future\", {\n  \"default\": function (v) {\n    Future = v;\n  }\n}, 8);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 9);\nvar check = void 0;\nmodule.importSync(\"meteor/check\", {\n  check: function (v) {\n    check = v;\n  }\n}, 10);\nvar getSlug = void 0;\nmodule.importSync(\"/lib/api\", {\n  getSlug: function (v) {\n    getSlug = v;\n  }\n}, 11);\nvar Media = void 0,\n    Orders = void 0,\n    Products = void 0,\n    Shops = void 0,\n    Packages = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Media: function (v) {\n    Media = v;\n  },\n  Orders: function (v) {\n    Orders = v;\n  },\n  Products: function (v) {\n    Products = v;\n  },\n  Shops: function (v) {\n    Shops = v;\n  },\n  Packages: function (v) {\n    Packages = v;\n  }\n}, 12);\nvar Schemas = Object.create(null);\nmodule.importSync(\"/lib/collections/schemas\", {\n  \"*\": function (v, n) {\n    Schemas[n] = v;\n  }\n}, 13);\nvar Logger = void 0,\n    Hooks = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  },\n  Hooks: function (v) {\n    Hooks = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 14);\n\nfunction orderCreditMethod(order) {\n  return order.billing.filter(function (value) {\n    return value.paymentMethod.method === \"credit\";\n  })[0];\n}\n\nfunction orderDebitMethod(order) {\n  return order.billing.filter(function (value) {\n    return value.paymentMethod.method === \"debit\";\n  })[0];\n}\n\nfunction ordersInventoryAdjust(orderId) {\n  check(orderId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  }\n\n  var order = Orders.findOne(orderId);\n  order.items.forEach(function (item) {\n    Products.update({\n      _id: item.variants._id\n    }, {\n      $inc: {\n        inventoryQuantity: -item.quantity\n      }\n    }, {\n      publish: true,\n      selector: {\n        type: \"variant\"\n      }\n    });\n  });\n}\n\nvar methods = {\n  /**\n   * orders/shipmentPacked\n   *\n   * @summary update packing status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @param {Boolean} packed - packed status\n   * @return {Object} return workflow result\n   */\"orders/shipmentPacked\": function (order, shipment, packed) {\n    check(order, Object);\n    check(shipment, Object);\n    check(packed, Boolean);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    if (order) {\n      Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.packed\": packed\n        }\n      }); // Set the status of the items as packed\n\n      var itemIds = shipment.items.map(function (item) {\n        return item._id;\n      });\n      var result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/packed\", order, itemIds);\n\n      if (result === 1) {\n        return Orders.update({\n          \"_id\": order._id,\n          \"shipping._id\": shipment._id\n        }, {\n          $set: {\n            \"shipping.$.packed\": packed\n          }\n        });\n      }\n\n      return result;\n    }\n  },\n  /**\n   * orders/makeAdjustmentsToInvoice\n   *\n   * @summary Update the status of an invoice to allow adjustments to be made\n   * @param {Object} order - order object\n   * @return {Object} Mongo update\n   */\"orders/makeAdjustmentsToInvoice\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"adjustments\"\n      }\n    });\n  },\n  /**\n   * orders/approvePayment\n   *\n   * @summary Approve payment and apply any adjustments\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\"orders/approvePayment\": function (order) {\n    check(order, Object);\n    var invoice = orderCreditMethod(order).invoice;\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock(); // this is server side check to verify\n    // that the math all still adds up.\n\n    var subTotal = invoice.subtotal;\n    var shipping = invoice.shipping;\n    var taxes = invoice.taxes;\n    var discount = invoice.discounts;\n    var discountTotal = Math.max(0, subTotal - discount); // ensure no discounting below 0.\n\n    var total = accounting.toFixed(discountTotal + shipping + taxes, 2); // Updates flattened inventory count on variants in Products collection\n\n    ordersInventoryAdjust(order._id);\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.amount\": total,\n        \"billing.$.paymentMethod.status\": \"approved\",\n        \"billing.$.paymentMethod.mode\": \"capture\",\n        \"billing.$.invoice.discounts\": discount,\n        \"billing.$.invoice.total\": Number(total)\n      }\n    });\n  },\n  /**\n   * orders/cancelOrder\n   *\n   * @summary Start the cancel order process\n   * @param {Object} order - order object\n   * @param {Boolean} returnToStock - condition to return product to stock\n   * @return {Object} ret\n   */\"orders/cancelOrder\": function (order, returnToStock) {\n    check(order, Object);\n    check(returnToStock, Boolean);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    if (!returnToStock) {\n      ordersInventoryAdjust(order._id);\n    }\n\n    var paymentMethod = orderCreditMethod(order).paymentMethod;\n    paymentMethod = Object.assign(paymentMethod, {\n      amount: Number(paymentMethod.amount)\n    });\n    var invoiceTotal = order.billing[0].invoice.total;\n    var shipment = order.shipping[0];\n    var itemIds = shipment.items.map(function (item) {\n      return item._id;\n    }); // refund payment to customer\n\n    Meteor.call(\"orders/refunds/create\", order._id, paymentMethod, Number(invoiceTotal)); // send notification to user\n\n    var prefix = Reaction.getShopPrefix();\n    var url = prefix + \"/notifications\";\n    var sms = true;\n    Meteor.call(\"notification/send\", order.userId, \"orderCancelled\", url, sms, function (err) {\n      if (err) Logger.error(err);\n    }); // update item workflow\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/canceled\", order, itemIds);\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"workflow.status\": \"coreOrderWorkflow/canceled\",\n        \"billing.$.paymentMethod.mode\": \"cancel\"\n      },\n      $push: {\n        \"workflow.workflow\": \"coreOrderWorkflow/canceled\"\n      }\n    });\n  },\n  /**\n   * orders/processPayment\n   *\n   * @summary trigger processPayment and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\"orders/processPayment\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n    return Meteor.call(\"orders/processPayments\", order._id, function (error, result) {\n      if (result) {\n        Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"coreProcessPayment\", order._id); // Set the status of the items as shipped\n\n        var itemIds = order.shipping[0].items.map(function (item) {\n          return item._id;\n        });\n        Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n        return this.processPayment(order);\n      }\n\n      return false;\n    });\n  },\n  /**\n   * orders/shipmentShipped\n   *\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return results of several operations\n   */\"orders/shipmentShipped\": function (order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      Logger.error(\"User does not have 'orders' permissions\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n    var completedItemsResult = void 0;\n    var completedOrderResult = void 0;\n    var itemIds = shipment.items.map(function (item) {\n      return item._id;\n    }); // TODO: In the future, this could be handled by shipping delivery status\n\n    Hooks.Events.run(\"onOrderShipmentShipped\", order, itemIds);\n    var workflowResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/shipped\", order, itemIds);\n\n    if (workflowResult === 1) {\n      // Move to completed status for items\n      completedItemsResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n      if (completedItemsResult === 1) {\n        // Then try to mark order as completed.\n        completedOrderResult = Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      }\n    }\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, \"shipped\");\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.shipped\": true\n      }\n    });\n    return {\n      workflowResult: workflowResult,\n      completedItems: completedItemsResult,\n      completedOrder: completedOrderResult\n    };\n  },\n  /**\n   * orders/shipmentDelivered\n   *\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return workflow result\n   */\"orders/shipmentDelivered\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n    var shipment = order.shipping[0];\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, function (err) {\n        if (err) {\n          Logger.error(err, \"orders/shipmentDelivered: Failed to send notification\");\n        }\n      });\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    var itemIds = shipment.items.map(function (item) {\n      return item._id;\n    });\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/delivered\", order, itemIds);\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n    var isCompleted = _every(order.items, function (item) {\n      return _includes(item.workflow.workflow, \"coreOrderItemWorkflow/completed\");\n    });\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.delivered\": true\n      }\n    });\n\n    if (isCompleted === true) {\n      Hooks.Events.run(\"onOrderShipmentDelivered\", order._id);\n      Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      return true;\n    }\n\n    Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n    return false;\n  },\n  /**\n   * orders/sendNotification\n   *\n   * @summary send order notification email\n   * @param {Object} order - order object\n   * @param {Object} action - send notification action\n   * @return {Boolean} email sent or not\n   */\"orders/sendNotification\": function (order, action) {\n    check(order, Object);\n    check(action, Match.OneOf(String, undefined));\n\n    if (!this.userId) {\n      Logger.error(\"orders/sendNotification: Access denied\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock(); // Get Shop information\n\n    var shop = Shops.findOne(order.shopId); // Get shop logo, if available\n\n    var emailLogo = void 0;\n\n    if (Array.isArray(shop.brandAssets)) {\n      var brandAsset = _find(shop.brandAssets, function (asset) {\n        return asset.type === \"navbarBrandImage\";\n      });\n\n      var mediaId = Media.findOne(brandAsset.mediaId);\n      emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n    } else {\n      emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n    }\n\n    var billing = orderCreditMethod(order);\n    var refundResult = Meteor.call(\"orders/refunds/list\", order);\n    var refundTotal = 0;\n\n    _each(refundResult, function (item) {\n      refundTotal += parseFloat(item.amount);\n    }); // Get user currency formatting from shops collection, remove saved rate\n\n\n    var userCurrencyFormatting = _omit(shop.currencies[billing.currency.userCurrency], [\"enabled\", \"rate\"]); // Get user currency exchange rate at time of transaction\n\n\n    var userCurrencyExchangeRate = billing.currency.exchangeRate; // Combine same products into single \"product\" for display purposes\n\n    var combinedItems = [];\n\n    if (order) {\n      var _loop = function (orderItem) {\n        // Find an exising item in the combinedItems array\n        var foundItem = combinedItems.find(function (combinedItem) {\n          // If and item variant exists, then we return true\n          if (combinedItem.variants) {\n            return combinedItem.variants._id === orderItem.variants._id;\n          }\n\n          return false;\n        }); // Increment the quantity count for the duplicate product variants\n\n        if (foundItem) {\n          foundItem.quantity++;\n        } else {\n          // Otherwise push the unique item into the combinedItems array\n          // Add displayPrice to match user currency settings\n          orderItem.variants.displayPrice = accounting.formatMoney(orderItem.variants.price * userCurrencyExchangeRate, userCurrencyFormatting);\n          combinedItems.push(orderItem); // Placeholder image if there is no product image\n\n          orderItem.placeholderImage = Meteor.absoluteUrl() + \"resources/placeholder.gif\";\n          var variantImage = Media.findOne({\n            \"metadata.productId\": orderItem.productId,\n            \"metadata.variantId\": orderItem.variants._id\n          }); // variant image\n\n          if (variantImage) {\n            orderItem.variantImage = path.join(Meteor.absoluteUrl(), variantImage.url());\n          } // find a default image\n\n\n          var productImage = Media.findOne({\n            \"metadata.productId\": orderItem.productId\n          });\n\n          if (productImage) {\n            orderItem.productImage = path.join(Meteor.absoluteUrl(), productImage.url());\n          }\n        }\n      };\n\n      // Loop through all items in the order. The items are split into indivital items\n      for (var _iterator = order.items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var orderItem = _ref;\n\n        _loop(orderItem);\n      } // Merge data into single object to pass to email template\n\n\n      var dataForEmail = {\n        // Shop Data\n        shop: shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo: emailLogo,\n        copyrightDate: moment().format(\"YYYY\"),\n        legalName: shop.addressBook[0].company,\n        physicalAddress: {\n          address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n          city: shop.addressBook[0].city,\n          region: shop.addressBook[0].region,\n          postal: shop.addressBook[0].postal\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Order Data\n        order: order,\n        billing: {\n          address: {\n            address: billing.address.address1,\n            city: billing.address.city,\n            region: billing.address.region,\n            postal: billing.address.postal\n          },\n          paymentMethod: billing.paymentMethod.storedCard || billing.paymentMethod.processor,\n          subtotal: accounting.formatMoney(billing.invoice.subtotal * userCurrencyExchangeRate, userCurrencyFormatting),\n          shipping: accounting.formatMoney(billing.invoice.shipping * userCurrencyExchangeRate, userCurrencyFormatting),\n          taxes: accounting.formatMoney(billing.invoice.taxes * userCurrencyExchangeRate, userCurrencyFormatting),\n          discounts: accounting.formatMoney(billing.invoice.discounts * userCurrencyExchangeRate, userCurrencyFormatting),\n          refunds: accounting.formatMoney(refundTotal * userCurrencyExchangeRate, userCurrencyFormatting),\n          total: accounting.formatMoney(billing.invoice.total * userCurrencyExchangeRate, userCurrencyFormatting),\n          adjustedTotal: accounting.formatMoney((billing.paymentMethod.amount - refundTotal) * userCurrencyExchangeRate, userCurrencyFormatting)\n        },\n        combinedItems: combinedItems,\n        orderDate: moment(order.createdAt).format(\"MM/DD/YYYY\"),\n        orderUrl: getSlug(shop.name) + \"/cart/completed?_id=\" + order.cartId,\n        shipping: {\n          tracking: order.shipping[0].tracking,\n          carrier: order.shipping[0].shipmentMethod.carrier,\n          address: {\n            address: order.shipping[0].address.address1,\n            city: order.shipping[0].address.city,\n            region: order.shipping[0].address.region,\n            postal: order.shipping[0].address.postal\n          }\n        }\n      };\n      Logger.debug(\"orders/sendNotification status: \" + order.workflow.status); // handle missing root shop email\n\n      if (!shop.emails[0].address) {\n        shop.emails[0].address = \"no-reply@reactioncommerce.com\";\n        Logger.warn(\"No shop email configured. Using no-reply to send mail\");\n      } // anonymous users without emails.\n\n\n      if (!order.email) {\n        var msg = \"No order email found. No notification sent.\";\n        Logger.warn(msg);\n        throw new Meteor.Error(\"email-error\", msg);\n      } // Compile Email with SSR\n\n\n      var subject = void 0;\n      var tpl = void 0;\n\n      if (action === \"shipped\") {\n        tpl = \"orders/shipped\";\n        subject = \"orders/shipped/subject\";\n      } else if (action === \"refunded\") {\n        tpl = \"orders/refunded\";\n        subject = \"orders/refunded/subject\";\n      } else {\n        tpl = \"orders/\" + order.workflow.status;\n        subject = \"orders/\" + order.workflow.status + \"/subject\";\n      }\n\n      SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n      SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n      Reaction.Email.send({\n        to: order.email,\n        from: shop.name + \" <\" + shop.emails[0].address + \">\",\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n      return true;\n    }\n\n    return false;\n  },\n  /**\n   * orders/updateShipmentTracking\n   * @summary Adds tracking information to order without workflow update.\n   * Call after any tracking code is generated\n   * @param {Object} order - An Order object\n   * @param {Object} shipment - A Shipment object\n   * @param {String} tracking - tracking id\n   * @return {String} returns order update result\n   */\"orders/updateShipmentTracking\": function (order, shipment, tracking) {\n    var _$set;\n\n    check(order, Object);\n    check(shipment, Object);\n    check(tracking, String);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: (_$set = {}, _$set[\"shipping.$.tracking\"] = tracking, _$set)\n    });\n  },\n  /**\n   * orders/addOrderEmail\n   * @summary Adds email to order, used for guest users\n   * @param {String} cartId - add tracking to orderId\n   * @param {String} email - valid email address\n   * @return {String} returns order update result\n   */\"orders/addOrderEmail\": function (cartId, email) {\n    check(cartId, String);\n    check(email, String); /**\n                          *Instead of checking the Orders permission, we should check if user is\n                          *connected.This is only needed for guest where email is\n                          *provided for tracking order progress.\n                          */\n\n    if (!Meteor.userId()) {\n      throw new Meteor.Error(403, \"Access Denied. You are not connected.\");\n    }\n\n    return Orders.update({\n      cartId: cartId\n    }, {\n      $set: {\n        email: email\n      }\n    });\n  },\n  /**\n   * orders/updateHistory\n   * @summary adds order history item for tracking and logging order updates\n   * @param {String} orderId - add tracking to orderId\n   * @param {String} event - workflow event\n   * @param {String} value - event value\n   * @return {String} returns order update result\n   */\"orders/updateHistory\": function (orderId, event, value) {\n    check(orderId, String);\n    check(event, String);\n    check(value, Match.Optional(String));\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Orders.update(orderId, {\n      $addToSet: {\n        history: {\n          event: event,\n          value: value,\n          userId: Meteor.userId(),\n          updatedAt: new Date()\n        }\n      }\n    });\n  },\n  /**\n   * orders/capturePayments\n   * @summary Finalize any payment where mode is \"authorize\"\n   * and status is \"approved\", reprocess as \"capture\"\n   * @todo: add tests working with new payment methods\n   * @todo: refactor to use non Meteor.namespace\n   * @param {String} orderId - add tracking to orderId\n   * @return {null} no return value\n   */\"orders/capturePayments\": function (orderId) {\n    check(orderId, String);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var order = Orders.findOne(orderId);\n    var itemIds = order.shipping[0].items.map(function (item) {\n      return item._id;\n    });\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds); // process order..payment.paymentMethod\n\n    _each(order.billing, function (billing) {\n      var paymentMethod = billing.paymentMethod;\n      var transactionId = paymentMethod.transactionId;\n\n      if (paymentMethod.mode === \"capture\" && paymentMethod.status === \"approved\" && paymentMethod.processor) {\n        // Grab the amount from the shipment, otherwise use the original amount\n        var processor = paymentMethod.processor.toLowerCase();\n        Meteor.call(processor + \"/payment/capture\", paymentMethod, function (error, result) {\n          if (result && result.saved === true) {\n            var metadata = Object.assign(billing.paymentMethod.metadata || {}, result.metadata || {});\n            Orders.update({\n              \"_id\": orderId,\n              \"billing.paymentMethod.transactionId\": transactionId\n            }, {\n              $set: {\n                \"billing.$.paymentMethod.mode\": \"capture\",\n                \"billing.$.paymentMethod.status\": \"completed\",\n                \"billing.$.paymentMethod.metadata\": metadata\n              },\n              $push: {\n                \"billing.$.paymentMethod.transactions\": result\n              }\n            }); // event onOrderPaymentCaptured used for confirmation hooks\n            // ie: confirmShippingMethodForOrder is triggered here\n\n            Hooks.Events.run(\"onOrderPaymentCaptured\", orderId);\n          } else {\n            if (result && result.error) {\n              Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, result.error);\n            } else {\n              Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, error);\n            }\n\n            Orders.update({\n              \"_id\": orderId,\n              \"billing.paymentMethod.transactionId\": transactionId\n            }, {\n              $set: {\n                \"billing.$.paymentMethod.mode\": \"capture\",\n                \"billing.$.paymentMethod.status\": \"error\"\n              },\n              $push: {\n                \"billing.$.paymentMethod.transactions\": result\n              }\n            });\n            return {\n              error: \"orders/capturePayments: Failed to capture transaction\"\n            };\n          }\n\n          return {\n            error: error,\n            result: result\n          };\n        });\n      }\n    });\n  },\n  /**\n   * orders/refund/list\n   * loop through order's payments and find existing refunds.\n   * @summary Get a list of refunds for a particular payment method.\n   * @param {Object} order - order object\n   * @return {null} no return value\n   */\"orders/refunds/list\": function (order) {\n    check(order, Object);\n    var paymentMethod = orderCreditMethod(order).paymentMethod;\n\n    if (!this.userId === order.userId && !Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n    var future = new Future();\n    var processor = paymentMethod.processor.toLowerCase();\n    Meteor.call(processor + \"/refund/list\", paymentMethod, function (error, result) {\n      if (error) {\n        future.return(error);\n      } else {\n        check(result, [Schemas.Refund]);\n        future.return(result);\n      }\n    });\n    return future.wait();\n  },\n  /**\n   * orders/refund/create\n   *\n   * @summary Apply a refund to an already captured order\n   * @param {String} orderId - order object\n   * @param {Object} paymentMethod - paymentMethod object\n   * @param {Number} amount - Amount of the refund, as a positive number\n   * @return {null} no return value\n   */\"orders/refunds/create\": function (orderId, paymentMethod, amount) {\n    check(orderId, String);\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var processor = paymentMethod.processor.toLowerCase();\n    var order = Orders.findOne(orderId);\n    var transactionId = paymentMethod.transactionId;\n    var packageId = paymentMethod.paymentPackageId;\n    var settingsKey = paymentMethod.paymentSettingsKey; // check if payment provider supports de-authorize\n\n    var checkSupportedMethods = Packages.findOne({\n      _id: packageId,\n      shopId: Reaction.getShopId()\n    }).settings[settingsKey].support;\n    var orderStatus = paymentMethod.status;\n    var orderMode = paymentMethod.mode;\n    var result = void 0;\n    var query = {};\n\n    if (_includes(checkSupportedMethods, \"De-authorize\")) {\n      result = Meteor.call(processor + \"/payment/deAuthorize\", paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      }; // Send email to notify cuustomer of a refund\n\n      Meteor.call(\"orders/sendNotification\", order);\n\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for de-authorize transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to de-authorize transaction failed\", result.error);\n      }\n    } else if (orderStatus === \"completed\" && orderMode === \"capture\") {\n      result = Meteor.call(processor + \"/refund/create\", paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      }; // Send email to notify cuustomer of a refund\n\n      Meteor.call(\"orders/sendNotification\", order, \"refunded\");\n\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for refund transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to refund transaction failed\", result.error);\n      }\n    }\n\n    Orders.update({\n      \"_id\": orderId,\n      \"billing.paymentMethod.transactionId\": transactionId\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"refunded\"\n      },\n      query: query\n    });\n    Hooks.Events.run(\"onOrderRefundCreated\", orderId);\n  }\n};\nMeteor.methods(methods);","map":{"version":3,"sources":["/server/methods/core/orders.js"],"names":["path","moment","accounting","Future","Meteor","check","getSlug","Media","Orders","Products","Shops","Packages","Schemas","Logger","Hooks","Reaction","orderCreditMethod","order","billing","filter","value","paymentMethod","method","orderDebitMethod","ordersInventoryAdjust","orderId","String","hasPermission","Error","findOne","items","forEach","item","update","_id","variants","$inc","inventoryQuantity","quantity","publish","selector","type","methods","shipment","packed","Object","Boolean","$set","itemIds","map","result","call","unblock","invoice","subTotal","subtotal","shipping","taxes","discount","discounts","discountTotal","Math","max","total","toFixed","Number","returnToStock","assign","amount","invoiceTotal","prefix","getShopPrefix","url","sms","userId","err","error","$push","processPayment","completedItemsResult","completedOrderResult","Events","run","workflowResult","email","warn","completedItems","completedOrder","isCompleted","workflow","action","Match","OneOf","undefined","shop","shopId","emailLogo","Array","isArray","brandAssets","brandAsset","asset","mediaId","join","absoluteUrl","refundResult","refundTotal","parseFloat","userCurrencyFormatting","currencies","currency","userCurrency","userCurrencyExchangeRate","exchangeRate","combinedItems","orderItem","foundItem","find","combinedItem","displayPrice","formatMoney","price","push","placeholderImage","variantImage","productId","productImage","dataForEmail","contactEmail","emails","address","homepage","copyrightDate","format","legalName","addressBook","company","physicalAddress","address1","address2","city","region","postal","shopName","name","socialLinks","display","facebook","icon","link","googlePlus","twitter","storedCard","processor","refunds","adjustedTotal","orderDate","createdAt","orderUrl","cartId","tracking","carrier","shipmentMethod","debug","status","msg","subject","tpl","SSR","compileTemplate","Email","getTemplate","getSubject","send","to","from","render","html","event","Optional","$addToSet","history","updatedAt","Date","transactionId","mode","toLowerCase","saved","metadata","fatal","future","return","Refund","wait","PaymentMethod","packageId","paymentPackageId","settingsKey","paymentSettingsKey","checkSupportedMethods","getShopId","settings","support","orderStatus","orderMode","query"],"mappings":"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","file":"/server/methods/core/orders.js.map","sourcesContent":["import _ from \"lodash\";\nimport path from \"path\";\nimport moment from \"moment\";\nimport accounting from \"accounting-js\";\nimport Future from \"fibers/future\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { getSlug } from \"/lib/api\";\nimport { Media, Orders, Products, Shops, Packages } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Hooks, Reaction } from \"/server/api\";\n\n\n// helper to return the order credit object\n// the first credit paymentMethod on the order\n// returns entire payment method\nexport function orderCreditMethod(order) {\n  return order.billing.filter(value => value.paymentMethod.method ===  \"credit\")[0];\n}\n// helper to return the order debit object\nexport function orderDebitMethod(order) {\n  return order.billing.filter(value => value.paymentMethod.method ===  \"debit\")[0];\n}\n\n/**\n * ordersInventoryAdjust\n * adjust inventory when an order is placed\n * @param {String} orderId - add tracking to orderId\n * @return {null} no return value\n */\nexport function ordersInventoryAdjust(orderId) {\n  check(orderId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  }\n\n  const order = Orders.findOne(orderId);\n  order.items.forEach(item => {\n    Products.update({\n      _id: item.variants._id\n    }, {\n      $inc: {\n        inventoryQuantity: -item.quantity\n      }\n    }, {\n      publish: true,\n      selector: {\n        type: \"variant\"\n      }\n    });\n  });\n}\n\n\n/**\n * Reaction Order Methods\n */\nexport const methods = {\n  /**\n   * orders/shipmentPacked\n   *\n   * @summary update packing status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @param {Boolean} packed - packed status\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentPacked\": function (order, shipment, packed) {\n    check(order, Object);\n    check(shipment, Object);\n    check(packed, Boolean);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    if (order) {\n      Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.packed\": packed\n        }\n      });\n\n      // Set the status of the items as packed\n      const itemIds = shipment.items.map((item) => {\n        return item._id;\n      });\n\n      const result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/packed\", order, itemIds);\n      if (result === 1) {\n        return Orders.update({\n          \"_id\": order._id,\n          \"shipping._id\": shipment._id\n        }, {\n          $set: {\n            \"shipping.$.packed\": packed\n          }\n        });\n      }\n      return result;\n    }\n  },\n\n  /**\n   * orders/makeAdjustmentsToInvoice\n   *\n   * @summary Update the status of an invoice to allow adjustments to be made\n   * @param {Object} order - order object\n   * @return {Object} Mongo update\n   */\n  \"orders/makeAdjustmentsToInvoice\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"adjustments\"\n      }\n    });\n  },\n\n  /**\n   * orders/approvePayment\n   *\n   * @summary Approve payment and apply any adjustments\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/approvePayment\": function (order) {\n    check(order, Object);\n    const invoice = orderCreditMethod(order).invoice;\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    // this is server side check to verify\n    // that the math all still adds up.\n    const subTotal = invoice.subtotal;\n    const shipping = invoice.shipping;\n    const taxes = invoice.taxes;\n    const discount = invoice.discounts;\n    const discountTotal = Math.max(0, subTotal - discount); // ensure no discounting below 0.\n    const total = accounting.toFixed(discountTotal + shipping + taxes, 2);\n\n    // Updates flattened inventory count on variants in Products collection\n    ordersInventoryAdjust(order._id);\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.amount\": total,\n        \"billing.$.paymentMethod.status\": \"approved\",\n        \"billing.$.paymentMethod.mode\": \"capture\",\n        \"billing.$.invoice.discounts\": discount,\n        \"billing.$.invoice.total\": Number(total)\n      }\n    });\n  },\n\n  /**\n   * orders/cancelOrder\n   *\n   * @summary Start the cancel order process\n   * @param {Object} order - order object\n   * @param {Boolean} returnToStock - condition to return product to stock\n   * @return {Object} ret\n   */\n  \"orders/cancelOrder\": function (order, returnToStock) {\n    check(order, Object);\n    check(returnToStock, Boolean);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    if (!returnToStock) {\n      ordersInventoryAdjust(order._id);\n    }\n\n    let paymentMethod = orderCreditMethod(order).paymentMethod;\n    paymentMethod = Object.assign(paymentMethod, { amount: Number(paymentMethod.amount) });\n    const invoiceTotal = order.billing[0].invoice.total;\n    const shipment = order.shipping[0];\n    const itemIds = shipment.items.map((item) => {\n      return item._id;\n    });\n\n    // refund payment to customer\n    Meteor.call(\"orders/refunds/create\", order._id, paymentMethod, Number(invoiceTotal));\n\n    // send notification to user\n    const prefix = Reaction.getShopPrefix();\n    const url = `${prefix}/notifications`;\n    const sms = true;\n    Meteor.call(\"notification/send\", order.userId, \"orderCancelled\", url, sms, (err) => {\n      if (err) Logger.error(err);\n    });\n\n    // update item workflow\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/canceled\", order, itemIds);\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"workflow.status\": \"coreOrderWorkflow/canceled\",\n        \"billing.$.paymentMethod.mode\": \"cancel\"\n      },\n      $push: {\n        \"workflow.workflow\": \"coreOrderWorkflow/canceled\"\n      }\n    });\n  },\n\n  /**\n   * orders/processPayment\n   *\n   * @summary trigger processPayment and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/processPayment\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    return Meteor.call(\"orders/processPayments\", order._id, function (error, result) {\n      if (result) {\n        Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"coreProcessPayment\", order._id);\n\n        // Set the status of the items as shipped\n        const itemIds = order.shipping[0].items.map((item) => {\n          return item._id;\n        });\n\n        Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n\n        return this.processPayment(order);\n      }\n      return false;\n    });\n  },\n  /**\n   * orders/shipmentShipped\n   *\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return results of several operations\n   */\n  \"orders/shipmentShipped\": function (order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      Logger.error(\"User does not have 'orders' permissions\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    let completedItemsResult;\n    let completedOrderResult;\n\n    const itemIds = shipment.items.map((item) => {\n      return item._id;\n    });\n\n    // TODO: In the future, this could be handled by shipping delivery status\n    Hooks.Events.run(\"onOrderShipmentShipped\", order, itemIds);\n    const workflowResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/shipped\", order, itemIds);\n\n    if (workflowResult === 1) {\n      // Move to completed status for items\n      completedItemsResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n      if (completedItemsResult === 1) {\n        // Then try to mark order as completed.\n        completedOrderResult = Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      }\n    }\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, \"shipped\");\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.shipped\": true\n      }\n    });\n\n    return {\n      workflowResult: workflowResult,\n      completedItems: completedItemsResult,\n      completedOrder: completedOrderResult\n    };\n  },\n\n  /**\n   * orders/shipmentDelivered\n   *\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentDelivered\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    const shipment = order.shipping[0];\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, (err) => {\n        if (err) {\n          Logger.error(err, \"orders/shipmentDelivered: Failed to send notification\");\n        }\n      });\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    const itemIds = shipment.items.map((item) => {\n      return item._id;\n    });\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/delivered\", order, itemIds);\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n    const isCompleted = _.every(order.items, (item) => {\n      return _.includes(item.workflow.workflow, \"coreOrderItemWorkflow/completed\");\n    });\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.delivered\": true\n      }\n    });\n\n    if (isCompleted === true) {\n      Hooks.Events.run(\"onOrderShipmentDelivered\", order._id);\n      Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      return true;\n    }\n\n    Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n\n    return false;\n  },\n\n  /**\n   * orders/sendNotification\n   *\n   * @summary send order notification email\n   * @param {Object} order - order object\n   * @param {Object} action - send notification action\n   * @return {Boolean} email sent or not\n   */\n  \"orders/sendNotification\": function (order, action) {\n    check(order, Object);\n    check(action, Match.OneOf(String, undefined));\n\n    if (!this.userId) {\n      Logger.error(\"orders/sendNotification: Access denied\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    // Get Shop information\n    const shop = Shops.findOne(order.shopId);\n\n    // Get shop logo, if available\n    let emailLogo;\n    if (Array.isArray(shop.brandAssets)) {\n      const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n      const mediaId = Media.findOne(brandAsset.mediaId);\n      emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n    } else {\n      emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n    }\n\n    const billing = orderCreditMethod(order);\n    const refundResult = Meteor.call(\"orders/refunds/list\", order);\n    let refundTotal = 0;\n\n    _.each(refundResult, function (item) {\n      refundTotal += parseFloat(item.amount);\n    });\n\n    // Get user currency formatting from shops collection, remove saved rate\n    const userCurrencyFormatting = _.omit(shop.currencies[billing.currency.userCurrency], [\"enabled\", \"rate\"]);\n\n    // Get user currency exchange rate at time of transaction\n    const userCurrencyExchangeRate = billing.currency.exchangeRate;\n\n    // Combine same products into single \"product\" for display purposes\n    const combinedItems = [];\n    if (order) {\n      // Loop through all items in the order. The items are split into indivital items\n      for (const orderItem of order.items) {\n        // Find an exising item in the combinedItems array\n        const foundItem = combinedItems.find((combinedItem) => {\n          // If and item variant exists, then we return true\n          if (combinedItem.variants) {\n            return combinedItem.variants._id === orderItem.variants._id;\n          }\n\n          return false;\n        });\n\n        // Increment the quantity count for the duplicate product variants\n        if (foundItem) {\n          foundItem.quantity++;\n        } else {\n          // Otherwise push the unique item into the combinedItems array\n\n          // Add displayPrice to match user currency settings\n          orderItem.variants.displayPrice = accounting.formatMoney(\n            orderItem.variants.price * userCurrencyExchangeRate, userCurrencyFormatting\n          );\n\n          combinedItems.push(orderItem);\n\n          // Placeholder image if there is no product image\n          orderItem.placeholderImage = Meteor.absoluteUrl() + \"resources/placeholder.gif\";\n\n          const variantImage = Media.findOne({\n            \"metadata.productId\": orderItem.productId,\n            \"metadata.variantId\": orderItem.variants._id\n          });\n          // variant image\n          if (variantImage) {\n            orderItem.variantImage = path.join(Meteor.absoluteUrl(), variantImage.url());\n          }\n          // find a default image\n          const productImage = Media.findOne({ \"metadata.productId\": orderItem.productId });\n          if (productImage) {\n            orderItem.productImage = path.join(Meteor.absoluteUrl(), productImage.url());\n          }\n        }\n      }\n\n      // Merge data into single object to pass to email template\n      const dataForEmail = {\n        // Shop Data\n        shop: shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo: emailLogo,\n        copyrightDate: moment().format(\"YYYY\"),\n        legalName: shop.addressBook[0].company,\n        physicalAddress: {\n          address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n          city: shop.addressBook[0].city,\n          region: shop.addressBook[0].region,\n          postal: shop.addressBook[0].postal\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Order Data\n        order: order,\n        billing: {\n          address: {\n            address: billing.address.address1,\n            city: billing.address.city,\n            region: billing.address.region,\n            postal: billing.address.postal\n          },\n          paymentMethod: billing.paymentMethod.storedCard || billing.paymentMethod.processor,\n          subtotal: accounting.formatMoney(\n            billing.invoice.subtotal * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          shipping: accounting.formatMoney(\n            billing.invoice.shipping * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          taxes: accounting.formatMoney(\n            billing.invoice.taxes * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          discounts: accounting.formatMoney(\n            billing.invoice.discounts * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          refunds: accounting.formatMoney(\n            refundTotal * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          total: accounting.formatMoney(\n            billing.invoice.total * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          adjustedTotal: accounting.formatMoney(\n            (billing.paymentMethod.amount - refundTotal) * userCurrencyExchangeRate, userCurrencyFormatting\n          )\n        },\n        combinedItems: combinedItems,\n        orderDate: moment(order.createdAt).format(\"MM/DD/YYYY\"),\n        orderUrl: getSlug(shop.name) + \"/cart/completed?_id=\" + order.cartId,\n        shipping: {\n          tracking: order.shipping[0].tracking,\n          carrier: order.shipping[0].shipmentMethod.carrier,\n          address: {\n            address: order.shipping[0].address.address1,\n            city: order.shipping[0].address.city,\n            region: order.shipping[0].address.region,\n            postal: order.shipping[0].address.postal\n          }\n        }\n      };\n\n      Logger.debug(`orders/sendNotification status: ${order.workflow.status}`);\n\n\n      // handle missing root shop email\n      if (!shop.emails[0].address) {\n        shop.emails[0].address = \"no-reply@reactioncommerce.com\";\n        Logger.warn(\"No shop email configured. Using no-reply to send mail\");\n      }\n\n      // anonymous users without emails.\n      if (!order.email) {\n        const msg = \"No order email found. No notification sent.\";\n        Logger.warn(msg);\n        throw new Meteor.Error(\"email-error\", msg);\n      }\n\n      // Compile Email with SSR\n      let subject;\n      let tpl;\n\n      if (action === \"shipped\") {\n        tpl = \"orders/shipped\";\n        subject = \"orders/shipped/subject\";\n      } else if (action === \"refunded\") {\n        tpl = \"orders/refunded\";\n        subject = \"orders/refunded/subject\";\n      } else {\n        tpl = `orders/${order.workflow.status}`;\n        subject = `orders/${order.workflow.status}/subject`;\n      }\n\n      SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n      SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n      Reaction.Email.send({\n        to: order.email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * orders/updateShipmentTracking\n   * @summary Adds tracking information to order without workflow update.\n   * Call after any tracking code is generated\n   * @param {Object} order - An Order object\n   * @param {Object} shipment - A Shipment object\n   * @param {String} tracking - tracking id\n   * @return {String} returns order update result\n   */\n  \"orders/updateShipmentTracking\": function (order, shipment, tracking) {\n    check(order, Object);\n    check(shipment, Object);\n    check(tracking, String);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        [\"shipping.$.tracking\"]: tracking\n      }\n    });\n  },\n\n  /**\n   * orders/addOrderEmail\n   * @summary Adds email to order, used for guest users\n   * @param {String} cartId - add tracking to orderId\n   * @param {String} email - valid email address\n   * @return {String} returns order update result\n   */\n  \"orders/addOrderEmail\": function (cartId, email) {\n    check(cartId, String);\n    check(email, String);\n    /**\n    *Instead of checking the Orders permission, we should check if user is\n    *connected.This is only needed for guest where email is\n    *provided for tracking order progress.\n    */\n\n    if (!Meteor.userId()) {\n      throw new Meteor.Error(403, \"Access Denied. You are not connected.\");\n    }\n\n    return Orders.update({\n      cartId: cartId\n    }, {\n      $set: {\n        email: email\n      }\n    });\n  },\n\n  /**\n   * orders/updateHistory\n   * @summary adds order history item for tracking and logging order updates\n   * @param {String} orderId - add tracking to orderId\n   * @param {String} event - workflow event\n   * @param {String} value - event value\n   * @return {String} returns order update result\n   */\n  \"orders/updateHistory\": function (orderId, event, value) {\n    check(orderId, String);\n    check(event, String);\n    check(value, Match.Optional(String));\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Orders.update(orderId, {\n      $addToSet: {\n        history: {\n          event: event,\n          value: value,\n          userId: Meteor.userId(),\n          updatedAt: new Date()\n        }\n      }\n    });\n  },\n\n\n  /**\n   * orders/capturePayments\n   * @summary Finalize any payment where mode is \"authorize\"\n   * and status is \"approved\", reprocess as \"capture\"\n   * @todo: add tests working with new payment methods\n   * @todo: refactor to use non Meteor.namespace\n   * @param {String} orderId - add tracking to orderId\n   * @return {null} no return value\n   */\n  \"orders/capturePayments\": (orderId) => {\n    check(orderId, String);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const order = Orders.findOne(orderId);\n    const itemIds = order.shipping[0].items.map((item) => {\n      return item._id;\n    });\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n\n    // process order..payment.paymentMethod\n    _.each(order.billing, function (billing) {\n      const paymentMethod = billing.paymentMethod;\n      const transactionId = paymentMethod.transactionId;\n\n      if (paymentMethod.mode === \"capture\" && paymentMethod.status === \"approved\" && paymentMethod.processor) {\n        // Grab the amount from the shipment, otherwise use the original amount\n        const processor = paymentMethod.processor.toLowerCase();\n\n        Meteor.call(`${processor}/payment/capture`, paymentMethod, (error, result) => {\n          if (result && result.saved === true) {\n            const metadata = Object.assign(billing.paymentMethod.metadata || {}, result.metadata || {});\n\n            Orders.update({\n              \"_id\": orderId,\n              \"billing.paymentMethod.transactionId\": transactionId\n            }, {\n              $set: {\n                \"billing.$.paymentMethod.mode\": \"capture\",\n                \"billing.$.paymentMethod.status\": \"completed\",\n                \"billing.$.paymentMethod.metadata\": metadata\n              },\n              $push: {\n                \"billing.$.paymentMethod.transactions\": result\n              }\n            });\n\n            // event onOrderPaymentCaptured used for confirmation hooks\n            // ie: confirmShippingMethodForOrder is triggered here\n            Hooks.Events.run(\"onOrderPaymentCaptured\", orderId);\n          } else {\n            if (result && result.error) {\n              Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, result.error);\n            } else {\n              Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, error);\n            }\n\n            Orders.update({\n              \"_id\": orderId,\n              \"billing.paymentMethod.transactionId\": transactionId\n            }, {\n              $set: {\n                \"billing.$.paymentMethod.mode\": \"capture\",\n                \"billing.$.paymentMethod.status\": \"error\"\n              },\n              $push: {\n                \"billing.$.paymentMethod.transactions\": result\n              }\n            });\n\n            return { error: \"orders/capturePayments: Failed to capture transaction\" };\n          }\n          return { error, result };\n        });\n      }\n    });\n  },\n\n  /**\n   * orders/refund/list\n   * loop through order's payments and find existing refunds.\n   * @summary Get a list of refunds for a particular payment method.\n   * @param {Object} order - order object\n   * @return {null} no return value\n   */\n  \"orders/refunds/list\": function (order) {\n    check(order, Object);\n    const paymentMethod = orderCreditMethod(order).paymentMethod;\n\n    if (!this.userId === order.userId && !Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    const future = new Future();\n    const processor = paymentMethod.processor.toLowerCase();\n\n    Meteor.call(`${processor}/refund/list`, paymentMethod, (error, result) => {\n      if (error) {\n        future.return(error);\n      } else {\n        check(result, [Schemas.Refund]);\n        future.return(result);\n      }\n    });\n\n    return future.wait();\n  },\n\n  /**\n   * orders/refund/create\n   *\n   * @summary Apply a refund to an already captured order\n   * @param {String} orderId - order object\n   * @param {Object} paymentMethod - paymentMethod object\n   * @param {Number} amount - Amount of the refund, as a positive number\n   * @return {null} no return value\n   */\n  \"orders/refunds/create\": function (orderId, paymentMethod, amount) {\n    check(orderId, String);\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const processor = paymentMethod.processor.toLowerCase();\n    const order = Orders.findOne(orderId);\n    const transactionId = paymentMethod.transactionId;\n\n    const packageId = paymentMethod.paymentPackageId;\n    const settingsKey = paymentMethod.paymentSettingsKey;\n    // check if payment provider supports de-authorize\n    const checkSupportedMethods = Packages.findOne({\n      _id: packageId,\n      shopId: Reaction.getShopId()\n    }).settings[settingsKey].support;\n\n    const orderStatus = paymentMethod.status;\n    const orderMode = paymentMethod.mode;\n\n    let result;\n    let query = {};\n    if (_.includes(checkSupportedMethods, \"De-authorize\")) {\n      result = Meteor.call(`${processor}/payment/deAuthorize`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n      // Send email to notify cuustomer of a refund\n      Meteor.call(\"orders/sendNotification\", order);\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for de-authorize transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to de-authorize transaction failed\", result.error);\n      }\n    } else if (orderStatus === \"completed\" && orderMode === \"capture\") {\n      result = Meteor.call(`${processor}/refund/create`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n      // Send email to notify cuustomer of a refund\n      Meteor.call(\"orders/sendNotification\", order, \"refunded\");\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for refund transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to refund transaction failed\", result.error);\n      }\n    }\n\n    Orders.update({\n      \"_id\": orderId,\n      \"billing.paymentMethod.transactionId\": transactionId\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"refunded\"\n      },\n      query\n    });\n\n    Hooks.Events.run(\"onOrderRefundCreated\", orderId);\n  }\n};\n\nMeteor.methods(methods);\n"]},"hash":"2479848ec1485c47409742ef59cc128a25b01df7"}
