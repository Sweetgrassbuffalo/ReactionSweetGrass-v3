{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"later","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"later"}]},{"source":"moment","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"moment"}]},{"source":"/lib/collections","imported":["Jobs"],"specifiers":[{"kind":"named","imported":"Jobs","local":"Jobs"}]},{"source":"/server/api","imported":["Hooks","Logger"],"specifiers":[{"kind":"named","imported":"Hooks","local":"Hooks"},{"kind":"named","imported":"Logger","local":"Logger"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/plugins/included/jobcontrol/server/jobs/cleanup.js","filenameRelative":"/imports/plugins/included/jobcontrol/server/jobs/cleanup.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/included/jobcontrol/server/jobs/cleanup.js"],"names":["later","moment","Jobs","Hooks","Logger","Events","add","debug","Job","retry","retries","wait","backoff","repeat","schedule","parse","text","save","cancelRepeats","removeStaleJobs","processJobs","pollInterval","workTimeout","job","callback","olderThan","subtract","_d","ids","find","type","$nin","status","$in","updated","$lt","fields","_id","map","d","success","length","removeJobs","done","repeatId","observe","added","trigger"],"mappings":"AAAA;AAAA,OAAkB;;;;;;;;;;;;;;;;;;;;;;;;;;GAClB,AAAO,AAAY,AACnB,AAAS,AAAY,AACrB,AAAS,AAAO,AAAc,AAE9B,AAAM,AAAO,AAAI,AAAoB,AAAM;AACzC,MAAO,OAAP,AAAa,oCAAb,AAEA;AAAI,SAAJ,AAAQ,MAAR,AAAc,AAA8B,AACzC,AAAM,AACL,AAAS,AACT;UAFK,AAEC,oCACN;AAJJ,AAMU,aACN;UAPJ,AAMU,AACI,AAAM,AAAM,AAAK,AAE5B;AATH,AASQ,aATR,AASQ,AACJ,AAAe;AAVnB,AACS,AAGI,AAEV;+BASL,AAAe,AAAY,AACzB;AAnBF,AAeC,KAIO;AACU,mBADuD,AACvD,AAAK,AAAK,AAAM,AAC9B;AAFsB,AAAK,AAAY,AAA8B,AACrE;AADsB,AAA+C,AAExD,AAAK,AACjB,AAAC,AAAK,AAAa,AACpB,AAAO,AAAM,AAEb;OA9BG,kBAAP,8BA+BI;MAAM,AAAY,uBAAA,AAAS,AAAS,YAApC,AAAkB,AAAqB,AAAQ;;AAE/C;AAAM,AAAM,iBAAK,KAAL,AAAU,AACpB;oBAAM,UACJ;WAAM,AAAC,MAFW,AACd,AACE,AAER,6CAAQ,AACN;;QAAK,AAAC,YAAD,AAAc,SAAd,SAA2B,GAA3B,QALa,AAIZ,AAGR;;QAAS;;eAPC,AAAU,AAUnB,AACD;AAJS,AACF;;aAIA,2BAZG,AAUT,AACO;AAAA,AACN;AAZQ,AAcT,AAAI,AAAC;AAEJ,aAAJ,AACA;AAjBA,AAAY,AAcE,AAAE,AAEhB;AARI;AAUG;aADP,AAEE,AAAW,AAAU,AAAI,AAAO,AAChC,AAAO,AAAM,AACd;AAHC,AAAgB,AAChB;AAFF,AAAI,AAAI,AAAS,AAAG,AAClB;AAGK,eACL,AAAU,AACV;;QAAA,AAAO,AAAM,AACd;;;sBACD;AAAA,AAAI,AAAK,AAAS,iCAAE;aAAU,MAAZ;AAAlB,WACA;AAAO,gBAnCT,AAAwB,AAmCtB,AACD;mBAED;AAAA,AAAK,AAAK,AACR;;QAAM;gBADE,AAER;;WAFQ,AAEA;AAFV,AAGG,AAAQ,AACT,AAAQ,AACN;;;YALJ,AAGW;AAEP,AAAO,AAAgB,AACxB;;;;AAEJ","file":"/imports/plugins/included/jobcontrol/server/jobs/cleanup.js.map","sourcesContent":["import later from \"later\";\nimport moment from \"moment\";\nimport { Jobs } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\n\nHooks.Events.add(\"onJobServerStart\", () => {\n  Logger.debug(\"Adding Job jobControl/removeStaleJobs to JobControl\");\n\n  new Job(Jobs, \"jobControl/removeStaleJobs\", {})\n    .retry({\n      retries: 5,\n      wait: 60000,\n      backoff: \"exponential\"\n    })\n    .repeat({\n      schedule: later.parse.text(\"every day\")\n    })\n    .save({\n      cancelRepeats: true\n    });\n});\n\n\nexport default function () {\n  const removeStaleJobs = Jobs.processJobs(\"jobControl/removeStaleJobs\", {\n    pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n    workTimeout: 60 * 1000\n  }, (job, callback) => {\n    Logger.debug(\"Processing jobControl/removeStaleJobs...\");\n\n    // TODO: set this interval in the admin UI\n    const olderThan = moment().subtract(3, \"days\")._d;\n\n    const ids = Jobs.find({\n      type: {\n        $nin: [\"sendEmail\"]\n      },\n      status: {\n        $in: [\"cancelled\", \"completed\", \"failed\"]\n      },\n      updated: {\n        $lt: olderThan\n      }\n    }, {\n      fields: {\n        _id: 1\n      }\n    }).map((d) => d._id);\n\n    let success;\n    if (ids.length > 0) {\n      Jobs.removeJobs(ids);\n      success = `Removed ${ids.length} stale jobs`;\n      Logger.debug(success);\n    } else {\n      success = \"No eligible jobs to cleanup\";\n      Logger.debug(success);\n    }\n    job.done(success, { repeatId: true });\n    return callback();\n  });\n\n  Jobs.find({\n    type: \"jobControl/removeStaleJobs\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return removeStaleJobs.trigger();\n    }\n  });\n}\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/included/jobcontrol/server/jobs/cleanup.js.map","sourceFileName":"/imports/plugins/included/jobcontrol/server/jobs/cleanup.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cleanup"},"ignored":false,"code":"var later = void 0;\nmodule.importSync(\"later\", {\n  \"default\": function (v) {\n    later = v;\n  }\n}, 0);\nvar moment = void 0;\nmodule.importSync(\"moment\", {\n  \"default\": function (v) {\n    moment = v;\n  }\n}, 1);\nvar Jobs = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Jobs: function (v) {\n    Jobs = v;\n  }\n}, 2);\nvar Hooks = void 0,\n    Logger = void 0;\nmodule.importSync(\"/server/api\", {\n  Hooks: function (v) {\n    Hooks = v;\n  },\n  Logger: function (v) {\n    Logger = v;\n  }\n}, 3);\nHooks.Events.add(\"onJobServerStart\", function () {\n  Logger.debug(\"Adding Job jobControl/removeStaleJobs to JobControl\");\n  new Job(Jobs, \"jobControl/removeStaleJobs\", {}).retry({\n    retries: 5,\n    wait: 60000,\n    backoff: \"exponential\"\n  }).repeat({\n    schedule: later.parse.text(\"every day\")\n  }).save({\n    cancelRepeats: true\n  });\n});\nmodule.export(\"default\", exports.default = function () {\n  var removeStaleJobs = Jobs.processJobs(\"jobControl/removeStaleJobs\", {\n    pollInterval: 60 * 60 * 1000,\n    // backup polling, see observer below\n    workTimeout: 60 * 1000\n  }, function (job, callback) {\n    Logger.debug(\"Processing jobControl/removeStaleJobs...\"); // TODO: set this interval in the admin UI\n\n    var olderThan = moment().subtract(3, \"days\")._d;\n\n    var ids = Jobs.find({\n      type: {\n        $nin: [\"sendEmail\"]\n      },\n      status: {\n        $in: [\"cancelled\", \"completed\", \"failed\"]\n      },\n      updated: {\n        $lt: olderThan\n      }\n    }, {\n      fields: {\n        _id: 1\n      }\n    }).map(function (d) {\n      return d._id;\n    });\n    var success = void 0;\n\n    if (ids.length > 0) {\n      Jobs.removeJobs(ids);\n      success = \"Removed \" + ids.length + \" stale jobs\";\n      Logger.debug(success);\n    } else {\n      success = \"No eligible jobs to cleanup\";\n      Logger.debug(success);\n    }\n\n    job.done(success, {\n      repeatId: true\n    });\n    return callback();\n  });\n  Jobs.find({\n    type: \"jobControl/removeStaleJobs\",\n    status: \"ready\"\n  }).observe({\n    added: function () {\n      return removeStaleJobs.trigger();\n    }\n  });\n});","map":{"version":3,"sources":["/imports/plugins/included/jobcontrol/server/jobs/cleanup.js"],"names":["later","moment","Jobs","Hooks","Logger","Events","add","debug","Job","retry","retries","wait","backoff","repeat","schedule","parse","text","save","cancelRepeats","removeStaleJobs","processJobs","pollInterval","workTimeout","job","callback","olderThan","subtract","_d","ids","find","type","$nin","status","$in","updated","$lt","fields","_id","map","d","success","length","removeJobs","done","repeatId","observe","added","trigger"],"mappings":"AAAA;AAAA,OAAkB;;;;;;;;;;;;;;;;;;;;;;;;;;GAClB,AAAO,AAAY,AACnB,AAAS,AAAY,AACrB,AAAS,AAAO,AAAc,AAE9B,AAAM,AAAO,AAAI,AAAoB,AAAM;AACzC,MAAO,OAAP,AAAa,oCAAb,AAEA;AAAI,SAAJ,AAAQ,MAAR,AAAc,AAA8B,AACzC,AAAM,AACL,AAAS,AACT;UAFK,AAEC,oCACN;AAJJ,AAMU,aACN;UAPJ,AAMU,AACI,AAAM,AAAM,AAAK,AAE5B;AATH,AASQ,aATR,AASQ,AACJ,AAAe;AAVnB,AACS,AAGI,AAEV;+BASL,AAAe,AAAY,AACzB;AAnBF,AAeC,KAIO;AACU,mBADuD,AACvD,AAAK,AAAK,AAAM,AAC9B;AAFsB,AAAK,AAAY,AAA8B,AACrE;AADsB,AAA+C,AAExD,AAAK,AACjB,AAAC,AAAK,AAAa,AACpB,AAAO,AAAM,AAEb;OA9BG,kBAAP,8BA+BI;MAAM,AAAY,uBAAA,AAAS,AAAS,YAApC,AAAkB,AAAqB,AAAQ;;AAE/C;AAAM,AAAM,iBAAK,KAAL,AAAU,AACpB;oBAAM,UACJ;WAAM,AAAC,MAFW,AACd,AACE,AAER,6CAAQ,AACN;;QAAK,AAAC,YAAD,AAAc,SAAd,SAA2B,GAA3B,QALa,AAIZ,AAGR;;QAAS;;eAPC,AAAU,AAUnB,AACD;AAJS,AACF;;aAIA,2BAZG,AAUT,AACO;AAAA,AACN;AAZQ,AAcT,AAAI,AAAC;AAEJ,aAAJ,AACA;AAjBA,AAAY,AAcE,AAAE,AAEhB;AARI;AAUG;aADP,AAEE,AAAW,AAAU,AAAI,AAAO,AAChC,AAAO,AAAM,AACd;AAHC,AAAgB,AAChB;AAFF,AAAI,AAAI,AAAS,AAAG,AAClB;AAGK,eACL,AAAU,AACV;;QAAA,AAAO,AAAM,AACd;;;sBACD;AAAA,AAAI,AAAK,AAAS,iCAAE;aAAU,MAAZ;AAAlB,WACA;AAAO,gBAnCT,AAAwB,AAmCtB,AACD;mBAED;AAAA,AAAK,AAAK,AACR;;QAAM;gBADE,AAER;;WAFQ,AAEA;AAFV,AAGG,AAAQ,AACT,AAAQ,AACN;;;YALJ,AAGW;AAEP,AAAO,AAAgB,AACxB;;;;AAEJ","file":"/imports/plugins/included/jobcontrol/server/jobs/cleanup.js.map","sourcesContent":["import later from \"later\";\nimport moment from \"moment\";\nimport { Jobs } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\n\nHooks.Events.add(\"onJobServerStart\", () => {\n  Logger.debug(\"Adding Job jobControl/removeStaleJobs to JobControl\");\n\n  new Job(Jobs, \"jobControl/removeStaleJobs\", {})\n    .retry({\n      retries: 5,\n      wait: 60000,\n      backoff: \"exponential\"\n    })\n    .repeat({\n      schedule: later.parse.text(\"every day\")\n    })\n    .save({\n      cancelRepeats: true\n    });\n});\n\n\nexport default function () {\n  const removeStaleJobs = Jobs.processJobs(\"jobControl/removeStaleJobs\", {\n    pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n    workTimeout: 60 * 1000\n  }, (job, callback) => {\n    Logger.debug(\"Processing jobControl/removeStaleJobs...\");\n\n    // TODO: set this interval in the admin UI\n    const olderThan = moment().subtract(3, \"days\")._d;\n\n    const ids = Jobs.find({\n      type: {\n        $nin: [\"sendEmail\"]\n      },\n      status: {\n        $in: [\"cancelled\", \"completed\", \"failed\"]\n      },\n      updated: {\n        $lt: olderThan\n      }\n    }, {\n      fields: {\n        _id: 1\n      }\n    }).map((d) => d._id);\n\n    let success;\n    if (ids.length > 0) {\n      Jobs.removeJobs(ids);\n      success = `Removed ${ids.length} stale jobs`;\n      Logger.debug(success);\n    } else {\n      success = \"No eligible jobs to cleanup\";\n      Logger.debug(success);\n    }\n    job.done(success, { repeatId: true });\n    return callback();\n  });\n\n  Jobs.find({\n    type: \"jobControl/removeStaleJobs\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return removeStaleJobs.trigger();\n    }\n  });\n}\n"]},"hash":"4447f964b813ffc1ec7faf58c5d78add04e87d7e"}
