{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","createClass","classCallCheck","extends","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"react","imported":["default","Component","PropTypes"],"specifiers":[{"kind":"named","imported":"default","local":"React"},{"kind":"named","imported":"Component","local":"Component"},{"kind":"named","imported":"PropTypes","local":"PropTypes"}]},{"source":"lodash/debounce","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"debounce"}]},{"source":"react/lib/update","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"update"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"/client/api","imported":["Reaction","i18next"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"},{"kind":"named","imported":"i18next","local":"i18next"}]},{"source":"/lib/api/compose","imported":["composeWithTracker"],"specifiers":[{"kind":"named","imported":"composeWithTracker","local":"composeWithTracker"}]},{"source":"../components/tags","imported":["TagList"],"specifiers":[{"kind":"named","imported":"TagList","local":"TagList"}]},{"source":"/lib/collections","imported":["Tags"],"specifiers":[{"kind":"named","imported":"Tags","local":"Tags"}]},{"source":"/lib/selectors/tags","imported":["getTagIds"],"specifiers":[{"kind":"named","imported":"getTagIds","local":"getTagIds"}]},{"source":"/imports/plugins/core/ui/client/providers","imported":["DragDropProvider"],"specifiers":[{"kind":"named","imported":"DragDropProvider","local":"DragDropProvider"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/plugins/core/ui/client/containers/tagListContainer.js","filenameRelative":"/imports/plugins/core/ui/client/containers/tagListContainer.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/core/ui/client/containers/tagListContainer.js"],"names":["React","Component","PropTypes","debounce","update","Meteor","Reaction","i18next","composeWithTracker","TagList","Tags","getTagIds","DragDropProvider","updateSuggestions","term","excludeTags","slug","getSlug","selector","RegExp","Array","isArray","_id","$nin","tags","find","map","tag","label","name","TagListContainer","constructor","props","state","tagIds","tagsByKey","newTag","suggestions","debounceUpdateTagOrder","call","product","componentWillReceiveProps","nextProps","setState","productId","canSaveTag","trim","length","originalTag","handleNewTagSave","error","Alerts","toast","t","handleNewTagUpdate","handleTagSave","handleTagRemove","handleTagUpdate","newState","$set","handleMoveTag","dragIndex","hoverIndex","$splice","handleGetSuggestions","suggestionUpdateRequest","value","handleClearSuggestions","editable","tagId","tagsAsArray","render","handleEditButtonClick","propTypes","children","node","bool","hasPermission","object","arrayOf","string","composer","onData","_","hashtags","id","findOne","isEditable","permissions","isProductTags","undefined","decoratedComponent"],"mappings":"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","file":"/imports/plugins/core/ui/client/containers/tagListContainer.js.map","sourcesContent":["import React, { Component, PropTypes } from \"react\";\nimport debounce from \"lodash/debounce\";\nimport update from \"react/lib/update\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Reaction, i18next } from \"/client/api\";\nimport { composeWithTracker } from \"/lib/api/compose\";\nimport { TagList } from \"../components/tags\";\nimport { Tags } from \"/lib/collections\";\nimport { getTagIds } from \"/lib/selectors/tags\";\nimport { DragDropProvider } from \"/imports/plugins/core/ui/client/providers\";\n\n\nfunction updateSuggestions(term, { excludeTags }) {\n  const slug = Reaction.getSlug(term);\n\n  const selector = {\n    slug: new RegExp(slug, \"i\")\n  };\n\n  if (Array.isArray(excludeTags)) {\n    selector._id = {\n      $nin: excludeTags\n    };\n  }\n\n  const tags = Tags.find(selector).map((tag) => {\n    return {\n      label: tag.name\n    };\n  });\n\n  return tags;\n}\n\nclass TagListContainer extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      tagIds: props.tagIds || [],\n      tagsByKey: props.tagsByKey || {},\n      newTag: {\n        name: \"\"\n      },\n      suggestions: []\n    };\n\n    this.debounceUpdateTagOrder = debounce(() => {\n      Meteor.call(\n        \"products/updateProductField\",\n        this.props.product._id,\n        \"hashtags\",\n        this.state.tagIds\n      );\n    }, 500);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setState({\n      tagIds: nextProps.tagIds || [],\n      tagsByKey: nextProps.tagsByKey || {}\n    });\n  }\n\n  get productId() {\n    if (this.props.product) {\n      return this.props.product._id;\n    }\n    return null;\n  }\n\n  canSaveTag(tag) {\n    // Blank tags cannot be saved\n    if (typeof tag.name === \"string\" && tag.name.trim().length === 0) {\n      return false;\n    }\n\n    // If the tag does not have an id, then allow the save\n    if (!tag._id) {\n      return true;\n    }\n\n    // Get the original tag from the props\n    // Tags from props are not mutated, and come from an outside source\n    const originalTag = this.props.tagsByKey[tag._id];\n\n    if (originalTag && originalTag.name !== tag.name) {\n      return true;\n    }\n\n    return false;\n  }\n\n  handleNewTagSave = (tag) => {\n    if (this.productId && this.canSaveTag(tag)) {\n      Meteor.call(\"products/updateProductTags\", this.productId, tag.name, null, (error) => {\n        if (error) {\n          return Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n        }\n\n        this.setState({\n          newTag: {\n            name: \"\"\n          },\n          suggestions: []\n        });\n\n        return true;\n      });\n    }\n  }\n\n  handleNewTagUpdate = (tag) => {\n    this.setState({\n      newTag: tag\n    });\n  }\n\n  handleTagSave = (tag) => {\n    if (this.productId && this.canSaveTag(tag)) {\n      Meteor.call(\"products/updateProductTags\", this.productId, tag.name, tag._id, (error) => {\n        if (error) {\n          return Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n        }\n\n        this.setState({\n          suggestions: []\n        });\n\n        return true;\n      });\n    }\n  }\n\n  handleTagRemove = (tag) => {\n    if (this.productId) {\n      Meteor.call(\"products/removeProductTag\", this.productId, tag._id, (error) => {\n        if (error) {\n          Alerts.toast(i18next.t(\"productDetail.tagInUse\"), \"error\");\n        }\n      });\n    }\n  }\n\n  handleTagUpdate = (tag) => {\n    const newState = update(this.state, {\n      tagsByKey: {\n        [tag._id]: {\n          $set: tag\n        }\n      }\n    });\n\n    this.setState(newState);\n  }\n\n  handleMoveTag = (dragIndex, hoverIndex) => {\n    const tag = this.state.tagIds[dragIndex];\n\n    // Apply new sort order to variant list\n    const newState = update(this.state, {\n      tagIds: {\n        $splice: [\n          [dragIndex, 1],\n          [hoverIndex, 0, tag]\n        ]\n      }\n    });\n\n    // Set local state so the component does't have to wait for a round-trip\n    // to the server to get the updated list of variants\n    this.setState(newState, () => {\n      // Save the updated positions\n      if (this.props.product) {\n        this.debounceUpdateTagOrder();\n      }\n    });\n  }\n\n  handleGetSuggestions = (suggestionUpdateRequest) => {\n    const suggestions = updateSuggestions(\n      suggestionUpdateRequest.value,\n      { excludeTags: this.state.tagIds }\n    );\n\n    this.setState({\n      suggestions: suggestions\n    });\n  }\n\n  handleClearSuggestions = () => {\n    this.setState({\n      suggestions: []\n    });\n  }\n\n  get tags() {\n    if (this.props.editable) {\n      return this.state.tagIds.map((tagId) => this.state.tagsByKey[tagId]);\n    }\n\n    return this.props.tagsAsArray;\n  }\n\n  render() {\n    return (\n      <DragDropProvider>\n        <TagList\n          newTag={this.state.newTag}\n          onClick={this.handleEditButtonClick}\n          onClearSuggestions={this.handleClearSuggestions}\n          onGetSuggestions={this.handleGetSuggestions}\n          onMoveTag={this.handleMoveTag}\n          onNewTagSave={this.handleNewTagSave}\n          onNewTagUpdate={this.handleNewTagUpdate}\n          onTagRemove={this.handleTagRemove}\n          onTagSave={this.handleTagSave}\n          onTagUpdate={this.handleTagUpdate}\n          suggestions={this.state.suggestions}\n          tags={this.tags}\n          tooltip=\"Unpublished changes\"\n          {...this.props}\n        />\n      </DragDropProvider>\n    );\n  }\n}\n\nTagListContainer.propTypes = {\n  children: PropTypes.node,\n  editable: PropTypes.bool,\n  hasPermission: PropTypes.bool,\n  product: PropTypes.object,\n  tagIds: PropTypes.arrayOf(PropTypes.string),\n  tagsAsArray: PropTypes.arrayOf(PropTypes.object),\n  tagsByKey: PropTypes.object\n};\n\nfunction composer(props, onData) {\n  let tags = props.tags;\n\n  if (props.product) {\n    if (_.isArray(props.product.hashtags)) {\n      tags = _.map(props.product.hashtags, function (id) {\n        return Tags.findOne(id);\n      });\n    }\n  }\n\n  let isEditable = props.editable;\n\n  if (typeof isEditable !== \"boolean\") {\n    isEditable = Reaction.hasPermission(props.permissions);\n  }\n\n  const tagsByKey = {};\n\n  if (Array.isArray(tags)) {\n    for (const tag of tags) {\n      tagsByKey[tag._id] = tag;\n    }\n  }\n\n  onData(null, {\n    isProductTags: props.product !== undefined,\n    tagIds: getTagIds({ tags }),\n    tagsByKey,\n    tagsAsArray: tags,\n    editable: isEditable\n  });\n}\n\nlet decoratedComponent = TagListContainer;\ndecoratedComponent = composeWithTracker(composer)(decoratedComponent);\n\nexport default decoratedComponent;\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/core/ui/client/containers/tagListContainer.js.map","sourceFileName":"/imports/plugins/core/ui/client/containers/tagListContainer.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"tagListContainer"},"ignored":false,"code":"var _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar React = void 0,\n    Component = void 0,\n    PropTypes = void 0;\nmodule.importSync(\"react\", {\n  \"default\": function (v) {\n    React = v;\n  },\n  Component: function (v) {\n    Component = v;\n  },\n  PropTypes: function (v) {\n    PropTypes = v;\n  }\n}, 0);\nvar debounce = void 0;\nmodule.importSync(\"lodash/debounce\", {\n  \"default\": function (v) {\n    debounce = v;\n  }\n}, 1);\nvar update = void 0;\nmodule.importSync(\"react/lib/update\", {\n  \"default\": function (v) {\n    update = v;\n  }\n}, 2);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 3);\nvar Reaction = void 0,\n    i18next = void 0;\nmodule.importSync(\"/client/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  },\n  i18next: function (v) {\n    i18next = v;\n  }\n}, 4);\nvar composeWithTracker = void 0;\nmodule.importSync(\"/lib/api/compose\", {\n  composeWithTracker: function (v) {\n    composeWithTracker = v;\n  }\n}, 5);\nvar TagList = void 0;\nmodule.importSync(\"../components/tags\", {\n  TagList: function (v) {\n    TagList = v;\n  }\n}, 6);\nvar Tags = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Tags: function (v) {\n    Tags = v;\n  }\n}, 7);\nvar getTagIds = void 0;\nmodule.importSync(\"/lib/selectors/tags\", {\n  getTagIds: function (v) {\n    getTagIds = v;\n  }\n}, 8);\nvar DragDropProvider = void 0;\nmodule.importSync(\"/imports/plugins/core/ui/client/providers\", {\n  DragDropProvider: function (v) {\n    DragDropProvider = v;\n  }\n}, 9);\n\nfunction updateSuggestions(term, _ref) {\n  var excludeTags = _ref.excludeTags;\n  var slug = Reaction.getSlug(term);\n  var selector = {\n    slug: new RegExp(slug, \"i\")\n  };\n\n  if (Array.isArray(excludeTags)) {\n    selector._id = {\n      $nin: excludeTags\n    };\n  }\n\n  var tags = Tags.find(selector).map(function (tag) {\n    return {\n      label: tag.name\n    };\n  });\n  return tags;\n}\n\nvar TagListContainer = function (_Component) {\n  (0, _inherits3.default)(TagListContainer, _Component);\n\n  function TagListContainer(props) {\n    (0, _classCallCheck3.default)(this, TagListContainer);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, _Component.call(this, props));\n\n    _this.handleNewTagSave = function (tag) {\n      if (_this.productId && _this.canSaveTag(tag)) {\n        Meteor.call(\"products/updateProductTags\", _this.productId, tag.name, null, function (error) {\n          if (error) {\n            return Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n          }\n\n          _this.setState({\n            newTag: {\n              name: \"\"\n            },\n            suggestions: []\n          });\n\n          return true;\n        });\n      }\n    };\n\n    _this.handleNewTagUpdate = function (tag) {\n      _this.setState({\n        newTag: tag\n      });\n    };\n\n    _this.handleTagSave = function (tag) {\n      if (_this.productId && _this.canSaveTag(tag)) {\n        Meteor.call(\"products/updateProductTags\", _this.productId, tag.name, tag._id, function (error) {\n          if (error) {\n            return Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n          }\n\n          _this.setState({\n            suggestions: []\n          });\n\n          return true;\n        });\n      }\n    };\n\n    _this.handleTagRemove = function (tag) {\n      if (_this.productId) {\n        Meteor.call(\"products/removeProductTag\", _this.productId, tag._id, function (error) {\n          if (error) {\n            Alerts.toast(i18next.t(\"productDetail.tagInUse\"), \"error\");\n          }\n        });\n      }\n    };\n\n    _this.handleTagUpdate = function (tag) {\n      var _tagsByKey;\n\n      var newState = update(_this.state, {\n        tagsByKey: (_tagsByKey = {}, _tagsByKey[tag._id] = {\n          $set: tag\n        }, _tagsByKey)\n      });\n\n      _this.setState(newState);\n    };\n\n    _this.handleMoveTag = function (dragIndex, hoverIndex) {\n      var tag = _this.state.tagIds[dragIndex]; // Apply new sort order to variant list\n\n      var newState = update(_this.state, {\n        tagIds: {\n          $splice: [[dragIndex, 1], [hoverIndex, 0, tag]]\n        }\n      }); // Set local state so the component does't have to wait for a round-trip\n      // to the server to get the updated list of variants\n\n      _this.setState(newState, function () {\n        // Save the updated positions\n        if (_this.props.product) {\n          _this.debounceUpdateTagOrder();\n        }\n      });\n    };\n\n    _this.handleGetSuggestions = function (suggestionUpdateRequest) {\n      var suggestions = updateSuggestions(suggestionUpdateRequest.value, {\n        excludeTags: _this.state.tagIds\n      });\n\n      _this.setState({\n        suggestions: suggestions\n      });\n    };\n\n    _this.handleClearSuggestions = function () {\n      _this.setState({\n        suggestions: []\n      });\n    };\n\n    _this.state = {\n      tagIds: props.tagIds || [],\n      tagsByKey: props.tagsByKey || {},\n      newTag: {\n        name: \"\"\n      },\n      suggestions: []\n    };\n    _this.debounceUpdateTagOrder = debounce(function () {\n      Meteor.call(\"products/updateProductField\", _this.props.product._id, \"hashtags\", _this.state.tagIds);\n    }, 500);\n    return _this;\n  }\n\n  TagListContainer.prototype.componentWillReceiveProps = function () {\n    function componentWillReceiveProps(nextProps) {\n      this.setState({\n        tagIds: nextProps.tagIds || [],\n        tagsByKey: nextProps.tagsByKey || {}\n      });\n    }\n\n    return componentWillReceiveProps;\n  }();\n\n  TagListContainer.prototype.canSaveTag = function () {\n    function canSaveTag(tag) {\n      // Blank tags cannot be saved\n      if (typeof tag.name === \"string\" && tag.name.trim().length === 0) {\n        return false;\n      } // If the tag does not have an id, then allow the save\n\n\n      if (!tag._id) {\n        return true;\n      } // Get the original tag from the props\n      // Tags from props are not mutated, and come from an outside source\n\n\n      var originalTag = this.props.tagsByKey[tag._id];\n\n      if (originalTag && originalTag.name !== tag.name) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return canSaveTag;\n  }();\n\n  TagListContainer.prototype.render = function () {\n    function render() {\n      return React.createElement(\n        DragDropProvider,\n        null,\n        React.createElement(TagList, (0, _extends3.default)({\n          newTag: this.state.newTag,\n          onClick: this.handleEditButtonClick,\n          onClearSuggestions: this.handleClearSuggestions,\n          onGetSuggestions: this.handleGetSuggestions,\n          onMoveTag: this.handleMoveTag,\n          onNewTagSave: this.handleNewTagSave,\n          onNewTagUpdate: this.handleNewTagUpdate,\n          onTagRemove: this.handleTagRemove,\n          onTagSave: this.handleTagSave,\n          onTagUpdate: this.handleTagUpdate,\n          suggestions: this.state.suggestions,\n          tags: this.tags,\n          tooltip: \"Unpublished changes\"\n        }, this.props))\n      );\n    }\n\n    return render;\n  }();\n\n  (0, _createClass3.default)(TagListContainer, [{\n    key: \"productId\",\n    get: function () {\n      if (this.props.product) {\n        return this.props.product._id;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"tags\",\n    get: function () {\n      var _this2 = this;\n\n      if (this.props.editable) {\n        return this.state.tagIds.map(function (tagId) {\n          return _this2.state.tagsByKey[tagId];\n        });\n      }\n\n      return this.props.tagsAsArray;\n    }\n  }]);\n  return TagListContainer;\n}(Component);\n\nTagListContainer.propTypes = {\n  children: PropTypes.node,\n  editable: PropTypes.bool,\n  hasPermission: PropTypes.bool,\n  product: PropTypes.object,\n  tagIds: PropTypes.arrayOf(PropTypes.string),\n  tagsAsArray: PropTypes.arrayOf(PropTypes.object),\n  tagsByKey: PropTypes.object\n};\n\nfunction composer(props, onData) {\n  var tags = props.tags;\n\n  if (props.product) {\n    if (_.isArray(props.product.hashtags)) {\n      tags = _.map(props.product.hashtags, function (id) {\n        return Tags.findOne(id);\n      });\n    }\n  }\n\n  var isEditable = props.editable;\n\n  if (typeof isEditable !== \"boolean\") {\n    isEditable = Reaction.hasPermission(props.permissions);\n  }\n\n  var tagsByKey = {};\n\n  if (Array.isArray(tags)) {\n    for (var _iterator = tags, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var tag = _ref2;\n      tagsByKey[tag._id] = tag;\n    }\n  }\n\n  onData(null, {\n    isProductTags: props.product !== undefined,\n    tagIds: getTagIds({\n      tags: tags\n    }),\n    tagsByKey: tagsByKey,\n    tagsAsArray: tags,\n    editable: isEditable\n  });\n}\n\nvar decoratedComponent = TagListContainer;\ndecoratedComponent = composeWithTracker(composer)(decoratedComponent);\nmodule.export(\"default\", exports.default = decoratedComponent);","map":{"version":3,"sources":["/imports/plugins/core/ui/client/containers/tagListContainer.js"],"names":["React","Component","PropTypes","debounce","update","Meteor","Reaction","i18next","composeWithTracker","TagList","Tags","getTagIds","DragDropProvider","updateSuggestions","term","excludeTags","slug","getSlug","selector","RegExp","Array","isArray","_id","$nin","tags","find","map","tag","label","name","TagListContainer","constructor","props","state","tagIds","tagsByKey","newTag","suggestions","debounceUpdateTagOrder","call","product","componentWillReceiveProps","nextProps","setState","productId","canSaveTag","trim","length","originalTag","handleNewTagSave","error","Alerts","toast","t","handleNewTagUpdate","handleTagSave","handleTagRemove","handleTagUpdate","newState","$set","handleMoveTag","dragIndex","hoverIndex","$splice","handleGetSuggestions","suggestionUpdateRequest","value","handleClearSuggestions","editable","tagId","tagsAsArray","render","handleEditButtonClick","propTypes","children","node","bool","hasPermission","object","arrayOf","string","composer","onData","_","hashtags","id","findOne","isEditable","permissions","isProductTags","undefined","decoratedComponent"],"mappings":"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","file":"/imports/plugins/core/ui/client/containers/tagListContainer.js.map","sourcesContent":["import React, { Component, PropTypes } from \"react\";\nimport debounce from \"lodash/debounce\";\nimport update from \"react/lib/update\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Reaction, i18next } from \"/client/api\";\nimport { composeWithTracker } from \"/lib/api/compose\";\nimport { TagList } from \"../components/tags\";\nimport { Tags } from \"/lib/collections\";\nimport { getTagIds } from \"/lib/selectors/tags\";\nimport { DragDropProvider } from \"/imports/plugins/core/ui/client/providers\";\n\n\nfunction updateSuggestions(term, { excludeTags }) {\n  const slug = Reaction.getSlug(term);\n\n  const selector = {\n    slug: new RegExp(slug, \"i\")\n  };\n\n  if (Array.isArray(excludeTags)) {\n    selector._id = {\n      $nin: excludeTags\n    };\n  }\n\n  const tags = Tags.find(selector).map((tag) => {\n    return {\n      label: tag.name\n    };\n  });\n\n  return tags;\n}\n\nclass TagListContainer extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      tagIds: props.tagIds || [],\n      tagsByKey: props.tagsByKey || {},\n      newTag: {\n        name: \"\"\n      },\n      suggestions: []\n    };\n\n    this.debounceUpdateTagOrder = debounce(() => {\n      Meteor.call(\n        \"products/updateProductField\",\n        this.props.product._id,\n        \"hashtags\",\n        this.state.tagIds\n      );\n    }, 500);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setState({\n      tagIds: nextProps.tagIds || [],\n      tagsByKey: nextProps.tagsByKey || {}\n    });\n  }\n\n  get productId() {\n    if (this.props.product) {\n      return this.props.product._id;\n    }\n    return null;\n  }\n\n  canSaveTag(tag) {\n    // Blank tags cannot be saved\n    if (typeof tag.name === \"string\" && tag.name.trim().length === 0) {\n      return false;\n    }\n\n    // If the tag does not have an id, then allow the save\n    if (!tag._id) {\n      return true;\n    }\n\n    // Get the original tag from the props\n    // Tags from props are not mutated, and come from an outside source\n    const originalTag = this.props.tagsByKey[tag._id];\n\n    if (originalTag && originalTag.name !== tag.name) {\n      return true;\n    }\n\n    return false;\n  }\n\n  handleNewTagSave = (tag) => {\n    if (this.productId && this.canSaveTag(tag)) {\n      Meteor.call(\"products/updateProductTags\", this.productId, tag.name, null, (error) => {\n        if (error) {\n          return Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n        }\n\n        this.setState({\n          newTag: {\n            name: \"\"\n          },\n          suggestions: []\n        });\n\n        return true;\n      });\n    }\n  }\n\n  handleNewTagUpdate = (tag) => {\n    this.setState({\n      newTag: tag\n    });\n  }\n\n  handleTagSave = (tag) => {\n    if (this.productId && this.canSaveTag(tag)) {\n      Meteor.call(\"products/updateProductTags\", this.productId, tag.name, tag._id, (error) => {\n        if (error) {\n          return Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n        }\n\n        this.setState({\n          suggestions: []\n        });\n\n        return true;\n      });\n    }\n  }\n\n  handleTagRemove = (tag) => {\n    if (this.productId) {\n      Meteor.call(\"products/removeProductTag\", this.productId, tag._id, (error) => {\n        if (error) {\n          Alerts.toast(i18next.t(\"productDetail.tagInUse\"), \"error\");\n        }\n      });\n    }\n  }\n\n  handleTagUpdate = (tag) => {\n    const newState = update(this.state, {\n      tagsByKey: {\n        [tag._id]: {\n          $set: tag\n        }\n      }\n    });\n\n    this.setState(newState);\n  }\n\n  handleMoveTag = (dragIndex, hoverIndex) => {\n    const tag = this.state.tagIds[dragIndex];\n\n    // Apply new sort order to variant list\n    const newState = update(this.state, {\n      tagIds: {\n        $splice: [\n          [dragIndex, 1],\n          [hoverIndex, 0, tag]\n        ]\n      }\n    });\n\n    // Set local state so the component does't have to wait for a round-trip\n    // to the server to get the updated list of variants\n    this.setState(newState, () => {\n      // Save the updated positions\n      if (this.props.product) {\n        this.debounceUpdateTagOrder();\n      }\n    });\n  }\n\n  handleGetSuggestions = (suggestionUpdateRequest) => {\n    const suggestions = updateSuggestions(\n      suggestionUpdateRequest.value,\n      { excludeTags: this.state.tagIds }\n    );\n\n    this.setState({\n      suggestions: suggestions\n    });\n  }\n\n  handleClearSuggestions = () => {\n    this.setState({\n      suggestions: []\n    });\n  }\n\n  get tags() {\n    if (this.props.editable) {\n      return this.state.tagIds.map((tagId) => this.state.tagsByKey[tagId]);\n    }\n\n    return this.props.tagsAsArray;\n  }\n\n  render() {\n    return (\n      <DragDropProvider>\n        <TagList\n          newTag={this.state.newTag}\n          onClick={this.handleEditButtonClick}\n          onClearSuggestions={this.handleClearSuggestions}\n          onGetSuggestions={this.handleGetSuggestions}\n          onMoveTag={this.handleMoveTag}\n          onNewTagSave={this.handleNewTagSave}\n          onNewTagUpdate={this.handleNewTagUpdate}\n          onTagRemove={this.handleTagRemove}\n          onTagSave={this.handleTagSave}\n          onTagUpdate={this.handleTagUpdate}\n          suggestions={this.state.suggestions}\n          tags={this.tags}\n          tooltip=\"Unpublished changes\"\n          {...this.props}\n        />\n      </DragDropProvider>\n    );\n  }\n}\n\nTagListContainer.propTypes = {\n  children: PropTypes.node,\n  editable: PropTypes.bool,\n  hasPermission: PropTypes.bool,\n  product: PropTypes.object,\n  tagIds: PropTypes.arrayOf(PropTypes.string),\n  tagsAsArray: PropTypes.arrayOf(PropTypes.object),\n  tagsByKey: PropTypes.object\n};\n\nfunction composer(props, onData) {\n  let tags = props.tags;\n\n  if (props.product) {\n    if (_.isArray(props.product.hashtags)) {\n      tags = _.map(props.product.hashtags, function (id) {\n        return Tags.findOne(id);\n      });\n    }\n  }\n\n  let isEditable = props.editable;\n\n  if (typeof isEditable !== \"boolean\") {\n    isEditable = Reaction.hasPermission(props.permissions);\n  }\n\n  const tagsByKey = {};\n\n  if (Array.isArray(tags)) {\n    for (const tag of tags) {\n      tagsByKey[tag._id] = tag;\n    }\n  }\n\n  onData(null, {\n    isProductTags: props.product !== undefined,\n    tagIds: getTagIds({ tags }),\n    tagsByKey,\n    tagsAsArray: tags,\n    editable: isEditable\n  });\n}\n\nlet decoratedComponent = TagListContainer;\ndecoratedComponent = composeWithTracker(composer)(decoratedComponent);\n\nexport default decoratedComponent;\n"]},"hash":"51713efb7a1249c7262ea980c19b55116b4fc2a5"}
