{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash/every","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_every"}]},{"source":"lodash/isArray","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_isArray"}]},{"source":"lodash/isEmpty","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_isEmpty"}]},{"source":"/lib/collections/schemas","imported":["*"],"specifiers":[{"kind":"namespace","local":"Schemas"}]}],"exports":{"exported":["PropTypes"],"specifiers":[{"kind":"local","local":"PropTypes","exported":"PropTypes"}]}}},"options":{"filename":"/lib/api/prop-types.js","filenameRelative":"/lib/api/prop-types.js","inputSourceMap":{"version":3,"sources":["/lib/api/prop-types.js"],"names":["Schemas","TagSchema","Tag","newContext","PropTypes","props","propName","check","Object","String","validate","Error","arrayOfTags","valid","tag"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAO,AAAK,YAAZ,AAAyB,YAAzB,AAEA,AAAM,AAAY,AAAQ,AAAI,AAE9B;AAAO,IAAM,Y,AAAN,AAAkB,AAEzB;;AAMA,AAAU,AAAM,AAAC,AAAO,AAAa;;;;;aACnC,AAAa,gBAAb,iBACA;QAAM,OAAN,AAAgB;kBAEhB,AAAI,AAAU,AAAM,AAAe,AAAO,AACxC;;MAAI,SAAU,MAAV,AAAmB,AAAM,eAAzB,AAAmB,OAAvB,AAA4C,AAAO,AACjD;QAAO,AAAI,UAAJ,AAAU,qCAAjB,AAAO,AACR;uBACF;AARH,AASC,A;AAED;CAVE,AAAM,EAgBR,AAAU,AAAc,AAAC,AAAO,AAAa,AAC3C,AAAM,AAAO;;;;;;;AACb,AAAM,UAAN,AAAgB,cAAhB;eAEA;AAAI,QAAU,UAAd,AAAI,AAAU,AAAM,AAAe,AAAS,AAAU,AAAM,AAAY,AACtE,AAAM,AAAQ,AAAQ,AAAM,AAAW,AAAC,AAAQ,AAC9C;;MAAO,eAAP,AAAO,AAAU,AAAS,mDAC3B;AAFD,AAAc;gCAId;AAAA,AAAI,AAAU,AAAO,AACnB,AAAO,AAAI,AAAM,AAClB;;yBACF;uBAZH,AAaC","file":"/lib/api/prop-types.js.map","sourcesContent":["import _ from \"lodash\";\nimport * as Schemas from \"/lib/collections/schemas\";\n\nconst TagSchema = Schemas.Tag.newContext();\n\nexport const PropTypes = {};\n\n/**\n * React Component propType validator for a single Tag\n * @param  {Object} props An object containing all props passed into the component\n * @param  {String} propName Name of prop to validate\n * @return {Error|undefined} returns an error if validation us unseccessful\n */\nPropTypes.Tag = (props, propName) => {\n  check(props, Object);\n  check(propName, String);\n\n  if (_.isEmpty(props[propName]) === false) {\n    if (TagSchema.validate(props[propName]) === false) {\n      return new Error(\"Tag must be of type: Schemas.Tag\");\n    }\n  }\n};\n\n/**\n * React Component propType validator for an array of Tags\n * @param  {Object} props An object containing all props passed into the component\n * @param  {String} propName Name of prop to validate\n * @return {Error|undefined} returns an error if validation us unseccessful\n */\nPropTypes.arrayOfTags = (props, propName) => {\n  check(props, Object);\n  check(propName, String);\n\n  if (_.isEmpty(props[propName]) === false && _.isArray(props[propName])) {\n    const valid = _.every(props[propName], (tag) => {\n      return TagSchema.validate(tag);\n    });\n\n    if (valid === false) {\n      return new Error(\"Objects in array must be of type: Schemas.Tag\");\n    }\n  }\n};\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/lib/api/prop-types.js.map","sourceFileName":"/lib/api/prop-types.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"prop-types"},"ignored":false,"code":"module.export({\n  PropTypes: function () {\n    return PropTypes;\n  }\n});\n\nvar _every = void 0;\n\nmodule.importSync(\"lodash/every\", {\n  \"default\": function (v) {\n    _every = v;\n  }\n}, 0);\n\nvar _isArray = void 0;\n\nmodule.importSync(\"lodash/isArray\", {\n  \"default\": function (v) {\n    _isArray = v;\n  }\n}, 1);\n\nvar _isEmpty = void 0;\n\nmodule.importSync(\"lodash/isEmpty\", {\n  \"default\": function (v) {\n    _isEmpty = v;\n  }\n}, 2);\nvar Schemas = Object.create(null);\nmodule.importSync(\"/lib/collections/schemas\", {\n  \"*\": function (v, n) {\n    Schemas[n] = v;\n  }\n}, 3);\nvar TagSchema = Schemas.Tag.newContext();\nvar PropTypes = {};\n\n/**\n * React Component propType validator for a single Tag\n * @param  {Object} props An object containing all props passed into the component\n * @param  {String} propName Name of prop to validate\n * @return {Error|undefined} returns an error if validation us unseccessful\n */PropTypes.Tag = function (props, propName) {\n  check(props, Object);\n  check(propName, String);\n\n  if (_isEmpty(props[propName]) === false) {\n    if (TagSchema.validate(props[propName]) === false) {\n      return new Error(\"Tag must be of type: Schemas.Tag\");\n    }\n  }\n}; /**\n    * React Component propType validator for an array of Tags\n    * @param  {Object} props An object containing all props passed into the component\n    * @param  {String} propName Name of prop to validate\n    * @return {Error|undefined} returns an error if validation us unseccessful\n    */\n\nPropTypes.arrayOfTags = function (props, propName) {\n  check(props, Object);\n  check(propName, String);\n\n  if (_isEmpty(props[propName]) === false && _isArray(props[propName])) {\n    var valid = _every(props[propName], function (tag) {\n      return TagSchema.validate(tag);\n    });\n\n    if (valid === false) {\n      return new Error(\"Objects in array must be of type: Schemas.Tag\");\n    }\n  }\n};","map":{"version":3,"sources":["/lib/api/prop-types.js"],"names":["Schemas","TagSchema","Tag","newContext","PropTypes","props","propName","check","Object","String","validate","Error","arrayOfTags","valid","tag"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAO,AAAK,YAAZ,AAAyB,YAAzB,AAEA,AAAM,AAAY,AAAQ,AAAI,AAE9B;AAAO,IAAM,Y,AAAN,AAAkB,AAEzB;;AAMA,AAAU,AAAM,AAAC,AAAO,AAAa;;;;;aACnC,AAAa,gBAAb,iBACA;QAAM,OAAN,AAAgB;kBAEhB,AAAI,AAAU,AAAM,AAAe,AAAO,AACxC;;MAAI,SAAU,MAAV,AAAmB,AAAM,eAAzB,AAAmB,OAAvB,AAA4C,AAAO,AACjD;QAAO,AAAI,UAAJ,AAAU,qCAAjB,AAAO,AACR;uBACF;AARH,AASC,A;AAED;CAVE,AAAM,EAgBR,AAAU,AAAc,AAAC,AAAO,AAAa,AAC3C,AAAM,AAAO;;;;;;;AACb,AAAM,UAAN,AAAgB,cAAhB;eAEA;AAAI,QAAU,UAAd,AAAI,AAAU,AAAM,AAAe,AAAS,AAAU,AAAM,AAAY,AACtE,AAAM,AAAQ,AAAQ,AAAM,AAAW,AAAC,AAAQ,AAC9C;;MAAO,eAAP,AAAO,AAAU,AAAS,mDAC3B;AAFD,AAAc;gCAId;AAAA,AAAI,AAAU,AAAO,AACnB,AAAO,AAAI,AAAM,AAClB;;yBACF;uBAZH,AAaC","file":"/lib/api/prop-types.js.map","sourcesContent":["import _ from \"lodash\";\nimport * as Schemas from \"/lib/collections/schemas\";\n\nconst TagSchema = Schemas.Tag.newContext();\n\nexport const PropTypes = {};\n\n/**\n * React Component propType validator for a single Tag\n * @param  {Object} props An object containing all props passed into the component\n * @param  {String} propName Name of prop to validate\n * @return {Error|undefined} returns an error if validation us unseccessful\n */\nPropTypes.Tag = (props, propName) => {\n  check(props, Object);\n  check(propName, String);\n\n  if (_.isEmpty(props[propName]) === false) {\n    if (TagSchema.validate(props[propName]) === false) {\n      return new Error(\"Tag must be of type: Schemas.Tag\");\n    }\n  }\n};\n\n/**\n * React Component propType validator for an array of Tags\n * @param  {Object} props An object containing all props passed into the component\n * @param  {String} propName Name of prop to validate\n * @return {Error|undefined} returns an error if validation us unseccessful\n */\nPropTypes.arrayOfTags = (props, propName) => {\n  check(props, Object);\n  check(propName, String);\n\n  if (_.isEmpty(props[propName]) === false && _.isArray(props[propName])) {\n    const valid = _.every(props[propName], (tag) => {\n      return TagSchema.validate(tag);\n    });\n\n    if (valid === false) {\n      return new Error(\"Objects in array must be of type: Schemas.Tag\");\n    }\n  }\n};\n"]},"hash":"cdb78235b4b32f552a32f468b2c19291fdd10fba"}
