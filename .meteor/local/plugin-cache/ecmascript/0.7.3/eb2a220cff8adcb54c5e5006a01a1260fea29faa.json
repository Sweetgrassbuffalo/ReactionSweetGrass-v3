{"metadata":{"usedHelpers":["classCallCheck","toConsumableArray","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/ongoworks:security/lib/server/Security.Rule.js","filenameRelative":"/packages/ongoworks:security/lib/server/Security.Rule.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/ongoworks:security/lib/server/Security.Rule.js.map","sourceFileName":"/packages/ongoworks:security/lib/server/Security.Rule.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"Security.Rule"},"ignored":false,"code":"var _toConsumableArray2 = require(\"babel-runtime/helpers/toConsumableArray\");\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nSecurity.Rule = function () {\n  function _class(types) {\n    (0, _classCallCheck3.default)(this, _class);\n    if (!_.isArray(types)) types = [types];\n    this._types = types;\n    this._restrictions = [];\n  }\n\n  _class.prototype.collections = function () {\n    function collections(_collections) {\n      var _this = this;\n\n      // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n      // an array of them. If it's a single collection, convert it to a one-item array.\n      if (!_.isArray(_collections)) _collections = [_collections]; // Keep list keyed by collection name\n\n      _.each(_collections, function (collection) {\n        if (!(collection instanceof Mongo.Collection) && // CollectionFS has underlying collection on `files` property\n        !(collection.files instanceof Mongo.Collection)) {\n          throw new Error(Security.errorMessages.collectionsArg);\n        } // CollectionFS has underlying collection on `files` property\n\n\n        var collectionName = getCollectionName(collection);\n        rulesByCollection[collectionName] = rulesByCollection[collectionName] || [];\n        rulesByCollection[collectionName].push(_this);\n      });\n\n      this._collections = _collections;\n      return this;\n    }\n\n    return collections;\n  }();\n\n  _class.prototype.combinedFetch = function () {\n    function combinedFetch() {\n      // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n      // or a function that takes the argument passed to the restriction method and returns an array.\n      var fetch = [];\n\n      _.every(this._restrictions, function (restriction) {\n        if (_.isArray(restriction.definition.fetch)) {\n          fetch = _.union(fetch, restriction.definition.fetch);\n        } else if (typeof restriction.definition.fetch === \"function\") {\n          fetch = _.union(fetch, restriction.definition.fetch(restriction.arg));\n        } else if (!restriction.definition.hasOwnProperty('fetch')) {\n          // If `fetch` property isn't present, we should fetch the full doc.\n          fetch = null;\n          return false; // Exit loop\n        }\n\n        return true;\n      });\n\n      return fetch;\n    }\n\n    return combinedFetch;\n  }();\n\n  _class.prototype.allowInClientCode = function () {\n    function allowInClientCode() {\n      if (!this._collections || !this._types) throw new Error(Security.errorMessages.noCollectionOrType);\n      ensureSecureDeny(this._collections, this._types);\n    }\n\n    return allowInClientCode;\n  }();\n\n  _class.prototype.allow = function () {\n    function allow(type, collection, userId, doc, modifier) {\n      for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n        args[_key - 5] = arguments[_key];\n      }\n\n      var fields = void 0;\n      if (type === 'update') fields = computeChangedFieldsFromModifier(modifier); // Loop through all defined restrictions. Restrictions are additive for this chained\n      // rule, so if any allow function returns false, this function should return false.\n\n      return _.every(this._restrictions, function (restriction) {\n        var _restriction$definiti;\n\n        // Clone the doc in case we need to transform it. Transformations\n        // should apply to only the one restriction.\n        var loopDoc = _.clone(doc); // If transform is a function, apply that\n\n\n        var transform = restriction.definition.transform;\n\n        if (transform !== null) {\n          transform = transform || collection._transform;\n\n          if (typeof transform === 'function') {\n            var addedRandomId = false;\n\n            if (type === 'insert' && !loopDoc._id) {\n              // The wrapped transform requires an _id, but we\n              // don't have access to the generatedId from Meteor API,\n              // so we'll fudge one and then remove it.\n              loopDoc._id = Random.id();\n              addedRandomId = true;\n            }\n\n            loopDoc = transform(loopDoc);\n            if (addedRandomId) delete loopDoc._id;\n          }\n        }\n\n        return (_restriction$definiti = restriction.definition).allow.apply(_restriction$definiti, [type, restriction.arg, userId, loopDoc, fields, modifier].concat(args));\n      });\n    }\n\n    return allow;\n  }();\n\n  return _class;\n}();\n\nfunction ensureSecureDeny(collections, types) {\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(collections, types);\n\n  _.each(types, function (t) {\n    _.each(collections, function (collection) {\n      ensureCreated('deny', [collection], [t], null, function () {\n        var _Security$can;\n\n        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        var userId = args.shift(); // If type is update, remove the `fields` argument. We will create our own\n        // for consistency.\n\n        if (t === 'update') args = [args[0], args[2]];\n        return !(_Security$can = Security.can(userId))[t].apply(_Security$can, (0, _toConsumableArray3.default)(args)).for(collection).check();\n      });\n    });\n  });\n}\n\nfunction computeChangedFieldsFromModifier(modifier) {\n  var fields = []; // This is the same logic Meteor's mongo package uses in\n  // https://github.com/meteor/meteor/blob/devel/packages/mongo/collection.js\n\n  _.each(modifier, function (params) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.')); // record the field we are trying to change\n\n      if (!_.contains(fields, field)) fields.push(field);\n    });\n  });\n\n  return fields;\n}","map":{"version":3,"sources":["/packages/ongoworks:security/lib/server/Security.Rule.js"],"names":["Security","Rule","types","_","isArray","_types","_restrictions","collections","each","collection","Mongo","Collection","files","Error","errorMessages","collectionsArg","collectionName","getCollectionName","rulesByCollection","push","_collections","combinedFetch","fetch","every","restriction","definition","union","arg","hasOwnProperty","allowInClientCode","noCollectionOrType","ensureSecureDeny","allow","type","userId","doc","modifier","args","fields","computeChangedFieldsFromModifier","loopDoc","clone","transform","_transform","addedRandomId","_id","Random","id","ensureDefaultAllow","ensureCreated","t","shift","can","for","check","params","keys","field","indexOf","substring","contains"],"mappings":"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","file":"/packages/ongoworks:security/lib/server/Security.Rule.js.map","sourcesContent":["Security.Rule = class {\n  constructor(types) {\n    if (!_.isArray(types)) types = [types];\n    this._types = types;\n    this._restrictions = [];\n  }\n\n  collections(collections) {\n    // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n    // an array of them. If it's a single collection, convert it to a one-item array.\n    if (!_.isArray(collections)) collections = [collections];\n\n    // Keep list keyed by collection name\n    _.each(collections, collection => {\n      if (!(collection instanceof Mongo.Collection) &&\n          // CollectionFS has underlying collection on `files` property\n        !(collection.files instanceof Mongo.Collection)) {\n        throw new Error(Security.errorMessages.collectionsArg);\n      }\n      // CollectionFS has underlying collection on `files` property\n      const collectionName = getCollectionName(collection);\n      rulesByCollection[collectionName] = rulesByCollection[collectionName] || [];\n      rulesByCollection[collectionName].push(this);\n    });\n\n    this._collections = collections;\n\n    return this;\n  }\n\n  combinedFetch() {\n    // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n    // or a function that takes the argument passed to the restriction method and returns an array.\n    let fetch = [];\n    _.every(this._restrictions, restriction => {\n      if (_.isArray(restriction.definition.fetch)) {\n        fetch = _.union(fetch, restriction.definition.fetch);\n      } else if (typeof restriction.definition.fetch === \"function\") {\n        fetch = _.union(fetch, restriction.definition.fetch(restriction.arg));\n      } else if (!restriction.definition.hasOwnProperty('fetch')) {\n        // If `fetch` property isn't present, we should fetch the full doc.\n        fetch = null;\n        return false; // Exit loop\n      }\n      return true;\n    });\n    return fetch;\n  }\n\n  allowInClientCode() {\n    if (!this._collections || !this._types) throw new Error(Security.errorMessages.noCollectionOrType);\n    ensureSecureDeny(this._collections, this._types);\n  }\n\n  allow(type, collection, userId, doc, modifier, ...args) {\n    let fields;\n    if (type === 'update') fields = computeChangedFieldsFromModifier(modifier);\n\n    // Loop through all defined restrictions. Restrictions are additive for this chained\n    // rule, so if any allow function returns false, this function should return false.\n    return _.every(this._restrictions, restriction => {\n      // Clone the doc in case we need to transform it. Transformations\n      // should apply to only the one restriction.\n      let loopDoc = _.clone(doc);\n\n      // If transform is a function, apply that\n      let transform = restriction.definition.transform;\n      if (transform !== null) {\n        transform = transform || collection._transform;\n        if (typeof transform === 'function') {\n          let addedRandomId = false;\n          if (type === 'insert' && !loopDoc._id) {\n            // The wrapped transform requires an _id, but we\n            // don't have access to the generatedId from Meteor API,\n            // so we'll fudge one and then remove it.\n            loopDoc._id = Random.id();\n            addedRandomId = true;\n          }\n          loopDoc = transform(loopDoc);\n          if (addedRandomId) delete loopDoc._id;\n        }\n      }\n\n      return restriction.definition.allow(type, restriction.arg, userId, loopDoc, fields, modifier, ...args);\n    });\n  }\n}\n\nfunction ensureSecureDeny(collections, types) {\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(collections, types);\n\n  _.each(types, t => {\n    _.each(collections, collection => {\n      ensureCreated('deny', [collection], [t], null, function (...args) {\n        const userId = args.shift();\n\n        // If type is update, remove the `fields` argument. We will create our own\n        // for consistency.\n        if (t === 'update') args = [args[0], args[2]];\n\n        return !Security.can(userId)[t](...args).for(collection).check();\n      });\n    });\n  });\n}\n\nfunction computeChangedFieldsFromModifier(modifier) {\n  var fields = [];\n  // This is the same logic Meteor's mongo package uses in\n  // https://github.com/meteor/meteor/blob/devel/packages/mongo/collection.js\n  _.each(modifier, function (params) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1)\n        field = field.substring(0, field.indexOf('.'));\n\n      // record the field we are trying to change\n      if (!_.contains(fields, field))\n        fields.push(field);\n    });\n  });\n  return fields;\n}\n"]},"hash":"eb2a220cff8adcb54c5e5006a01a1260fea29faa"}
