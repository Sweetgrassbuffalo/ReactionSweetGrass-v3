{"metadata":{"usedHelpers":["createClass","classCallCheck","extends","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"react","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"React"}]},{"source":"react-router","imported":["Route"],"specifiers":[{"kind":"named","imported":"Route","local":"Route"}]},{"source":"history/createBrowserHistory","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createBrowserHistory"}]},{"source":"history/createMemoryHistory","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"createMemoryHistory"}]},{"source":"path-to-regexp","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"pathToRegexp"}]},{"source":"query-parse","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"queryParse"}]},{"source":"immutable","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Immutable"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/gadicc:blaze-react-component","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Blaze"}]},{"source":"meteor/tracker","imported":["Tracker"],"specifiers":[{"kind":"named","imported":"Tracker","local":"Tracker"}]},{"source":"/lib/collections","imported":["Packages","Shops"],"specifiers":[{"kind":"named","imported":"Packages","local":"Packages"},{"kind":"named","imported":"Shops","local":"Shops"}]},{"source":"/imports/plugins/core/layout/lib/components","imported":["getComponent"],"specifiers":[{"kind":"named","imported":"getComponent","local":"getComponent"}]},{"source":"/imports/plugins/core/layout/lib/blazeLayout","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"BlazeLayout"}]},{"source":"./hooks","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Hooks"}]}],"exports":{"exported":["history","ReactionLayout","options"],"specifiers":[{"kind":"local","local":"history","exported":"history"},{"kind":"local","local":"ReactionLayout","exported":"ReactionLayout"},{"kind":"local","local":"options","exported":"options"}]}}},"options":{"filename":"/imports/plugins/core/router/lib/router.js","filenameRelative":"/imports/plugins/core/router/lib/router.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/core/router/lib/router.js"],"names":["React","Route","createBrowserHistory","createMemoryHistory","pathToRegexp","queryParse","Immutable","Meteor","Blaze","Tracker","Packages","Shops","getComponent","BlazeLayout","Hooks","history","currentRoute","Map","routerReadyDependency","Dependency","routerChangeDependency","isClient","Router","routes","_routes","_initialized","ready","depend","triggerRouterReady","changed","triggers","current","toJS","setCurrentRoute","routeData","getRouteName","options","name","getParam","params","undefined","getQueryParam","query","watchPathChange","pathFor","path","foundPath","find","pathObject","hash","toPath","compile","route","compiledPath","queryString","toString","length","go","actualPath","startsWith","window","push","replace","reload","fullPath","isActiveClassName","routeName","group","prefix","routeDef","hasRoutePermission","Reaction","hasPermission","userId","getRegistryRouteName","packageName","registryItem","template","split","selectLayout","layout","setLayout","setWorkflow","currentLayout","Session","get","currentWorkflow","workflow","enabled","ReactionLayout","shop","findOne","getShopId","layoutName","workflowName","layoutStructure","layoutHeader","layoutFooter","notFound","dashboardHeader","dashboardControls","dashboardHeaderControls","adminControlsFooter","sortedLayout","sort","prev","next","priority","foundLayout","x","structure","optionsHasTemplate","Template","component","props","createElement","initPackageRoutes","reactionContext","pkgs","fetch","getShopPrefix","reactRouterRoutes","shopSub","subscribe","shopCount","Counts","indexLayout","indexRoute","notFoundLayout","notFoundRoute","pkg","newRoutes","registry","Array","from","meta","reactionLayout","newRouteConfig","triggersEnter","triggersExit","uniqRoutes","Set","index","substring","reactComponents"],"mappings":";;;;;;;;;;;;;;AAAA,OAAA,AAAO;AAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;G,AAClB,AAAS,AAAa,AACtB,AAAO,AAA0B,AACjC,AAAO,AAAyB,AAChC,AAAO,AAAkB,AACzB,AAAO,AAAgB,AACvB,AAAO,AAAe,AACtB,AAAS,AAAc,AACvB,AAAO,AAAW,AAClB,AAAS,AAAe,AACxB,AAAS,AAAU,AAAa,AAChC,AAAS,AAAoB,AAC7B,AAAO,AAAiB,AACxB,AAAO,AAAW,AAGlB,AAAO,AAAI,AAEX,AACA;IACA,AAAI,AAAe,AAAU;AAC7B,AAAM,AAAwB,AAAI,AAAQ;AAC1C,A,AAAM,AAAyB,AAAI,AAAQ,AAE3C;;AACA,AAAI,IAAJ,AAAW,AAAU;AACnB,IAAU,yBAAV,YADF,AAEC,AAAM,cACL,AAAU;;AACX,AAED,A;;OACA;AAAM,oCAAN,AAAa,AACX;AAAA,AAAO,AAAU,AACjB,AAAO,AAAQ,EACf,AAAO,AAAS,AAChB;;;;;;;;;;4BAQA;AAAO,oBAAP,AAA4B,AAC1B;AAAA,AAAsB,AACvB;;;OANC;;;;kCAQF;AAAA,AAAW,AAAW,4BACpB;AAAA,AAAO,AACR;;;;;;uBAMD;AAAO,0BAAP,AAAuB,AAAW,AAChC;AAAA,AAAe,AAAU,AAAI,AAC7B,AAAuB,AACxB;;;;;;;mCAED;AAAA,AAAO,AAAe,6BACpB;AAAA,AAAM,AAAU,AAAO,AAEvB,AAAO,AAAQ,AAAW,AAAQ,AAAQ,AAAQ,AACnD;;;;;;;2BAED,AAAO,AAAS,AAAM,AACpB;qBAAuB,WAAvB,wBACA;AAAA,AAAM,AAAU,AAAO,AAEvB,AAAO,AAAQ,AAAU,AAAQ,AAAO,AAAS,AAClD;;;;;;;6BAED;AAAO,oBAAP,AAAqB,OAArB,AAA2B,AACzB,AAAuB,AACvB;AAAM,qBAAU,AAAO,UAAvB,AAAgB,wBAEhB;AAAA,AAAO,AAAQ,AAAS,AAAQ,AAAM,AAAS,AAChD;;;;;;iCAED;AAAA,AAAO,6BAAkB,AACvB;2BAAA,AAAuB,AACxB;qDAnDU,A,AAsDb;;;;;;;;;;;;;;;;qBAlCE;AAAO,aAAP,AAAiB,AACf;AAAA,AAAO,AAAa,AACrB;;;KAuCH,AAAO,AAAU,AAAC,AAAM,AAAU,AAAO,AACvC,AACA,AACA,AACA,AACA;;;;;;;;AAlEW,AAIX,AAAO,AAAU,AAAO,AAAO,iBAC/B;OAAO,QAAP,AAAsB;gBAEtB;OAAA,AAAO,AAAQ;sBACb,AAAsB,AACtB,AAAO,AAAO,AACf;;AAyDD;AACA;AACA;AACA;AAEA;AAAM,AAAY,AAAO,AAAO,AAAK,AAAC,AAAe,AACnD;AACA;AAAA,AAAI,AAAW,AAAQ,AAAS,AAAM,AACpC;AAAA,AAAO,AACR;;AACD,AAAO,AACR;AAND,AAAkB;AAQlB;AAAI,QAAJ,AAAe,kCACb;aACA;AACA;;WACA;AACA,AACA;;MAAM;AAGN;AATa,AASb,AAAM,AAAS,AAAa,AAAQ,AAAU,AAE9C;AACA;AAZa,AAYb,AAAM,AAAe,AAAO,AAE5B,AACA;;0CAfa,AAgBb,AAAM,AAAc,AAAW,AAAS,AAAK,AAE7C,IACA;;AAAI,QAAO,SAAP,AAAuB,aAAvB,QAAmC,UAAvC,AAAmD,AAAQ,AACzD,AAAQ,AAAE,AAAa,AAAG,AAAY,AACvC,QArBY,AAuBb;;8BACA,OAAA,AAAO,AACR;;;+CA5CH,AA8CE,AAAO,AACR;;+DAGD;AAAA,AAAO,AAAK,AAAC,aAAD,AAAO,AAAQ,qBAAf,AAAyB,AACnC;AAAA,AAAI,AAEJ,KAlCe,AAMb,AAAa,AAAW,AAAQ,AAAQ,AAExC,CA0BF,AAAI,AAAO,AAAS,AAAY,AAAK,AAAW,AAAM,AACpD;;;WAAA,AAAa,AACd;AAFD,AAEO,AACL,AAAa,AAAO,AAAQ,AAAM,AAChC;;SAAM,AACJ;AADI,AACD,AACH;;AAHJ,AAAa,AAAqB,2CAMnC;MAED;;MAAA,AAAI,OAAQ,2CACV;AAAA,AAAQ,iBAAR,AAAa,AACd;SAhBH,AAiBC;;AAED,AAAO,uCAAP,AAAiB,AAAC,AAAM,AAAQ,AAAU,AACxC;AAAM,AAAa,AAAO,AAAQ,AAAM,AACtC,AAAM,AACJ,AAAG,AACH;;;AAHoC,AAChC;;AADR,AAAmB;iBAOnB;AAAA,AAAI,AAAQ,AACV;AAAA,AAAQ,AAAQ,AACjB;;AAVH,AAWC;;AAED,AAAO,AAAS,AAAM,AACpB,AAAM,qCAAN,AAAgB,AAAO;AADzB,AAGE,AAAI,AAAQ,AACV,AAAQ,AAAQ,AAAQ,AAAM,AAAY,AAC3C,AACF;;AAND;;AAQA,A;;;;;;uBAOA;;MAAO,QAAP,AAA2B,AAAC,AAAc,AACxC;AAAM,YAAU,QAAO,QAAP,MAAhB,YACA;AAAA,AAAM,AAAQ,AAAQ,AAAM,AAC5B;AAAA,AAAM,AAAO,AAAQ,AAAM,AAC3B,AAAI,GAEJ,AAAI,AAAS,AAAM,AAAQ,AACzB,AAAS,AAAQ,AAAM,AAAM,AAC9B,AAAM,AACL,AAAS,AACV;;;;;;;;AAED,AAAI,OAAA,AAAO,AAAS,8BAApB,AAA8B,WAC5B;MAAM,UAAW,OAAjB,AAAiB,AAAK,AAAQ,AAAS,AAAK,AAC5C;MAAO,gBAAa,MAApB,AAAO,AAAyB,AAAW,AAC5C;;MAfH,AAiBE,AAAO,AACR;;AAED,A;;;;;;gCAMA;AAAS,wBAAT,AAA4B,QAAO,cACjC;AAAM,WAAY,aAAlB,AAAwB;AAExB,AAAI,AAAc,AAAW,AAAc,AAAa,AACtD;;SAAA,AAAO,AACR;AAFD,AAEO,AAAI,AAAO,AAAS,AAAc,AAAW,AAAO,AAAW,AACpE,AAAO,GACR,AAED,AAAO,AACR,AAGD,A;;;;;;;;;;;;wEAQA;AAAS,WAAT,AAA8B,AAAa,AAAc,AACvD;AAAA,AAAI,AACJ;;AAAI,SAAJ,AAAmB,AAAc,AAC/B;AAAA,AAAI,AAAa,AAAM,AACrB,AAAY,AAAa,AAC1B,AAAM,AAAI,AAAa,AAAU,EAHH,AAGxB,AACL,AAAa,AAAE,AAAY,AAAG,AAAa,AAAS,AACrD,AAAM,AACL,AAAY,AACb,AACD,AACA,AAAY,AAAU,AAAM,AAAK,AACjC,AAAO;;;;;;;;;AACR;MACD;;MAAA,AAAO;;;;;;;KAGT,A,AAFC,CASD;;;AAAS,gBAAT,AAAsB,UAAtB,AAA8B,WAA9B,AAAyC,AAAa,AACpD;AAAM,WAAN,AAAsB,AAAa,AAAQ,AAAI,AAAqB,AACpE;AAAA,AAAM,AAAkB,AAAe,AAAQ,AAAI,AAAuB;;SAC1E;AAAA,AAAI,AAAO,AAAW,AAAiB,AAAO,AAAa,AAAmB,AAAO,AAAY,AAAM,AACrG,AAAO,E,AACR,AACD,AAAO,AACR,AAED;;;;;;;;;;;;;WAQA;AAAO,AAAS,AAAe,AAAU,AAAI,AAC3C;;SACA;AAF2C,AAG3C,AAAM,AAAO,AAAM,AAAQ,AAAO,AAAS,AAE3C,EAL2C,AAM3C,AACA,AACA,AAAM,AAAa,AAAQ,AAAU,AAAQ,AAAI,AAAqB,AACtE,AAAM,AAAe,AAAQ,AAAY,AAAQ,AAAI,AAAuB,AAE5E,AACA,AACA,AAAI,AAAkB,AACpB;;;;;;;;;AAAU,SADU;AAEpB;AAFoB,AAEN,AACd;AAHoB,AAGN,AACd;MAAU,aAJU,wBAAA,AAKpB,AAAiB,AACjB,cANoB,AAMD,AACnB;AAPoB,AAOK,AACzB;AARoB,AAQC;;AArBoB,AAa3C,AAWA;4EACA,AAAI,AAAM,AACR,gBAAA,AAAM,AAAe,AAAK,AAAO,AAAK,AAAC,AAAM,AAAS,AAAK,AAAW,AAAK,AAC3E;AAAA,AAAM,AAAc,AAAa,AAAK,AAAC,AAAM,AAAa,AAAG,AAAY;;;AAErE,cAAJ,AAAmB,AAAY,AAAW,AACxC;kBAAkB,AAChB;AAAG,kBADa,AACD;AADjB,cAGD;qBAjCwC,AAkC1C;AAED,uBACA;6BACA;yBACA,AACA,AACA;AAZE,KAaF;;YACA;;kCACA;;;;;;8CACA;AAAA,AAAM,AAAqB,AAAO,AAAQ,AAAa,+DAEvD,AAAI,AAAoB,AACtB;AAAA,AAAgB,AAAW,AAAQ,AACpC;AAjD0C,AAmD3C,AACA;AACA;AAAA,AAAI,AAAC,AAAS,AAAgB,AAAa,AAAC,AAAa,AAAgB,AAAW,AAClF;AAAA,AACE,AAAC,AAAM,AAAS,AAAC,AAAgB,AAEpC;AAzD0C,AA2D3C;;AACA;AAAO,AACL;AADK,AACM,AACX;;;MAAW,AAAC,AAAU,iDAAE,AACtB;;MAAM,AAAQ,oBAAd,AAAc,AAAO,AAAU,AAC/B;AAAM,oBAAY,mBAChB;AAHkB,AAEpB,AAAkB,AACb,AAGL,AACA;AACA;;;OAAI,SAAmB,gBAAnB,AAA8B,aAA9B,CAAuC,AAAM,aAAN,AAAe,gBAA1D,AAAuE,WACrE;AAAA,AAAU,AAAW,AACtB;gCAED;;AAAA,AAAI,AAAa,AAAa,AAC5B,AAAO,AAAM,AAAc,AAAa,AAAa,AACnD,IADmD,AAChD,AACH;;;;AAFF,AAAO,eAIR;AALD,AAKO,yBAAI,OAAS;AAAb,AAAI,AAAsB,AAC/B;UACE,AAAC,eAAD,AACE,AAAI,UAFR,AACE,AACE,AACA,AAAc,AAAC,AAGpB;iDA1BL,AAAO,AA4BH,AAAO,AAAC,AAAM,AAAS,AAAC,AAAU,AACnC,kBAEJ,A,AAED;;;;;;;;wFAOA,AAAO;qBAAP,AAA2B,AAAC,AAAY,AACtC,AAAO,AAAW,AAAQ,AAC1B;;AAAO,aAAP,IAAA,AAAgB,sBAEhB;AAAA,AAAM,AAAO,AAAS,AAAO,AAC7B,AAAM,mCAAN,AAAe,AAAO,AAAS,AAC/B,AAAM,wCANgC,AAMtC,AAA0B,AAE1B,AACA;yBACA,AACA;;AAAA,AAAM,AAAU,AAAO,AAAU,AACjC;;AAAI,iCAAA,AAAQ;AAAZ,AAAqB,4BACnB;;AADmB,AAEnB,AAAM,AAAY,AAAO,AAAI,AAE7B;AAzCyD,AAExC;AAwCjB,AAAM,AAAc,AAAe,AAAQ;;AAC3C,AAAM,AAAa,AACjB,AAAO,AACP,AAAM,AACN,AAAS,AACP,AAAM,AACN,AAAG,AAAQ,AACX,AAAW,AAAY;;;;;;UACZ,8BAAY;4BAPR;AAAnB,kBAWA,AAAkB,AAChB,AAAC,AACC,AAAM,AAAC,AACP,AAAI,AACJ,AAAK,AACL,AAAO,AAAC,AAAY,AAIxB;MAAM,gBAAiB,OAAe,AAAE;MAAU,yBAAZ;AAAtC,AAAuB,0BACvB,AAAM,AAAgB,AACpB,GAnBS,CAkBW,AACb,AACP;AAFoB,AAEd,AACN;AAAS,AACP;;MAAM,iBADC,UAEP;;MAAG;AAFI,AAGI,AAAe,AAC1B;QAAW,uBAPO,AAGX,AAImB,gBAP9B,AAWA;;QAAkB,cAAlB,AACE,AAAC,AACC,AAAI,uBAFR,AACE,AAEE,AAAK,AACL,AAAO,AAAC,AAAe,AAI3B;QAAA,AAAO,AAAO;AACP,aA/CY,AA+CnB,AAAc,AAAK,AAEnB;YACA;AAAA,AAAK,AAAM,AAAO,AAAM,AACtB;AAAM,cADgB,AACtB,AAAkB,AAClB;iBACA;AAAI,AAAI,mBAAJ,AAAgB,AAAI,YAAxB,AAAiC,AAC/B;AAAM,mBAAW,YAAjB,AAAiB,AAAM,AAAK,AAAI,AAChC,AAAK,AAAM,AAAgB,AAAU,AACnC,AACA;;AAXN,AAAmB,AACnB;AAUU,sBAAJ,AAAiB,AAAO,AACtB,yBAAM,AACJ;aADI,AAEJ;WAFI,AAGJ;YAHI,AAIJ;cAJI,YADgB,AACtB,AAAM,AAKJ,AACE,AAEJ,AACA;;QAAM,AAAO;AAAqB,AAAI,gBAVhB,AAUtB,AAAa,AAA+B,AAE5C,AACA;;;aACA;YAAM,AAAiB,AAAe,AAAE;AAAF,AAAY;cAAZ,AAAsB;wBAAtB;AAAtC,AAAuB,kCACvB;AAAM,kCAAiB,AACrB,AACA,AACA,AAAS,AACP;;;AADO,sBAEP,yBAFO,AAGP;WAHO,AAIP;YAJO,AAKP;6BALO,AAKQ,AAAO,AAAM,AAAI,AAAW,AAC3C,AAAc,AAAO,AAAM,AAAI,AAAU,AACzC,AAAW,AAAe,AAC1B,AAAW,AAAe;;uBAXP;WAfD,AAetB,AAeA,YACA,gBAAA,AAAU,AAAK,AAChB;;AAlCkC,AAkCjC;;;;;;;;;;;;;sBACH,IArC8B,AAqC7B,AAEF;;;sCAEA;;;;;;;;;;;;;;;;;;AACA,AAAM,AAAa,AAAI,AAAI,AAC3B,AAAI,gBAAJ,AAAY,OAIV,AAAM,AAAQ,AAEd;gBALF,AAAK;gBAAL,AAAW,AAAS,AAAY,AAC9B;gBACA;gBACA,kCAEA,AAAI,AAAM,AAAM,AAAU,AAAG,AAAO,AAAK,AACvC;;gBAAA,AAAM,OAAN,AAAc,AAAM,AAAM,+BAD5B,AAEE,AAAM,AAAM,AAAS,AACtB,eAAM,AAAI,AAAa,AAAG,AACzB;AADK,AACL,AAAM,AAAM,AAAS,AACtB;;AAAM;;;AACL;;gBAAA,AAAM,AAAM,AAAS;AAXO,AAY5B,AAAM,AAAS,AAAE,AAAO,AAAE,AAAM,AAAM,AACvC,AAED;;;AACA;AAAA,AAAkB,AAChB,AAAC,AACC,AAAI,AAAE,AAAE,AAAI,AAAK,AAAG,AAAM,AAAK,AAAG,AAAQ,AAC1C,AAAK,AAAC,AAAM,AACZ,AAAM,AAAC,AACP,AAAO,AAAC,AAAM,AAAQ,AAI1B;AAAA,AAAO,AAAO,AAAK,AACpB;AACF;2DA5HgB,AA6HlB,AAAC;;;0CAEF,AAAO,AAAe,AACtB,AAAO,AAAkB,AACzB,AAAO,AAAU,AAAO,AAExB;;AAvBQ,AACA,eAsBR,AAAsB,AACvB;;2BAhJH,AAiJC;;;SAxCO,CA2CR,AAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA1GA,AAEW,AAClB;;;;;;;;CApBA;;yBAnZR","file":"/imports/plugins/core/router/lib/router.js.map","sourcesContent":["import React from \"react\";\nimport { Route } from \"react-router\";\nimport createBrowserHistory from \"history/createBrowserHistory\";\nimport createMemoryHistory from \"history/createMemoryHistory\";\nimport pathToRegexp from \"path-to-regexp\";\nimport queryParse from \"query-parse\";\nimport Immutable from \"immutable\";\nimport { Meteor } from \"meteor/meteor\";\nimport Blaze from \"meteor/gadicc:blaze-react-component\";\nimport { Tracker } from \"meteor/tracker\";\nimport { Packages, Shops } from \"/lib/collections\";\nimport { getComponent } from \"/imports/plugins/core/layout/lib/components\";\nimport BlazeLayout from \"/imports/plugins/core/layout/lib/blazeLayout\";\nimport Hooks from \"./hooks\";\n\n\nexport let history;\n\n// Private vars\n// const currentRoute = new ReactiveVar({});\nlet currentRoute = Immutable.Map();\nconst routerReadyDependency = new Tracker.Dependency;\nconst routerChangeDependency = new Tracker.Dependency;\n\n// Create history object depending on if this is client or server\nif (Meteor.isClient) {\n  history = createBrowserHistory();\n} else {\n  history = createMemoryHistory();\n}\n\n// Base router class (static)\nclass Router {\n  static history = history\n  static Hooks = Hooks\n  static routes = []\n  static _routes = Router.routes // for legacy\n  static _initialized = false;\n\n  static ready() {\n    routerReadyDependency.depend();\n    return Router._initialized;\n  }\n\n  static triggerRouterReady() {\n    routerReadyDependency.changed();\n  }\n\n  static get triggers() {\n    return Hooks;\n  }\n\n  static current() {\n    return currentRoute.toJS();\n  }\n\n  static setCurrentRoute(routeData) {\n    currentRoute = Immutable.Map(routeData);\n    routerChangeDependency.changed();\n  }\n\n  static getRouteName() {\n    const current = Router.current();\n\n    return current.options && current.options.name || \"\";\n  }\n\n  static getParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n\n    return current.params && current.params[name] || undefined;\n  }\n\n  static getQueryParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n\n    return current.query && current.query[name] || undefined;\n  }\n\n  static watchPathChange() {\n    routerChangeDependency.depend();\n  }\n}\n\n/**\n * pathFor\n * @summary get current router path\n * @param {String} path - path to fetch\n * @param {Object} options - url params\n * @return {String} returns current router path\n */\nRouter.pathFor = (path, options = {}) => {\n  // const params = options.hash || {};\n  // const query = params.query ? Router._qs.parse(params.query) : {};\n  // // prevent undefined param error\n  // for (const i in params) {\n  //   if (params[i] === null || params[i] === undefined) {\n  //     params[i] = \"/\";\n  //   }\n  // }\n  // return Router.path(path, params, query);\n\n  const foundPath = Router.routes.find((pathObject) => {\n    // console.log(pathObject.options.name, path);\n    if (pathObject.options.name === path) {\n      return true;\n    }\n    return false;\n  });\n\n  if (foundPath) {\n    // Pull the hash out of options\n    //\n    // This is becuase of Spacebars that we have hash.\n    // Spacebars takes all params passed into a template tag and places\n    // them into the options.hash object. This will also include any `query` params\n    const hash = options && options.hash || {};\n\n    // Create an executable function based on the route regex\n    const toPath = pathToRegexp.compile(foundPath.route);\n\n    // Compile the regex path with the params from the hash\n    const compiledPath = toPath(hash);\n\n    // Convert the query object to a string\n    // e.g. { a: \"one\", b: \"two\"} => \"a=one&b=two\"\n    const queryString = queryParse.toString(hash.query);\n\n    // Return the compiled path + query string if we have one\n    if (typeof queryString === \"string\" && queryString.length) {\n      return `${compiledPath}?${queryString}`;\n    }\n\n    // Return only the compiled path\n    return compiledPath;\n  }\n\n  return \"/\";\n};\n\n\nRouter.go = (path, params, query) => {\n  let actualPath;\n\n  if (typeof path === \"string\" && path.startsWith(\"/\")) {\n    actualPath = path;\n  } else {\n    actualPath = Router.pathFor(path, {\n      hash: {\n        ...params,\n        query\n      }\n    });\n  }\n\n  if (window) {\n    history.push(actualPath);\n  }\n};\n\nRouter.replace = (path, params, query) => {\n  const actualPath = Router.pathFor(path, {\n    hash: {\n      ...params,\n      query\n    }\n  });\n\n  if (window) {\n    history.replace(actualPath);\n  }\n};\n\nRouter.reload = () => {\n  const current = Router.current();\n\n  if (window) {\n    history.replace(current.route.fullPath || \"/\");\n  }\n};\n\n/**\n * isActive\n * @summary general helper to return \"active\" when on current path\n * @example {{active \"name\"}}\n * @param {String} routeName - route name as defined in registry\n * @return {String} return \"active\" or null\n */\nRouter.isActiveClassName = (routeName) => {\n  const current = Router.current();\n  const group = current.route.group;\n  const path = current.route.path;\n  let prefix;\n\n  if (group && group.prefix) {\n    prefix = current.route.group.prefix;\n  } else {\n    prefix = \"\";\n  }\n\n  if (typeof path === \"string\") {\n    const routeDef = path.replace(prefix + \"/\", \"\");\n    return routeDef === routeName ? \"active\" : \"\";\n  }\n\n  return \"\";\n};\n\n/**\n * hasRoutePermission\n * check if user has route permissions\n * @param  {Object} route - route context\n * @return {Boolean} returns `true` if route is autoriized, `false` otherwise\n */\nfunction hasRoutePermission(route) {\n  const routeName = route.name;\n\n  if (routeName === \"index\" || routeName === \"not-found\") {\n    return true;\n  } else if (Router.Reaction.hasPermission(routeName, Meteor.userId())) {\n    return true;\n  }\n\n  return false;\n}\n\n\n/**\n * getRouteName\n * assemble route name to be standard\n * prefix/package name + registry name or route\n * @param  {String} packageName  [package name]\n * @param  {Object} registryItem [registry object]\n * @return {String}              [route name]\n */\nfunction getRegistryRouteName(packageName, registryItem) {\n  let routeName;\n  if (packageName && registryItem) {\n    if (registryItem.name) {\n      routeName = registryItem.name;\n    } else if (registryItem.template) {\n      routeName = `${packageName}/${registryItem.template}`;\n    } else {\n      routeName = packageName;\n    }\n    // dont include params in the name\n    routeName = routeName.split(\":\")[0];\n    return routeName;\n  }\n  return null;\n}\n\n/**\n * selectLayout\n * @param {Object} layout - element of shops.layout array\n * @param {Object} setLayout - layout\n * @param {Object} setWorkflow - workflow\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\nfunction selectLayout(layout, setLayout, setWorkflow) {\n  const currentLayout = setLayout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const currentWorkflow = setWorkflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n  if (layout.layout === currentLayout && layout.workflow === currentWorkflow && layout.enabled === true) {\n    return layout;\n  }\n  return null;\n}\n\n/**\n * ReactionLayout\n * sets and returns reaction layout structure\n * @param {Object} options - this router context\n * @param {String} options.layout - string of shop.layout.layout (defaults to coreLayout)\n * @param {String} options.workflow - string of shop.layout.workflow (defaults to coreLayout)\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\nexport function ReactionLayout(options = {}) {\n  // Find a workflow layout to render\n  // Get the current shop data\n  const shop = Shops.findOne(Router.Reaction.getShopId());\n\n  // get the layout & workflow from options if they exist\n  // Otherwise get them from the Session. this is set in `/client/config/defaults`\n  // Otherwise, default to hard-coded values\n  const layoutName = options.layout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const workflowName = options.workflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n\n  // Layout object used to render\n  // Defaults provided for reference\n  let layoutStructure = {\n    template: \"\",\n    layoutHeader: \"\",\n    layoutFooter: \"\",\n    notFound: \"notFound\",\n    dashboardHeader: \"\",\n    dashboardControls: \"\",\n    dashboardHeaderControls: \"\",\n    adminControlsFooter: \"\"\n  };\n\n  // Find a registered layout using the layoutName and workflowName\n  if (shop) {\n    const sortedLayout = shop.layout.sort((prev, next) => prev.priority - next.priority);\n    const foundLayout = sortedLayout.find((x) => selectLayout(x, layoutName, workflowName));\n\n    if (foundLayout && foundLayout.structure) {\n      layoutStructure = {\n        ...foundLayout.structure\n      };\n    }\n  }\n\n  // If the original options did not include a workflow, but did have a template,\n  // then we override the template from the layout with the one provided by the options.\n  //\n  // Why is this? We always need a workflow to render the entire layout of the app.\n  // The default layout has a default template that may not be the one we want to render.\n  // Some routes, such as `/account/profile` do no have a workflow, but define a template.\n  // Without the logic below, it would end up rendering the homepage instead of the profile\n  // page.\n  // const optionsHasWorkflow = typeof options.workflow === \"string\";\n  const optionsHasTemplate = typeof options.template === \"string\";\n\n  if (optionsHasTemplate) {\n    layoutStructure.template = options.template;\n  }\n\n  // If there is no Blaze Template (Template[]) or React Component (getComponent)\n  // Then use the notFound template instead\n  if (!Template[layoutStructure.template] && !getComponent(layoutStructure.template)) {\n    return (\n      <Blaze template={layoutStructure.notFound} />\n    );\n  }\n\n  // Render the layout\n  return {\n    structure: layoutStructure,\n    component: (props) => { // eslint-disable-line react/no-multi-comp, react/display-name\n      const route = Router.current().route;\n      const structure = {\n        ...layoutStructure\n      };\n\n      // If the current route is unauthorized, and is not the \"not-found\" route,\n      // then override the template to use the default unauthroized template\n      if (hasRoutePermission(route) === false && route.name !== \"not-found\") {\n        structure.template = \"unauthorized\";\n      }\n\n      if (getComponent(layoutName)) {\n        return React.createElement(getComponent(layoutName), {\n          ...props,\n          structure: structure\n        });\n      } else if (Template[layoutName]) {\n        return (\n          <BlazeLayout\n            {...structure}\n            blazeTemplate={layoutName}\n          />\n        );\n      }\n\n      return <Blaze template={structure.notFound} />;\n    }\n  };\n}\n\n/**\n * initPackageRoutes\n * registers route and template when registry item has\n * registryItem.route && registryItem.template\n * @param {Object} options - options and context for route creation\n * @returns {undefined} returns undefined\n */\nRouter.initPackageRoutes = (options) => {\n  Router.Reaction = options.reactionContext;\n  Router.routes = [];\n\n  const pkgs = Packages.find().fetch();\n  const prefix = Router.Reaction.getShopPrefix();\n  const reactRouterRoutes = [];\n\n  // prefixing isnt necessary if we only have one shop\n  // but we need to bypass the current\n  // subscription to determine this.\n  const shopSub = Meteor.subscribe(\"shopsCount\");\n  if (shopSub.ready()) {\n    // using tmeasday:publish-counts\n    const shopCount = Counts.get(\"shops-count\");\n\n    // Index layout\n    const indexLayout = ReactionLayout(options.indexRoute);\n    const indexRoute = {\n      route: \"/\",\n      name: \"index\",\n      options: {\n        name: \"index\",\n        ...options.indexRoute,\n        component: indexLayout.component,\n        structure: indexLayout.structure\n      }\n    };\n\n    reactRouterRoutes.push(\n      <Route\n        exact={true}\n        key=\"index\"\n        path=\"/\"\n        render={indexLayout.component}\n      />\n    );\n\n    const notFoundLayout = ReactionLayout({ template: \"notFound\" });\n    const notFoundRoute = {\n      route: \"/not-found\",\n      name: \"not-found\",\n      options: {\n        name: \"not-found\",\n        ...notFoundLayout.indexRoute,\n        component: notFoundLayout.component,\n        structure: notFoundLayout.structure\n      }\n    };\n\n    reactRouterRoutes.push(\n      <Route\n        key=\"not-found\"\n        path=\"/not-found\"\n        render={notFoundLayout.component}\n      />\n    );\n\n    Router.routes.push(indexRoute);\n    Router.routes.push(notFoundRoute);\n\n    // get package registry route configurations\n    for (const pkg of pkgs) {\n      const newRoutes = [];\n      // pkg registry\n      if (pkg.registry && pkg.enabled) {\n        const registry = Array.from(pkg.registry);\n        for (const registryItem of registry) {\n          // registryItems\n          if (registryItem.route) {\n            const {\n              meta,\n              route,\n              template,\n              layout,\n              workflow\n            } = registryItem;\n\n            // get registry route name\n            const name = getRegistryRouteName(pkg.name, registryItem);\n\n            // define new route\n            // we could allow the options to be passed in the registry if we need to be more flexible\n            const reactionLayout = ReactionLayout({ template, workflow, layout });\n            const newRouteConfig = {\n              route,\n              name,\n              options: {\n                meta,\n                name,\n                template,\n                layout,\n                triggersEnter: Router.Hooks.get(\"onEnter\", name),\n                triggersExit: Router.Hooks.get(\"onExit\", name),\n                component: reactionLayout.component,\n                structure: reactionLayout.structure\n              }\n            };\n\n            // push new routes\n            newRoutes.push(newRouteConfig);\n          } // end registryItems\n        } // end package.registry\n\n        //\n        // add group and routes to routing table\n        //\n        const uniqRoutes = new Set(newRoutes);\n        let index = 0;\n        for (const route of uniqRoutes) {\n          // allow overriding of prefix in route definitions\n          // define an \"absolute\" url by excluding \"/\"\n          route.group = {};\n\n          if (route.route.substring(0, 1) !== \"/\") {\n            route.route = \"/\" + route.route;\n            route.group.prefix = \"\";\n          } else if (shopCount <= 1) {\n            route.group.prefix = \"\";\n          } else {\n            route.group.prefix = prefix;\n            route.route = `${prefix}${route.route}`;\n          }\n\n          // Add the route to the routing table\n          reactRouterRoutes.push(\n            <Route\n              key={`${pkg.name}-${route.name}-${index++}`}\n              path={route.route}\n              exact={true}\n              render={route.options.component}\n            />\n          );\n\n          Router.routes.push(route);\n        }\n      }\n    } // end package loop\n\n    Router._initialized = true;\n    Router.reactComponents = reactRouterRoutes;\n    Router._routes = Router.routes;\n\n    routerReadyDependency.changed();\n  }\n};\n\n\nexport default Router;\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/core/router/lib/router.js.map","sourceFileName":"/imports/plugins/core/router/lib/router.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"router"},"ignored":false,"code":"var _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n  history: function () {\n    return history;\n  },\n  ReactionLayout: function () {\n    return ReactionLayout;\n  }\n});\nvar React = void 0;\nmodule.importSync(\"react\", {\n  \"default\": function (v) {\n    React = v;\n  }\n}, 0);\nvar Route = void 0;\nmodule.importSync(\"react-router\", {\n  Route: function (v) {\n    Route = v;\n  }\n}, 1);\nvar createBrowserHistory = void 0;\nmodule.importSync(\"history/createBrowserHistory\", {\n  \"default\": function (v) {\n    createBrowserHistory = v;\n  }\n}, 2);\nvar createMemoryHistory = void 0;\nmodule.importSync(\"history/createMemoryHistory\", {\n  \"default\": function (v) {\n    createMemoryHistory = v;\n  }\n}, 3);\nvar pathToRegexp = void 0;\nmodule.importSync(\"path-to-regexp\", {\n  \"default\": function (v) {\n    pathToRegexp = v;\n  }\n}, 4);\nvar queryParse = void 0;\nmodule.importSync(\"query-parse\", {\n  \"default\": function (v) {\n    queryParse = v;\n  }\n}, 5);\nvar Immutable = void 0;\nmodule.importSync(\"immutable\", {\n  \"default\": function (v) {\n    Immutable = v;\n  }\n}, 6);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 7);\nvar Blaze = void 0;\nmodule.importSync(\"meteor/gadicc:blaze-react-component\", {\n  \"default\": function (v) {\n    Blaze = v;\n  }\n}, 8);\nvar Tracker = void 0;\nmodule.importSync(\"meteor/tracker\", {\n  Tracker: function (v) {\n    Tracker = v;\n  }\n}, 9);\nvar Packages = void 0,\n    Shops = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Packages: function (v) {\n    Packages = v;\n  },\n  Shops: function (v) {\n    Shops = v;\n  }\n}, 10);\nvar getComponent = void 0;\nmodule.importSync(\"/imports/plugins/core/layout/lib/components\", {\n  getComponent: function (v) {\n    getComponent = v;\n  }\n}, 11);\nvar BlazeLayout = void 0;\nmodule.importSync(\"/imports/plugins/core/layout/lib/blazeLayout\", {\n  \"default\": function (v) {\n    BlazeLayout = v;\n  }\n}, 12);\nvar Hooks = void 0;\nmodule.importSync(\"./hooks\", {\n  \"default\": function (v) {\n    Hooks = v;\n  }\n}, 13);\nvar history = void 0;\n// Private vars\n// const currentRoute = new ReactiveVar({});\nvar currentRoute = Immutable.Map();\nvar routerReadyDependency = new Tracker.Dependency();\nvar routerChangeDependency = new Tracker.Dependency(); // Create history object depending on if this is client or server\n\nif (Meteor.isClient) {\n  module.runModuleSetters(history = createBrowserHistory());\n} else {\n  module.runModuleSetters(history = createMemoryHistory());\n} // Base router class (static)\n\n\nvar Router = function () {\n  function Router() {\n    (0, _classCallCheck3.default)(this, Router);\n  }\n\n  Router.ready = function () {\n    function ready() {\n      routerReadyDependency.depend();\n      return Router._initialized;\n    }\n\n    return ready;\n  }(); // for legacy\n\n\n  Router.triggerRouterReady = function () {\n    function triggerRouterReady() {\n      routerReadyDependency.changed();\n    }\n\n    return triggerRouterReady;\n  }();\n\n  Router.current = function () {\n    function current() {\n      return currentRoute.toJS();\n    }\n\n    return current;\n  }();\n\n  Router.setCurrentRoute = function () {\n    function setCurrentRoute(routeData) {\n      currentRoute = Immutable.Map(routeData);\n      routerChangeDependency.changed();\n    }\n\n    return setCurrentRoute;\n  }();\n\n  Router.getRouteName = function () {\n    function getRouteName() {\n      var current = Router.current();\n      return current.options && current.options.name || \"\";\n    }\n\n    return getRouteName;\n  }();\n\n  Router.getParam = function () {\n    function getParam(name) {\n      routerChangeDependency.depend();\n      var current = Router.current();\n      return current.params && current.params[name] || undefined;\n    }\n\n    return getParam;\n  }();\n\n  Router.getQueryParam = function () {\n    function getQueryParam(name) {\n      routerChangeDependency.depend();\n      var current = Router.current();\n      return current.query && current.query[name] || undefined;\n    }\n\n    return getQueryParam;\n  }();\n\n  Router.watchPathChange = function () {\n    function watchPathChange() {\n      routerChangeDependency.depend();\n    }\n\n    return watchPathChange;\n  }();\n\n  (0, _createClass3.default)(Router, null, [{\n    key: \"triggers\",\n    get: function () {\n      return Hooks;\n    }\n  }]);\n  return Router;\n}(); /**\n      * pathFor\n      * @summary get current router path\n      * @param {String} path - path to fetch\n      * @param {Object} options - url params\n      * @return {String} returns current router path\n      */\n\nRouter.history = history;\nRouter.Hooks = Hooks;\nRouter.routes = [];\nRouter._routes = Router.routes;\nRouter._initialized = false;\n\nRouter.pathFor = function (path) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // const params = options.hash || {};\n  // const query = params.query ? Router._qs.parse(params.query) : {};\n  // // prevent undefined param error\n  // for (const i in params) {\n  //   if (params[i] === null || params[i] === undefined) {\n  //     params[i] = \"/\";\n  //   }\n  // }\n  // return Router.path(path, params, query);\n  var foundPath = Router.routes.find(function (pathObject) {\n    // console.log(pathObject.options.name, path);\n    if (pathObject.options.name === path) {\n      return true;\n    }\n\n    return false;\n  });\n\n  if (foundPath) {\n    // Pull the hash out of options\n    //\n    // This is becuase of Spacebars that we have hash.\n    // Spacebars takes all params passed into a template tag and places\n    // them into the options.hash object. This will also include any `query` params\n    var hash = options && options.hash || {}; // Create an executable function based on the route regex\n\n    var toPath = pathToRegexp.compile(foundPath.route); // Compile the regex path with the params from the hash\n\n    var compiledPath = toPath(hash); // Convert the query object to a string\n    // e.g. { a: \"one\", b: \"two\"} => \"a=one&b=two\"\n\n    var queryString = queryParse.toString(hash.query); // Return the compiled path + query string if we have one\n\n    if (typeof queryString === \"string\" && queryString.length) {\n      return compiledPath + \"?\" + queryString;\n    } // Return only the compiled path\n\n\n    return compiledPath;\n  }\n\n  return \"/\";\n};\n\nRouter.go = function (path, params, query) {\n  var actualPath = void 0;\n\n  if (typeof path === \"string\" && path.startsWith(\"/\")) {\n    actualPath = path;\n  } else {\n    actualPath = Router.pathFor(path, {\n      hash: (0, _extends3.default)({}, params, {\n        query: query\n      })\n    });\n  }\n\n  if (window) {\n    history.push(actualPath);\n  }\n};\n\nRouter.replace = function (path, params, query) {\n  var actualPath = Router.pathFor(path, {\n    hash: (0, _extends3.default)({}, params, {\n      query: query\n    })\n  });\n\n  if (window) {\n    history.replace(actualPath);\n  }\n};\n\nRouter.reload = function () {\n  var current = Router.current();\n\n  if (window) {\n    history.replace(current.route.fullPath || \"/\");\n  }\n}; /**\n    * isActive\n    * @summary general helper to return \"active\" when on current path\n    * @example {{active \"name\"}}\n    * @param {String} routeName - route name as defined in registry\n    * @return {String} return \"active\" or null\n    */\n\nRouter.isActiveClassName = function (routeName) {\n  var current = Router.current();\n  var group = current.route.group;\n  var path = current.route.path;\n  var prefix = void 0;\n\n  if (group && group.prefix) {\n    prefix = current.route.group.prefix;\n  } else {\n    prefix = \"\";\n  }\n\n  if (typeof path === \"string\") {\n    var routeDef = path.replace(prefix + \"/\", \"\");\n    return routeDef === routeName ? \"active\" : \"\";\n  }\n\n  return \"\";\n}; /**\n    * hasRoutePermission\n    * check if user has route permissions\n    * @param  {Object} route - route context\n    * @return {Boolean} returns `true` if route is autoriized, `false` otherwise\n    */\n\nfunction hasRoutePermission(route) {\n  var routeName = route.name;\n\n  if (routeName === \"index\" || routeName === \"not-found\") {\n    return true;\n  } else if (Router.Reaction.hasPermission(routeName, Meteor.userId())) {\n    return true;\n  }\n\n  return false;\n} /**\n   * getRouteName\n   * assemble route name to be standard\n   * prefix/package name + registry name or route\n   * @param  {String} packageName  [package name]\n   * @param  {Object} registryItem [registry object]\n   * @return {String}              [route name]\n   */\n\nfunction getRegistryRouteName(packageName, registryItem) {\n  var routeName = void 0;\n\n  if (packageName && registryItem) {\n    if (registryItem.name) {\n      routeName = registryItem.name;\n    } else if (registryItem.template) {\n      routeName = packageName + \"/\" + registryItem.template;\n    } else {\n      routeName = packageName;\n    } // dont include params in the name\n\n\n    routeName = routeName.split(\":\")[0];\n    return routeName;\n  }\n\n  return null;\n} /**\n   * selectLayout\n   * @param {Object} layout - element of shops.layout array\n   * @param {Object} setLayout - layout\n   * @param {Object} setWorkflow - workflow\n   * @returns {Object} layout - return object of template definitions for Blaze Layout\n   */\n\nfunction selectLayout(layout, setLayout, setWorkflow) {\n  var currentLayout = setLayout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  var currentWorkflow = setWorkflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n\n  if (layout.layout === currentLayout && layout.workflow === currentWorkflow && layout.enabled === true) {\n    return layout;\n  }\n\n  return null;\n} /**\n   * ReactionLayout\n   * sets and returns reaction layout structure\n   * @param {Object} options - this router context\n   * @param {String} options.layout - string of shop.layout.layout (defaults to coreLayout)\n   * @param {String} options.workflow - string of shop.layout.workflow (defaults to coreLayout)\n   * @returns {Object} layout - return object of template definitions for Blaze Layout\n   */\n\nfunction ReactionLayout() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // Find a workflow layout to render\n  // Get the current shop data\n  var shop = Shops.findOne(Router.Reaction.getShopId()); // get the layout & workflow from options if they exist\n  // Otherwise get them from the Session. this is set in `/client/config/defaults`\n  // Otherwise, default to hard-coded values\n\n  var layoutName = options.layout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  var workflowName = options.workflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\"; // Layout object used to render\n  // Defaults provided for reference\n\n  var layoutStructure = {\n    template: \"\",\n    layoutHeader: \"\",\n    layoutFooter: \"\",\n    notFound: \"notFound\",\n    dashboardHeader: \"\",\n    dashboardControls: \"\",\n    dashboardHeaderControls: \"\",\n    adminControlsFooter: \"\"\n  }; // Find a registered layout using the layoutName and workflowName\n\n  if (shop) {\n    var sortedLayout = shop.layout.sort(function (prev, next) {\n      return prev.priority - next.priority;\n    });\n    var foundLayout = sortedLayout.find(function (x) {\n      return selectLayout(x, layoutName, workflowName);\n    });\n\n    if (foundLayout && foundLayout.structure) {\n      layoutStructure = (0, _extends3.default)({}, foundLayout.structure);\n    }\n  } // If the original options did not include a workflow, but did have a template,\n  // then we override the template from the layout with the one provided by the options.\n  //\n  // Why is this? We always need a workflow to render the entire layout of the app.\n  // The default layout has a default template that may not be the one we want to render.\n  // Some routes, such as `/account/profile` do no have a workflow, but define a template.\n  // Without the logic below, it would end up rendering the homepage instead of the profile\n  // page.\n  // const optionsHasWorkflow = typeof options.workflow === \"string\";\n\n\n  var optionsHasTemplate = typeof options.template === \"string\";\n\n  if (optionsHasTemplate) {\n    layoutStructure.template = options.template;\n  } // If there is no Blaze Template (Template[]) or React Component (getComponent)\n  // Then use the notFound template instead\n\n\n  if (!Template[layoutStructure.template] && !getComponent(layoutStructure.template)) {\n    return React.createElement(Blaze, {\n      template: layoutStructure.notFound\n    });\n  } // Render the layout\n\n\n  return {\n    structure: layoutStructure,\n    component: function (props) {\n      // eslint-disable-line react/no-multi-comp, react/display-name\n      var route = Router.current().route;\n      var structure = (0, _extends3.default)({}, layoutStructure); // If the current route is unauthorized, and is not the \"not-found\" route,\n      // then override the template to use the default unauthroized template\n\n      if (hasRoutePermission(route) === false && route.name !== \"not-found\") {\n        structure.template = \"unauthorized\";\n      }\n\n      if (getComponent(layoutName)) {\n        return React.createElement(getComponent(layoutName), (0, _extends3.default)({}, props, {\n          structure: structure\n        }));\n      } else if (Template[layoutName]) {\n        return React.createElement(BlazeLayout, (0, _extends3.default)({}, structure, {\n          blazeTemplate: layoutName\n        }));\n      }\n\n      return React.createElement(Blaze, {\n        template: structure.notFound\n      });\n    }\n  };\n}\n\n/**\n * initPackageRoutes\n * registers route and template when registry item has\n * registryItem.route && registryItem.template\n * @param {Object} options - options and context for route creation\n * @returns {undefined} returns undefined\n */Router.initPackageRoutes = function (options) {\n  Router.Reaction = options.reactionContext;\n  Router.routes = [];\n  var pkgs = Packages.find().fetch();\n  var prefix = Router.Reaction.getShopPrefix();\n  var reactRouterRoutes = []; // prefixing isnt necessary if we only have one shop\n  // but we need to bypass the current\n  // subscription to determine this.\n\n  var shopSub = Meteor.subscribe(\"shopsCount\");\n\n  if (shopSub.ready()) {\n    // using tmeasday:publish-counts\n    var shopCount = Counts.get(\"shops-count\"); // Index layout\n\n    var indexLayout = ReactionLayout(options.indexRoute);\n    var indexRoute = {\n      route: \"/\",\n      name: \"index\",\n      options: (0, _extends3.default)({\n        name: \"index\"\n      }, options.indexRoute, {\n        component: indexLayout.component,\n        structure: indexLayout.structure\n      })\n    };\n    reactRouterRoutes.push(React.createElement(Route, {\n      exact: true,\n      key: \"index\",\n      path: \"/\",\n      render: indexLayout.component\n    }));\n    var notFoundLayout = ReactionLayout({\n      template: \"notFound\"\n    });\n    var notFoundRoute = {\n      route: \"/not-found\",\n      name: \"not-found\",\n      options: (0, _extends3.default)({\n        name: \"not-found\"\n      }, notFoundLayout.indexRoute, {\n        component: notFoundLayout.component,\n        structure: notFoundLayout.structure\n      })\n    };\n    reactRouterRoutes.push(React.createElement(Route, {\n      key: \"not-found\",\n      path: \"/not-found\",\n      render: notFoundLayout.component\n    }));\n    Router.routes.push(indexRoute);\n    Router.routes.push(notFoundRoute); // get package registry route configurations\n\n    for (var _iterator = pkgs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var pkg = _ref;\n      var newRoutes = []; // pkg registry\n\n      if (pkg.registry && pkg.enabled) {\n        var registry = Array.from(pkg.registry);\n\n        for (var _iterator2 = registry, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n          var _ref2;\n\n          if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i2++];\n          } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref2 = _i2.value;\n          }\n\n          var registryItem = _ref2;\n\n          // registryItems\n          if (registryItem.route) {\n            var meta = registryItem.meta,\n                _route = registryItem.route,\n                template = registryItem.template,\n                layout = registryItem.layout,\n                workflow = registryItem.workflow; // get registry route name\n\n            var name = getRegistryRouteName(pkg.name, registryItem); // define new route\n            // we could allow the options to be passed in the registry if we need to be more flexible\n\n            var reactionLayout = ReactionLayout({\n              template: template,\n              workflow: workflow,\n              layout: layout\n            });\n            var newRouteConfig = {\n              route: _route,\n              name: name,\n              options: {\n                meta: meta,\n                name: name,\n                template: template,\n                layout: layout,\n                triggersEnter: Router.Hooks.get(\"onEnter\", name),\n                triggersExit: Router.Hooks.get(\"onExit\", name),\n                component: reactionLayout.component,\n                structure: reactionLayout.structure\n              }\n            }; // push new routes\n\n            newRoutes.push(newRouteConfig);\n          } // end registryItems\n\n        } // end package.registry\n        //\n        // add group and routes to routing table\n        //\n\n\n        var uniqRoutes = new Set(newRoutes);\n        var index = 0;\n\n        for (var _iterator3 = uniqRoutes, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n          var _ref3;\n\n          if (_isArray3) {\n            if (_i3 >= _iterator3.length) break;\n            _ref3 = _iterator3[_i3++];\n          } else {\n            _i3 = _iterator3.next();\n            if (_i3.done) break;\n            _ref3 = _i3.value;\n          }\n\n          var route = _ref3;\n          // allow overriding of prefix in route definitions\n          // define an \"absolute\" url by excluding \"/\"\n          route.group = {};\n\n          if (route.route.substring(0, 1) !== \"/\") {\n            route.route = \"/\" + route.route;\n            route.group.prefix = \"\";\n          } else if (shopCount <= 1) {\n            route.group.prefix = \"\";\n          } else {\n            route.group.prefix = prefix;\n            route.route = \"\" + prefix + route.route;\n          } // Add the route to the routing table\n\n\n          reactRouterRoutes.push(React.createElement(Route, {\n            key: pkg.name + \"-\" + route.name + \"-\" + index++,\n            path: route.route,\n            exact: true,\n            render: route.options.component\n          }));\n          Router.routes.push(route);\n        }\n      }\n    } // end package loop\n\n\n    Router._initialized = true;\n    Router.reactComponents = reactRouterRoutes;\n    Router._routes = Router.routes;\n    routerReadyDependency.changed();\n  }\n};\n\nmodule.export(\"default\", exports.default = Router);","map":{"version":3,"sources":["/imports/plugins/core/router/lib/router.js"],"names":["React","Route","createBrowserHistory","createMemoryHistory","pathToRegexp","queryParse","Immutable","Meteor","Blaze","Tracker","Packages","Shops","getComponent","BlazeLayout","Hooks","history","currentRoute","Map","routerReadyDependency","Dependency","routerChangeDependency","isClient","Router","routes","_routes","_initialized","ready","depend","triggerRouterReady","changed","triggers","current","toJS","setCurrentRoute","routeData","getRouteName","options","name","getParam","params","undefined","getQueryParam","query","watchPathChange","pathFor","path","foundPath","find","pathObject","hash","toPath","compile","route","compiledPath","queryString","toString","length","go","actualPath","startsWith","window","push","replace","reload","fullPath","isActiveClassName","routeName","group","prefix","routeDef","hasRoutePermission","Reaction","hasPermission","userId","getRegistryRouteName","packageName","registryItem","template","split","selectLayout","layout","setLayout","setWorkflow","currentLayout","Session","get","currentWorkflow","workflow","enabled","ReactionLayout","shop","findOne","getShopId","layoutName","workflowName","layoutStructure","layoutHeader","layoutFooter","notFound","dashboardHeader","dashboardControls","dashboardHeaderControls","adminControlsFooter","sortedLayout","sort","prev","next","priority","foundLayout","x","structure","optionsHasTemplate","Template","component","props","createElement","initPackageRoutes","reactionContext","pkgs","fetch","getShopPrefix","reactRouterRoutes","shopSub","subscribe","shopCount","Counts","indexLayout","indexRoute","notFoundLayout","notFoundRoute","pkg","newRoutes","registry","Array","from","meta","reactionLayout","newRouteConfig","triggersEnter","triggersExit","uniqRoutes","Set","index","substring","reactComponents"],"mappings":"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","file":"/imports/plugins/core/router/lib/router.js.map","sourcesContent":["import React from \"react\";\nimport { Route } from \"react-router\";\nimport createBrowserHistory from \"history/createBrowserHistory\";\nimport createMemoryHistory from \"history/createMemoryHistory\";\nimport pathToRegexp from \"path-to-regexp\";\nimport queryParse from \"query-parse\";\nimport Immutable from \"immutable\";\nimport { Meteor } from \"meteor/meteor\";\nimport Blaze from \"meteor/gadicc:blaze-react-component\";\nimport { Tracker } from \"meteor/tracker\";\nimport { Packages, Shops } from \"/lib/collections\";\nimport { getComponent } from \"/imports/plugins/core/layout/lib/components\";\nimport BlazeLayout from \"/imports/plugins/core/layout/lib/blazeLayout\";\nimport Hooks from \"./hooks\";\n\n\nexport let history;\n\n// Private vars\n// const currentRoute = new ReactiveVar({});\nlet currentRoute = Immutable.Map();\nconst routerReadyDependency = new Tracker.Dependency;\nconst routerChangeDependency = new Tracker.Dependency;\n\n// Create history object depending on if this is client or server\nif (Meteor.isClient) {\n  history = createBrowserHistory();\n} else {\n  history = createMemoryHistory();\n}\n\n// Base router class (static)\nclass Router {\n  static history = history\n  static Hooks = Hooks\n  static routes = []\n  static _routes = Router.routes // for legacy\n  static _initialized = false;\n\n  static ready() {\n    routerReadyDependency.depend();\n    return Router._initialized;\n  }\n\n  static triggerRouterReady() {\n    routerReadyDependency.changed();\n  }\n\n  static get triggers() {\n    return Hooks;\n  }\n\n  static current() {\n    return currentRoute.toJS();\n  }\n\n  static setCurrentRoute(routeData) {\n    currentRoute = Immutable.Map(routeData);\n    routerChangeDependency.changed();\n  }\n\n  static getRouteName() {\n    const current = Router.current();\n\n    return current.options && current.options.name || \"\";\n  }\n\n  static getParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n\n    return current.params && current.params[name] || undefined;\n  }\n\n  static getQueryParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n\n    return current.query && current.query[name] || undefined;\n  }\n\n  static watchPathChange() {\n    routerChangeDependency.depend();\n  }\n}\n\n/**\n * pathFor\n * @summary get current router path\n * @param {String} path - path to fetch\n * @param {Object} options - url params\n * @return {String} returns current router path\n */\nRouter.pathFor = (path, options = {}) => {\n  // const params = options.hash || {};\n  // const query = params.query ? Router._qs.parse(params.query) : {};\n  // // prevent undefined param error\n  // for (const i in params) {\n  //   if (params[i] === null || params[i] === undefined) {\n  //     params[i] = \"/\";\n  //   }\n  // }\n  // return Router.path(path, params, query);\n\n  const foundPath = Router.routes.find((pathObject) => {\n    // console.log(pathObject.options.name, path);\n    if (pathObject.options.name === path) {\n      return true;\n    }\n    return false;\n  });\n\n  if (foundPath) {\n    // Pull the hash out of options\n    //\n    // This is becuase of Spacebars that we have hash.\n    // Spacebars takes all params passed into a template tag and places\n    // them into the options.hash object. This will also include any `query` params\n    const hash = options && options.hash || {};\n\n    // Create an executable function based on the route regex\n    const toPath = pathToRegexp.compile(foundPath.route);\n\n    // Compile the regex path with the params from the hash\n    const compiledPath = toPath(hash);\n\n    // Convert the query object to a string\n    // e.g. { a: \"one\", b: \"two\"} => \"a=one&b=two\"\n    const queryString = queryParse.toString(hash.query);\n\n    // Return the compiled path + query string if we have one\n    if (typeof queryString === \"string\" && queryString.length) {\n      return `${compiledPath}?${queryString}`;\n    }\n\n    // Return only the compiled path\n    return compiledPath;\n  }\n\n  return \"/\";\n};\n\n\nRouter.go = (path, params, query) => {\n  let actualPath;\n\n  if (typeof path === \"string\" && path.startsWith(\"/\")) {\n    actualPath = path;\n  } else {\n    actualPath = Router.pathFor(path, {\n      hash: {\n        ...params,\n        query\n      }\n    });\n  }\n\n  if (window) {\n    history.push(actualPath);\n  }\n};\n\nRouter.replace = (path, params, query) => {\n  const actualPath = Router.pathFor(path, {\n    hash: {\n      ...params,\n      query\n    }\n  });\n\n  if (window) {\n    history.replace(actualPath);\n  }\n};\n\nRouter.reload = () => {\n  const current = Router.current();\n\n  if (window) {\n    history.replace(current.route.fullPath || \"/\");\n  }\n};\n\n/**\n * isActive\n * @summary general helper to return \"active\" when on current path\n * @example {{active \"name\"}}\n * @param {String} routeName - route name as defined in registry\n * @return {String} return \"active\" or null\n */\nRouter.isActiveClassName = (routeName) => {\n  const current = Router.current();\n  const group = current.route.group;\n  const path = current.route.path;\n  let prefix;\n\n  if (group && group.prefix) {\n    prefix = current.route.group.prefix;\n  } else {\n    prefix = \"\";\n  }\n\n  if (typeof path === \"string\") {\n    const routeDef = path.replace(prefix + \"/\", \"\");\n    return routeDef === routeName ? \"active\" : \"\";\n  }\n\n  return \"\";\n};\n\n/**\n * hasRoutePermission\n * check if user has route permissions\n * @param  {Object} route - route context\n * @return {Boolean} returns `true` if route is autoriized, `false` otherwise\n */\nfunction hasRoutePermission(route) {\n  const routeName = route.name;\n\n  if (routeName === \"index\" || routeName === \"not-found\") {\n    return true;\n  } else if (Router.Reaction.hasPermission(routeName, Meteor.userId())) {\n    return true;\n  }\n\n  return false;\n}\n\n\n/**\n * getRouteName\n * assemble route name to be standard\n * prefix/package name + registry name or route\n * @param  {String} packageName  [package name]\n * @param  {Object} registryItem [registry object]\n * @return {String}              [route name]\n */\nfunction getRegistryRouteName(packageName, registryItem) {\n  let routeName;\n  if (packageName && registryItem) {\n    if (registryItem.name) {\n      routeName = registryItem.name;\n    } else if (registryItem.template) {\n      routeName = `${packageName}/${registryItem.template}`;\n    } else {\n      routeName = packageName;\n    }\n    // dont include params in the name\n    routeName = routeName.split(\":\")[0];\n    return routeName;\n  }\n  return null;\n}\n\n/**\n * selectLayout\n * @param {Object} layout - element of shops.layout array\n * @param {Object} setLayout - layout\n * @param {Object} setWorkflow - workflow\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\nfunction selectLayout(layout, setLayout, setWorkflow) {\n  const currentLayout = setLayout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const currentWorkflow = setWorkflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n  if (layout.layout === currentLayout && layout.workflow === currentWorkflow && layout.enabled === true) {\n    return layout;\n  }\n  return null;\n}\n\n/**\n * ReactionLayout\n * sets and returns reaction layout structure\n * @param {Object} options - this router context\n * @param {String} options.layout - string of shop.layout.layout (defaults to coreLayout)\n * @param {String} options.workflow - string of shop.layout.workflow (defaults to coreLayout)\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\nexport function ReactionLayout(options = {}) {\n  // Find a workflow layout to render\n  // Get the current shop data\n  const shop = Shops.findOne(Router.Reaction.getShopId());\n\n  // get the layout & workflow from options if they exist\n  // Otherwise get them from the Session. this is set in `/client/config/defaults`\n  // Otherwise, default to hard-coded values\n  const layoutName = options.layout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const workflowName = options.workflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n\n  // Layout object used to render\n  // Defaults provided for reference\n  let layoutStructure = {\n    template: \"\",\n    layoutHeader: \"\",\n    layoutFooter: \"\",\n    notFound: \"notFound\",\n    dashboardHeader: \"\",\n    dashboardControls: \"\",\n    dashboardHeaderControls: \"\",\n    adminControlsFooter: \"\"\n  };\n\n  // Find a registered layout using the layoutName and workflowName\n  if (shop) {\n    const sortedLayout = shop.layout.sort((prev, next) => prev.priority - next.priority);\n    const foundLayout = sortedLayout.find((x) => selectLayout(x, layoutName, workflowName));\n\n    if (foundLayout && foundLayout.structure) {\n      layoutStructure = {\n        ...foundLayout.structure\n      };\n    }\n  }\n\n  // If the original options did not include a workflow, but did have a template,\n  // then we override the template from the layout with the one provided by the options.\n  //\n  // Why is this? We always need a workflow to render the entire layout of the app.\n  // The default layout has a default template that may not be the one we want to render.\n  // Some routes, such as `/account/profile` do no have a workflow, but define a template.\n  // Without the logic below, it would end up rendering the homepage instead of the profile\n  // page.\n  // const optionsHasWorkflow = typeof options.workflow === \"string\";\n  const optionsHasTemplate = typeof options.template === \"string\";\n\n  if (optionsHasTemplate) {\n    layoutStructure.template = options.template;\n  }\n\n  // If there is no Blaze Template (Template[]) or React Component (getComponent)\n  // Then use the notFound template instead\n  if (!Template[layoutStructure.template] && !getComponent(layoutStructure.template)) {\n    return (\n      <Blaze template={layoutStructure.notFound} />\n    );\n  }\n\n  // Render the layout\n  return {\n    structure: layoutStructure,\n    component: (props) => { // eslint-disable-line react/no-multi-comp, react/display-name\n      const route = Router.current().route;\n      const structure = {\n        ...layoutStructure\n      };\n\n      // If the current route is unauthorized, and is not the \"not-found\" route,\n      // then override the template to use the default unauthroized template\n      if (hasRoutePermission(route) === false && route.name !== \"not-found\") {\n        structure.template = \"unauthorized\";\n      }\n\n      if (getComponent(layoutName)) {\n        return React.createElement(getComponent(layoutName), {\n          ...props,\n          structure: structure\n        });\n      } else if (Template[layoutName]) {\n        return (\n          <BlazeLayout\n            {...structure}\n            blazeTemplate={layoutName}\n          />\n        );\n      }\n\n      return <Blaze template={structure.notFound} />;\n    }\n  };\n}\n\n/**\n * initPackageRoutes\n * registers route and template when registry item has\n * registryItem.route && registryItem.template\n * @param {Object} options - options and context for route creation\n * @returns {undefined} returns undefined\n */\nRouter.initPackageRoutes = (options) => {\n  Router.Reaction = options.reactionContext;\n  Router.routes = [];\n\n  const pkgs = Packages.find().fetch();\n  const prefix = Router.Reaction.getShopPrefix();\n  const reactRouterRoutes = [];\n\n  // prefixing isnt necessary if we only have one shop\n  // but we need to bypass the current\n  // subscription to determine this.\n  const shopSub = Meteor.subscribe(\"shopsCount\");\n  if (shopSub.ready()) {\n    // using tmeasday:publish-counts\n    const shopCount = Counts.get(\"shops-count\");\n\n    // Index layout\n    const indexLayout = ReactionLayout(options.indexRoute);\n    const indexRoute = {\n      route: \"/\",\n      name: \"index\",\n      options: {\n        name: \"index\",\n        ...options.indexRoute,\n        component: indexLayout.component,\n        structure: indexLayout.structure\n      }\n    };\n\n    reactRouterRoutes.push(\n      <Route\n        exact={true}\n        key=\"index\"\n        path=\"/\"\n        render={indexLayout.component}\n      />\n    );\n\n    const notFoundLayout = ReactionLayout({ template: \"notFound\" });\n    const notFoundRoute = {\n      route: \"/not-found\",\n      name: \"not-found\",\n      options: {\n        name: \"not-found\",\n        ...notFoundLayout.indexRoute,\n        component: notFoundLayout.component,\n        structure: notFoundLayout.structure\n      }\n    };\n\n    reactRouterRoutes.push(\n      <Route\n        key=\"not-found\"\n        path=\"/not-found\"\n        render={notFoundLayout.component}\n      />\n    );\n\n    Router.routes.push(indexRoute);\n    Router.routes.push(notFoundRoute);\n\n    // get package registry route configurations\n    for (const pkg of pkgs) {\n      const newRoutes = [];\n      // pkg registry\n      if (pkg.registry && pkg.enabled) {\n        const registry = Array.from(pkg.registry);\n        for (const registryItem of registry) {\n          // registryItems\n          if (registryItem.route) {\n            const {\n              meta,\n              route,\n              template,\n              layout,\n              workflow\n            } = registryItem;\n\n            // get registry route name\n            const name = getRegistryRouteName(pkg.name, registryItem);\n\n            // define new route\n            // we could allow the options to be passed in the registry if we need to be more flexible\n            const reactionLayout = ReactionLayout({ template, workflow, layout });\n            const newRouteConfig = {\n              route,\n              name,\n              options: {\n                meta,\n                name,\n                template,\n                layout,\n                triggersEnter: Router.Hooks.get(\"onEnter\", name),\n                triggersExit: Router.Hooks.get(\"onExit\", name),\n                component: reactionLayout.component,\n                structure: reactionLayout.structure\n              }\n            };\n\n            // push new routes\n            newRoutes.push(newRouteConfig);\n          } // end registryItems\n        } // end package.registry\n\n        //\n        // add group and routes to routing table\n        //\n        const uniqRoutes = new Set(newRoutes);\n        let index = 0;\n        for (const route of uniqRoutes) {\n          // allow overriding of prefix in route definitions\n          // define an \"absolute\" url by excluding \"/\"\n          route.group = {};\n\n          if (route.route.substring(0, 1) !== \"/\") {\n            route.route = \"/\" + route.route;\n            route.group.prefix = \"\";\n          } else if (shopCount <= 1) {\n            route.group.prefix = \"\";\n          } else {\n            route.group.prefix = prefix;\n            route.route = `${prefix}${route.route}`;\n          }\n\n          // Add the route to the routing table\n          reactRouterRoutes.push(\n            <Route\n              key={`${pkg.name}-${route.name}-${index++}`}\n              path={route.route}\n              exact={true}\n              render={route.options.component}\n            />\n          );\n\n          Router.routes.push(route);\n        }\n      }\n    } // end package loop\n\n    Router._initialized = true;\n    Router.reactComponents = reactRouterRoutes;\n    Router._routes = Router.routes;\n\n    routerReadyDependency.changed();\n  }\n};\n\n\nexport default Router;\n"]},"hash":"c93f375cc751d78097a2d082f2fbf411e92ba6cd"}
