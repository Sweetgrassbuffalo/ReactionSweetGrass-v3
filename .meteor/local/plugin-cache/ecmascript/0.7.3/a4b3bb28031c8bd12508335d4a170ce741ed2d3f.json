{"metadata":{"usedHelpers":["extends","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":["copyFile","fileObj","newMetaData"],"specifiers":[{"kind":"local","local":"copyFile","exported":"copyFile"},{"kind":"local","local":"fileObj","exported":"fileObj"},{"kind":"local","local":"newMetaData","exported":"newMetaData"}]}}},"options":{"filename":"/lib/api/files.js","filenameRelative":"/lib/api/files.js","inputSourceMap":{"version":3,"sources":["/lib/api/files.js"],"names":["_copyStoreData","fileObj","storeName","sourceKey","callback","isMounted","Error","storage","collection","storesLookup","destinationKey","adapter","fileKey","readStream","createReadStreamForFileKey","writeStream","createWriteStreamForFileKey","once","result","error","pipe","copyStoreData","Meteor","wrapAsync","copyFile","newMetaData","self","fileRecord","files","findOne","_id","transform","oldMetaData","metadata","newId","direct","insert","newFile","mod","oldKey","name","copies","hasOwnProperty","key","sourceFileStorage","update","$set"],"mappings":";;;;;;AAAA;;WAIA,AAAS,AAAe,AAAS,AAAW,AAAW,AAAU;;;;;;;GAC/D,AAAI,AAAC,SAAQ,eAAb,AAAK,AAAqB;OAClB,AAAI,QAAJ,AAAU,aAAhB,AAAM,AACP;;AAED,AAAM,AAAU,AAAQ,AAAW,AAAa;;gDAChD;;MAAI,CAAJ,AAAK,SAAS,AACZ;UAAM,IAAA,AAAI,MAAM,YAAhB,AAAM,AAAsB,AAC7B;AAR8D,AAU/D,AACA,GATE;AAUF;;;MAAM,iBAAiB,QAAA,AAAQ,QAAR,AAAgB,QAAvC,AAAuB,AAAwB,AAC/C;MAAM,aAAa,QAAA,AAAQ,QAAR,AAAgB,2BAAnC,AAAmB,AAA2C,AAC9D;MAAM,cAAc,QAAA,AAAQ,QAAR,AAAgB,4BAApC,AAAoB,AAA4C,AAEhE,AAAY,AAAK,AAAU,AAAU,AAAQ,AAC3C;AAAS,cAAT,KAAe,AAAO,UAAtB,kBADF,AAEC;0BAED;AAAA,AAAY,AAAK,AAAS,AAAU,AAAO,AACzC,AAAS,AACV;AAFD,6CAIA;aAAA,AAAW,AAAK,AACjB;AACD;AAAM,kBAAN,AAAsB,A,AAAA,AAAO,AAAU,AAEvC;;;sDAIA,AAAO,AAAS,AAAS,AAAS,AAAa,AAC7C,AAAM,AAAO,AAEb,AAAI,AAAC,AAAK,AAAa,AACrB;;;;;AAAM,AAAI,SAAJ,AAAU;AAJ2B,AAO7C;;yBACA;AAAM,oBAAa,AAAK,AAAW,AAAM,AAAQ,AAAE;AAAhC,AAA8B,AAAO,AAAK,AAAO,AAAE,GAJpE,AAAM,AACP,CAGmE,AAAa;;;AAA9D,MAAnB,AAA4F;;;;QAE5F;;MAAA,AAAI,aAAa,AACf;QAAM,cAAc,WAAA,AAAW,YAA/B,AAA2C,AAE3C,AAAW,AAAW,AACpB;AAAG,eADiB,AAEpB,sCAFF,AAAsB,AAEjB,aAfsC,AAiB5C,AAED;AACA,IApB6C,AAoB7C,AAAO,AAAW,AAElB;;;oBACA,AAAM,AAAQ,AAAK,AAAW,AAAM,AAAO,AAAO,AAElD,KAzB6C,AAyB7C,AAAM,AAAU,AAAK,AAAW,AAAQ,AAExC;;kDACA,AAAI,AACJ;AAAI,MAAJ,kCACA,QAAA,AAAK,AAAM,AAAQ,AAAQ,AAAQ,AACjC;;MAAA,AAAI,AAAQ,AAAO,AAAe,AAAO,AACvC;MAAA,AAAS,AAAQ,AAAO,AAAM;;2EAC9B;QAAI,QAAJ,AAAY,6BACV;oCACA;;kBACA;AACA;AACA;AACA;AACA;AAAA,AAAM,AAAoB,AAAK,AAAW,AAAa;AACvD;AAAI,AAAC,YAAL,AAAwB,iDACtB;;aAAM,AAAI,AAAM,mBAAhB,AAAM,AAAiB,AACxB;;AACD;;iBAAS,kBAAA,AAAkB,QAAlB,AAA0B,QAXzB,AAWV,AAAS,AAAkC,AAC3C,OACA;;eAAO,QAAA,AAAQ,OAAR,AAAe,MAAtB,AAA4B,AAC5B;cAAM,OAAN,AAAa,AACb;YAAI,YAAA,AAAY,OAAhB,AAAuB,UAAU,cAAA,AAAc,SAAd,AAAuB,MAAxD,AAAiC,AAA6B,AAC/D;AACF;AACF;AAnD4C,AAoD7C;;;WACA;AAAI,SAAJ,AAAS;AACF,WAAL,AAAgB,AAAM,AAAO,AAAO,AAClC;AADF;AAEG,YAAA,AACD,AAAM;AAHR,AAAoC,AAC7B;AADP,AAKD;;SAED;AAAA,AAAO,AACR","file":"/lib/api/files.js.map","sourcesContent":["/*\n * Copy store data, copied from Meteor CollectionsFS\n * https://github.com/CollectionFS/Meteor-CollectionFS/blob/master/packages/file/fsFile-server.js#L225\n */\nfunction _copyStoreData(fileObj, storeName, sourceKey, callback) {\n  if (!fileObj.isMounted()) {\n    throw new Error(\"Cannot copy store data for a file that is not associated with a collection\");\n  }\n\n  const storage = fileObj.collection.storesLookup[storeName];\n  if (!storage) {\n    throw new Error(storeName + \" is not a valid store name\");\n  }\n\n  // We want to prevent beforeWrite and transformWrite from running, so\n  // we interact directly with the store.\n  const destinationKey = storage.adapter.fileKey(fileObj);\n  const readStream = storage.adapter.createReadStreamForFileKey(sourceKey);\n  const writeStream = storage.adapter.createWriteStreamForFileKey(destinationKey);\n\n  writeStream.once(\"stored\", function (result) {\n    callback(null, result.fileKey);\n  });\n\n  writeStream.once(\"error\", function (error) {\n    callback(error);\n  });\n\n  readStream.pipe(writeStream);\n}\nconst copyStoreData = Meteor.wrapAsync(_copyStoreData);\n\n/*\n * Modified from Meteor CollectionsFS\n * https://github.com/CollectionFS/Meteor-CollectionFS/blob/master/packages/file/fsFile-server.js#L126\n */\nexport function copyFile(fileObj, newMetaData) {\n  const self = fileObj;\n\n  if (!self.isMounted()) {\n    throw new Error(\"Cannot copy a file that is not associated with a collection\");\n  }\n\n  // Get the file record\n  const fileRecord = self.collection.files.findOne({ _id: self._id }, { transform: null }) || {};\n\n  if (newMetaData) {\n    const oldMetaData = fileRecord.metadata || {};\n\n    fileRecord.metadata = {\n      ...oldMetaData,\n      ...newMetaData\n    };\n  }\n\n  // Remove _id and copy keys from the file record\n  delete fileRecord._id;\n\n  // Insert directly; we don't have access to \"original\" in this case\n  const newId = self.collection.files.direct.insert(fileRecord);\n\n  const newFile = self.collection.findOne(newId);\n\n  // Copy underlying files in the stores\n  let mod;\n  let oldKey;\n  for (const name in newFile.copies) {\n    if (newFile.copies.hasOwnProperty(name)) {\n      oldKey = newFile.copies[name].key;\n      if (oldKey) {\n        // We need to ask the adapter for the true oldKey because\n        // right now gridfs does some extra stuff.\n        // TODO GridFS should probably set the full key object\n        // (with _id and filename) into `copies.key`\n        // so that copies.key can be passed directly to\n        // createReadStreamForFileKey\n        const sourceFileStorage = self.collection.storesLookup[name];\n        if (!sourceFileStorage) {\n          throw new Error(name + \" is not a valid store name\");\n        }\n        oldKey = sourceFileStorage.adapter.fileKey(self);\n        // delete so that new fileKey will be generated in copyStoreData\n        delete newFile.copies[name].key;\n        mod = mod || {};\n        mod[\"copies.\" + name + \".key\"] = copyStoreData(newFile, name, oldKey);\n      }\n    }\n  }\n  // Update keys in the filerecord\n  if (mod) {\n    self.collection.files.direct.update({\n      _id: newId\n    }, {\n      $set: mod\n    });\n  }\n\n  return newFile;\n}\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/lib/api/files.js.map","sourceFileName":"/lib/api/files.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"files"},"ignored":false,"code":"var _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n  copyFile: function () {\n    return copyFile;\n  }\n});\n\n/*\n * Copy store data, copied from Meteor CollectionsFS\n * https://github.com/CollectionFS/Meteor-CollectionFS/blob/master/packages/file/fsFile-server.js#L225\n */function _copyStoreData(fileObj, storeName, sourceKey, callback) {\n  if (!fileObj.isMounted()) {\n    throw new Error(\"Cannot copy store data for a file that is not associated with a collection\");\n  }\n\n  var storage = fileObj.collection.storesLookup[storeName];\n\n  if (!storage) {\n    throw new Error(storeName + \" is not a valid store name\");\n  } // We want to prevent beforeWrite and transformWrite from running, so\n  // we interact directly with the store.\n\n\n  var destinationKey = storage.adapter.fileKey(fileObj);\n  var readStream = storage.adapter.createReadStreamForFileKey(sourceKey);\n  var writeStream = storage.adapter.createWriteStreamForFileKey(destinationKey);\n  writeStream.once(\"stored\", function (result) {\n    callback(null, result.fileKey);\n  });\n  writeStream.once(\"error\", function (error) {\n    callback(error);\n  });\n  readStream.pipe(writeStream);\n}\n\nvar copyStoreData = Meteor.wrapAsync(_copyStoreData); /*\n                                                       * Modified from Meteor CollectionsFS\n                                                       * https://github.com/CollectionFS/Meteor-CollectionFS/blob/master/packages/file/fsFile-server.js#L126\n                                                       */\n\nfunction copyFile(fileObj, newMetaData) {\n  var self = fileObj;\n\n  if (!self.isMounted()) {\n    throw new Error(\"Cannot copy a file that is not associated with a collection\");\n  } // Get the file record\n\n\n  var fileRecord = self.collection.files.findOne({\n    _id: self._id\n  }, {\n    transform: null\n  }) || {};\n\n  if (newMetaData) {\n    var oldMetaData = fileRecord.metadata || {};\n    fileRecord.metadata = (0, _extends3.default)({}, oldMetaData, newMetaData);\n  } // Remove _id and copy keys from the file record\n\n\n  delete fileRecord._id; // Insert directly; we don't have access to \"original\" in this case\n\n  var newId = self.collection.files.direct.insert(fileRecord);\n  var newFile = self.collection.findOne(newId); // Copy underlying files in the stores\n\n  var mod = void 0;\n  var oldKey = void 0;\n\n  for (var name in meteorBabelHelpers.sanitizeForInObject(newFile.copies)) {\n    if (newFile.copies.hasOwnProperty(name)) {\n      oldKey = newFile.copies[name].key;\n\n      if (oldKey) {\n        // We need to ask the adapter for the true oldKey because\n        // right now gridfs does some extra stuff.\n        // TODO GridFS should probably set the full key object\n        // (with _id and filename) into `copies.key`\n        // so that copies.key can be passed directly to\n        // createReadStreamForFileKey\n        var sourceFileStorage = self.collection.storesLookup[name];\n\n        if (!sourceFileStorage) {\n          throw new Error(name + \" is not a valid store name\");\n        }\n\n        oldKey = sourceFileStorage.adapter.fileKey(self); // delete so that new fileKey will be generated in copyStoreData\n\n        delete newFile.copies[name].key;\n        mod = mod || {};\n        mod[\"copies.\" + name + \".key\"] = copyStoreData(newFile, name, oldKey);\n      }\n    }\n  } // Update keys in the filerecord\n\n\n  if (mod) {\n    self.collection.files.direct.update({\n      _id: newId\n    }, {\n      $set: mod\n    });\n  }\n\n  return newFile;\n}","map":{"version":3,"sources":["/lib/api/files.js"],"names":["_copyStoreData","fileObj","storeName","sourceKey","callback","isMounted","Error","storage","collection","storesLookup","destinationKey","adapter","fileKey","readStream","createReadStreamForFileKey","writeStream","createWriteStreamForFileKey","once","result","error","pipe","copyStoreData","Meteor","wrapAsync","copyFile","newMetaData","self","fileRecord","files","findOne","_id","transform","oldMetaData","metadata","newId","direct","insert","newFile","mod","oldKey","name","copies","hasOwnProperty","key","sourceFileStorage","update","$set"],"mappings":";;;;;;AAAA;;WAIA,AAAS,AAAe,AAAS,AAAW,AAAW,AAAU;;;;;;;GAC/D,AAAI,AAAC,SAAQ,eAAb,AAAK,AAAqB;OAClB,AAAI,QAAJ,AAAU,aAAhB,AAAM,AACP;;AAED,AAAM,AAAU,AAAQ,AAAW,AAAa;;gDAChD;;MAAI,CAAJ,AAAK,SAAS,AACZ;UAAM,IAAA,AAAI,MAAM,YAAhB,AAAM,AAAsB,AAC7B;AAR8D,AAU/D,AACA,GATE;AAUF;;;MAAM,iBAAiB,QAAA,AAAQ,QAAR,AAAgB,QAAvC,AAAuB,AAAwB,AAC/C;MAAM,aAAa,QAAA,AAAQ,QAAR,AAAgB,2BAAnC,AAAmB,AAA2C,AAC9D;MAAM,cAAc,QAAA,AAAQ,QAAR,AAAgB,4BAApC,AAAoB,AAA4C,AAEhE,AAAY,AAAK,AAAU,AAAU,AAAQ,AAC3C;AAAS,cAAT,KAAe,AAAO,UAAtB,kBADF,AAEC;0BAED;AAAA,AAAY,AAAK,AAAS,AAAU,AAAO,AACzC,AAAS,AACV;AAFD,6CAIA;aAAA,AAAW,AAAK,AACjB;AACD;AAAM,kBAAN,AAAsB,A,AAAA,AAAO,AAAU,AAEvC;;;sDAIA,AAAO,AAAS,AAAS,AAAS,AAAa,AAC7C,AAAM,AAAO,AAEb,AAAI,AAAC,AAAK,AAAa,AACrB;;;;;AAAM,AAAI,SAAJ,AAAU;AAJ2B,AAO7C;;yBACA;AAAM,oBAAa,AAAK,AAAW,AAAM,AAAQ,AAAE;AAAhC,AAA8B,AAAO,AAAK,AAAO,AAAE,GAJpE,AAAM,AACP,CAGmE,AAAa;;;AAA9D,MAAnB,AAA4F;;;;QAE5F;;MAAA,AAAI,aAAa,AACf;QAAM,cAAc,WAAA,AAAW,YAA/B,AAA2C,AAE3C,AAAW,AAAW,AACpB;AAAG,eADiB,AAEpB,sCAFF,AAAsB,AAEjB,aAfsC,AAiB5C,AAED;AACA,IApB6C,AAoB7C,AAAO,AAAW,AAElB;;;oBACA,AAAM,AAAQ,AAAK,AAAW,AAAM,AAAO,AAAO,AAElD,KAzB6C,AAyB7C,AAAM,AAAU,AAAK,AAAW,AAAQ,AAExC;;kDACA,AAAI,AACJ;AAAI,MAAJ,kCACA,QAAA,AAAK,AAAM,AAAQ,AAAQ,AAAQ,AACjC;;MAAA,AAAI,AAAQ,AAAO,AAAe,AAAO,AACvC;MAAA,AAAS,AAAQ,AAAO,AAAM;;2EAC9B;QAAI,QAAJ,AAAY,6BACV;oCACA;;kBACA;AACA;AACA;AACA;AACA;AAAA,AAAM,AAAoB,AAAK,AAAW,AAAa;AACvD;AAAI,AAAC,YAAL,AAAwB,iDACtB;;aAAM,AAAI,AAAM,mBAAhB,AAAM,AAAiB,AACxB;;AACD;;iBAAS,kBAAA,AAAkB,QAAlB,AAA0B,QAXzB,AAWV,AAAS,AAAkC,AAC3C,OACA;;eAAO,QAAA,AAAQ,OAAR,AAAe,MAAtB,AAA4B,AAC5B;cAAM,OAAN,AAAa,AACb;YAAI,YAAA,AAAY,OAAhB,AAAuB,UAAU,cAAA,AAAc,SAAd,AAAuB,MAAxD,AAAiC,AAA6B,AAC/D;AACF;AACF;AAnD4C,AAoD7C;;;WACA;AAAI,SAAJ,AAAS;AACF,WAAL,AAAgB,AAAM,AAAO,AAAO,AAClC;AADF;AAEG,YAAA,AACD,AAAM;AAHR,AAAoC,AAC7B;AADP,AAKD;;SAED;AAAA,AAAO,AACR","file":"/lib/api/files.js.map","sourcesContent":["/*\n * Copy store data, copied from Meteor CollectionsFS\n * https://github.com/CollectionFS/Meteor-CollectionFS/blob/master/packages/file/fsFile-server.js#L225\n */\nfunction _copyStoreData(fileObj, storeName, sourceKey, callback) {\n  if (!fileObj.isMounted()) {\n    throw new Error(\"Cannot copy store data for a file that is not associated with a collection\");\n  }\n\n  const storage = fileObj.collection.storesLookup[storeName];\n  if (!storage) {\n    throw new Error(storeName + \" is not a valid store name\");\n  }\n\n  // We want to prevent beforeWrite and transformWrite from running, so\n  // we interact directly with the store.\n  const destinationKey = storage.adapter.fileKey(fileObj);\n  const readStream = storage.adapter.createReadStreamForFileKey(sourceKey);\n  const writeStream = storage.adapter.createWriteStreamForFileKey(destinationKey);\n\n  writeStream.once(\"stored\", function (result) {\n    callback(null, result.fileKey);\n  });\n\n  writeStream.once(\"error\", function (error) {\n    callback(error);\n  });\n\n  readStream.pipe(writeStream);\n}\nconst copyStoreData = Meteor.wrapAsync(_copyStoreData);\n\n/*\n * Modified from Meteor CollectionsFS\n * https://github.com/CollectionFS/Meteor-CollectionFS/blob/master/packages/file/fsFile-server.js#L126\n */\nexport function copyFile(fileObj, newMetaData) {\n  const self = fileObj;\n\n  if (!self.isMounted()) {\n    throw new Error(\"Cannot copy a file that is not associated with a collection\");\n  }\n\n  // Get the file record\n  const fileRecord = self.collection.files.findOne({ _id: self._id }, { transform: null }) || {};\n\n  if (newMetaData) {\n    const oldMetaData = fileRecord.metadata || {};\n\n    fileRecord.metadata = {\n      ...oldMetaData,\n      ...newMetaData\n    };\n  }\n\n  // Remove _id and copy keys from the file record\n  delete fileRecord._id;\n\n  // Insert directly; we don't have access to \"original\" in this case\n  const newId = self.collection.files.direct.insert(fileRecord);\n\n  const newFile = self.collection.findOne(newId);\n\n  // Copy underlying files in the stores\n  let mod;\n  let oldKey;\n  for (const name in newFile.copies) {\n    if (newFile.copies.hasOwnProperty(name)) {\n      oldKey = newFile.copies[name].key;\n      if (oldKey) {\n        // We need to ask the adapter for the true oldKey because\n        // right now gridfs does some extra stuff.\n        // TODO GridFS should probably set the full key object\n        // (with _id and filename) into `copies.key`\n        // so that copies.key can be passed directly to\n        // createReadStreamForFileKey\n        const sourceFileStorage = self.collection.storesLookup[name];\n        if (!sourceFileStorage) {\n          throw new Error(name + \" is not a valid store name\");\n        }\n        oldKey = sourceFileStorage.adapter.fileKey(self);\n        // delete so that new fileKey will be generated in copyStoreData\n        delete newFile.copies[name].key;\n        mod = mod || {};\n        mod[\"copies.\" + name + \".key\"] = copyStoreData(newFile, name, oldKey);\n      }\n    }\n  }\n  // Update keys in the filerecord\n  if (mod) {\n    self.collection.files.direct.update({\n      _id: newId\n    }, {\n      $set: mod\n    });\n  }\n\n  return newFile;\n}\n"]},"hash":"a4b3bb28031c8bd12508335d4a170ce741ed2d3f"}
