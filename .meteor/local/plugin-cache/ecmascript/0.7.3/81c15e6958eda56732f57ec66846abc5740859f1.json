{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/check","imported":["check","Match"],"specifiers":[{"kind":"named","imported":"check","local":"check"},{"kind":"named","imported":"Match","local":"Match"}]},{"source":"meteor/http","imported":["HTTP"],"specifiers":[{"kind":"named","imported":"HTTP","local":"HTTP"}]},{"source":"meteor/vsivsi:job-collection","imported":["Job"],"specifiers":[{"kind":"named","imported":"Job","local":"Job"}]},{"source":"/lib/collections","imported":["*"],"specifiers":[{"kind":"namespace","local":"Collections"}]},{"source":"/lib/collections/schemas","imported":["*"],"specifiers":[{"kind":"namespace","local":"Schemas"}]},{"source":"/server/api","imported":["GeoCoder","Logger","Reaction"],"specifiers":[{"kind":"named","imported":"GeoCoder","local":"GeoCoder"},{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/methods/core/shop.js","filenameRelative":"/server/methods/core/shop.js","inputSourceMap":{"version":3,"sources":["/server/methods/core/shop.js"],"names":["Meteor","check","Match","HTTP","Job","Collections","Schemas","GeoCoder","Logger","Reaction","methods","shopAdminUserId","shopData","Optional","String","Shop","shop","hasOwnerAccess","Error","count","Shops","find","currentUser","userId","findOne","getShopId","adminRoles","Roles","getRolesForUser","_id","Random","id","name","insert","error","info","addUsersToRoles","unblock","clientAddress","geo","result","defaultCountryCode","localeCurrency","connection","fields","addressBook","locales","currencies","currency","length","country","geoCountryCode","geoip","country_code","countryCode","toUpperCase","locale","countries","shopCurrency","split","_","each","exchangeRate","call","warn","Locale","field","rate","shopId","baseCurrency","shopCurrencies","shopSettings","Packages","settings","openexchangerates","appId","openexchangeratesAppId","rateUrl","rateResults","get","message","response","data","description","exchangeRates","rates","currencyConfig","currencyKey","undefined","rateUpdate","Date","timestamp","collectionKey","update","$set","updatedAt","setHours","getHours","now","$unset","modifier","CorePackageConfig","hasPermission","refreshPeriod","fetchCurrencyRatesJob","Jobs","priority","retry","retries","wait","backoff","repeat","schedule","later","parse","text","save","cancelRepeats","latitude","longitude","Number","reverse","tagName","isTopLevel","Boolean","tag","slug","getSlug","createdAt","Tags","tagId","currentTagId","OneOf","newTagId","newTag","existingTag","debug","$addToSet","relatedTagIds","$pull","productCount","Products","hashtags","$in","relatedTagsCount","remove","shopWorkflows","defaultWorkflows","$elemMatch","provides","language","enabled","defaultLanguage","updateObject","Array","isArray","languages","forEach","languageData","index","i18n","defaultCurrency","currencyName","hasOwnProperty","asset","mediaId","type","shopWithBrandAsset","$push","brandAssets","packageId","hasAdminAccess","newLayout","i","layout"],"mappings":"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","file":"/server/methods/core/shop.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { HTTP } from \"meteor/http\";\nimport { Job } from \"meteor/vsivsi:job-collection\";\nimport * as Collections from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { GeoCoder, Logger, Reaction } from \"/server/api\";\n\n/**\n * Reaction Shop Methods\n */\nMeteor.methods({\n  /**\n   * shop/createShop\n   * @param {String} shopAdminUserId - optionally create shop for provided userId\n   * @param {Object} shopData - optionally provide shop object to customize\n   * @return {String} return shopId\n   */\n  \"shop/createShop\": function (shopAdminUserId, shopData) {\n    check(shopAdminUserId, Match.Optional(String));\n    check(shopData, Match.Optional(Schemas.Shop));\n    let shop = {};\n    // must have owner access to create new shops\n    if (!Reaction.hasOwnerAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    // this.unblock();\n    const count = Collections.Shops.find().count() || \"\";\n    const currentUser = Meteor.userId();\n    // we'll accept a shop object, or clone the current shop\n    shop = shopData || Collections.Shops.findOne(Reaction.getShopId());\n    // if we don't have any shop data, use fixture\n\n    check(shop, Schemas.Shop);\n    if (!currentUser) {\n      throw new Meteor.Error(\"Unable to create shop with specified user\");\n    }\n\n    // identify a shop admin\n    const userId = shopAdminUserId || Meteor.userId();\n    const adminRoles = Roles.getRolesForUser(currentUser, Reaction.getShopId());\n    // ensure unique id and shop name\n    shop._id = Random.id();\n    shop.name = shop.name + count;\n\n    check(shop, Schemas.Shop);\n    try {\n      Collections.Shops.insert(shop);\n    } catch (error) {\n      return Logger.error(error, \"Failed to shop/createShop\");\n    }\n    // we should have created new shop, or errored\n    Logger.info(\"Created shop: \", shop._id);\n    Roles.addUsersToRoles([currentUser, userId], adminRoles, shop._id);\n    return shop._id;\n  },\n\n  /**\n   * shop/getLocale\n   * @summary determine user's countryCode and return locale object\n   * determine local currency and conversion rate from shop currency\n   * @return {Object} returns user location and locale\n   */\n  \"shop/getLocale\": function () {\n    this.unblock();\n    let clientAddress;\n    const geo = new GeoCoder();\n    const result = {};\n    let defaultCountryCode = \"US\";\n    let localeCurrency = \"USD\";\n    // if called from server, ip won't be defined.\n    if (this.connection !== null) {\n      clientAddress = this.connection.clientAddress;\n    } else {\n      clientAddress = \"127.0.0.1\";\n    }\n\n    // get shop locale/currency related data\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n\n    if (!shop) {\n      throw new Meteor.Error(\n        \"Failed to find shop data. Unable to determine locale.\");\n    }\n    // cofigure default defaultCountryCode\n    // fallback to shop settings\n    if (shop.addressBook) {\n      if (shop.addressBook.length >= 1) {\n        if (shop.addressBook[0].country) {\n          defaultCountryCode = shop.addressBook[0].country;\n        }\n      }\n    }\n    // geocode reverse ip lookup\n    const geoCountryCode = geo.geoip(clientAddress).country_code;\n\n    // countryCode either from geo or defaults\n    const countryCode = (geoCountryCode || defaultCountryCode).toUpperCase();\n\n    // get currency rates\n    result.currency = {};\n    result.locale = shop.locales.countries[countryCode];\n\n    // to return default currency if rates will failed, we need to bring access\n    // to this data\n    result.shopCurrency = shop.currencies[shop.currency];\n\n    // check if locale has a currency defined\n    if (typeof result.locale === \"object\" &&\n      typeof result.locale.currency === \"string\") {\n      localeCurrency = result.locale.currency.split(\",\");\n    }\n\n    // localeCurrency is an array of allowed currencies\n    _.each(localeCurrency, function (currency) {\n      let exchangeRate;\n      if (shop.currencies[currency]) {\n        result.currency = shop.currencies[currency];\n        // only fetch rates if locale and shop currency are not equal\n        // if shop.curency = locale currency the rate is 1\n        if (shop.currency !== currency) {\n          exchangeRate = Meteor.call(\"shop/getCurrencyRates\", currency);\n\n          if (typeof exchangeRate === \"number\") {\n            result.currency.exchangeRate = exchangeRate;\n          } else {\n            Logger.warn(\"Failed to get currency exchange rates.\");\n          }\n        }\n      }\n    });\n\n    // set server side locale\n    Reaction.Locale = result;\n\n    // should contain rates, locale, currency\n    return result;\n  },\n\n  /**\n   * shop/getCurrencyRates\n   * @summary It returns the current exchange rate against the shop currency\n   * usage: Meteor.call(\"shop/getCurrencyRates\",\"USD\")\n   * @param {String} currency code\n   * @return {Number|Object} currency conversion rate\n   */\n  \"shop/getCurrencyRates\": function (currency) {\n    check(currency, String);\n    this.unblock();\n\n    const field = `currencies.${currency}.rate`;\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        [field]: 1\n      }\n    });\n\n    return typeof shop.currencies[currency].rate === \"number\" &&\n      shop.currencies[currency].rate;\n  },\n\n  /**\n   * shop/fetchCurrencyRate\n   * @summary fetch the latest currency rates from\n   * https://openexchangerates.org\n   * usage: Meteor.call(\"shop/fetchCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/fetchCurrencyRate\": function () {\n    this.unblock();\n\n    const shopId = Reaction.getShopId();\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n    const baseCurrency = shop.currency || \"USD\";\n    const shopCurrencies = shop.currencies;\n\n    // fetch shop settings for api auth credentials\n    const shopSettings = Collections.Packages.findOne({\n      shopId: shopId,\n      name: \"core\"\n    }, {\n      fields: {\n        settings: 1\n      }\n    });\n\n    // update Shops.currencies[currencyKey].rate\n    // with current rates from Open Exchange Rates\n    // warn if we don't have app_id\n    if (!shopSettings.settings.openexchangerates) {\n      throw new Meteor.Error(\"notConfigured\",\n        \"Open Exchange Rates not configured. Configure for current rates.\");\n    } else {\n      if (!shopSettings.settings.openexchangerates.appId) {\n        throw new Meteor.Error(\"notConfigured\",\n          \"Open Exchange Rates AppId not configured. Configure for current rates.\");\n      } else {\n        // shop open exchange rates appId\n        const openexchangeratesAppId = shopSettings.settings.openexchangerates.appId;\n\n        // we'll update all the available rates in Shops.currencies whenever we\n        // get a rate request, using base currency\n        const rateUrl =\n          `https://openexchangerates.org/api/latest.json?base=${\n          baseCurrency}&app_id=${openexchangeratesAppId}`;\n        let rateResults;\n\n        // We can get an error if we try to change the base currency with a simple\n        // account\n        try {\n          rateResults = HTTP.get(rateUrl);\n        } catch (error) {\n          if (error.error) {\n            Logger.error(error.message);\n            throw new Meteor.Error(error.message);\n          } else {\n            // https://openexchangerates.org/documentation#errors\n            throw new Meteor.Error(error.response.data.description);\n          }\n        }\n\n        const exchangeRates = rateResults.data.rates;\n\n        _.each(shopCurrencies, function (currencyConfig, currencyKey) {\n          if (exchangeRates[currencyKey] !== undefined) {\n            const rateUpdate = {\n              // this needed for shop/flushCurrencyRates Method\n              \"currencies.updatedAt\": new Date(rateResults.data.timestamp * 1000)\n            };\n            const collectionKey = `currencies.${currencyKey}.rate`;\n            rateUpdate[collectionKey] = exchangeRates[currencyKey];\n            Collections.Shops.update(shopId, {\n              $set: rateUpdate\n            });\n          }\n        });\n      }\n    }\n  },\n\n  /**\n   * shop/flushCurrencyRate\n   * @description Method calls by cron job\n   * @summary It removes exchange rates that are too old\n   * usage: Meteor.call(\"shop/flushCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/flushCurrencyRate\": function () {\n    this.unblock();\n\n    const shopId = Reaction.getShopId();\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        currencies: 1\n      }\n    });\n    const updatedAt = shop.currencies.updatedAt;\n\n    // if updatedAt is not a Date(), then there is no rates yet\n    if (typeof updatedAt !== \"object\") {\n      throw new Meteor.Error(\"notExists\",\n        \"[flushCurrencyRates worker]: There is nothing to flush.\");\n    }\n\n    updatedAt.setHours(updatedAt.getHours() + 48);\n    const now = new Date();\n\n    if (now < updatedAt) { // todo remove this line. its for tests\n      _.each(shop.currencies, function (currencyConfig, currencyKey) {\n        const rate = `currencies.${currencyKey}.rate`;\n\n        if (typeof currencyConfig.rate === \"number\") {\n          Collections.Shops.update(shopId, {\n            $unset: {\n              [rate]: \"\"\n            }\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * shop/updateShopExternalServices\n   * @description On submit OpenExchangeRatesForm handler\n   * @summary we need to rerun fetch exchange rates job on every form submit,\n   * that's why we update autoform type to \"method-update\"\n   * @param {Object} modifier - the modifier object generated from the form values\n   * @param {String} _id - the _id of the document being updated\n   * @fires Collections.Packages#update\n   * @todo This method fires Packages collection, so maybe someday it could be\n   * @returns {undefined}\n   * moved to another file\n   */\n  \"shop/updateShopExternalServices\": function (modifier, _id) {\n    check(modifier, Match.Optional(Schemas.CorePackageConfig));\n    check(_id, String);\n\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    // we should run new job on every form change, even if not all of them will\n    // change currencyRate job\n    const refreshPeriod = modifier.$set[\"settings.openexchangerates.refreshPeriod\"];\n    const fetchCurrencyRatesJob = new Job(Collections.Jobs, \"shop/fetchCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\" // delay by twice as long for each subsequent retry\n      })\n      .repeat({\n        // wait: refreshPeriod * 60 * 1000\n        schedule: Collections.Jobs.later.parse.text(refreshPeriod)\n      })\n      .save({\n        // Cancel any jobs of the same type,\n        // but only if this job repeats forever.\n        cancelRepeats: true\n      });\n\n    Collections.Packages.update(_id, modifier);\n    return fetchCurrencyRatesJob;\n  },\n\n  /**\n   * shop/locateAddress\n   * @summary determine user's full location for autopopulating addresses\n   * @param {Number} latitude - latitude\n   * @param {Number} longitude - longitude\n   * @return {Object} returns address\n   */\n  \"shop/locateAddress\": function (latitude, longitude) {\n    check(latitude, Match.Optional(Number));\n    check(longitude, Match.Optional(Number));\n    let clientAddress;\n    this.unblock();\n\n    // if called from server, ip won't be defined.\n    if (this.connection !== null) {\n      clientAddress = this.connection.clientAddress;\n    } else {\n      clientAddress = \"127.0.0.1\";\n    }\n\n    // begin actual address lookups\n    if (latitude !== null && longitude !== null) {\n      const geo = new GeoCoder();\n      return geo.reverse(latitude, longitude);\n    }\n    // geocode reverse ip lookup\n    const geo = new GeoCoder();\n    return geo.geoip(clientAddress);\n  },\n\n  /**\n   * shop/createTag\n   * @summary creates new tag\n   * @param {String} tagName - new tag name\n   * @param {Boolean} isTopLevel - if true -- new tag will be created on top of\n   * tags tree\n   * @since 0.14.0\n   * @hooks after method\n   * @return {String} with created tag _id\n   */\n  \"shop/createTag\": function (tagName, isTopLevel) {\n    check(tagName, String);\n    check(isTopLevel, Boolean);\n\n    // must have 'core' permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const tag = {\n      name: tagName,\n      slug: Reaction.getSlug(tagName),\n      isTopLevel: isTopLevel,\n      updatedAt: new Date(),\n      createdAt: new Date()\n    };\n\n    return Collections.Tags.insert(tag);\n  },\n\n  /**\n   * shop/updateHeaderTags\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} tagName will insert, tagName + tagId will update existing\n   * @param {String} tagId - tagId to update\n   * @param {String} currentTagId - currentTagId will update related/hierarchy\n   * @return {Boolean} return true/false after insert\n   */\n  \"shop/updateHeaderTags\": function (tagName, tagId, currentTagId) {\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null, void 0));\n    check(currentTagId, Match.OneOf(String, null, void 0));\n\n    let newTagId = {};\n    // must have 'core' permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n\n    const existingTag = Collections.Tags.findOne({\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    });\n\n    if (tagId) {\n      return Collections.Tags.update(tagId, {\n        $set: newTag\n      }, function () {\n        Logger.debug(\n          `Changed name of tag ${tagId} to ${tagName}`);\n        return true;\n      });\n    } else if (existingTag) {\n      // if is currentTag\n      if (currentTagId) {\n        return Collections.Tags.update(currentTagId, {\n          $addToSet: {\n            relatedTagIds: existingTag._id\n          }\n        }, function () {\n          Logger.debug(\n            `Added tag ${existingTag.name} to the related tags list for tag ${currentTagId}`\n          );\n          return true;\n        });\n      }\n      // update existing tag\n      return Collections.Tags.update(existingTag._id, {\n        $set: {\n          isTopLevel: true\n        }\n      }, function () {\n        Logger.debug(`Marked tag ${existingTag.name} as a top level tag`);\n        return true;\n      });\n    }\n    // create newTags\n    newTagId = Meteor.call(\"shop/createTag\", tagName, !currentTagId);\n\n    // if result is an Error object, we return it immediately\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    if (currentTagId) {\n      return Collections.Tags.update(currentTagId, {\n        $addToSet: {\n          relatedTagIds: newTagId\n        }\n      }, function () {\n        Logger.debug(`Added tag${newTag.name} to the related tags list for tag ${currentTagId}`);\n        return true;\n      });\n      // TODO: refactor this. unnecessary check\n    } else if (typeof newTagId === \"string\" && !currentTagId) {\n      return true;\n    }\n    throw new Meteor.Error(403, \"Failed to update header tags.\");\n  },\n\n  /**\n   * shop/removeHeaderTag\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\n  \"shop/removeHeaderTag\": function (tagId, currentTagId) {\n    check(tagId, String);\n    check(currentTagId, String);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n    // remove from related tag use\n    Collections.Tags.update(currentTagId, {\n      $pull: {\n        relatedTagIds: tagId\n      }\n    });\n    // check to see if tag is in use.\n    const productCount = Collections.Products.find({\n      hashtags: {\n        $in: [tagId]\n      }\n    }).count();\n    // check to see if in use as a related tag\n    const relatedTagsCount = Collections.Tags.find({\n      relatedTagIds: {\n        $in: [tagId]\n      }\n    }).count();\n    // not in use anywhere, delete it\n    if (productCount === 0 && relatedTagsCount === 0) {\n      return Collections.Tags.remove(tagId);\n    }\n    // unable to delete anything\n    throw new Meteor.Error(403, \"Unable to delete tags that are in use.\");\n  },\n\n  /**\n   * shop/hideHeaderTag\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\n  \"shop/hideHeaderTag\": function (tagId) {\n    check(tagId, String);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n    // hide it\n    return Collections.Tags.update({\n      _id: tagId\n    }, {\n      $set: {\n        isTopLevel: false\n      }\n    });\n  },\n\n  /**\n   * shop/getWorkflow\n   * @summary gets the current shop workflows\n   * @param {String} name - workflow name\n   * @return {Array} returns workflow array\n   */\n  \"shop/getWorkflow\": function (name) {\n    check(name, String);\n\n    const shopWorkflows = Collections.Shops.findOne({\n      defaultWorkflows: {\n        $elemMatch: {\n          provides: name\n        }\n      }\n    }, {\n      fields: {\n        defaultWorkflows: true\n      }\n    });\n    return shopWorkflows;\n  },\n  /**\n   * shop/updateLanguageConfiguration\n   * @summary enable / disable a language\n   * @param {String} language - language name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Array} returns workflow array\n   */\n  \"shop/updateLanguageConfiguration\": function (language, enabled) {\n    check(language, String);\n    check(enabled, Boolean);\n\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n\n    const defaultLanguage = shop.language;\n\n    if (language === \"all\") {\n      const updateObject = {};\n\n      if (Array.isArray(shop.languages)) {\n        shop.languages.forEach((languageData, index) => {\n          if (languageData.i18n === defaultLanguage) {\n            updateObject[`languages.${index}.enabled`] = true;\n          } else {\n            updateObject[`languages.${index}.enabled`] = enabled;\n          }\n        });\n      }\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (language === defaultLanguage) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"languages.i18n\": language\n      }, {\n        $set: {\n          \"languages.$.enabled\": true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      \"_id\": Reaction.getShopId(),\n      \"languages.i18n\": language\n    }, {\n      $set: {\n        \"languages.$.enabled\": enabled\n      }\n    });\n  },\n\n  /**\n   * shop/updateCurrencyConfiguration\n   * @summary enable / disable a currency\n   * @param {String} currency - currency name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Number} returns mongo update result\n   */\n  \"shop/updateCurrencyConfiguration\": function (currency, enabled) {\n    check(currency, String);\n    check(enabled, Boolean);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n\n    const defaultCurrency = shop.currency;\n\n    if (currency === \"all\") {\n      const updateObject = {};\n      for (const currencyName in shop.currencies) {\n        if ({}.hasOwnProperty.call(shop.currencies, currencyName) && currencyName !== \"updatedAt\") {\n          if (currencyName === defaultCurrency) {\n            updateObject[`currencies.${currencyName}.enabled`] = true;\n          } else {\n            updateObject[`currencies.${currencyName}.enabled`] = enabled;\n          }\n        }\n      }\n\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (currency === defaultCurrency) {\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: {\n          [`currencies.${currency}.enabled`]: true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $set: {\n        [`currencies.${currency}.enabled`]: enabled\n      }\n    });\n  },\n\n  /**\n   * shop/updateBrandAsset\n   * @param {Object} asset - brand asset {mediaId: \"\", type, \"\"}\n   * @return {Int} returns update result\n   */\n  \"shop/updateBrandAssets\": function (asset) {\n    check(asset, {\n      mediaId: String,\n      type: String\n    });\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    // Does our shop contain the brandasset we're tring to add\n    const shopWithBrandAsset = Collections.Shops.findOne({\n      \"_id\": Reaction.getShopId(),\n      \"brandAssets.type\": asset.type\n    });\n\n    // If it does, then we update it with the new asset reference\n    if (shopWithBrandAsset) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"brandAssets.type\": \"navbarBrandImage\"\n      }, {\n        $set: {\n          \"brandAssets.$\": {\n            mediaId: asset.mediaId,\n            type: asset.type\n          }\n        }\n      });\n    }\n\n    // Otherwise we insert a new brand asset reference\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $push: {\n        brandAssets: {\n          mediaId: asset.mediaId,\n          type: asset.type\n        }\n      }\n    });\n  },\n\n  /*\n   * shop/togglePackage\n   * @summary enable/disable Reaction package\n   * @param {String} packageId - package _id\n   * @param {Boolean} enabled - current package `enabled` state\n   * @return {Number} mongo update result\n   */\n  \"shop/togglePackage\": function (packageId, enabled) {\n    check(packageId, String);\n    check(enabled, Boolean);\n    if (!Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Collections.Packages.update(packageId, {\n      $set: {\n        enabled: !enabled\n      }\n    });\n  },\n  /*\n  * shop/changeLayout\n  * @summary Change the layout for all workflows so you can use a custom one\n  * @param {String} shopId - the shop's ID\n  * @param {String} layout - new layout to use\n  * @return {Number} mongo update result\n   */\n  \"shop/changeLayouts\": function (shopId, newLayout) {\n    check(shopId, String);\n    check(newLayout, String);\n    const shop = Collections.Shops.findOne(shopId);\n    for (let i = 0; i < shop.layout.length; i++) {\n      shop.layout[i].layout = newLayout;\n    }\n    return Collections.Shops.update(shopId, {\n      $set: { layout: shop.layout }\n    });\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/methods/core/shop.js.map","sourceFileName":"/server/methods/core/shop.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"shop"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar check = void 0,\n    Match = void 0;\nmodule.importSync(\"meteor/check\", {\n  check: function (v) {\n    check = v;\n  },\n  Match: function (v) {\n    Match = v;\n  }\n}, 1);\nvar HTTP = void 0;\nmodule.importSync(\"meteor/http\", {\n  HTTP: function (v) {\n    HTTP = v;\n  }\n}, 2);\nvar Job = void 0;\nmodule.importSync(\"meteor/vsivsi:job-collection\", {\n  Job: function (v) {\n    Job = v;\n  }\n}, 3);\nvar Collections = Object.create(null);\nmodule.importSync(\"/lib/collections\", {\n  \"*\": function (v, n) {\n    Collections[n] = v;\n  }\n}, 4);\nvar Schemas = Object.create(null);\nmodule.importSync(\"/lib/collections/schemas\", {\n  \"*\": function (v, n) {\n    Schemas[n] = v;\n  }\n}, 5);\nvar GeoCoder = void 0,\n    Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  GeoCoder: function (v) {\n    GeoCoder = v;\n  },\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 6);\n/**\n * Reaction Shop Methods\n */Meteor.methods({\n  /**\n   * shop/createShop\n   * @param {String} shopAdminUserId - optionally create shop for provided userId\n   * @param {Object} shopData - optionally provide shop object to customize\n   * @return {String} return shopId\n   */\"shop/createShop\": function (shopAdminUserId, shopData) {\n    check(shopAdminUserId, Match.Optional(String));\n    check(shopData, Match.Optional(Schemas.Shop));\n    var shop = {}; // must have owner access to create new shops\n\n    if (!Reaction.hasOwnerAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    } // this.unblock();\n\n\n    var count = Collections.Shops.find().count() || \"\";\n    var currentUser = Meteor.userId(); // we'll accept a shop object, or clone the current shop\n\n    shop = shopData || Collections.Shops.findOne(Reaction.getShopId()); // if we don't have any shop data, use fixture\n\n    check(shop, Schemas.Shop);\n\n    if (!currentUser) {\n      throw new Meteor.Error(\"Unable to create shop with specified user\");\n    } // identify a shop admin\n\n\n    var userId = shopAdminUserId || Meteor.userId();\n    var adminRoles = Roles.getRolesForUser(currentUser, Reaction.getShopId()); // ensure unique id and shop name\n\n    shop._id = Random.id();\n    shop.name = shop.name + count;\n    check(shop, Schemas.Shop);\n\n    try {\n      Collections.Shops.insert(shop);\n    } catch (error) {\n      return Logger.error(error, \"Failed to shop/createShop\");\n    } // we should have created new shop, or errored\n\n\n    Logger.info(\"Created shop: \", shop._id);\n    Roles.addUsersToRoles([currentUser, userId], adminRoles, shop._id);\n    return shop._id;\n  },\n  /**\n   * shop/getLocale\n   * @summary determine user's countryCode and return locale object\n   * determine local currency and conversion rate from shop currency\n   * @return {Object} returns user location and locale\n   */\"shop/getLocale\": function () {\n    this.unblock();\n    var clientAddress = void 0;\n    var geo = new GeoCoder();\n    var result = {};\n    var defaultCountryCode = \"US\";\n    var localeCurrency = \"USD\"; // if called from server, ip won't be defined.\n\n    if (this.connection !== null) {\n      clientAddress = this.connection.clientAddress;\n    } else {\n      clientAddress = \"127.0.0.1\";\n    } // get shop locale/currency related data\n\n\n    var shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n\n    if (!shop) {\n      throw new Meteor.Error(\"Failed to find shop data. Unable to determine locale.\");\n    } // cofigure default defaultCountryCode\n    // fallback to shop settings\n\n\n    if (shop.addressBook) {\n      if (shop.addressBook.length >= 1) {\n        if (shop.addressBook[0].country) {\n          defaultCountryCode = shop.addressBook[0].country;\n        }\n      }\n    } // geocode reverse ip lookup\n\n\n    var geoCountryCode = geo.geoip(clientAddress).country_code; // countryCode either from geo or defaults\n\n    var countryCode = (geoCountryCode || defaultCountryCode).toUpperCase(); // get currency rates\n\n    result.currency = {};\n    result.locale = shop.locales.countries[countryCode]; // to return default currency if rates will failed, we need to bring access\n    // to this data\n\n    result.shopCurrency = shop.currencies[shop.currency]; // check if locale has a currency defined\n\n    if ((0, _typeof3.default)(result.locale) === \"object\" && typeof result.locale.currency === \"string\") {\n      localeCurrency = result.locale.currency.split(\",\");\n    } // localeCurrency is an array of allowed currencies\n\n\n    _.each(localeCurrency, function (currency) {\n      var exchangeRate = void 0;\n\n      if (shop.currencies[currency]) {\n        result.currency = shop.currencies[currency]; // only fetch rates if locale and shop currency are not equal\n        // if shop.curency = locale currency the rate is 1\n\n        if (shop.currency !== currency) {\n          exchangeRate = Meteor.call(\"shop/getCurrencyRates\", currency);\n\n          if (typeof exchangeRate === \"number\") {\n            result.currency.exchangeRate = exchangeRate;\n          } else {\n            Logger.warn(\"Failed to get currency exchange rates.\");\n          }\n        }\n      }\n    }); // set server side locale\n\n\n    Reaction.Locale = result; // should contain rates, locale, currency\n\n    return result;\n  },\n  /**\n   * shop/getCurrencyRates\n   * @summary It returns the current exchange rate against the shop currency\n   * usage: Meteor.call(\"shop/getCurrencyRates\",\"USD\")\n   * @param {String} currency code\n   * @return {Number|Object} currency conversion rate\n   */\"shop/getCurrencyRates\": function (currency) {\n    var _fields;\n\n    check(currency, String);\n    this.unblock();\n    var field = \"currencies.\" + currency + \".rate\";\n    var shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: (_fields = {}, _fields[field] = 1, _fields)\n    });\n    return typeof shop.currencies[currency].rate === \"number\" && shop.currencies[currency].rate;\n  },\n  /**\n   * shop/fetchCurrencyRate\n   * @summary fetch the latest currency rates from\n   * https://openexchangerates.org\n   * usage: Meteor.call(\"shop/fetchCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\"shop/fetchCurrencyRate\": function () {\n    this.unblock();\n    var shopId = Reaction.getShopId();\n    var shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n    var baseCurrency = shop.currency || \"USD\";\n    var shopCurrencies = shop.currencies; // fetch shop settings for api auth credentials\n\n    var shopSettings = Collections.Packages.findOne({\n      shopId: shopId,\n      name: \"core\"\n    }, {\n      fields: {\n        settings: 1\n      }\n    }); // update Shops.currencies[currencyKey].rate\n    // with current rates from Open Exchange Rates\n    // warn if we don't have app_id\n\n    if (!shopSettings.settings.openexchangerates) {\n      throw new Meteor.Error(\"notConfigured\", \"Open Exchange Rates not configured. Configure for current rates.\");\n    } else {\n      if (!shopSettings.settings.openexchangerates.appId) {\n        throw new Meteor.Error(\"notConfigured\", \"Open Exchange Rates AppId not configured. Configure for current rates.\");\n      } else {\n        // shop open exchange rates appId\n        var openexchangeratesAppId = shopSettings.settings.openexchangerates.appId; // we'll update all the available rates in Shops.currencies whenever we\n        // get a rate request, using base currency\n\n        var rateUrl = \"https://openexchangerates.org/api/latest.json?base=\" + baseCurrency + \"&app_id=\" + openexchangeratesAppId;\n        var rateResults = void 0; // We can get an error if we try to change the base currency with a simple\n        // account\n\n        try {\n          rateResults = HTTP.get(rateUrl);\n        } catch (error) {\n          if (error.error) {\n            Logger.error(error.message);\n            throw new Meteor.Error(error.message);\n          } else {\n            // https://openexchangerates.org/documentation#errors\n            throw new Meteor.Error(error.response.data.description);\n          }\n        }\n\n        var exchangeRates = rateResults.data.rates;\n\n        _.each(shopCurrencies, function (currencyConfig, currencyKey) {\n          if (exchangeRates[currencyKey] !== undefined) {\n            var rateUpdate = {\n              // this needed for shop/flushCurrencyRates Method\n              \"currencies.updatedAt\": new Date(rateResults.data.timestamp * 1000)\n            };\n            var collectionKey = \"currencies.\" + currencyKey + \".rate\";\n            rateUpdate[collectionKey] = exchangeRates[currencyKey];\n            Collections.Shops.update(shopId, {\n              $set: rateUpdate\n            });\n          }\n        });\n      }\n    }\n  },\n  /**\n   * shop/flushCurrencyRate\n   * @description Method calls by cron job\n   * @summary It removes exchange rates that are too old\n   * usage: Meteor.call(\"shop/flushCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\"shop/flushCurrencyRate\": function () {\n    this.unblock();\n    var shopId = Reaction.getShopId();\n    var shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        currencies: 1\n      }\n    });\n    var updatedAt = shop.currencies.updatedAt; // if updatedAt is not a Date(), then there is no rates yet\n\n    if ((typeof updatedAt === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(updatedAt)) !== \"object\") {\n      throw new Meteor.Error(\"notExists\", \"[flushCurrencyRates worker]: There is nothing to flush.\");\n    }\n\n    updatedAt.setHours(updatedAt.getHours() + 48);\n    var now = new Date();\n\n    if (now < updatedAt) {\n      // todo remove this line. its for tests\n      _.each(shop.currencies, function (currencyConfig, currencyKey) {\n        var rate = \"currencies.\" + currencyKey + \".rate\";\n\n        if (typeof currencyConfig.rate === \"number\") {\n          var _$unset;\n\n          Collections.Shops.update(shopId, {\n            $unset: (_$unset = {}, _$unset[rate] = \"\", _$unset)\n          });\n        }\n      });\n    }\n  },\n  /**\n   * shop/updateShopExternalServices\n   * @description On submit OpenExchangeRatesForm handler\n   * @summary we need to rerun fetch exchange rates job on every form submit,\n   * that's why we update autoform type to \"method-update\"\n   * @param {Object} modifier - the modifier object generated from the form values\n   * @param {String} _id - the _id of the document being updated\n   * @fires Collections.Packages#update\n   * @todo This method fires Packages collection, so maybe someday it could be\n   * @returns {undefined}\n   * moved to another file\n   */\"shop/updateShopExternalServices\": function (modifier, _id) {\n    check(modifier, Match.Optional(Schemas.CorePackageConfig));\n    check(_id, String); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock(); // we should run new job on every form change, even if not all of them will\n    // change currencyRate job\n\n    var refreshPeriod = modifier.$set[\"settings.openexchangerates.refreshPeriod\"];\n    var fetchCurrencyRatesJob = new Job(Collections.Jobs, \"shop/fetchCurrencyRates\", {}).priority(\"normal\").retry({\n      retries: 5,\n      wait: 60000,\n      backoff: \"exponential\" // delay by twice as long for each subsequent retry\n\n    }).repeat({\n      // wait: refreshPeriod * 60 * 1000\n      schedule: Collections.Jobs.later.parse.text(refreshPeriod)\n    }).save({\n      // Cancel any jobs of the same type,\n      // but only if this job repeats forever.\n      cancelRepeats: true\n    });\n    Collections.Packages.update(_id, modifier);\n    return fetchCurrencyRatesJob;\n  },\n  /**\n   * shop/locateAddress\n   * @summary determine user's full location for autopopulating addresses\n   * @param {Number} latitude - latitude\n   * @param {Number} longitude - longitude\n   * @return {Object} returns address\n   */\"shop/locateAddress\": function (latitude, longitude) {\n    check(latitude, Match.Optional(Number));\n    check(longitude, Match.Optional(Number));\n    var clientAddress = void 0;\n    this.unblock(); // if called from server, ip won't be defined.\n\n    if (this.connection !== null) {\n      clientAddress = this.connection.clientAddress;\n    } else {\n      clientAddress = \"127.0.0.1\";\n    } // begin actual address lookups\n\n\n    if (latitude !== null && longitude !== null) {\n      var _geo = new GeoCoder();\n\n      return _geo.reverse(latitude, longitude);\n    } // geocode reverse ip lookup\n\n\n    var geo = new GeoCoder();\n    return geo.geoip(clientAddress);\n  },\n  /**\n   * shop/createTag\n   * @summary creates new tag\n   * @param {String} tagName - new tag name\n   * @param {Boolean} isTopLevel - if true -- new tag will be created on top of\n   * tags tree\n   * @since 0.14.0\n   * @hooks after method\n   * @return {String} with created tag _id\n   */\"shop/createTag\": function (tagName, isTopLevel) {\n    check(tagName, String);\n    check(isTopLevel, Boolean); // must have 'core' permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var tag = {\n      name: tagName,\n      slug: Reaction.getSlug(tagName),\n      isTopLevel: isTopLevel,\n      updatedAt: new Date(),\n      createdAt: new Date()\n    };\n    return Collections.Tags.insert(tag);\n  },\n  /**\n   * shop/updateHeaderTags\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} tagName will insert, tagName + tagId will update existing\n   * @param {String} tagId - tagId to update\n   * @param {String} currentTagId - currentTagId will update related/hierarchy\n   * @return {Boolean} return true/false after insert\n   */\"shop/updateHeaderTags\": function (tagName, tagId, currentTagId) {\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null, void 0));\n    check(currentTagId, Match.OneOf(String, null, void 0));\n    var newTagId = {}; // must have 'core' permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n    var newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n    var existingTag = Collections.Tags.findOne({\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    });\n\n    if (tagId) {\n      return Collections.Tags.update(tagId, {\n        $set: newTag\n      }, function () {\n        Logger.debug(\"Changed name of tag \" + tagId + \" to \" + tagName);\n        return true;\n      });\n    } else if (existingTag) {\n      // if is currentTag\n      if (currentTagId) {\n        return Collections.Tags.update(currentTagId, {\n          $addToSet: {\n            relatedTagIds: existingTag._id\n          }\n        }, function () {\n          Logger.debug(\"Added tag \" + existingTag.name + \" to the related tags list for tag \" + currentTagId);\n          return true;\n        });\n      } // update existing tag\n\n\n      return Collections.Tags.update(existingTag._id, {\n        $set: {\n          isTopLevel: true\n        }\n      }, function () {\n        Logger.debug(\"Marked tag \" + existingTag.name + \" as a top level tag\");\n        return true;\n      });\n    } // create newTags\n\n\n    newTagId = Meteor.call(\"shop/createTag\", tagName, !currentTagId); // if result is an Error object, we return it immediately\n\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    if (currentTagId) {\n      return Collections.Tags.update(currentTagId, {\n        $addToSet: {\n          relatedTagIds: newTagId\n        }\n      }, function () {\n        Logger.debug(\"Added tag\" + newTag.name + \" to the related tags list for tag \" + currentTagId);\n        return true;\n      }); // TODO: refactor this. unnecessary check\n    } else if (typeof newTagId === \"string\" && !currentTagId) {\n      return true;\n    }\n\n    throw new Meteor.Error(403, \"Failed to update header tags.\");\n  },\n  /**\n   * shop/removeHeaderTag\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\"shop/removeHeaderTag\": function (tagId, currentTagId) {\n    check(tagId, String);\n    check(currentTagId, String); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock(); // remove from related tag use\n\n    Collections.Tags.update(currentTagId, {\n      $pull: {\n        relatedTagIds: tagId\n      }\n    }); // check to see if tag is in use.\n\n    var productCount = Collections.Products.find({\n      hashtags: {\n        $in: [tagId]\n      }\n    }).count(); // check to see if in use as a related tag\n\n    var relatedTagsCount = Collections.Tags.find({\n      relatedTagIds: {\n        $in: [tagId]\n      }\n    }).count(); // not in use anywhere, delete it\n\n    if (productCount === 0 && relatedTagsCount === 0) {\n      return Collections.Tags.remove(tagId);\n    } // unable to delete anything\n\n\n    throw new Meteor.Error(403, \"Unable to delete tags that are in use.\");\n  },\n  /**\n   * shop/hideHeaderTag\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\"shop/hideHeaderTag\": function (tagId) {\n    check(tagId, String); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock(); // hide it\n\n    return Collections.Tags.update({\n      _id: tagId\n    }, {\n      $set: {\n        isTopLevel: false\n      }\n    });\n  },\n  /**\n   * shop/getWorkflow\n   * @summary gets the current shop workflows\n   * @param {String} name - workflow name\n   * @return {Array} returns workflow array\n   */\"shop/getWorkflow\": function (name) {\n    check(name, String);\n    var shopWorkflows = Collections.Shops.findOne({\n      defaultWorkflows: {\n        $elemMatch: {\n          provides: name\n        }\n      }\n    }, {\n      fields: {\n        defaultWorkflows: true\n      }\n    });\n    return shopWorkflows;\n  },\n  /**\n   * shop/updateLanguageConfiguration\n   * @summary enable / disable a language\n   * @param {String} language - language name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Array} returns workflow array\n   */\"shop/updateLanguageConfiguration\": function (language, enabled) {\n    check(language, String);\n    check(enabled, Boolean); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n    var shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n    var defaultLanguage = shop.language;\n\n    if (language === \"all\") {\n      var updateObject = {};\n\n      if (Array.isArray(shop.languages)) {\n        shop.languages.forEach(function (languageData, index) {\n          if (languageData.i18n === defaultLanguage) {\n            updateObject[\"languages.\" + index + \".enabled\"] = true;\n          } else {\n            updateObject[\"languages.\" + index + \".enabled\"] = enabled;\n          }\n        });\n      }\n\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (language === defaultLanguage) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"languages.i18n\": language\n      }, {\n        $set: {\n          \"languages.$.enabled\": true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      \"_id\": Reaction.getShopId(),\n      \"languages.i18n\": language\n    }, {\n      $set: {\n        \"languages.$.enabled\": enabled\n      }\n    });\n  },\n  /**\n   * shop/updateCurrencyConfiguration\n   * @summary enable / disable a currency\n   * @param {String} currency - currency name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Number} returns mongo update result\n   */\"shop/updateCurrencyConfiguration\": function (currency, enabled) {\n    var _$set2;\n\n    check(currency, String);\n    check(enabled, Boolean); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n    var shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n    var defaultCurrency = shop.currency;\n\n    if (currency === \"all\") {\n      var updateObject = {};\n\n      for (var currencyName in meteorBabelHelpers.sanitizeForInObject(shop.currencies)) {\n        if ({}.hasOwnProperty.call(shop.currencies, currencyName) && currencyName !== \"updatedAt\") {\n          if (currencyName === defaultCurrency) {\n            updateObject[\"currencies.\" + currencyName + \".enabled\"] = true;\n          } else {\n            updateObject[\"currencies.\" + currencyName + \".enabled\"] = enabled;\n          }\n        }\n      }\n\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (currency === defaultCurrency) {\n      var _$set;\n\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: (_$set = {}, _$set[\"currencies.\" + currency + \".enabled\"] = true, _$set)\n      });\n    }\n\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $set: (_$set2 = {}, _$set2[\"currencies.\" + currency + \".enabled\"] = enabled, _$set2)\n    });\n  },\n  /**\n   * shop/updateBrandAsset\n   * @param {Object} asset - brand asset {mediaId: \"\", type, \"\"}\n   * @return {Int} returns update result\n   */\"shop/updateBrandAssets\": function (asset) {\n    check(asset, {\n      mediaId: String,\n      type: String\n    }); // must have core permissions\n\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock(); // Does our shop contain the brandasset we're tring to add\n\n    var shopWithBrandAsset = Collections.Shops.findOne({\n      \"_id\": Reaction.getShopId(),\n      \"brandAssets.type\": asset.type\n    }); // If it does, then we update it with the new asset reference\n\n    if (shopWithBrandAsset) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"brandAssets.type\": \"navbarBrandImage\"\n      }, {\n        $set: {\n          \"brandAssets.$\": {\n            mediaId: asset.mediaId,\n            type: asset.type\n          }\n        }\n      });\n    } // Otherwise we insert a new brand asset reference\n\n\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $push: {\n        brandAssets: {\n          mediaId: asset.mediaId,\n          type: asset.type\n        }\n      }\n    });\n  },\n  /*\n   * shop/togglePackage\n   * @summary enable/disable Reaction package\n   * @param {String} packageId - package _id\n   * @param {Boolean} enabled - current package `enabled` state\n   * @return {Number} mongo update result\n   */\"shop/togglePackage\": function (packageId, enabled) {\n    check(packageId, String);\n    check(enabled, Boolean);\n\n    if (!Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Collections.Packages.update(packageId, {\n      $set: {\n        enabled: !enabled\n      }\n    });\n  },\n  /*\n  * shop/changeLayout\n  * @summary Change the layout for all workflows so you can use a custom one\n  * @param {String} shopId - the shop's ID\n  * @param {String} layout - new layout to use\n  * @return {Number} mongo update result\n   */\"shop/changeLayouts\": function (shopId, newLayout) {\n    check(shopId, String);\n    check(newLayout, String);\n    var shop = Collections.Shops.findOne(shopId);\n\n    for (var i = 0; i < shop.layout.length; i++) {\n      shop.layout[i].layout = newLayout;\n    }\n\n    return Collections.Shops.update(shopId, {\n      $set: {\n        layout: shop.layout\n      }\n    });\n  }\n});","map":{"version":3,"sources":["/server/methods/core/shop.js"],"names":["Meteor","check","Match","HTTP","Job","Collections","Schemas","GeoCoder","Logger","Reaction","methods","shopAdminUserId","shopData","Optional","String","Shop","shop","hasOwnerAccess","Error","count","Shops","find","currentUser","userId","findOne","getShopId","adminRoles","Roles","getRolesForUser","_id","Random","id","name","insert","error","info","addUsersToRoles","unblock","clientAddress","geo","result","defaultCountryCode","localeCurrency","connection","fields","addressBook","locales","currencies","currency","length","country","geoCountryCode","geoip","country_code","countryCode","toUpperCase","locale","countries","shopCurrency","split","_","each","exchangeRate","call","warn","Locale","field","rate","shopId","baseCurrency","shopCurrencies","shopSettings","Packages","settings","openexchangerates","appId","openexchangeratesAppId","rateUrl","rateResults","get","message","response","data","description","exchangeRates","rates","currencyConfig","currencyKey","undefined","rateUpdate","Date","timestamp","collectionKey","update","$set","updatedAt","setHours","getHours","now","$unset","modifier","CorePackageConfig","hasPermission","refreshPeriod","fetchCurrencyRatesJob","Jobs","priority","retry","retries","wait","backoff","repeat","schedule","later","parse","text","save","cancelRepeats","latitude","longitude","Number","reverse","tagName","isTopLevel","Boolean","tag","slug","getSlug","createdAt","Tags","tagId","currentTagId","OneOf","newTagId","newTag","existingTag","debug","$addToSet","relatedTagIds","$pull","productCount","Products","hashtags","$in","relatedTagsCount","remove","shopWorkflows","defaultWorkflows","$elemMatch","provides","language","enabled","defaultLanguage","updateObject","Array","isArray","languages","forEach","languageData","index","i18n","defaultCurrency","currencyName","hasOwnProperty","asset","mediaId","type","shopWithBrandAsset","$push","brandAssets","packageId","hasAdminAccess","newLayout","i","layout"],"mappings":"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","file":"/server/methods/core/shop.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { HTTP } from \"meteor/http\";\nimport { Job } from \"meteor/vsivsi:job-collection\";\nimport * as Collections from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { GeoCoder, Logger, Reaction } from \"/server/api\";\n\n/**\n * Reaction Shop Methods\n */\nMeteor.methods({\n  /**\n   * shop/createShop\n   * @param {String} shopAdminUserId - optionally create shop for provided userId\n   * @param {Object} shopData - optionally provide shop object to customize\n   * @return {String} return shopId\n   */\n  \"shop/createShop\": function (shopAdminUserId, shopData) {\n    check(shopAdminUserId, Match.Optional(String));\n    check(shopData, Match.Optional(Schemas.Shop));\n    let shop = {};\n    // must have owner access to create new shops\n    if (!Reaction.hasOwnerAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    // this.unblock();\n    const count = Collections.Shops.find().count() || \"\";\n    const currentUser = Meteor.userId();\n    // we'll accept a shop object, or clone the current shop\n    shop = shopData || Collections.Shops.findOne(Reaction.getShopId());\n    // if we don't have any shop data, use fixture\n\n    check(shop, Schemas.Shop);\n    if (!currentUser) {\n      throw new Meteor.Error(\"Unable to create shop with specified user\");\n    }\n\n    // identify a shop admin\n    const userId = shopAdminUserId || Meteor.userId();\n    const adminRoles = Roles.getRolesForUser(currentUser, Reaction.getShopId());\n    // ensure unique id and shop name\n    shop._id = Random.id();\n    shop.name = shop.name + count;\n\n    check(shop, Schemas.Shop);\n    try {\n      Collections.Shops.insert(shop);\n    } catch (error) {\n      return Logger.error(error, \"Failed to shop/createShop\");\n    }\n    // we should have created new shop, or errored\n    Logger.info(\"Created shop: \", shop._id);\n    Roles.addUsersToRoles([currentUser, userId], adminRoles, shop._id);\n    return shop._id;\n  },\n\n  /**\n   * shop/getLocale\n   * @summary determine user's countryCode and return locale object\n   * determine local currency and conversion rate from shop currency\n   * @return {Object} returns user location and locale\n   */\n  \"shop/getLocale\": function () {\n    this.unblock();\n    let clientAddress;\n    const geo = new GeoCoder();\n    const result = {};\n    let defaultCountryCode = \"US\";\n    let localeCurrency = \"USD\";\n    // if called from server, ip won't be defined.\n    if (this.connection !== null) {\n      clientAddress = this.connection.clientAddress;\n    } else {\n      clientAddress = \"127.0.0.1\";\n    }\n\n    // get shop locale/currency related data\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n\n    if (!shop) {\n      throw new Meteor.Error(\n        \"Failed to find shop data. Unable to determine locale.\");\n    }\n    // cofigure default defaultCountryCode\n    // fallback to shop settings\n    if (shop.addressBook) {\n      if (shop.addressBook.length >= 1) {\n        if (shop.addressBook[0].country) {\n          defaultCountryCode = shop.addressBook[0].country;\n        }\n      }\n    }\n    // geocode reverse ip lookup\n    const geoCountryCode = geo.geoip(clientAddress).country_code;\n\n    // countryCode either from geo or defaults\n    const countryCode = (geoCountryCode || defaultCountryCode).toUpperCase();\n\n    // get currency rates\n    result.currency = {};\n    result.locale = shop.locales.countries[countryCode];\n\n    // to return default currency if rates will failed, we need to bring access\n    // to this data\n    result.shopCurrency = shop.currencies[shop.currency];\n\n    // check if locale has a currency defined\n    if (typeof result.locale === \"object\" &&\n      typeof result.locale.currency === \"string\") {\n      localeCurrency = result.locale.currency.split(\",\");\n    }\n\n    // localeCurrency is an array of allowed currencies\n    _.each(localeCurrency, function (currency) {\n      let exchangeRate;\n      if (shop.currencies[currency]) {\n        result.currency = shop.currencies[currency];\n        // only fetch rates if locale and shop currency are not equal\n        // if shop.curency = locale currency the rate is 1\n        if (shop.currency !== currency) {\n          exchangeRate = Meteor.call(\"shop/getCurrencyRates\", currency);\n\n          if (typeof exchangeRate === \"number\") {\n            result.currency.exchangeRate = exchangeRate;\n          } else {\n            Logger.warn(\"Failed to get currency exchange rates.\");\n          }\n        }\n      }\n    });\n\n    // set server side locale\n    Reaction.Locale = result;\n\n    // should contain rates, locale, currency\n    return result;\n  },\n\n  /**\n   * shop/getCurrencyRates\n   * @summary It returns the current exchange rate against the shop currency\n   * usage: Meteor.call(\"shop/getCurrencyRates\",\"USD\")\n   * @param {String} currency code\n   * @return {Number|Object} currency conversion rate\n   */\n  \"shop/getCurrencyRates\": function (currency) {\n    check(currency, String);\n    this.unblock();\n\n    const field = `currencies.${currency}.rate`;\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        [field]: 1\n      }\n    });\n\n    return typeof shop.currencies[currency].rate === \"number\" &&\n      shop.currencies[currency].rate;\n  },\n\n  /**\n   * shop/fetchCurrencyRate\n   * @summary fetch the latest currency rates from\n   * https://openexchangerates.org\n   * usage: Meteor.call(\"shop/fetchCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/fetchCurrencyRate\": function () {\n    this.unblock();\n\n    const shopId = Reaction.getShopId();\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n    const baseCurrency = shop.currency || \"USD\";\n    const shopCurrencies = shop.currencies;\n\n    // fetch shop settings for api auth credentials\n    const shopSettings = Collections.Packages.findOne({\n      shopId: shopId,\n      name: \"core\"\n    }, {\n      fields: {\n        settings: 1\n      }\n    });\n\n    // update Shops.currencies[currencyKey].rate\n    // with current rates from Open Exchange Rates\n    // warn if we don't have app_id\n    if (!shopSettings.settings.openexchangerates) {\n      throw new Meteor.Error(\"notConfigured\",\n        \"Open Exchange Rates not configured. Configure for current rates.\");\n    } else {\n      if (!shopSettings.settings.openexchangerates.appId) {\n        throw new Meteor.Error(\"notConfigured\",\n          \"Open Exchange Rates AppId not configured. Configure for current rates.\");\n      } else {\n        // shop open exchange rates appId\n        const openexchangeratesAppId = shopSettings.settings.openexchangerates.appId;\n\n        // we'll update all the available rates in Shops.currencies whenever we\n        // get a rate request, using base currency\n        const rateUrl =\n          `https://openexchangerates.org/api/latest.json?base=${\n          baseCurrency}&app_id=${openexchangeratesAppId}`;\n        let rateResults;\n\n        // We can get an error if we try to change the base currency with a simple\n        // account\n        try {\n          rateResults = HTTP.get(rateUrl);\n        } catch (error) {\n          if (error.error) {\n            Logger.error(error.message);\n            throw new Meteor.Error(error.message);\n          } else {\n            // https://openexchangerates.org/documentation#errors\n            throw new Meteor.Error(error.response.data.description);\n          }\n        }\n\n        const exchangeRates = rateResults.data.rates;\n\n        _.each(shopCurrencies, function (currencyConfig, currencyKey) {\n          if (exchangeRates[currencyKey] !== undefined) {\n            const rateUpdate = {\n              // this needed for shop/flushCurrencyRates Method\n              \"currencies.updatedAt\": new Date(rateResults.data.timestamp * 1000)\n            };\n            const collectionKey = `currencies.${currencyKey}.rate`;\n            rateUpdate[collectionKey] = exchangeRates[currencyKey];\n            Collections.Shops.update(shopId, {\n              $set: rateUpdate\n            });\n          }\n        });\n      }\n    }\n  },\n\n  /**\n   * shop/flushCurrencyRate\n   * @description Method calls by cron job\n   * @summary It removes exchange rates that are too old\n   * usage: Meteor.call(\"shop/flushCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/flushCurrencyRate\": function () {\n    this.unblock();\n\n    const shopId = Reaction.getShopId();\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        currencies: 1\n      }\n    });\n    const updatedAt = shop.currencies.updatedAt;\n\n    // if updatedAt is not a Date(), then there is no rates yet\n    if (typeof updatedAt !== \"object\") {\n      throw new Meteor.Error(\"notExists\",\n        \"[flushCurrencyRates worker]: There is nothing to flush.\");\n    }\n\n    updatedAt.setHours(updatedAt.getHours() + 48);\n    const now = new Date();\n\n    if (now < updatedAt) { // todo remove this line. its for tests\n      _.each(shop.currencies, function (currencyConfig, currencyKey) {\n        const rate = `currencies.${currencyKey}.rate`;\n\n        if (typeof currencyConfig.rate === \"number\") {\n          Collections.Shops.update(shopId, {\n            $unset: {\n              [rate]: \"\"\n            }\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * shop/updateShopExternalServices\n   * @description On submit OpenExchangeRatesForm handler\n   * @summary we need to rerun fetch exchange rates job on every form submit,\n   * that's why we update autoform type to \"method-update\"\n   * @param {Object} modifier - the modifier object generated from the form values\n   * @param {String} _id - the _id of the document being updated\n   * @fires Collections.Packages#update\n   * @todo This method fires Packages collection, so maybe someday it could be\n   * @returns {undefined}\n   * moved to another file\n   */\n  \"shop/updateShopExternalServices\": function (modifier, _id) {\n    check(modifier, Match.Optional(Schemas.CorePackageConfig));\n    check(_id, String);\n\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    // we should run new job on every form change, even if not all of them will\n    // change currencyRate job\n    const refreshPeriod = modifier.$set[\"settings.openexchangerates.refreshPeriod\"];\n    const fetchCurrencyRatesJob = new Job(Collections.Jobs, \"shop/fetchCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\" // delay by twice as long for each subsequent retry\n      })\n      .repeat({\n        // wait: refreshPeriod * 60 * 1000\n        schedule: Collections.Jobs.later.parse.text(refreshPeriod)\n      })\n      .save({\n        // Cancel any jobs of the same type,\n        // but only if this job repeats forever.\n        cancelRepeats: true\n      });\n\n    Collections.Packages.update(_id, modifier);\n    return fetchCurrencyRatesJob;\n  },\n\n  /**\n   * shop/locateAddress\n   * @summary determine user's full location for autopopulating addresses\n   * @param {Number} latitude - latitude\n   * @param {Number} longitude - longitude\n   * @return {Object} returns address\n   */\n  \"shop/locateAddress\": function (latitude, longitude) {\n    check(latitude, Match.Optional(Number));\n    check(longitude, Match.Optional(Number));\n    let clientAddress;\n    this.unblock();\n\n    // if called from server, ip won't be defined.\n    if (this.connection !== null) {\n      clientAddress = this.connection.clientAddress;\n    } else {\n      clientAddress = \"127.0.0.1\";\n    }\n\n    // begin actual address lookups\n    if (latitude !== null && longitude !== null) {\n      const geo = new GeoCoder();\n      return geo.reverse(latitude, longitude);\n    }\n    // geocode reverse ip lookup\n    const geo = new GeoCoder();\n    return geo.geoip(clientAddress);\n  },\n\n  /**\n   * shop/createTag\n   * @summary creates new tag\n   * @param {String} tagName - new tag name\n   * @param {Boolean} isTopLevel - if true -- new tag will be created on top of\n   * tags tree\n   * @since 0.14.0\n   * @hooks after method\n   * @return {String} with created tag _id\n   */\n  \"shop/createTag\": function (tagName, isTopLevel) {\n    check(tagName, String);\n    check(isTopLevel, Boolean);\n\n    // must have 'core' permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const tag = {\n      name: tagName,\n      slug: Reaction.getSlug(tagName),\n      isTopLevel: isTopLevel,\n      updatedAt: new Date(),\n      createdAt: new Date()\n    };\n\n    return Collections.Tags.insert(tag);\n  },\n\n  /**\n   * shop/updateHeaderTags\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} tagName will insert, tagName + tagId will update existing\n   * @param {String} tagId - tagId to update\n   * @param {String} currentTagId - currentTagId will update related/hierarchy\n   * @return {Boolean} return true/false after insert\n   */\n  \"shop/updateHeaderTags\": function (tagName, tagId, currentTagId) {\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null, void 0));\n    check(currentTagId, Match.OneOf(String, null, void 0));\n\n    let newTagId = {};\n    // must have 'core' permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n\n    const existingTag = Collections.Tags.findOne({\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    });\n\n    if (tagId) {\n      return Collections.Tags.update(tagId, {\n        $set: newTag\n      }, function () {\n        Logger.debug(\n          `Changed name of tag ${tagId} to ${tagName}`);\n        return true;\n      });\n    } else if (existingTag) {\n      // if is currentTag\n      if (currentTagId) {\n        return Collections.Tags.update(currentTagId, {\n          $addToSet: {\n            relatedTagIds: existingTag._id\n          }\n        }, function () {\n          Logger.debug(\n            `Added tag ${existingTag.name} to the related tags list for tag ${currentTagId}`\n          );\n          return true;\n        });\n      }\n      // update existing tag\n      return Collections.Tags.update(existingTag._id, {\n        $set: {\n          isTopLevel: true\n        }\n      }, function () {\n        Logger.debug(`Marked tag ${existingTag.name} as a top level tag`);\n        return true;\n      });\n    }\n    // create newTags\n    newTagId = Meteor.call(\"shop/createTag\", tagName, !currentTagId);\n\n    // if result is an Error object, we return it immediately\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    if (currentTagId) {\n      return Collections.Tags.update(currentTagId, {\n        $addToSet: {\n          relatedTagIds: newTagId\n        }\n      }, function () {\n        Logger.debug(`Added tag${newTag.name} to the related tags list for tag ${currentTagId}`);\n        return true;\n      });\n      // TODO: refactor this. unnecessary check\n    } else if (typeof newTagId === \"string\" && !currentTagId) {\n      return true;\n    }\n    throw new Meteor.Error(403, \"Failed to update header tags.\");\n  },\n\n  /**\n   * shop/removeHeaderTag\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\n  \"shop/removeHeaderTag\": function (tagId, currentTagId) {\n    check(tagId, String);\n    check(currentTagId, String);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n    // remove from related tag use\n    Collections.Tags.update(currentTagId, {\n      $pull: {\n        relatedTagIds: tagId\n      }\n    });\n    // check to see if tag is in use.\n    const productCount = Collections.Products.find({\n      hashtags: {\n        $in: [tagId]\n      }\n    }).count();\n    // check to see if in use as a related tag\n    const relatedTagsCount = Collections.Tags.find({\n      relatedTagIds: {\n        $in: [tagId]\n      }\n    }).count();\n    // not in use anywhere, delete it\n    if (productCount === 0 && relatedTagsCount === 0) {\n      return Collections.Tags.remove(tagId);\n    }\n    // unable to delete anything\n    throw new Meteor.Error(403, \"Unable to delete tags that are in use.\");\n  },\n\n  /**\n   * shop/hideHeaderTag\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\n  \"shop/hideHeaderTag\": function (tagId) {\n    check(tagId, String);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n    // hide it\n    return Collections.Tags.update({\n      _id: tagId\n    }, {\n      $set: {\n        isTopLevel: false\n      }\n    });\n  },\n\n  /**\n   * shop/getWorkflow\n   * @summary gets the current shop workflows\n   * @param {String} name - workflow name\n   * @return {Array} returns workflow array\n   */\n  \"shop/getWorkflow\": function (name) {\n    check(name, String);\n\n    const shopWorkflows = Collections.Shops.findOne({\n      defaultWorkflows: {\n        $elemMatch: {\n          provides: name\n        }\n      }\n    }, {\n      fields: {\n        defaultWorkflows: true\n      }\n    });\n    return shopWorkflows;\n  },\n  /**\n   * shop/updateLanguageConfiguration\n   * @summary enable / disable a language\n   * @param {String} language - language name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Array} returns workflow array\n   */\n  \"shop/updateLanguageConfiguration\": function (language, enabled) {\n    check(language, String);\n    check(enabled, Boolean);\n\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n\n    const defaultLanguage = shop.language;\n\n    if (language === \"all\") {\n      const updateObject = {};\n\n      if (Array.isArray(shop.languages)) {\n        shop.languages.forEach((languageData, index) => {\n          if (languageData.i18n === defaultLanguage) {\n            updateObject[`languages.${index}.enabled`] = true;\n          } else {\n            updateObject[`languages.${index}.enabled`] = enabled;\n          }\n        });\n      }\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (language === defaultLanguage) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"languages.i18n\": language\n      }, {\n        $set: {\n          \"languages.$.enabled\": true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      \"_id\": Reaction.getShopId(),\n      \"languages.i18n\": language\n    }, {\n      $set: {\n        \"languages.$.enabled\": enabled\n      }\n    });\n  },\n\n  /**\n   * shop/updateCurrencyConfiguration\n   * @summary enable / disable a currency\n   * @param {String} currency - currency name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Number} returns mongo update result\n   */\n  \"shop/updateCurrencyConfiguration\": function (currency, enabled) {\n    check(currency, String);\n    check(enabled, Boolean);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n\n    const defaultCurrency = shop.currency;\n\n    if (currency === \"all\") {\n      const updateObject = {};\n      for (const currencyName in shop.currencies) {\n        if ({}.hasOwnProperty.call(shop.currencies, currencyName) && currencyName !== \"updatedAt\") {\n          if (currencyName === defaultCurrency) {\n            updateObject[`currencies.${currencyName}.enabled`] = true;\n          } else {\n            updateObject[`currencies.${currencyName}.enabled`] = enabled;\n          }\n        }\n      }\n\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (currency === defaultCurrency) {\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: {\n          [`currencies.${currency}.enabled`]: true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $set: {\n        [`currencies.${currency}.enabled`]: enabled\n      }\n    });\n  },\n\n  /**\n   * shop/updateBrandAsset\n   * @param {Object} asset - brand asset {mediaId: \"\", type, \"\"}\n   * @return {Int} returns update result\n   */\n  \"shop/updateBrandAssets\": function (asset) {\n    check(asset, {\n      mediaId: String,\n      type: String\n    });\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    // Does our shop contain the brandasset we're tring to add\n    const shopWithBrandAsset = Collections.Shops.findOne({\n      \"_id\": Reaction.getShopId(),\n      \"brandAssets.type\": asset.type\n    });\n\n    // If it does, then we update it with the new asset reference\n    if (shopWithBrandAsset) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"brandAssets.type\": \"navbarBrandImage\"\n      }, {\n        $set: {\n          \"brandAssets.$\": {\n            mediaId: asset.mediaId,\n            type: asset.type\n          }\n        }\n      });\n    }\n\n    // Otherwise we insert a new brand asset reference\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $push: {\n        brandAssets: {\n          mediaId: asset.mediaId,\n          type: asset.type\n        }\n      }\n    });\n  },\n\n  /*\n   * shop/togglePackage\n   * @summary enable/disable Reaction package\n   * @param {String} packageId - package _id\n   * @param {Boolean} enabled - current package `enabled` state\n   * @return {Number} mongo update result\n   */\n  \"shop/togglePackage\": function (packageId, enabled) {\n    check(packageId, String);\n    check(enabled, Boolean);\n    if (!Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Collections.Packages.update(packageId, {\n      $set: {\n        enabled: !enabled\n      }\n    });\n  },\n  /*\n  * shop/changeLayout\n  * @summary Change the layout for all workflows so you can use a custom one\n  * @param {String} shopId - the shop's ID\n  * @param {String} layout - new layout to use\n  * @return {Number} mongo update result\n   */\n  \"shop/changeLayouts\": function (shopId, newLayout) {\n    check(shopId, String);\n    check(newLayout, String);\n    const shop = Collections.Shops.findOne(shopId);\n    for (let i = 0; i < shop.layout.length; i++) {\n      shop.layout[i].layout = newLayout;\n    }\n    return Collections.Shops.update(shopId, {\n      $set: { layout: shop.layout }\n    });\n  }\n});\n"]},"hash":"81c15e6958eda56732f57ec66846abc5740859f1"}
