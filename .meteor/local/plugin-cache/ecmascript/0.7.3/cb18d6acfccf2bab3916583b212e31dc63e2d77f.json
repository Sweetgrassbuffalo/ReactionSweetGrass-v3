{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"/lib/collections","imported":["Cart","Products","Orders"],"specifiers":[{"kind":"named","imported":"Cart","local":"Cart"},{"kind":"named","imported":"Products","local":"Products"},{"kind":"named","imported":"Orders","local":"Orders"}]},{"source":"/server/api","imported":["Logger"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"}]},{"source":"../methods/inventory","imported":["registerInventory"],"specifiers":[{"kind":"named","imported":"registerInventory","local":"registerInventory"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/plugins/included/inventory/server/hooks/hooks.js","filenameRelative":"/imports/plugins/included/inventory/server/hooks/hooks.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/included/inventory/server/hooks/hooks.js"],"names":["Cart","Products","Orders","Logger","registerInventory","after","update","userId","cart","fieldNames","modifier","$addToSet","items","debug","Meteor","call","$inc","before","$pull","remove","doc","type","variantItem","productId","ancestors","variantId","_id","shopId","$set","$push","updatedAt","Date","insert","markInventoryShipped","order","findOne","orderItems","cartItems","orderItem","cartItem","cartItemId","quantity","variants","title","push","markInventorySold","fieldnames"],"mappings":"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","file":"/imports/plugins/included/inventory/server/hooks/hooks.js.map","sourcesContent":["import { Cart, Products, Orders } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\nimport { registerInventory } from \"../methods/inventory\";\n\n/**\n * Collection Hooks\n * transform collections based on events\n *\n * See: https://github.com/matb33/meteor-collection-hooks\n */\n\n/**\n * After cart update\n */\nCart.after.update((userId, cart, fieldNames, modifier) => {\n  // if we're adding a new product or variant to the cart\n  if (modifier.$addToSet) {\n    if (modifier.$addToSet.items) {\n      Logger.debug(\"after cart update, call inventory/addReserve\");\n      Meteor.call(\"inventory/addReserve\", cart.items);\n    }\n  }\n  // or we're adding more quantity\n  if (modifier.$inc) {\n    Logger.debug(\"after variant increment, call inventory/addReserve\");\n    Meteor.call(\"inventory/addReserve\", cart.items);\n  }\n});\n\n/**\n * Before cart update. When Item is removed from Cart, release the inventory reservation.\n */\nCart.before.update((userId, cart, fieldNames, modifier) => {\n  // removing  cart items, clear inventory reserve\n  if (modifier.$pull) {\n    if (modifier.$pull.items) {\n      Logger.debug(\"remove cart items, call inventory/clearReserve\");\n      Meteor.call(\"inventory/clearReserve\", cart.items);\n    }\n  }\n});\n\n/**\n * after variant were removed\n * @fires `inventory/remove` Method\n */\nProducts.after.remove((userId, doc) => {\n  if (doc.type === \"variant\") {\n    const variantItem = {\n      productId: doc.ancestors[0],\n      variantId: doc._id,\n      shopId: doc.shopId\n    };\n    Logger.debug(`remove inventory variants for variant: ${doc._id\n      }, call inventory/remove`);\n    Meteor.call(\"inventory/remove\", variantItem);\n  }\n});\n\n//\n// after product update\n//\nProducts.after.update((userId, doc, fieldNames, modifier) => {\n  // product update can't affect on inventory, so we don't manage this cases\n  // we should keep in mind that returning false within hook prevents other\n  // hooks to be run\n  if (doc.type !== \"variant\") return false;\n\n  // check if modifier is set and $pull and $push are undefined. This need\n  // because anyway on every create or delete operation we have additionally\n  // $set modifier because of auto-updating of `shopId` and `updateAt` schema\n  // properties\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    if (!modifier.$set) {\n      modifier.$set = {};\n    }\n    modifier.$set.updatedAt = new Date();\n    // triggers inventory adjustment\n    Meteor.call(\"inventory/adjust\", doc);\n  }\n});\n\n/**\n * after insert\n * @summary should fires on create new variants, on clones products/variants\n */\nProducts.after.insert((userId, doc) => {\n  if (doc.type !== \"variant\") {\n    return false;\n  }\n  registerInventory(doc);\n});\n\nfunction markInventoryShipped(doc) {\n  const order = Orders.findOne(doc._id);\n  const orderItems = order.items;\n  const cartItems = [];\n  for (const orderItem of orderItems) {\n    const cartItem = {\n      _id: orderItem.cartItemId || orderItem._id,\n      shopId: orderItem.shopId,\n      quantity: orderItem.quantity,\n      productId: orderItem.productId,\n      variants: orderItem.variants,\n      title: orderItem.title\n    };\n    cartItems.push(cartItem);\n  }\n  Meteor.call(\"inventory/shipped\", cartItems);\n}\n\nfunction markInventorySold(doc) {\n  const orderItems = doc.items;\n  const cartItems = [];\n  // If a cartItemId exists it's a legacy order and we use that\n  for (const orderItem of orderItems) {\n    const cartItem = {\n      _id: orderItem.cartItemId || orderItem._id,\n      shopId: orderItem.shopId,\n      quantity: orderItem.quantity,\n      productId: orderItem.productId,\n      variants: orderItem.variants,\n      title: orderItem.title\n    };\n    cartItems.push(cartItem);\n  }\n  Meteor.call(\"inventory/sold\", cartItems);\n}\n\nOrders.after.insert((userId, doc) => {\n  Logger.debug(\"Inventory module handling Order insert\");\n  markInventorySold(doc);\n});\n\nOrders.after.update((userId, doc, fieldnames, modifier) => {\n  Logger.debug(\"Inventory module handling Order update\");\n  if (modifier.$addToSet) {\n    if (modifier.$addToSet[\"workflow.workflow\"] === \"coreOrderWorkflow/completed\") {\n      markInventoryShipped(doc);\n    }\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/included/inventory/server/hooks/hooks.js.map","sourceFileName":"/imports/plugins/included/inventory/server/hooks/hooks.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"hooks"},"ignored":false,"code":"var Cart = void 0,\n    Products = void 0,\n    Orders = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Cart: function (v) {\n    Cart = v;\n  },\n  Products: function (v) {\n    Products = v;\n  },\n  Orders: function (v) {\n    Orders = v;\n  }\n}, 0);\nvar Logger = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  }\n}, 1);\nvar registerInventory = void 0;\nmodule.importSync(\"../methods/inventory\", {\n  registerInventory: function (v) {\n    registerInventory = v;\n  }\n}, 2);\n/**\n * Collection Hooks\n * transform collections based on events\n *\n * See: https://github.com/matb33/meteor-collection-hooks\n */ /**\n     * After cart update\n     */Cart.after.update(function (userId, cart, fieldNames, modifier) {\n  // if we're adding a new product or variant to the cart\n  if (modifier.$addToSet) {\n    if (modifier.$addToSet.items) {\n      Logger.debug(\"after cart update, call inventory/addReserve\");\n      Meteor.call(\"inventory/addReserve\", cart.items);\n    }\n  } // or we're adding more quantity\n\n\n  if (modifier.$inc) {\n    Logger.debug(\"after variant increment, call inventory/addReserve\");\n    Meteor.call(\"inventory/addReserve\", cart.items);\n  }\n}); /**\n     * Before cart update. When Item is removed from Cart, release the inventory reservation.\n     */\nCart.before.update(function (userId, cart, fieldNames, modifier) {\n  // removing  cart items, clear inventory reserve\n  if (modifier.$pull) {\n    if (modifier.$pull.items) {\n      Logger.debug(\"remove cart items, call inventory/clearReserve\");\n      Meteor.call(\"inventory/clearReserve\", cart.items);\n    }\n  }\n}); /**\n     * after variant were removed\n     * @fires `inventory/remove` Method\n     */\nProducts.after.remove(function (userId, doc) {\n  if (doc.type === \"variant\") {\n    var variantItem = {\n      productId: doc.ancestors[0],\n      variantId: doc._id,\n      shopId: doc.shopId\n    };\n    Logger.debug(\"remove inventory variants for variant: \" + doc._id + \", call inventory/remove\");\n    Meteor.call(\"inventory/remove\", variantItem);\n  }\n}); //\n// after product update\n//\n\nProducts.after.update(function (userId, doc, fieldNames, modifier) {\n  // product update can't affect on inventory, so we don't manage this cases\n  // we should keep in mind that returning false within hook prevents other\n  // hooks to be run\n  if (doc.type !== \"variant\") return false; // check if modifier is set and $pull and $push are undefined. This need\n  // because anyway on every create or delete operation we have additionally\n  // $set modifier because of auto-updating of `shopId` and `updateAt` schema\n  // properties\n\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    if (!modifier.$set) {\n      modifier.$set = {};\n    }\n\n    modifier.$set.updatedAt = new Date(); // triggers inventory adjustment\n\n    Meteor.call(\"inventory/adjust\", doc);\n  }\n}); /**\n     * after insert\n     * @summary should fires on create new variants, on clones products/variants\n     */\nProducts.after.insert(function (userId, doc) {\n  if (doc.type !== \"variant\") {\n    return false;\n  }\n\n  registerInventory(doc);\n});\n\nfunction markInventoryShipped(doc) {\n  var order = Orders.findOne(doc._id);\n  var orderItems = order.items;\n  var cartItems = [];\n\n  for (var _iterator = orderItems, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var orderItem = _ref;\n    var cartItem = {\n      _id: orderItem.cartItemId || orderItem._id,\n      shopId: orderItem.shopId,\n      quantity: orderItem.quantity,\n      productId: orderItem.productId,\n      variants: orderItem.variants,\n      title: orderItem.title\n    };\n    cartItems.push(cartItem);\n  }\n\n  Meteor.call(\"inventory/shipped\", cartItems);\n}\n\nfunction markInventorySold(doc) {\n  var orderItems = doc.items;\n  var cartItems = []; // If a cartItemId exists it's a legacy order and we use that\n\n  for (var _iterator2 = orderItems, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref2 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref2 = _i2.value;\n    }\n\n    var orderItem = _ref2;\n    var cartItem = {\n      _id: orderItem.cartItemId || orderItem._id,\n      shopId: orderItem.shopId,\n      quantity: orderItem.quantity,\n      productId: orderItem.productId,\n      variants: orderItem.variants,\n      title: orderItem.title\n    };\n    cartItems.push(cartItem);\n  }\n\n  Meteor.call(\"inventory/sold\", cartItems);\n}\n\nOrders.after.insert(function (userId, doc) {\n  Logger.debug(\"Inventory module handling Order insert\");\n  markInventorySold(doc);\n});\nOrders.after.update(function (userId, doc, fieldnames, modifier) {\n  Logger.debug(\"Inventory module handling Order update\");\n\n  if (modifier.$addToSet) {\n    if (modifier.$addToSet[\"workflow.workflow\"] === \"coreOrderWorkflow/completed\") {\n      markInventoryShipped(doc);\n    }\n  }\n});","map":{"version":3,"sources":["/imports/plugins/included/inventory/server/hooks/hooks.js"],"names":["Cart","Products","Orders","Logger","registerInventory","after","update","userId","cart","fieldNames","modifier","$addToSet","items","debug","Meteor","call","$inc","before","$pull","remove","doc","type","variantItem","productId","ancestors","variantId","_id","shopId","$set","$push","updatedAt","Date","insert","markInventoryShipped","order","findOne","orderItems","cartItems","orderItem","cartItem","cartItemId","quantity","variants","title","push","markInventorySold","fieldnames"],"mappings":"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","file":"/imports/plugins/included/inventory/server/hooks/hooks.js.map","sourcesContent":["import { Cart, Products, Orders } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\nimport { registerInventory } from \"../methods/inventory\";\n\n/**\n * Collection Hooks\n * transform collections based on events\n *\n * See: https://github.com/matb33/meteor-collection-hooks\n */\n\n/**\n * After cart update\n */\nCart.after.update((userId, cart, fieldNames, modifier) => {\n  // if we're adding a new product or variant to the cart\n  if (modifier.$addToSet) {\n    if (modifier.$addToSet.items) {\n      Logger.debug(\"after cart update, call inventory/addReserve\");\n      Meteor.call(\"inventory/addReserve\", cart.items);\n    }\n  }\n  // or we're adding more quantity\n  if (modifier.$inc) {\n    Logger.debug(\"after variant increment, call inventory/addReserve\");\n    Meteor.call(\"inventory/addReserve\", cart.items);\n  }\n});\n\n/**\n * Before cart update. When Item is removed from Cart, release the inventory reservation.\n */\nCart.before.update((userId, cart, fieldNames, modifier) => {\n  // removing  cart items, clear inventory reserve\n  if (modifier.$pull) {\n    if (modifier.$pull.items) {\n      Logger.debug(\"remove cart items, call inventory/clearReserve\");\n      Meteor.call(\"inventory/clearReserve\", cart.items);\n    }\n  }\n});\n\n/**\n * after variant were removed\n * @fires `inventory/remove` Method\n */\nProducts.after.remove((userId, doc) => {\n  if (doc.type === \"variant\") {\n    const variantItem = {\n      productId: doc.ancestors[0],\n      variantId: doc._id,\n      shopId: doc.shopId\n    };\n    Logger.debug(`remove inventory variants for variant: ${doc._id\n      }, call inventory/remove`);\n    Meteor.call(\"inventory/remove\", variantItem);\n  }\n});\n\n//\n// after product update\n//\nProducts.after.update((userId, doc, fieldNames, modifier) => {\n  // product update can't affect on inventory, so we don't manage this cases\n  // we should keep in mind that returning false within hook prevents other\n  // hooks to be run\n  if (doc.type !== \"variant\") return false;\n\n  // check if modifier is set and $pull and $push are undefined. This need\n  // because anyway on every create or delete operation we have additionally\n  // $set modifier because of auto-updating of `shopId` and `updateAt` schema\n  // properties\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    if (!modifier.$set) {\n      modifier.$set = {};\n    }\n    modifier.$set.updatedAt = new Date();\n    // triggers inventory adjustment\n    Meteor.call(\"inventory/adjust\", doc);\n  }\n});\n\n/**\n * after insert\n * @summary should fires on create new variants, on clones products/variants\n */\nProducts.after.insert((userId, doc) => {\n  if (doc.type !== \"variant\") {\n    return false;\n  }\n  registerInventory(doc);\n});\n\nfunction markInventoryShipped(doc) {\n  const order = Orders.findOne(doc._id);\n  const orderItems = order.items;\n  const cartItems = [];\n  for (const orderItem of orderItems) {\n    const cartItem = {\n      _id: orderItem.cartItemId || orderItem._id,\n      shopId: orderItem.shopId,\n      quantity: orderItem.quantity,\n      productId: orderItem.productId,\n      variants: orderItem.variants,\n      title: orderItem.title\n    };\n    cartItems.push(cartItem);\n  }\n  Meteor.call(\"inventory/shipped\", cartItems);\n}\n\nfunction markInventorySold(doc) {\n  const orderItems = doc.items;\n  const cartItems = [];\n  // If a cartItemId exists it's a legacy order and we use that\n  for (const orderItem of orderItems) {\n    const cartItem = {\n      _id: orderItem.cartItemId || orderItem._id,\n      shopId: orderItem.shopId,\n      quantity: orderItem.quantity,\n      productId: orderItem.productId,\n      variants: orderItem.variants,\n      title: orderItem.title\n    };\n    cartItems.push(cartItem);\n  }\n  Meteor.call(\"inventory/sold\", cartItems);\n}\n\nOrders.after.insert((userId, doc) => {\n  Logger.debug(\"Inventory module handling Order insert\");\n  markInventorySold(doc);\n});\n\nOrders.after.update((userId, doc, fieldnames, modifier) => {\n  Logger.debug(\"Inventory module handling Order update\");\n  if (modifier.$addToSet) {\n    if (modifier.$addToSet[\"workflow.workflow\"] === \"coreOrderWorkflow/completed\") {\n      markInventoryShipped(doc);\n    }\n  }\n});\n"]},"hash":"cb18d6acfccf2bab3916583b212e31dc63e2d77f"}
