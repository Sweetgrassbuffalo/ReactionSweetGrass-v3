{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]},{"source":"/server/api","imported":["Reaction","Hooks"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"},{"kind":"named","imported":"Hooks","local":"Hooks"}]},{"source":"/lib/collections","imported":["Packages","Accounts","Shops","Shipping","Cart","Orders"],"specifiers":[{"kind":"named","imported":"Packages","local":"Packages"},{"kind":"named","imported":"Accounts","local":"Accounts"},{"kind":"named","imported":"Shops","local":"Shops"},{"kind":"named","imported":"Shipping","local":"Shipping"},{"kind":"named","imported":"Cart","local":"Cart"},{"kind":"named","imported":"Orders","local":"Orders"}]},{"source":"../../lib/collections/schemas","imported":["ShippoPackageConfig"],"specifiers":[{"kind":"named","imported":"ShippoPackageConfig","local":"ShippoPackageConfig"}]},{"source":"./shippoapi","imported":["ShippoApi"],"specifiers":[{"kind":"named","imported":"ShippoApi","local":"ShippoApi"}]},{"source":"../lib/roles","imported":["shippingRoles"],"specifiers":[{"kind":"named","imported":"shippingRoles","local":"shippingRoles"}]}],"exports":{"exported":["methods"],"specifiers":[{"kind":"local","local":"methods","exported":"methods"}]}}},"options":{"filename":"/imports/plugins/included/shippo/server/methods/shippo.js","filenameRelative":"/imports/plugins/included/shippo/server/methods/shippo.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/included/shippo/server/methods/shippo.js"],"names":["Meteor","check","Reaction","Hooks","Packages","Accounts","Shops","Shipping","Cart","Orders","ShippoPackageConfig","ShippoApi","shippingRoles","createShippoAddress","reactionAddress","email","purpose","shippoAddress","object_purpose","name","fullName","street1","address1","street2","address2","city","company","state","region","zip","postal","country","phone","is_residential","isCommercial","createShippoParcel","reactionParcel","reactionMassUnit","reactionDistanceUnit","shippoParcel","width","length","height","weight","distance_unit","toLowerCase","mass_unit","ratesParser","shippoRates","shippoDocs","map","rate","rateAmount","parseFloat","amount","reactionRate","carrier","provider","method","enabled","label","servicelevel_name","handling","settings","rateId","object_id","serviceLevelToken","servicelevel_token","shopId","carrier_account","filterActiveCarriers","carrierList","activeCarriers","results","count","forEach","active","push","carrierAccountId","formatCarrierLabel","carrierName","replace","toUpperCase","getApiKey","getShopId","findOne","apiKey","addShippoProviders","carriers","result","carrierLabel","currentResult","insert","methods","shippoProvider","removeShippoProviders","carriersIds","remove","$in","$exists","updateShippoProviders","currentShippoProviders","find","fields","currentCarriersIds","doc","newActiveCarriers","unchangedActiveCarriersIds","carrierId","includes","deactivatedCarriersIds","_","difference","modifier","_id","String","field","Roles","userIsInRole","userId","hasOwnProperty","customModifier","$set","update","type","getAddressList","call","getCarrierAccountsList","orderId","Match","Optional","shippoOrders","$ne","updatingResult","order","orderShipment","shipping","transactionId","shippo","transaction","getTransaction","trackingStatus","tracking_status","status_date","trackingStatusDate","status","orderUpdating","cartId","Object","cart","shippoAddressTo","shop","addressBook","emails","unitsOfMeasure","$elemMatch","default","shippoAddressFrom","address","items","parcel","unitOfMeasure","uom","buyer","carrierAccounts","keys","shippoShipment","createShipment","rates_list","reactionRates","shipmentMethod","Error","createTransaction","label_url","tracking_number","Events","add"],"mappings":"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","file":"/imports/plugins/included/shippo/server/methods/shippo.js.map","sourcesContent":["/* eslint camelcase: 0 */\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Reaction, Hooks } from \"/server/api\";\nimport { Packages, Accounts, Shops, Shipping, Cart, Orders } from \"/lib/collections\";\nimport { ShippoPackageConfig } from \"../../lib/collections/schemas\";\nimport { ShippoApi } from \"./shippoapi\";\nimport { shippingRoles } from \"../lib/roles\";\n\n// Creates an address (for sender or recipient) suitable for Shippo Api Calls given\n// a reaction address an email and a purpose(\"QUOTE\"|\"PURCHASE\")\nfunction createShippoAddress(reactionAddress, email, purpose) {\n  const shippoAddress = {\n    object_purpose: purpose,\n    name: reactionAddress.fullName,\n    street1: reactionAddress.address1,\n    street2: reactionAddress.address2 || \"\", // \"\" in order to be cleaned later by SimpleSchema.clean\n    city: reactionAddress.city,\n    company: reactionAddress.company || \"\",\n    state: reactionAddress.region,\n    zip: reactionAddress.postal,\n    country: reactionAddress.country,\n    phone: reactionAddress.phone,\n    email: email,\n    is_residential: !reactionAddress.isCommercial\n  };\n\n  return shippoAddress;\n}\n\n// Creates a parcel object suitable for Shippo Api Calls given\n// a reaction product's parcel and units of measure for mass and distance\nfunction createShippoParcel(reactionParcel, reactionMassUnit, reactionDistanceUnit) {\n  const shippoParcel = {\n    width: reactionParcel.width || \"\",\n    length: reactionParcel.length || \"\",\n    height: reactionParcel.height || \"\",\n    weight: reactionParcel.weight || \"\",\n    distance_unit: reactionDistanceUnit.toLowerCase(), // Propably we need to have for each shop a uom/baseuom for distance\n    mass_unit: reactionMassUnit.toLowerCase()\n  };\n\n  return shippoParcel;\n}\n\n// converts the Rates List fetched from the Shippo Api to Reaction Shipping Rates form\nfunction ratesParser(shippoRates, shippoDocs) {\n  return shippoRates.map(rate => {\n    const rateAmount = parseFloat(rate.amount);\n    // const methodLabel = `${rate.provider} - ${rate.servicelevel_name}`;\n    const reactionRate = {\n      carrier: rate.provider,\n      method: {\n        enabled: true,\n        label: rate.servicelevel_name,\n        rate: rateAmount,\n        handling: 0,\n        carrier: rate.provider,\n        settings: {\n          // carrierAccount: rate.carrier_account,\n          rateId: rate.object_id,\n          serviceLevelToken: rate.servicelevel_token\n        }\n      },\n      rate: rateAmount,\n      shopId: shippoDocs[rate.carrier_account].shopId\n    };\n\n    return reactionRate;\n  });\n}\n\n// Filters the carrier list and gets and parses only the ones that are activated in the Shippo Account\nfunction filterActiveCarriers(carrierList) {\n  const activeCarriers = [];\n  if (carrierList.results && carrierList.count) {\n    carrierList.results.forEach(carrier => {\n      if (carrier.active) {\n        activeCarriers.push({\n          carrier: carrier.carrier, // this is a property of the returned result with value the name of the carrier\n          carrierAccountId: carrier.object_id\n        });\n      }\n    });\n\n    return activeCarriers;\n  }\n}\n\n// usps_express to USPS EXPRESS .We need a better approach - use a suitable static map object\nfunction formatCarrierLabel(carrierName) {\n  return carrierName.replace(/_/g, \" \").toUpperCase();\n}\n\n// get Shippo's Api Key from the Shippo package with the supplied shopId or alternatively of the current shop's Id\nfunction getApiKey(shopId = Reaction.getShopId()) {\n  const { settings } = Packages.findOne({\n    name: \"reaction-shippo\",\n    shopId\n  });\n\n  return settings.apiKey;\n}\n\n// Adds Shippo carriers in Shipping Collection (one doc per carrier) for the current Shop\nfunction addShippoProviders(carriers, shopId = Reaction.getShopId()) {\n  let result = true;\n  carriers.forEach(carrier => {\n    const carrierName = carrier.carrier;\n    const carrierLabel = formatCarrierLabel(carrierName);\n    const currentResult = Shipping.insert({\n      name: `${carrierLabel}`, // check it later for a better name\n      methods: [],\n      provider: {\n        name: carrierName,\n        label: carrierLabel,\n        enabled: true,\n        shippoProvider: {\n          carrierAccountId: carrier.carrierAccountId\n        }\n      },\n      shopId\n    });\n    result = result && currentResult;\n  });\n\n  return result;\n}\n\n// Remove from Shipping Collection shop's Shippo Providers with carrier account Id in carriersIds\n// or all of them (if carriersIds is set to false)\nfunction removeShippoProviders(carriersIds, shopId = Reaction.getShopId()) {\n  if (carriersIds) {\n    return Shipping.remove({\n      shopId,\n      \"provider.shippoProvider.carrierAccountId\": { $in: carriersIds }\n    });\n  }\n\n  return Shipping.remove({\n    shopId,\n    \"provider.shippoProvider\": { $exists: true }\n  });\n}\n\n// After getting the current active Carriers of the Shippo Account removes\n// from the Shipping Collection the Shippo providers that are deactivated(don't exist in active carriers)\n// and inserts the newly active carriers in Shipping Collection as shippo providers.\n\nfunction updateShippoProviders(activeCarriers, shopId = Reaction.getShopId()) {\n  const currentShippoProviders = Shipping.find({\n    \"shopId\": shopId,\n    \"provider.shippoProvider\": { $exists: true }\n  }, {\n    fields: { \"provider.shippoProvider.carrierAccountId\": 1 }\n  });\n\n  // Ids of Shippo Carriers that exist currently as docs in Shipping Collection\n  const currentCarriersIds = currentShippoProviders.map(doc => doc.provider.shippoProvider.carrierAccountId);\n\n  const newActiveCarriers = [];\n  const unchangedActiveCarriersIds = [];\n  activeCarriers.forEach(carrier => {\n    const carrierId = carrier.carrierAccountId;\n    if (!currentCarriersIds.includes(carrierId)) {\n      newActiveCarriers.push(carrier);\n    } else {\n      unchangedActiveCarriersIds.push(carrierId);\n    }\n  });\n\n  const deactivatedCarriersIds = _.difference(currentCarriersIds, unchangedActiveCarriersIds);\n  if (deactivatedCarriersIds.length) {\n    removeShippoProviders(deactivatedCarriersIds, shopId);\n  }\n  if (newActiveCarriers.length) {\n    addShippoProviders(newActiveCarriers, shopId);\n  }\n\n  return true;\n}\n\nexport const methods = {\n  /**\n   * Updates the Api key(Live/Test Token) used for connection with the Shippo account.\n   * Also inserts(and deletes if already exist) docs in the Shipping collection each of the\n   * activated Carriers of the Shippo account.\n   * This method is intended to be used mainly by Autoform.\n   * @param {Object} modifier - The Autoform's modifier string\n   * @param {String} _id - The id of the Shippo package that gets updated\n   * @return {Object} result - The object returned.\n   * @return {String} {string(\"update\"|\"delete\")} result.type - The type of updating happened.\n   */\n  \"shippo/updateApiKey\"(modifier, _id) {\n    // Important server-side check for security and data integrity\n    check(modifier, ShippoPackageConfig);\n    check(_id, String);\n\n    // Make sure user has proper rights to this package\n    const { shopId } = Packages.findOne({ _id },\n                                        { field: { shopId: 1 } });\n    if (shopId && Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      // If user wants to delete existing key\n      if (modifier.hasOwnProperty(\"$unset\")) {\n        const customModifier = { $set: { \"settings.apiKey\": null } };\n        Packages.update(_id, customModifier);\n        // remove shop's existing Shippo Providers from Shipping Collection\n        removeShippoProviders(false, shopId);\n\n        return { type: \"delete\" };\n      }\n\n      const apiKey = modifier.$set[\"settings.apiKey\"];\n\n      // Tries to use the apiKey by fetching a list of the addresses of Shippo Account\n      // if not possible throws a relative Meteor Error (eg invalid_credentials)\n      ShippoApi.methods.getAddressList.call({ apiKey });\n      // if everything is ok proceed with the api key update\n      Packages.update(_id, modifier);\n      // remove shop's existing Shippo Providers from Shipping Collection\n      removeShippoProviders(false, shopId);\n\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({ apiKey }));\n      if (activeCarriers.length) {\n        addShippoProviders(activeCarriers, shopId);\n      }\n\n      return { type: \"update\" };\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the current active Shippo Carriers from the Shippo Account and updates the\n   * Shipping Collection by keeping only these as Shippo Providers of the shop.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n\n  \"shippo/fetchProviders\"() {\n    const shopId = Reaction.getShopId();\n\n    if (Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      const apiKey = getApiKey(shopId);\n      if (!apiKey) {\n        return false;\n      }\n\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({ apiKey }));\n      return updateShippoProviders(activeCarriers, shopId);\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the tracking status of shipped orders from Shippo and updates the\n   * relevant orders' properties\n   * @param {String} orderId - optional orderId to get status of just one order.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n  \"shippo/fetchTrackingStatusForOrders\"(orderId) {\n    check(orderId, Match.Optional(String));\n    const shopId = Reaction.getShopId();\n    let shippoOrders;\n    const apiKey = getApiKey(shopId);\n    if (!apiKey) {\n      return false;\n    }\n\n    if (orderId) {\n      // return a specific order\n      shippoOrders = Orders.find({\n        shopId,\n        orderId\n      });\n    } else {\n      // Find the orders of the shop that have shippo provider, tracking number, that are shipped\n      // but they are not yet delivered;\n      shippoOrders = Orders.find({\n        shopId,\n        \"shipping.0.shippo.transactionId\": { $exists: true },\n        \"shipping.0.tracking\": { $exists: true },\n        \"shipping.0.shipped\": true,\n        \"shipping.0.delivered\": { $ne: true }\n        // For now we don' t have logic for returned products\n      });\n    }\n\n\n    // no orders to update\n    if (!shippoOrders.count()) {\n      return true;\n    }\n\n    // For each order get from Shippo the transaction item ,check the tracking and if it has been updated\n    let updatingResult = true;\n    shippoOrders.forEach(order => {\n      const orderShipment = order.shipping[0];\n      const transactionId = orderShipment.shippo.transactionId;\n      const transaction = ShippoApi.methods.getTransaction.call({ apiKey, transactionId });\n\n      // For Testing:\n      // Comment First line of code, and uncomment following block to mock the updating of tracking status\n      // as Shippo's tracking status for test Shipments isn't getting updated.\n      const trackingStatus = transaction.tracking_status;\n      // const trackingStatus = {};\n      // if (transaction.object_state === \"VALID\") {\n      //   trackingStatus.status_date = (new Date).toString();\n      //   trackingStatus.status = (!orderShipment.shippo.trackingStatusStatus ? \"TRANSIT\" : \"DELIVERED\");\n      // }\n\n      if (trackingStatus &&\n        trackingStatus.status_date !== orderShipment.shippo.trackingStatusDate) {\n        // Shippo's tracking_status.status\tenum\tIndicates the high level status of the shipment:\n        // 'UNKNOWN', 'DELIVERED', 'TRANSIT', 'FAILURE', 'RETURNED'.\n        if (trackingStatus.status === \"DELIVERED\") {\n          Meteor.call(\"orders/shipmentDelivered\", order);\n        }\n\n        // A batch update might be better option. Unfortunately Reaction.import doesn't support\n        // .. Orders currently\n        const orderUpdating = Orders.update({\n          _id: order._id\n        }, {\n          $set: {\n            \"shipping.0.shippo.trackingStatusDate\": trackingStatus.status_date,\n            \"shipping.0.shippo.trackingStatusStatus\": trackingStatus.status\n          }\n        });\n        updatingResult = updatingResult && orderUpdating;\n      }\n    });\n\n    return updatingResult;\n  },\n\n  /**\n   * Returns the available Shippo Methods/Rates for a selected cart, in the same form shipping/getShippingRates\n   * returns them.\n   * @param {String} cartId - The id of the cart that rates are to be supplied.\n   * @param {Object} shippoDocs - Contains all the Enabled Shipping Objects with provider.shippoProvider property.\n   * Each property has as key the Shippo's carrierAccountId and as value the corresponding document of shipping\n   * collection.\n   * @return {Array} rates - The rates of the enabled and available Shippo carriers.\n   * */\n  \"shippo/getShippingRatesForCart\"(cartId, shippoDocs) {\n    check(cartId, String);\n    check(shippoDocs, Object);\n    const cart = Cart.findOne(cartId);\n    if (cart && cart.userId === this.userId) { // confirm user has the right\n      let shippoAddressTo;\n      let shippoParcel;\n      const purpose = \"PURCHASE\";\n\n      const shop = Shops.findOne({\n        _id: cart.shopId\n      }, {\n        field: {\n          addressBook: 1,\n          emails: 1,\n          unitsOfMeasure: { $elemMatch: { default: true } }\n        }\n      });\n\n      const apiKey = getApiKey(cart.shopId);\n      // If for a weird reason Shop hasn't a Shippo Api key anymore return no-rates.\n      if (!apiKey) {\n        return [];\n      }\n      // TODO create a shipping address book record for shop.\n      const shippoAddressFrom = createShippoAddress(shop.addressBook[0], shop.emails[0].address, purpose);\n      // product in the cart has to have parcel property with the dimensions\n      if (cart.items && cart.items[0] && cart.items[0].parcel) {\n        const unitOfMeasure = shop && shop.unitsOfMeasure && shop.unitsOfMeasure[0].uom || \"KG\";\n        // at the moment shops don't have a kind of unitOfMeasure for distance\n        // so we put CM...\n        shippoParcel = createShippoParcel(cart.items[0].parcel, unitOfMeasure, \"CM\");\n      } else {\n        return [];\n      }\n\n      const buyer = Accounts.findOne({\n        _id: this.userId\n      }, {\n        field: { emails: 1 }\n      });\n      // check that there is address available in cart\n      if (cart.shipping && cart.shipping[0] && cart.shipping[0].address) {\n        // TODO take a more elegant approach to guest checkout -> no email address\n        // add Logger.trace if this smells\n        let email = shop.emails[0].address || \"noreply@localhost\";\n        if (buyer.emails.length > 0) {\n          if (buyer.emails[0].address) {\n            email = buyer.emails[0].address;\n          }\n        }\n        shippoAddressTo = createShippoAddress(cart.shipping[0].address, email, purpose);\n      } else {\n        return [];\n      }\n      const carrierAccounts = Object.keys(shippoDocs);\n      const shippoShipment = ShippoApi.methods.createShipment.call({\n        shippoAddressFrom,\n        shippoAddressTo,\n        shippoParcel,\n        purpose,\n        carrierAccounts,\n        apiKey\n      });\n      const shippoRates = shippoShipment.rates_list;\n      const reactionRates = ratesParser(shippoRates, shippoDocs);\n\n      return reactionRates;\n    }\n\n    return false;\n  },\n\n  /**\n   * Confirms Shippo order based on buyer's choice at the time of purchase\n   * and supplies the order doc with the tracking and label infos\n   * @param {String} orderId - The id of the ordered that labels are purchased for\n   * @return {Boolean} result - True if procedure completed succesfully,otherwise false\n   */\n  \"shippo/confirmShippingMethodForOrder\"(orderId) {\n    check(orderId, String);\n    const order = Orders.findOne(orderId);\n    // Make sure user has permissions in the shop's order\n    if (Roles.userIsInRole(this.userId, shippingRoles, order.shopId)) {\n      const orderShipment = order.shipping[0];\n      // Here we done it for the first/unique Shipment only . in the near future it will be done for multiple ones\n      if (orderShipment && orderShipment.shipmentMethod && orderShipment.shipmentMethod.settings && orderShipment.shipmentMethod.settings.rateId) {\n        const apiKey = getApiKey(order.shopId);\n        // If for a weird reason Shop hasn't a Shippo Api key anymore you have to throw an error\n        // cause the Shippo label purchasing is not gonna happen.\n        if (!apiKey) {\n          throw new Meteor.Error(\"403\", \"Invalid Shippo Credentials\");\n        }\n        const rateId = orderShipment.shipmentMethod.settings.rateId;\n        // make the actual purchase\n        const transaction = ShippoApi.methods.createTransaction.call({ rateId, apiKey });\n        if (transaction) {\n          return Orders.update({\n            _id: orderId\n          }, {\n            $set: {\n              \"shipping.0.shippingLabelUrl\": transaction.label_url,\n              \"shipping.0.tracking\": transaction.tracking_number,\n              \"shipping.0.shippo.transactionId\": transaction.object_id,\n              \"shipping.0.shippo.trackingStatusDate\": null,\n              \"shipping.0.shippo.trackingStatusStatus\": null\n            }\n          });\n        }\n      }\n    }\n    return false;\n  }\n};\n\nMeteor.methods(methods);\n\nHooks.Events.add(\"onOrderPaymentCaptured\", methods[\"shippo/confirmShippingMethodForOrder\"]);\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/included/shippo/server/methods/shippo.js.map","sourceFileName":"/imports/plugins/included/shippo/server/methods/shippo.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"shippo"},"ignored":false,"code":"module.export({\n  methods: function () {\n    return methods;\n  }\n});\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar check = void 0;\nmodule.importSync(\"meteor/check\", {\n  check: function (v) {\n    check = v;\n  }\n}, 1);\nvar Reaction = void 0,\n    Hooks = void 0;\nmodule.importSync(\"/server/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  },\n  Hooks: function (v) {\n    Hooks = v;\n  }\n}, 2);\nvar Packages = void 0,\n    Accounts = void 0,\n    Shops = void 0,\n    Shipping = void 0,\n    Cart = void 0,\n    Orders = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Packages: function (v) {\n    Packages = v;\n  },\n  Accounts: function (v) {\n    Accounts = v;\n  },\n  Shops: function (v) {\n    Shops = v;\n  },\n  Shipping: function (v) {\n    Shipping = v;\n  },\n  Cart: function (v) {\n    Cart = v;\n  },\n  Orders: function (v) {\n    Orders = v;\n  }\n}, 3);\nvar ShippoPackageConfig = void 0;\nmodule.importSync(\"../../lib/collections/schemas\", {\n  ShippoPackageConfig: function (v) {\n    ShippoPackageConfig = v;\n  }\n}, 4);\nvar ShippoApi = void 0;\nmodule.importSync(\"./shippoapi\", {\n  ShippoApi: function (v) {\n    ShippoApi = v;\n  }\n}, 5);\nvar shippingRoles = void 0;\nmodule.importSync(\"../lib/roles\", {\n  shippingRoles: function (v) {\n    shippingRoles = v;\n  }\n}, 6);\n\n// Creates an address (for sender or recipient) suitable for Shippo Api Calls given\n// a reaction address an email and a purpose(\"QUOTE\"|\"PURCHASE\")\nfunction createShippoAddress(reactionAddress, email, purpose) {\n  var shippoAddress = {\n    object_purpose: purpose,\n    name: reactionAddress.fullName,\n    street1: reactionAddress.address1,\n    street2: reactionAddress.address2 || \"\",\n    // \"\" in order to be cleaned later by SimpleSchema.clean\n    city: reactionAddress.city,\n    company: reactionAddress.company || \"\",\n    state: reactionAddress.region,\n    zip: reactionAddress.postal,\n    country: reactionAddress.country,\n    phone: reactionAddress.phone,\n    email: email,\n    is_residential: !reactionAddress.isCommercial\n  };\n  return shippoAddress;\n} // Creates a parcel object suitable for Shippo Api Calls given\n// a reaction product's parcel and units of measure for mass and distance\n\n\nfunction createShippoParcel(reactionParcel, reactionMassUnit, reactionDistanceUnit) {\n  var shippoParcel = {\n    width: reactionParcel.width || \"\",\n    length: reactionParcel.length || \"\",\n    height: reactionParcel.height || \"\",\n    weight: reactionParcel.weight || \"\",\n    distance_unit: reactionDistanceUnit.toLowerCase(),\n    // Propably we need to have for each shop a uom/baseuom for distance\n    mass_unit: reactionMassUnit.toLowerCase()\n  };\n  return shippoParcel;\n} // converts the Rates List fetched from the Shippo Api to Reaction Shipping Rates form\n\n\nfunction ratesParser(shippoRates, shippoDocs) {\n  return shippoRates.map(function (rate) {\n    var rateAmount = parseFloat(rate.amount); // const methodLabel = `${rate.provider} - ${rate.servicelevel_name}`;\n\n    var reactionRate = {\n      carrier: rate.provider,\n      method: {\n        enabled: true,\n        label: rate.servicelevel_name,\n        rate: rateAmount,\n        handling: 0,\n        carrier: rate.provider,\n        settings: {\n          // carrierAccount: rate.carrier_account,\n          rateId: rate.object_id,\n          serviceLevelToken: rate.servicelevel_token\n        }\n      },\n      rate: rateAmount,\n      shopId: shippoDocs[rate.carrier_account].shopId\n    };\n    return reactionRate;\n  });\n} // Filters the carrier list and gets and parses only the ones that are activated in the Shippo Account\n\n\nfunction filterActiveCarriers(carrierList) {\n  var activeCarriers = [];\n\n  if (carrierList.results && carrierList.count) {\n    carrierList.results.forEach(function (carrier) {\n      if (carrier.active) {\n        activeCarriers.push({\n          carrier: carrier.carrier,\n          // this is a property of the returned result with value the name of the carrier\n          carrierAccountId: carrier.object_id\n        });\n      }\n    });\n    return activeCarriers;\n  }\n} // usps_express to USPS EXPRESS .We need a better approach - use a suitable static map object\n\n\nfunction formatCarrierLabel(carrierName) {\n  return carrierName.replace(/_/g, \" \").toUpperCase();\n} // get Shippo's Api Key from the Shippo package with the supplied shopId or alternatively of the current shop's Id\n\n\nfunction getApiKey() {\n  var shopId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Reaction.getShopId();\n\n  var _Packages$findOne = Packages.findOne({\n    name: \"reaction-shippo\",\n    shopId: shopId\n  }),\n      settings = _Packages$findOne.settings;\n\n  return settings.apiKey;\n} // Adds Shippo carriers in Shipping Collection (one doc per carrier) for the current Shop\n\n\nfunction addShippoProviders(carriers) {\n  var shopId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Reaction.getShopId();\n  var result = true;\n  carriers.forEach(function (carrier) {\n    var carrierName = carrier.carrier;\n    var carrierLabel = formatCarrierLabel(carrierName);\n    var currentResult = Shipping.insert({\n      name: \"\" + carrierLabel,\n      // check it later for a better name\n      methods: [],\n      provider: {\n        name: carrierName,\n        label: carrierLabel,\n        enabled: true,\n        shippoProvider: {\n          carrierAccountId: carrier.carrierAccountId\n        }\n      },\n      shopId: shopId\n    });\n    result = result && currentResult;\n  });\n  return result;\n} // Remove from Shipping Collection shop's Shippo Providers with carrier account Id in carriersIds\n// or all of them (if carriersIds is set to false)\n\n\nfunction removeShippoProviders(carriersIds) {\n  var shopId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Reaction.getShopId();\n\n  if (carriersIds) {\n    return Shipping.remove({\n      shopId: shopId,\n      \"provider.shippoProvider.carrierAccountId\": {\n        $in: carriersIds\n      }\n    });\n  }\n\n  return Shipping.remove({\n    shopId: shopId,\n    \"provider.shippoProvider\": {\n      $exists: true\n    }\n  });\n} // After getting the current active Carriers of the Shippo Account removes\n// from the Shipping Collection the Shippo providers that are deactivated(don't exist in active carriers)\n// and inserts the newly active carriers in Shipping Collection as shippo providers.\n\n\nfunction updateShippoProviders(activeCarriers) {\n  var shopId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Reaction.getShopId();\n  var currentShippoProviders = Shipping.find({\n    \"shopId\": shopId,\n    \"provider.shippoProvider\": {\n      $exists: true\n    }\n  }, {\n    fields: {\n      \"provider.shippoProvider.carrierAccountId\": 1\n    }\n  }); // Ids of Shippo Carriers that exist currently as docs in Shipping Collection\n\n  var currentCarriersIds = currentShippoProviders.map(function (doc) {\n    return doc.provider.shippoProvider.carrierAccountId;\n  });\n  var newActiveCarriers = [];\n  var unchangedActiveCarriersIds = [];\n  activeCarriers.forEach(function (carrier) {\n    var carrierId = carrier.carrierAccountId;\n\n    if (!currentCarriersIds.includes(carrierId)) {\n      newActiveCarriers.push(carrier);\n    } else {\n      unchangedActiveCarriersIds.push(carrierId);\n    }\n  });\n\n  var deactivatedCarriersIds = _.difference(currentCarriersIds, unchangedActiveCarriersIds);\n\n  if (deactivatedCarriersIds.length) {\n    removeShippoProviders(deactivatedCarriersIds, shopId);\n  }\n\n  if (newActiveCarriers.length) {\n    addShippoProviders(newActiveCarriers, shopId);\n  }\n\n  return true;\n}\n\nvar methods = {\n  /**\n   * Updates the Api key(Live/Test Token) used for connection with the Shippo account.\n   * Also inserts(and deletes if already exist) docs in the Shipping collection each of the\n   * activated Carriers of the Shippo account.\n   * This method is intended to be used mainly by Autoform.\n   * @param {Object} modifier - The Autoform's modifier string\n   * @param {String} _id - The id of the Shippo package that gets updated\n   * @return {Object} result - The object returned.\n   * @return {String} {string(\"update\"|\"delete\")} result.type - The type of updating happened.\n   */\"shippo/updateApiKey\": function (modifier, _id) {\n    // Important server-side check for security and data integrity\n    check(modifier, ShippoPackageConfig);\n    check(_id, String); // Make sure user has proper rights to this package\n\n    var _Packages$findOne2 = Packages.findOne({\n      _id: _id\n    }, {\n      field: {\n        shopId: 1\n      }\n    }),\n        shopId = _Packages$findOne2.shopId;\n\n    if (shopId && Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      // If user wants to delete existing key\n      if (modifier.hasOwnProperty(\"$unset\")) {\n        var customModifier = {\n          $set: {\n            \"settings.apiKey\": null\n          }\n        };\n        Packages.update(_id, customModifier); // remove shop's existing Shippo Providers from Shipping Collection\n\n        removeShippoProviders(false, shopId);\n        return {\n          type: \"delete\"\n        };\n      }\n\n      var apiKey = modifier.$set[\"settings.apiKey\"]; // Tries to use the apiKey by fetching a list of the addresses of Shippo Account\n      // if not possible throws a relative Meteor Error (eg invalid_credentials)\n\n      ShippoApi.methods.getAddressList.call({\n        apiKey: apiKey\n      }); // if everything is ok proceed with the api key update\n\n      Packages.update(_id, modifier); // remove shop's existing Shippo Providers from Shipping Collection\n\n      removeShippoProviders(false, shopId);\n      var activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({\n        apiKey: apiKey\n      }));\n\n      if (activeCarriers.length) {\n        addShippoProviders(activeCarriers, shopId);\n      }\n\n      return {\n        type: \"update\"\n      };\n    }\n\n    return false;\n  },\n  /**\n   * Fetches the current active Shippo Carriers from the Shippo Account and updates the\n   * Shipping Collection by keeping only these as Shippo Providers of the shop.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\"shippo/fetchProviders\": function () {\n    var shopId = Reaction.getShopId();\n\n    if (Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      var apiKey = getApiKey(shopId);\n\n      if (!apiKey) {\n        return false;\n      }\n\n      var activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({\n        apiKey: apiKey\n      }));\n      return updateShippoProviders(activeCarriers, shopId);\n    }\n\n    return false;\n  },\n  /**\n   * Fetches the tracking status of shipped orders from Shippo and updates the\n   * relevant orders' properties\n   * @param {String} orderId - optional orderId to get status of just one order.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\"shippo/fetchTrackingStatusForOrders\": function (orderId) {\n    check(orderId, Match.Optional(String));\n    var shopId = Reaction.getShopId();\n    var shippoOrders = void 0;\n    var apiKey = getApiKey(shopId);\n\n    if (!apiKey) {\n      return false;\n    }\n\n    if (orderId) {\n      // return a specific order\n      shippoOrders = Orders.find({\n        shopId: shopId,\n        orderId: orderId\n      });\n    } else {\n      // Find the orders of the shop that have shippo provider, tracking number, that are shipped\n      // but they are not yet delivered;\n      shippoOrders = Orders.find({\n        shopId: shopId,\n        \"shipping.0.shippo.transactionId\": {\n          $exists: true\n        },\n        \"shipping.0.tracking\": {\n          $exists: true\n        },\n        \"shipping.0.shipped\": true,\n        \"shipping.0.delivered\": {\n          $ne: true\n        } // For now we don' t have logic for returned products\n\n      });\n    } // no orders to update\n\n\n    if (!shippoOrders.count()) {\n      return true;\n    } // For each order get from Shippo the transaction item ,check the tracking and if it has been updated\n\n\n    var updatingResult = true;\n    shippoOrders.forEach(function (order) {\n      var orderShipment = order.shipping[0];\n      var transactionId = orderShipment.shippo.transactionId;\n      var transaction = ShippoApi.methods.getTransaction.call({\n        apiKey: apiKey,\n        transactionId: transactionId\n      }); // For Testing:\n      // Comment First line of code, and uncomment following block to mock the updating of tracking status\n      // as Shippo's tracking status for test Shipments isn't getting updated.\n\n      var trackingStatus = transaction.tracking_status; // const trackingStatus = {};\n      // if (transaction.object_state === \"VALID\") {\n      //   trackingStatus.status_date = (new Date).toString();\n      //   trackingStatus.status = (!orderShipment.shippo.trackingStatusStatus ? \"TRANSIT\" : \"DELIVERED\");\n      // }\n\n      if (trackingStatus && trackingStatus.status_date !== orderShipment.shippo.trackingStatusDate) {\n        // Shippo's tracking_status.status\tenum\tIndicates the high level status of the shipment:\n        // 'UNKNOWN', 'DELIVERED', 'TRANSIT', 'FAILURE', 'RETURNED'.\n        if (trackingStatus.status === \"DELIVERED\") {\n          Meteor.call(\"orders/shipmentDelivered\", order);\n        } // A batch update might be better option. Unfortunately Reaction.import doesn't support\n        // .. Orders currently\n\n\n        var orderUpdating = Orders.update({\n          _id: order._id\n        }, {\n          $set: {\n            \"shipping.0.shippo.trackingStatusDate\": trackingStatus.status_date,\n            \"shipping.0.shippo.trackingStatusStatus\": trackingStatus.status\n          }\n        });\n        updatingResult = updatingResult && orderUpdating;\n      }\n    });\n    return updatingResult;\n  },\n  /**\n   * Returns the available Shippo Methods/Rates for a selected cart, in the same form shipping/getShippingRates\n   * returns them.\n   * @param {String} cartId - The id of the cart that rates are to be supplied.\n   * @param {Object} shippoDocs - Contains all the Enabled Shipping Objects with provider.shippoProvider property.\n   * Each property has as key the Shippo's carrierAccountId and as value the corresponding document of shipping\n   * collection.\n   * @return {Array} rates - The rates of the enabled and available Shippo carriers.\n   * */\"shippo/getShippingRatesForCart\": function (cartId, shippoDocs) {\n    check(cartId, String);\n    check(shippoDocs, Object);\n    var cart = Cart.findOne(cartId);\n\n    if (cart && cart.userId === this.userId) {\n      // confirm user has the right\n      var shippoAddressTo = void 0;\n      var shippoParcel = void 0;\n      var purpose = \"PURCHASE\";\n      var shop = Shops.findOne({\n        _id: cart.shopId\n      }, {\n        field: {\n          addressBook: 1,\n          emails: 1,\n          unitsOfMeasure: {\n            $elemMatch: {\n              \"default\": true\n            }\n          }\n        }\n      });\n      var apiKey = getApiKey(cart.shopId); // If for a weird reason Shop hasn't a Shippo Api key anymore return no-rates.\n\n      if (!apiKey) {\n        return [];\n      } // TODO create a shipping address book record for shop.\n\n\n      var shippoAddressFrom = createShippoAddress(shop.addressBook[0], shop.emails[0].address, purpose); // product in the cart has to have parcel property with the dimensions\n\n      if (cart.items && cart.items[0] && cart.items[0].parcel) {\n        var unitOfMeasure = shop && shop.unitsOfMeasure && shop.unitsOfMeasure[0].uom || \"KG\"; // at the moment shops don't have a kind of unitOfMeasure for distance\n        // so we put CM...\n\n        shippoParcel = createShippoParcel(cart.items[0].parcel, unitOfMeasure, \"CM\");\n      } else {\n        return [];\n      }\n\n      var buyer = Accounts.findOne({\n        _id: this.userId\n      }, {\n        field: {\n          emails: 1\n        }\n      }); // check that there is address available in cart\n\n      if (cart.shipping && cart.shipping[0] && cart.shipping[0].address) {\n        // TODO take a more elegant approach to guest checkout -> no email address\n        // add Logger.trace if this smells\n        var email = shop.emails[0].address || \"noreply@localhost\";\n\n        if (buyer.emails.length > 0) {\n          if (buyer.emails[0].address) {\n            email = buyer.emails[0].address;\n          }\n        }\n\n        shippoAddressTo = createShippoAddress(cart.shipping[0].address, email, purpose);\n      } else {\n        return [];\n      }\n\n      var carrierAccounts = Object.keys(shippoDocs);\n      var shippoShipment = ShippoApi.methods.createShipment.call({\n        shippoAddressFrom: shippoAddressFrom,\n        shippoAddressTo: shippoAddressTo,\n        shippoParcel: shippoParcel,\n        purpose: purpose,\n        carrierAccounts: carrierAccounts,\n        apiKey: apiKey\n      });\n      var shippoRates = shippoShipment.rates_list;\n      var reactionRates = ratesParser(shippoRates, shippoDocs);\n      return reactionRates;\n    }\n\n    return false;\n  },\n  /**\n   * Confirms Shippo order based on buyer's choice at the time of purchase\n   * and supplies the order doc with the tracking and label infos\n   * @param {String} orderId - The id of the ordered that labels are purchased for\n   * @return {Boolean} result - True if procedure completed succesfully,otherwise false\n   */\"shippo/confirmShippingMethodForOrder\": function (orderId) {\n    check(orderId, String);\n    var order = Orders.findOne(orderId); // Make sure user has permissions in the shop's order\n\n    if (Roles.userIsInRole(this.userId, shippingRoles, order.shopId)) {\n      var orderShipment = order.shipping[0]; // Here we done it for the first/unique Shipment only . in the near future it will be done for multiple ones\n\n      if (orderShipment && orderShipment.shipmentMethod && orderShipment.shipmentMethod.settings && orderShipment.shipmentMethod.settings.rateId) {\n        var apiKey = getApiKey(order.shopId); // If for a weird reason Shop hasn't a Shippo Api key anymore you have to throw an error\n        // cause the Shippo label purchasing is not gonna happen.\n\n        if (!apiKey) {\n          throw new Meteor.Error(\"403\", \"Invalid Shippo Credentials\");\n        }\n\n        var rateId = orderShipment.shipmentMethod.settings.rateId; // make the actual purchase\n\n        var transaction = ShippoApi.methods.createTransaction.call({\n          rateId: rateId,\n          apiKey: apiKey\n        });\n\n        if (transaction) {\n          return Orders.update({\n            _id: orderId\n          }, {\n            $set: {\n              \"shipping.0.shippingLabelUrl\": transaction.label_url,\n              \"shipping.0.tracking\": transaction.tracking_number,\n              \"shipping.0.shippo.transactionId\": transaction.object_id,\n              \"shipping.0.shippo.trackingStatusDate\": null,\n              \"shipping.0.shippo.trackingStatusStatus\": null\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n};\nMeteor.methods(methods);\nHooks.Events.add(\"onOrderPaymentCaptured\", methods[\"shippo/confirmShippingMethodForOrder\"]);","map":{"version":3,"sources":["/imports/plugins/included/shippo/server/methods/shippo.js"],"names":["Meteor","check","Reaction","Hooks","Packages","Accounts","Shops","Shipping","Cart","Orders","ShippoPackageConfig","ShippoApi","shippingRoles","createShippoAddress","reactionAddress","email","purpose","shippoAddress","object_purpose","name","fullName","street1","address1","street2","address2","city","company","state","region","zip","postal","country","phone","is_residential","isCommercial","createShippoParcel","reactionParcel","reactionMassUnit","reactionDistanceUnit","shippoParcel","width","length","height","weight","distance_unit","toLowerCase","mass_unit","ratesParser","shippoRates","shippoDocs","map","rate","rateAmount","parseFloat","amount","reactionRate","carrier","provider","method","enabled","label","servicelevel_name","handling","settings","rateId","object_id","serviceLevelToken","servicelevel_token","shopId","carrier_account","filterActiveCarriers","carrierList","activeCarriers","results","count","forEach","active","push","carrierAccountId","formatCarrierLabel","carrierName","replace","toUpperCase","getApiKey","getShopId","findOne","apiKey","addShippoProviders","carriers","result","carrierLabel","currentResult","insert","methods","shippoProvider","removeShippoProviders","carriersIds","remove","$in","$exists","updateShippoProviders","currentShippoProviders","find","fields","currentCarriersIds","doc","newActiveCarriers","unchangedActiveCarriersIds","carrierId","includes","deactivatedCarriersIds","_","difference","modifier","_id","String","field","Roles","userIsInRole","userId","hasOwnProperty","customModifier","$set","update","type","getAddressList","call","getCarrierAccountsList","orderId","Match","Optional","shippoOrders","$ne","updatingResult","order","orderShipment","shipping","transactionId","shippo","transaction","getTransaction","trackingStatus","tracking_status","status_date","trackingStatusDate","status","orderUpdating","cartId","Object","cart","shippoAddressTo","shop","addressBook","emails","unitsOfMeasure","$elemMatch","default","shippoAddressFrom","address","items","parcel","unitOfMeasure","uom","buyer","carrierAccounts","keys","shippoShipment","createShipment","rates_list","reactionRates","shipmentMethod","Error","createTransaction","label_url","tracking_number","Events","add"],"mappings":"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","file":"/imports/plugins/included/shippo/server/methods/shippo.js.map","sourcesContent":["/* eslint camelcase: 0 */\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Reaction, Hooks } from \"/server/api\";\nimport { Packages, Accounts, Shops, Shipping, Cart, Orders } from \"/lib/collections\";\nimport { ShippoPackageConfig } from \"../../lib/collections/schemas\";\nimport { ShippoApi } from \"./shippoapi\";\nimport { shippingRoles } from \"../lib/roles\";\n\n// Creates an address (for sender or recipient) suitable for Shippo Api Calls given\n// a reaction address an email and a purpose(\"QUOTE\"|\"PURCHASE\")\nfunction createShippoAddress(reactionAddress, email, purpose) {\n  const shippoAddress = {\n    object_purpose: purpose,\n    name: reactionAddress.fullName,\n    street1: reactionAddress.address1,\n    street2: reactionAddress.address2 || \"\", // \"\" in order to be cleaned later by SimpleSchema.clean\n    city: reactionAddress.city,\n    company: reactionAddress.company || \"\",\n    state: reactionAddress.region,\n    zip: reactionAddress.postal,\n    country: reactionAddress.country,\n    phone: reactionAddress.phone,\n    email: email,\n    is_residential: !reactionAddress.isCommercial\n  };\n\n  return shippoAddress;\n}\n\n// Creates a parcel object suitable for Shippo Api Calls given\n// a reaction product's parcel and units of measure for mass and distance\nfunction createShippoParcel(reactionParcel, reactionMassUnit, reactionDistanceUnit) {\n  const shippoParcel = {\n    width: reactionParcel.width || \"\",\n    length: reactionParcel.length || \"\",\n    height: reactionParcel.height || \"\",\n    weight: reactionParcel.weight || \"\",\n    distance_unit: reactionDistanceUnit.toLowerCase(), // Propably we need to have for each shop a uom/baseuom for distance\n    mass_unit: reactionMassUnit.toLowerCase()\n  };\n\n  return shippoParcel;\n}\n\n// converts the Rates List fetched from the Shippo Api to Reaction Shipping Rates form\nfunction ratesParser(shippoRates, shippoDocs) {\n  return shippoRates.map(rate => {\n    const rateAmount = parseFloat(rate.amount);\n    // const methodLabel = `${rate.provider} - ${rate.servicelevel_name}`;\n    const reactionRate = {\n      carrier: rate.provider,\n      method: {\n        enabled: true,\n        label: rate.servicelevel_name,\n        rate: rateAmount,\n        handling: 0,\n        carrier: rate.provider,\n        settings: {\n          // carrierAccount: rate.carrier_account,\n          rateId: rate.object_id,\n          serviceLevelToken: rate.servicelevel_token\n        }\n      },\n      rate: rateAmount,\n      shopId: shippoDocs[rate.carrier_account].shopId\n    };\n\n    return reactionRate;\n  });\n}\n\n// Filters the carrier list and gets and parses only the ones that are activated in the Shippo Account\nfunction filterActiveCarriers(carrierList) {\n  const activeCarriers = [];\n  if (carrierList.results && carrierList.count) {\n    carrierList.results.forEach(carrier => {\n      if (carrier.active) {\n        activeCarriers.push({\n          carrier: carrier.carrier, // this is a property of the returned result with value the name of the carrier\n          carrierAccountId: carrier.object_id\n        });\n      }\n    });\n\n    return activeCarriers;\n  }\n}\n\n// usps_express to USPS EXPRESS .We need a better approach - use a suitable static map object\nfunction formatCarrierLabel(carrierName) {\n  return carrierName.replace(/_/g, \" \").toUpperCase();\n}\n\n// get Shippo's Api Key from the Shippo package with the supplied shopId or alternatively of the current shop's Id\nfunction getApiKey(shopId = Reaction.getShopId()) {\n  const { settings } = Packages.findOne({\n    name: \"reaction-shippo\",\n    shopId\n  });\n\n  return settings.apiKey;\n}\n\n// Adds Shippo carriers in Shipping Collection (one doc per carrier) for the current Shop\nfunction addShippoProviders(carriers, shopId = Reaction.getShopId()) {\n  let result = true;\n  carriers.forEach(carrier => {\n    const carrierName = carrier.carrier;\n    const carrierLabel = formatCarrierLabel(carrierName);\n    const currentResult = Shipping.insert({\n      name: `${carrierLabel}`, // check it later for a better name\n      methods: [],\n      provider: {\n        name: carrierName,\n        label: carrierLabel,\n        enabled: true,\n        shippoProvider: {\n          carrierAccountId: carrier.carrierAccountId\n        }\n      },\n      shopId\n    });\n    result = result && currentResult;\n  });\n\n  return result;\n}\n\n// Remove from Shipping Collection shop's Shippo Providers with carrier account Id in carriersIds\n// or all of them (if carriersIds is set to false)\nfunction removeShippoProviders(carriersIds, shopId = Reaction.getShopId()) {\n  if (carriersIds) {\n    return Shipping.remove({\n      shopId,\n      \"provider.shippoProvider.carrierAccountId\": { $in: carriersIds }\n    });\n  }\n\n  return Shipping.remove({\n    shopId,\n    \"provider.shippoProvider\": { $exists: true }\n  });\n}\n\n// After getting the current active Carriers of the Shippo Account removes\n// from the Shipping Collection the Shippo providers that are deactivated(don't exist in active carriers)\n// and inserts the newly active carriers in Shipping Collection as shippo providers.\n\nfunction updateShippoProviders(activeCarriers, shopId = Reaction.getShopId()) {\n  const currentShippoProviders = Shipping.find({\n    \"shopId\": shopId,\n    \"provider.shippoProvider\": { $exists: true }\n  }, {\n    fields: { \"provider.shippoProvider.carrierAccountId\": 1 }\n  });\n\n  // Ids of Shippo Carriers that exist currently as docs in Shipping Collection\n  const currentCarriersIds = currentShippoProviders.map(doc => doc.provider.shippoProvider.carrierAccountId);\n\n  const newActiveCarriers = [];\n  const unchangedActiveCarriersIds = [];\n  activeCarriers.forEach(carrier => {\n    const carrierId = carrier.carrierAccountId;\n    if (!currentCarriersIds.includes(carrierId)) {\n      newActiveCarriers.push(carrier);\n    } else {\n      unchangedActiveCarriersIds.push(carrierId);\n    }\n  });\n\n  const deactivatedCarriersIds = _.difference(currentCarriersIds, unchangedActiveCarriersIds);\n  if (deactivatedCarriersIds.length) {\n    removeShippoProviders(deactivatedCarriersIds, shopId);\n  }\n  if (newActiveCarriers.length) {\n    addShippoProviders(newActiveCarriers, shopId);\n  }\n\n  return true;\n}\n\nexport const methods = {\n  /**\n   * Updates the Api key(Live/Test Token) used for connection with the Shippo account.\n   * Also inserts(and deletes if already exist) docs in the Shipping collection each of the\n   * activated Carriers of the Shippo account.\n   * This method is intended to be used mainly by Autoform.\n   * @param {Object} modifier - The Autoform's modifier string\n   * @param {String} _id - The id of the Shippo package that gets updated\n   * @return {Object} result - The object returned.\n   * @return {String} {string(\"update\"|\"delete\")} result.type - The type of updating happened.\n   */\n  \"shippo/updateApiKey\"(modifier, _id) {\n    // Important server-side check for security and data integrity\n    check(modifier, ShippoPackageConfig);\n    check(_id, String);\n\n    // Make sure user has proper rights to this package\n    const { shopId } = Packages.findOne({ _id },\n                                        { field: { shopId: 1 } });\n    if (shopId && Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      // If user wants to delete existing key\n      if (modifier.hasOwnProperty(\"$unset\")) {\n        const customModifier = { $set: { \"settings.apiKey\": null } };\n        Packages.update(_id, customModifier);\n        // remove shop's existing Shippo Providers from Shipping Collection\n        removeShippoProviders(false, shopId);\n\n        return { type: \"delete\" };\n      }\n\n      const apiKey = modifier.$set[\"settings.apiKey\"];\n\n      // Tries to use the apiKey by fetching a list of the addresses of Shippo Account\n      // if not possible throws a relative Meteor Error (eg invalid_credentials)\n      ShippoApi.methods.getAddressList.call({ apiKey });\n      // if everything is ok proceed with the api key update\n      Packages.update(_id, modifier);\n      // remove shop's existing Shippo Providers from Shipping Collection\n      removeShippoProviders(false, shopId);\n\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({ apiKey }));\n      if (activeCarriers.length) {\n        addShippoProviders(activeCarriers, shopId);\n      }\n\n      return { type: \"update\" };\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the current active Shippo Carriers from the Shippo Account and updates the\n   * Shipping Collection by keeping only these as Shippo Providers of the shop.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n\n  \"shippo/fetchProviders\"() {\n    const shopId = Reaction.getShopId();\n\n    if (Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      const apiKey = getApiKey(shopId);\n      if (!apiKey) {\n        return false;\n      }\n\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({ apiKey }));\n      return updateShippoProviders(activeCarriers, shopId);\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the tracking status of shipped orders from Shippo and updates the\n   * relevant orders' properties\n   * @param {String} orderId - optional orderId to get status of just one order.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n  \"shippo/fetchTrackingStatusForOrders\"(orderId) {\n    check(orderId, Match.Optional(String));\n    const shopId = Reaction.getShopId();\n    let shippoOrders;\n    const apiKey = getApiKey(shopId);\n    if (!apiKey) {\n      return false;\n    }\n\n    if (orderId) {\n      // return a specific order\n      shippoOrders = Orders.find({\n        shopId,\n        orderId\n      });\n    } else {\n      // Find the orders of the shop that have shippo provider, tracking number, that are shipped\n      // but they are not yet delivered;\n      shippoOrders = Orders.find({\n        shopId,\n        \"shipping.0.shippo.transactionId\": { $exists: true },\n        \"shipping.0.tracking\": { $exists: true },\n        \"shipping.0.shipped\": true,\n        \"shipping.0.delivered\": { $ne: true }\n        // For now we don' t have logic for returned products\n      });\n    }\n\n\n    // no orders to update\n    if (!shippoOrders.count()) {\n      return true;\n    }\n\n    // For each order get from Shippo the transaction item ,check the tracking and if it has been updated\n    let updatingResult = true;\n    shippoOrders.forEach(order => {\n      const orderShipment = order.shipping[0];\n      const transactionId = orderShipment.shippo.transactionId;\n      const transaction = ShippoApi.methods.getTransaction.call({ apiKey, transactionId });\n\n      // For Testing:\n      // Comment First line of code, and uncomment following block to mock the updating of tracking status\n      // as Shippo's tracking status for test Shipments isn't getting updated.\n      const trackingStatus = transaction.tracking_status;\n      // const trackingStatus = {};\n      // if (transaction.object_state === \"VALID\") {\n      //   trackingStatus.status_date = (new Date).toString();\n      //   trackingStatus.status = (!orderShipment.shippo.trackingStatusStatus ? \"TRANSIT\" : \"DELIVERED\");\n      // }\n\n      if (trackingStatus &&\n        trackingStatus.status_date !== orderShipment.shippo.trackingStatusDate) {\n        // Shippo's tracking_status.status\tenum\tIndicates the high level status of the shipment:\n        // 'UNKNOWN', 'DELIVERED', 'TRANSIT', 'FAILURE', 'RETURNED'.\n        if (trackingStatus.status === \"DELIVERED\") {\n          Meteor.call(\"orders/shipmentDelivered\", order);\n        }\n\n        // A batch update might be better option. Unfortunately Reaction.import doesn't support\n        // .. Orders currently\n        const orderUpdating = Orders.update({\n          _id: order._id\n        }, {\n          $set: {\n            \"shipping.0.shippo.trackingStatusDate\": trackingStatus.status_date,\n            \"shipping.0.shippo.trackingStatusStatus\": trackingStatus.status\n          }\n        });\n        updatingResult = updatingResult && orderUpdating;\n      }\n    });\n\n    return updatingResult;\n  },\n\n  /**\n   * Returns the available Shippo Methods/Rates for a selected cart, in the same form shipping/getShippingRates\n   * returns them.\n   * @param {String} cartId - The id of the cart that rates are to be supplied.\n   * @param {Object} shippoDocs - Contains all the Enabled Shipping Objects with provider.shippoProvider property.\n   * Each property has as key the Shippo's carrierAccountId and as value the corresponding document of shipping\n   * collection.\n   * @return {Array} rates - The rates of the enabled and available Shippo carriers.\n   * */\n  \"shippo/getShippingRatesForCart\"(cartId, shippoDocs) {\n    check(cartId, String);\n    check(shippoDocs, Object);\n    const cart = Cart.findOne(cartId);\n    if (cart && cart.userId === this.userId) { // confirm user has the right\n      let shippoAddressTo;\n      let shippoParcel;\n      const purpose = \"PURCHASE\";\n\n      const shop = Shops.findOne({\n        _id: cart.shopId\n      }, {\n        field: {\n          addressBook: 1,\n          emails: 1,\n          unitsOfMeasure: { $elemMatch: { default: true } }\n        }\n      });\n\n      const apiKey = getApiKey(cart.shopId);\n      // If for a weird reason Shop hasn't a Shippo Api key anymore return no-rates.\n      if (!apiKey) {\n        return [];\n      }\n      // TODO create a shipping address book record for shop.\n      const shippoAddressFrom = createShippoAddress(shop.addressBook[0], shop.emails[0].address, purpose);\n      // product in the cart has to have parcel property with the dimensions\n      if (cart.items && cart.items[0] && cart.items[0].parcel) {\n        const unitOfMeasure = shop && shop.unitsOfMeasure && shop.unitsOfMeasure[0].uom || \"KG\";\n        // at the moment shops don't have a kind of unitOfMeasure for distance\n        // so we put CM...\n        shippoParcel = createShippoParcel(cart.items[0].parcel, unitOfMeasure, \"CM\");\n      } else {\n        return [];\n      }\n\n      const buyer = Accounts.findOne({\n        _id: this.userId\n      }, {\n        field: { emails: 1 }\n      });\n      // check that there is address available in cart\n      if (cart.shipping && cart.shipping[0] && cart.shipping[0].address) {\n        // TODO take a more elegant approach to guest checkout -> no email address\n        // add Logger.trace if this smells\n        let email = shop.emails[0].address || \"noreply@localhost\";\n        if (buyer.emails.length > 0) {\n          if (buyer.emails[0].address) {\n            email = buyer.emails[0].address;\n          }\n        }\n        shippoAddressTo = createShippoAddress(cart.shipping[0].address, email, purpose);\n      } else {\n        return [];\n      }\n      const carrierAccounts = Object.keys(shippoDocs);\n      const shippoShipment = ShippoApi.methods.createShipment.call({\n        shippoAddressFrom,\n        shippoAddressTo,\n        shippoParcel,\n        purpose,\n        carrierAccounts,\n        apiKey\n      });\n      const shippoRates = shippoShipment.rates_list;\n      const reactionRates = ratesParser(shippoRates, shippoDocs);\n\n      return reactionRates;\n    }\n\n    return false;\n  },\n\n  /**\n   * Confirms Shippo order based on buyer's choice at the time of purchase\n   * and supplies the order doc with the tracking and label infos\n   * @param {String} orderId - The id of the ordered that labels are purchased for\n   * @return {Boolean} result - True if procedure completed succesfully,otherwise false\n   */\n  \"shippo/confirmShippingMethodForOrder\"(orderId) {\n    check(orderId, String);\n    const order = Orders.findOne(orderId);\n    // Make sure user has permissions in the shop's order\n    if (Roles.userIsInRole(this.userId, shippingRoles, order.shopId)) {\n      const orderShipment = order.shipping[0];\n      // Here we done it for the first/unique Shipment only . in the near future it will be done for multiple ones\n      if (orderShipment && orderShipment.shipmentMethod && orderShipment.shipmentMethod.settings && orderShipment.shipmentMethod.settings.rateId) {\n        const apiKey = getApiKey(order.shopId);\n        // If for a weird reason Shop hasn't a Shippo Api key anymore you have to throw an error\n        // cause the Shippo label purchasing is not gonna happen.\n        if (!apiKey) {\n          throw new Meteor.Error(\"403\", \"Invalid Shippo Credentials\");\n        }\n        const rateId = orderShipment.shipmentMethod.settings.rateId;\n        // make the actual purchase\n        const transaction = ShippoApi.methods.createTransaction.call({ rateId, apiKey });\n        if (transaction) {\n          return Orders.update({\n            _id: orderId\n          }, {\n            $set: {\n              \"shipping.0.shippingLabelUrl\": transaction.label_url,\n              \"shipping.0.tracking\": transaction.tracking_number,\n              \"shipping.0.shippo.transactionId\": transaction.object_id,\n              \"shipping.0.shippo.trackingStatusDate\": null,\n              \"shipping.0.shippo.trackingStatusStatus\": null\n            }\n          });\n        }\n      }\n    }\n    return false;\n  }\n};\n\nMeteor.methods(methods);\n\nHooks.Events.add(\"onOrderPaymentCaptured\", methods[\"shippo/confirmShippingMethodForOrder\"]);\n"]},"hash":"445d67ca546ee0b0751c1e2a2a8cac061e60be63"}
