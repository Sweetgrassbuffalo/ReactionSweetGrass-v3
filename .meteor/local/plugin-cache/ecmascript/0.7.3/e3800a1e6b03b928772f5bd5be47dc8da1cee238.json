{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"meteor/mongo","imported":["Mongo"],"specifiers":[{"kind":"named","imported":"Mongo","local":"Mongo"}]},{"source":"meteor/mongo-id","imported":["MongoID"],"specifiers":[{"kind":"named","imported":"MongoID","local":"MongoID"}]},{"source":"events","imported":["EventEmitter"],"specifiers":[{"kind":"named","imported":"EventEmitter","local":"EventEmitter"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/johanbrook:publication-collector/publication-collector.js","filenameRelative":"/packages/johanbrook:publication-collector/publication-collector.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/johanbrook:publication-collector/publication-collector.js.map","sourceFileName":"/packages/johanbrook:publication-collector/publication-collector.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"publication-collector"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar Mongo = void 0;\nmodule.importSync(\"meteor/mongo\", {\n  Mongo: function (v) {\n    Mongo = v;\n  }\n}, 0);\nvar MongoID = void 0;\nmodule.importSync(\"meteor/mongo-id\", {\n  MongoID: function (v) {\n    MongoID = v;\n  }\n}, 1);\nvar EventEmitter = void 0;\nmodule.importSync(\"events\", {\n  EventEmitter: function (v) {\n    EventEmitter = v;\n  }\n}, 2);\nvar validMongoId = Match.OneOf(String, Mongo.ObjectID); /*\n                                                          This class describes something like Subscription in\n                                                          meteor/meteor/packages/ddp/livedata_server.js, but instead of sending\n                                                          over a socket it just collects data.\n                                                        */\n\nPublicationCollector = function (_EventEmitter) {\n  (0, _inherits3.default)(PublicationCollector, _EventEmitter);\n\n  function PublicationCollector() {\n    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    (0, _classCallCheck3.default)(this, PublicationCollector);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));\n\n    check(context.userId, Match.Optional(String)); // Object where the keys are collection names, and then the keys are _ids\n\n    _this._documents = {};\n\n    _this.unblock = function () {};\n\n    _this.userId = context.userId;\n    _this._idFilter = {\n      idStringify: MongoID.idStringify,\n      idParse: MongoID.idParse\n    };\n\n    _this._isDeactivated = function () {};\n\n    return _this;\n  }\n\n  PublicationCollector.prototype.collect = function () {\n    function collect(name) {\n      var _this2 = this;\n\n      var callback = void 0; // extracts optional callback from latest argument\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (_.isFunction(args[args.length - 1])) {\n        callback = args.pop();\n      } // adds a one time listener function for the \"ready\" event\n\n\n      this.once('ready', function (collections) {\n        if (_.isFunction(callback)) {\n          callback(collections);\n        } // immediately stop the subscription\n\n\n        _this2.stop();\n      });\n      var handler = Meteor.server.publish_handlers[name];\n      var result = handler.call.apply(handler, [this].concat(args));\n\n      this._publishHandlerResult(result);\n    }\n\n    return collect;\n  }(); /**\n        * Reproduces \"_publishHandlerResult\" processing\n        * @see {@link https://github.com/meteor/meteor/blob/master/packages/ddp-server/livedata_server.js#L1045}\n        */\n\n  PublicationCollector.prototype._publishHandlerResult = function () {\n    function _publishHandlerResult(res) {\n      var _this3 = this;\n\n      var cursors = []; // publication handlers can return a collection cursor, an array of cursors or nothing.\n\n      if (this._isCursor(res)) {\n        cursors.push(res);\n      } else if (Array.isArray(res)) {\n        // check all the elements are cursors\n        var areCursors = res.reduce(function (valid, cur) {\n          return valid && _this3._isCursor(cur);\n        }, true);\n\n        if (!areCursors) {\n          this.error(new Error('Publish function returned an array of non-Cursors'));\n          return;\n        } // find duplicate collection names\n\n\n        var collectionNames = {};\n\n        for (var i = 0; i < res.length; ++i) {\n          var collectionName = res[i]._getCollectionName();\n\n          if ({}.hasOwnProperty.call(collectionNames, collectionName)) {\n            this.error(new Error(\"Publish function returned multiple cursors for collection \" + collectionName));\n            return;\n          }\n\n          collectionNames[collectionName] = true;\n          cursors.push(res[i]);\n        }\n      }\n\n      if (cursors.length > 0) {\n        try {\n          // for each cursor we call _publishCursor method which starts observing the cursor and\n          // publishes the results.\n          cursors.forEach(function (cur) {\n            _this3._ensureCollectionInRes(cur._getCollectionName());\n\n            cur._publishCursor(_this3);\n          });\n        } catch (e) {\n          this.error(e);\n          return;\n        } // mark subscription as ready (_publishCursor does NOT call ready())\n\n\n        this.ready();\n      } else if (res) {\n        // truthy values other than cursors or arrays are probably a\n        // user mistake (possible returning a Mongo document via, say,\n        // `coll.findOne()`).\n        this.error(new Error('Publish function can only return a Cursor or an array of Cursors'));\n      }\n    }\n\n    return _publishHandlerResult;\n  }();\n\n  PublicationCollector.prototype.added = function () {\n    function added(collection, id, fields) {\n      check(collection, String);\n      check(id, validMongoId);\n\n      this._ensureCollectionInRes(collection); // Make sure to ignore the _id in fields\n\n\n      var addedDocument = _.extend({\n        _id: id\n      }, _.omit(fields, '_id'));\n\n      this._documents[collection][id] = addedDocument;\n    }\n\n    return added;\n  }();\n\n  PublicationCollector.prototype.changed = function () {\n    function changed(collection, id, fields) {\n      check(collection, String);\n      check(id, validMongoId);\n\n      this._ensureCollectionInRes(collection);\n\n      var existingDocument = this._documents[collection][id];\n\n      var fieldsNoId = _.omit(fields, '_id');\n\n      if (existingDocument) {\n        _.extend(existingDocument, fieldsNoId); // Delete all keys that were undefined in fields (except _id)\n\n\n        _.forEach(fields, function (value, key) {\n          if (value === undefined) {\n            delete existingDocument[key];\n          }\n        });\n      }\n    }\n\n    return changed;\n  }();\n\n  PublicationCollector.prototype.removed = function () {\n    function removed(collection, id) {\n      check(collection, String);\n      check(id, validMongoId);\n\n      this._ensureCollectionInRes(collection);\n\n      delete this._documents[collection][id];\n\n      if (_.isEmpty(this._documents[collection])) {\n        delete this._documents[collection];\n      }\n    }\n\n    return removed;\n  }();\n\n  PublicationCollector.prototype.ready = function () {\n    function ready() {\n      // Synchronously calls each of the listeners registered for the \"ready\" event\n      this.emit('ready', this._generateResponse());\n    }\n\n    return ready;\n  }();\n\n  PublicationCollector.prototype.onStop = function () {\n    function onStop(callback) {\n      // Adds a one time listener function for the \"stop\" event\n      this.once('stop', callback);\n    }\n\n    return onStop;\n  }();\n\n  PublicationCollector.prototype.stop = function () {\n    function stop() {\n      // Synchronously calls each of the listeners registered for the \"stop\" event\n      this.emit('stop');\n    }\n\n    return stop;\n  }();\n\n  PublicationCollector.prototype.error = function () {\n    function error(_error) {\n      throw _error;\n    }\n\n    return error;\n  }();\n\n  PublicationCollector.prototype._isCursor = function () {\n    function _isCursor(c) {\n      return c && c._publishCursor;\n    }\n\n    return _isCursor;\n  }();\n\n  PublicationCollector.prototype._ensureCollectionInRes = function () {\n    function _ensureCollectionInRes(collection) {\n      this._documents[collection] = this._documents[collection] || {};\n    }\n\n    return _ensureCollectionInRes;\n  }();\n\n  PublicationCollector.prototype._generateResponse = function () {\n    function _generateResponse() {\n      var output = {};\n\n      _.forEach(this._documents, function (documents, collectionName) {\n        output[collectionName] = _.values(documents);\n      });\n\n      return output;\n    }\n\n    return _generateResponse;\n  }();\n\n  return PublicationCollector;\n}(EventEmitter);","map":{"version":3,"sources":["/packages/johanbrook:publication-collector/publication-collector.js"],"names":["Mongo","module","importSync","v","MongoID","EventEmitter","validMongoId","Match","OneOf","String","ObjectID","PublicationCollector","context","check","userId","Optional","_documents","unblock","_idFilter","idStringify","idParse","_isDeactivated","collect","name","callback","args","_","isFunction","length","pop","once","collections","stop","handler","Meteor","server","publish_handlers","result","call","_publishHandlerResult","res","cursors","_isCursor","push","Array","isArray","areCursors","reduce","valid","cur","error","Error","collectionNames","i","collectionName","_getCollectionName","hasOwnProperty","forEach","_ensureCollectionInRes","_publishCursor","e","ready","added","collection","id","fields","addedDocument","extend","_id","omit","changed","existingDocument","fieldsNoId","value","key","undefined","removed","isEmpty","emit","_generateResponse","onStop","c","output","documents","values"],"mappings":"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","file":"/packages/johanbrook:publication-collector/publication-collector.js.map","sourcesContent":["import { Mongo } from 'meteor/mongo';\nimport { MongoID } from 'meteor/mongo-id';\nimport { EventEmitter } from 'events';\n\nconst validMongoId = Match.OneOf(String, Mongo.ObjectID);\n\n/*\n  This class describes something like Subscription in\n  meteor/meteor/packages/ddp/livedata_server.js, but instead of sending\n  over a socket it just collects data.\n*/\nPublicationCollector = class PublicationCollector extends EventEmitter {\n\n  constructor(context = {}) {\n    super();\n    check(context.userId, Match.Optional(String));\n\n    // Object where the keys are collection names, and then the keys are _ids\n    this._documents = {};\n    this.unblock = () => {};\n    this.userId = context.userId;\n    this._idFilter = {\n      idStringify: MongoID.idStringify,\n      idParse: MongoID.idParse\n    };\n    this._isDeactivated = () => {};\n  }\n\n  collect(name, ...args) {\n    let callback;\n    // extracts optional callback from latest argument\n    if (_.isFunction(args[args.length - 1])) {\n      callback = args.pop();\n    }\n    // adds a one time listener function for the \"ready\" event\n    this.once('ready', (collections) => {\n      if (_.isFunction(callback)) {\n        callback(collections);\n      }\n      // immediately stop the subscription\n      this.stop();\n    });\n\n    const handler = Meteor.server.publish_handlers[name];\n    const result = handler.call(this, ...args);\n\n    this._publishHandlerResult(result);\n  }\n\n  /**\n   * Reproduces \"_publishHandlerResult\" processing\n   * @see {@link https://github.com/meteor/meteor/blob/master/packages/ddp-server/livedata_server.js#L1045}\n   */\n  _publishHandlerResult(res) {\n    const cursors = [];\n\n    // publication handlers can return a collection cursor, an array of cursors or nothing.\n    if (this._isCursor(res)) {\n      cursors.push(res);\n    } else if (Array.isArray(res)) {\n      // check all the elements are cursors\n      const areCursors = res.reduce((valid, cur) => valid && this._isCursor(cur), true);\n      if (!areCursors) {\n        this.error(new Error('Publish function returned an array of non-Cursors'));\n        return;\n      }\n      // find duplicate collection names\n      const collectionNames = {};\n      for (let i = 0; i < res.length; ++i) {\n        const collectionName = res[i]._getCollectionName();\n        if ({}.hasOwnProperty.call(collectionNames, collectionName)) {\n          this.error(new Error(\n            `Publish function returned multiple cursors for collection ${collectionName}`\n          ));\n          return;\n        }\n        collectionNames[collectionName] = true;\n        cursors.push(res[i]);\n      }\n    }\n\n    if (cursors.length > 0) {\n      try {\n        // for each cursor we call _publishCursor method which starts observing the cursor and\n        // publishes the results.\n        cursors.forEach((cur) => {\n          this._ensureCollectionInRes(cur._getCollectionName());\n          cur._publishCursor(this);\n        });\n      } catch (e) {\n        this.error(e);\n        return;\n      }\n      // mark subscription as ready (_publishCursor does NOT call ready())\n      this.ready();\n    } else if (res) {\n      // truthy values other than cursors or arrays are probably a\n      // user mistake (possible returning a Mongo document via, say,\n      // `coll.findOne()`).\n      this.error(new Error('Publish function can only return a Cursor or an array of Cursors'));\n    }\n  }\n\n  added(collection, id, fields) {\n    check(collection, String);\n    check(id, validMongoId);\n\n    this._ensureCollectionInRes(collection);\n\n    // Make sure to ignore the _id in fields\n    const addedDocument = _.extend({_id: id}, _.omit(fields, '_id'));\n    this._documents[collection][id] = addedDocument;\n  }\n\n  changed(collection, id, fields) {\n    check(collection, String);\n    check(id, validMongoId);\n\n    this._ensureCollectionInRes(collection);\n\n    const existingDocument = this._documents[collection][id];\n    const fieldsNoId = _.omit(fields, '_id');\n\n    if (existingDocument) {\n      _.extend(existingDocument, fieldsNoId);\n\n      // Delete all keys that were undefined in fields (except _id)\n      _.forEach(fields, (value, key) => {\n        if (value === undefined) {\n          delete existingDocument[key];\n        }\n      });\n    }\n  }\n\n  removed(collection, id) {\n    check(collection, String);\n    check(id, validMongoId);\n\n    this._ensureCollectionInRes(collection);\n\n    delete this._documents[collection][id];\n\n    if (_.isEmpty(this._documents[collection])) {\n      delete this._documents[collection];\n    }\n  }\n\n  ready() {\n    // Synchronously calls each of the listeners registered for the \"ready\" event\n    this.emit('ready', this._generateResponse());\n  }\n\n  onStop(callback) {\n    // Adds a one time listener function for the \"stop\" event\n    this.once('stop', callback);\n  }\n\n  stop() {\n    // Synchronously calls each of the listeners registered for the \"stop\" event\n    this.emit('stop');\n  }\n\n  error(error) {\n    throw error;\n  }\n\n  _isCursor(c) {\n    return c && c._publishCursor;\n  }\n\n  _ensureCollectionInRes(collection) {\n    this._documents[collection] = this._documents[collection] || {};\n  }\n\n  _generateResponse() {\n    const output = {};\n\n    _.forEach(this._documents, (documents, collectionName) => {\n      output[collectionName] = _.values(documents);\n    });\n\n    return output;\n  }\n};\n"]},"hash":"e3800a1e6b03b928772f5bd5be47dc8da1cee238"}
