{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"lodash/clone","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_clone"}]},{"source":"lodash/each","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_each"}]},{"source":"lodash/find","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_find"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]},{"source":"/lib/collections","imported":["*"],"specifiers":[{"kind":"namespace","local":"Collections"}]},{"source":"/server/api","imported":["Logger","Reaction"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/methods/core/cart.js","filenameRelative":"/server/methods/core/cart.js","inputSourceMap":{"version":3,"sources":["/server/methods/core/cart.js"],"names":["Meteor","check","Collections","Logger","Reaction","quantityProcessing","product","variant","itemQty","quantity","MIN","minOrderQuantity","MAX","inventoryQuantity","Infinity","debug","_id","Error","type","inventoryPolicy","getSessionCarts","userId","sessionId","shopId","carts","Cart","find","$and","$ne","$eq","allowedCarts","forEach","cart","Roles","userIsInRole","push","methods","cartId","currentSessionId","String","Match","Optional","currentCart","findOne","getShopId","sessionCarts","sessionCart","items","workflow","length","call","update","$addToSet","$each","remove","Accounts","users","status","anonymousUser","sessionCartCount","currentCartId","insert","account","profile","addressBook","address","isBillingDefault","isShippingDefault","currentUser","user","userCurrency","getShopCurrency","currency","productId","variantId","Number","error","Products","$in","doc","warn","cartVariantExists","some","item","variants","$inc","result","simpleSchema","namedContext","invalidKeys","Random","id","title","parcel","itemId","cartItem","$pull","removeQuantity","Math","abs","order","Object","assign","msg","email","emails","provides","createdAt","updatedAt","cartCount","cartShipping","cartSubTotal","cartTaxes","cartDiscounts","cartTotal","Array","isArray","shipping","paymentId","billing","exchangeRate","userExchangeRate","packed","shipped","delivered","orderId","Orders","newCartExists","count","info","err","method","selector","$set","shipmentMethod","e","userCurrencyString","$unset","Schemas","Address","addressId","needToUpdate","isShippingDeleting","paymentMethod","PaymentMethod","checkoutCart","invoice","subtotal","taxes","discounts","total"],"mappings":"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","file":"/server/methods/core/cart.js.map","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport * as Collections from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * quantityProcessing\n * @summary perform calculations admissibility of adding product to cart\n * @param {Object} product - product to add to Cart\n * @param {Object} variant - product variant\n * @param {Number} itemQty - qty to add to cart, defaults to 1, deducts\n *  from inventory\n * @since 1.10.1\n * @return {Number} quantity - revised quantity to be added to cart\n */\nfunction quantityProcessing(product, variant, itemQty = 1) {\n  let quantity = itemQty;\n  const MIN = variant.minOrderQuantity || 1;\n  const MAX = variant.inventoryQuantity || Infinity;\n\n  if (MIN > MAX) {\n    Logger.debug(`productId: ${product._id}, variantId ${variant._id\n      }: inventoryQuantity lower then minimum order`);\n    throw new Meteor.Error(`productId: ${product._id}, variantId ${variant._id\n      }: inventoryQuantity lower then minimum order`);\n  }\n\n  // TODO: think about #152 implementation here\n  switch (product.type) {\n    case \"not-in-stock\":\n      break;\n    default: // type: `simple` // todo: maybe it should be \"variant\"\n      if (quantity < MIN) {\n        quantity = MIN;\n      } else if (variant.inventoryPolicy && quantity > MAX) {\n        quantity = MAX;\n      }\n  }\n\n  return quantity;\n}\n\n/**\n * getSessionCarts\n * @summary get Cart cursor with all session carts\n * @param {String} userId - current user _id\n * @param {String} sessionId - current user session id\n * @param {String} shopId - shop id\n * @since 0.10.2\n * @return {Mongo.Cursor} with array of session carts\n */\nfunction getSessionCarts(userId, sessionId, shopId) {\n  const carts = Collections.Cart.find({\n    $and: [{\n      userId: {\n        $ne: userId\n      }\n    }, {\n      sessionId: {\n        $eq: sessionId\n      }\n    }, {\n      shopId: {\n        $eq: shopId\n      }\n    }]\n  });\n\n  // we can't use Array.map here, because we need to reduce the number of array\n  // elements if element belongs to registered user, we should throw it.\n  const allowedCarts = [];\n\n  // only anonymous user carts allowed\n  carts.forEach(cart => {\n    if (Roles.userIsInRole(cart.userId, \"anonymous\", shopId)) {\n      allowedCarts.push(cart);\n    }\n  });\n\n  return allowedCarts;\n}\n\n/**\n * Reaction Cart Methods\n */\n\n\nMeteor.methods({\n  /**\n   * cart/mergeCart\n   * @summary merge matching sessionId cart into specified userId cart\n   *\n   * There should be one cart for each independent, non logged in user session\n   * When a user logs in that cart now belongs to that user and we use the a\n   * single user cart.\n   * If they are logged in on more than one devices, regardless of session,the\n   * user cart will be used\n   * If they had more than one cart, on more than one device,logged in at\n   * separate times then merge the carts\n   *\n   * @param {String} cartId - cartId of the cart to merge matching session\n   * carts into.\n   * @param {String} [currentSessionId] - current client session id\n   * @todo I think this method should be moved out from methods to a Function\n   * Declaration to keep it more secure\n   * @return {Object|Boolean} cartId - cartId on success or false\n   */\n  \"cart/mergeCart\": function (cartId, currentSessionId) {\n    check(cartId, String);\n    check(currentSessionId, Match.Optional(String));\n\n    // we don't process current cart, but merge into it.\n    const currentCart = Collections.Cart.findOne(cartId);\n    if (!currentCart) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    // just used to filter out the current cart\n    // we do additional check of cart exists here and if it not exist, next\n    // check supposed to throw 403 error\n    const userId = currentCart && currentCart.userId;\n    // user should have an access to operate with only one - his - cart\n    if (this.userId !== null && userId !== this.userId) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // persistent sessions, see: publications/sessions.js\n    // this is the last place where we still need `Reaction.sessionId`.\n    // The use case is: on user log in. I don't know how pass `sessionId` down\n    // at that moment.\n    const sessionId = currentSessionId || Reaction.sessionId;\n    const shopId = Reaction.getShopId();\n\n    // no need to merge anonymous carts\n    if (Roles.userIsInRole(userId, \"anonymous\", shopId)) {\n      return false;\n    }\n    Logger.debug(\"merge cart: matching sessionId\");\n    Logger.debug(\"current userId:\", userId);\n    Logger.debug(\"sessionId:\", sessionId);\n    // get session carts without current user cart cursor\n    const sessionCarts = getSessionCarts(userId, sessionId, shopId);\n\n    Logger.debug(\n      `merge cart: begin merge processing of session ${\n      sessionId} into: ${currentCart._id}`\n    );\n    // loop through session carts and merge into user cart\n    sessionCarts.forEach(sessionCart => {\n      Logger.debug(\n        `merge cart: merge user userId: ${userId}, sessionCart.userId: ${\n          sessionCart.userId}, sessionCart id: ${sessionCart._id}`\n      );\n      // really if we have no items, there's nothing to merge\n      if (sessionCart.items) {\n        // if currentCart already have a cartWorkflow, we don't need to clean it\n        // up completely, just to `coreCheckoutShipping` stage. Also, we will\n        // need to recalculate shipping rates\n        if (typeof currentCart.workflow === \"object\" &&\n        typeof currentCart.workflow.workflow === \"object\") {\n          if (currentCart.workflow.workflow.length > 2) {\n            Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n            // refresh shipping quotes\n            Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n          }\n        } else {\n          // if user logged in he doesn't need to show `checkoutLogin` step\n          Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n        }\n\n        // We got an additional db call because of `workflow/revertCartWorkflow`\n        // call, but we also got things more cleaner in my opinion.\n        // merge session cart into current cart\n        Collections.Cart.update(currentCart._id, {\n          $addToSet: {\n            items: {\n              $each: sessionCart.items\n            }\n          }\n        });\n      }\n\n      // cleanup session Carts after merge.\n      if (sessionCart.userId !== this.userId) {\n        // clear the cart that was used for a session\n        // and we're also going to do some garbage Collection\n        Collections.Cart.remove(sessionCart._id);\n        // cleanup user/accounts\n        Collections.Accounts.remove({\n          userId: sessionCart.userId\n        });\n        Meteor.users.remove(sessionCart.userId);\n        Logger.debug(\n          `merge cart: delete cart ${\n          sessionCart._id} and user: ${sessionCart.userId}`\n        );\n      }\n      Logger.debug(\n        `merge cart: processed merge for cartId ${sessionCart._id}`\n      );\n    });\n\n    // `checkoutLogin` should be used for anonymous only. Registered users\n    // no need see this.\n    if (currentCart.workflow.status === \"new\") {\n      // to call `workflow/pushCartWorkflow` two times is the only way to move\n      // from status \"new\" to \"checkoutAddressBook\" which I found without\n      // refactoring of `workflow/pushCartWorkflow`\n      // We send `cartId` as arguments because this method could be called from\n      // publication method and in half cases it could be so, that\n      // Meteor.userId() will be null.\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"checkoutLogin\", cartId);\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"checkoutAddressBook\", cartId);\n    }\n\n    return currentCart._id;\n  },\n\n  /**\n   * cart/createCart\n   * @description create new cart for user, but all checks for current cart's\n   * existence should go before this method will be called, to keep it clean\n   * @summary create and return new cart for user\n   * @param {String} userId - userId to create cart for\n   * @param {String} sessionId - current client session id\n   * @todo I think this method should be moved out from methods to a Function\n   * Declaration to keep it more secure\n   * @returns {String} cartId - users cartId\n   */\n  \"cart/createCart\": function (userId, sessionId) {\n    check(userId, String);\n    check(sessionId, String);\n\n    const shopId = Reaction.getShopId();\n    // check if user has `anonymous` role.( this is a visitor)\n    const anonymousUser = Roles.userIsInRole(userId, \"anonymous\", shopId);\n    const sessionCartCount = getSessionCarts(userId, sessionId, shopId).length;\n\n    Logger.debug(\"create cart: shopId\", shopId);\n    Logger.debug(\"create cart: userId\", userId);\n    Logger.debug(\"create cart: sessionId\", sessionId);\n    Logger.debug(\"create cart: sessionCarts.count\", sessionCartCount);\n    Logger.debug(\"create cart: anonymousUser\", anonymousUser);\n\n    // we need to create a user cart for the new authenticated user or\n    // anonymous.\n    const currentCartId = Collections.Cart.insert({\n      sessionId: sessionId,\n      userId: userId\n    });\n    Logger.debug(\"create cart: into new user cart. created: \" +  currentCartId +\n      \" for user \" + userId);\n\n    // merge session carts into the current cart\n    if (sessionCartCount > 0 && !anonymousUser) {\n      Logger.debug(\"create cart: found existing cart. merge into \" + currentCartId\n        + \" for user \" + userId);\n      Meteor.call(\"cart/mergeCart\", currentCartId, sessionId);\n    }\n\n    // we should check for an default billing/shipping address in user account.\n    // this needed after submitting order, when user receives new cart\n    const account = Collections.Accounts.findOne(userId);\n    if (account && account.profile && account.profile.addressBook) {\n      account.profile.addressBook.forEach(address => {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", currentCartId, address);\n        }\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", currentCartId, address);\n        }\n      });\n    }\n\n    // attach current user currency to cart\n    const currentUser = Meteor.user();\n    let userCurrency = Reaction.getShopCurrency();\n\n    // Check to see if the user has a custom currency saved to their profile\n    // Use it if they do\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = currentUser.profile.currency;\n    }\n    Meteor.call(\"cart/setUserCurrency\", currentCartId, userCurrency);\n\n    return currentCartId;\n  },\n\n  /**\n   *  cart/addToCart\n   *  @summary add items to a user cart\n   *  when we add an item to the cart, we want to break all relationships\n   *  with the existing item. We want to fix price, qty, etc into history\n   *  however, we could check reactively for price /qty etc, adjustments on\n   *  the original and notify them\n   *  @param {String} productId - productId to add to Cart\n   *  @param {String} variantId - product variant _id\n   *  @param {Number} [itemQty] - qty to add to cart\n   *  @return {Number|Object} Mongo insert response\n   */\n  \"cart/addToCart\": function (productId, variantId, itemQty) {\n    check(productId, String);\n    check(variantId, String);\n    check(itemQty, Match.Optional(Number));\n\n    const cart = Collections.Cart.findOne({ userId: this.userId });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n    // With the flattened model we no longer need to work directly with the\n    // products. But product still could be necessary for a `quantityProcessing`\n    // TODO: need to understand: do we really need product inside\n    // `quantityProcessing`?\n    let product;\n    let variant;\n    Collections.Products.find({ _id: { $in: [\n      productId,\n      variantId\n    ] } }).forEach(doc => {\n      if (doc.type === \"simple\") {\n        product = doc;\n      } else {\n        variant = doc;\n      }\n    });\n\n    // TODO: this lines still needed. We could uncomment them in future if\n    // decide to not completely remove product data from this method\n    // const product = Collections.Products.findOne(productId);\n    // const variant = Collections.Products.findOne(variantId);\n    if (!product) {\n      Logger.warn(`Product: ${ productId } was not found in database`);\n      throw new Meteor.Error(404, \"Product not found\",\n        \"Product with such id was not found!\");\n    }\n    if (!variant) {\n      Logger.warn(`Product variant: ${ variantId } was not found in database`);\n      throw new Meteor.Error(404, \"ProductVariant not found\",\n        \"ProductVariant with such id was not found!\");\n    }\n    // performs calculations admissibility of adding product to cart\n    const quantity = quantityProcessing(product, variant, itemQty);\n    // performs search of variant inside cart\n    const cartVariantExists = cart.items && cart.items\n      .some(item => item.variants._id === variantId);\n\n    if (cartVariantExists) {\n      return Collections.Cart.update({\n        \"_id\": cart._id,\n        \"items.variants._id\": variantId\n      }, {\n        $inc: {\n          \"items.$.quantity\": quantity\n        }\n      }, function (error, result) {\n        if (error) {\n          Logger.warn(\"error adding to cart\",\n            Collections.Cart.simpleSchema().namedContext().invalidKeys());\n          return error;\n        }\n\n        // refresh shipping quotes\n        Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n        // revert workflow to checkout shipping step.\n        Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n        // reset selected shipment method\n        Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n        Logger.debug(`cart: increment variant ${variantId} quantity by ${\n          quantity}`);\n\n        return result;\n      });\n    }\n\n    // cart variant doesn't exist\n    return Collections.Cart.update({\n      _id: cart._id\n    }, {\n      $addToSet: {\n        items: {\n          _id: Random.id(),\n          shopId: product.shopId,\n          productId: productId,\n          quantity: quantity,\n          variants: variant,\n          title: product.title,\n          type: product.type,\n          parcel: product.parcel || null\n        }\n      }\n    }, function (error, result) {\n      if (error) {\n        Logger.error(error);\n        Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(),\n          \"Invalid keys. Error adding to cart.\");\n        return error;\n      }\n\n      // refresh shipping quotes\n      Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n      // revert workflow to checkout shipping step.\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n      // reset selected shipment method\n      Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n      Logger.debug(`cart: add variant ${variantId} to cartId ${cart._id}`);\n\n      return result;\n    });\n  },\n\n  /**\n   * cart/removeFromCart\n   * @summary removes or adjust quantity of a variant from the cart\n   * @param {String} itemId - cart item _id\n   * @param {Number} [quantity] - if provided will adjust increment by quantity\n   * @returns {Number} returns Mongo update result\n   */\n  \"cart/removeFromCart\": function (itemId, quantity) {\n    check(itemId, String);\n    check(quantity, Match.Optional(Number));\n\n    const userId = Meteor.userId();\n    const cart = Collections.Cart.findOne({\n      userId: userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"cart-not-found\", \"Cart not found for user with such id\");\n    }\n\n    let cartItem;\n\n    if (cart.items) {\n      cartItem = _.find(cart.items, (item) => item._id === itemId);\n    }\n\n    // extra check of item exists\n    if (typeof cartItem !== \"object\") {\n      Logger.error(`Unable to find an item: ${itemId} within the cart: ${cart._id}`);\n      throw new Meteor.Error(\"cart-item-not-found\", \"Unable to find an item with such id in cart.\");\n    }\n\n    // refresh shipping quotes\n    Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n    // revert workflow to checkout shipping step.\n    Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    // reset selected shipment method\n    Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n    if (!quantity || quantity >= cartItem.quantity) {\n      return Collections.Cart.update({\n        _id: cart._id\n      }, {\n        $pull: {\n          items: {\n            _id: itemId\n          }\n        }\n      }, (error, result) => {\n        if (error) {\n          Logger.error(error);\n          Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(),\n            \"error removing from cart\");\n          return error;\n        }\n        Logger.debug(`cart: deleted cart item variant id ${cartItem.variants._id}`);\n        return result;\n      });\n    }\n\n    // if quantity lets convert to negative and increment\n    const removeQuantity = Math.abs(quantity) * -1;\n    return Collections.Cart.update({\n      \"_id\": cart._id,\n      \"items._id\": cartItem._id\n    }, {\n      $inc: {\n        \"items.$.quantity\": removeQuantity\n      }\n    }, (error, result) => {\n      if (error) {\n        Logger.error(error);\n        Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(),\n          \"error removing from cart\");\n        return error;\n      }\n      Logger.debug(`cart: removed variant ${cartItem._id} quantity of ${quantity}`);\n      return result;\n    });\n  },\n\n  /**\n   * cart/copyCartToOrder\n   * @summary transform cart to order when a payment is processed we want to\n   * copy the cart over to an order object, and give the user a new empty\n   * cart. reusing the cart schema makes sense, but integrity of the order, we\n   * don't want to just make another cart item\n   * @todo:  Partial order processing, shopId processing\n   * @todo:  Review Security on this method\n   * @param {String} cartId - cartId to transform to order\n   * @return {String} returns orderId\n   */\n  \"cart/copyCartToOrder\": function (cartId) {\n    check(cartId, String);\n    const cart = Collections.Cart.findOne(cartId);\n    // security check\n    if (cart.userId !== this.userId) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const order = Object.assign({}, cart);\n    const sessionId = cart.sessionId;\n\n    if (!order.items || order.items.length === 0) {\n      const msg = \"An error occurred saving the order. Missing cart items.\";\n      Logger.error(msg);\n      throw new Meteor.Error(\"no-cart-items\", msg);\n    }\n\n    Logger.debug(\"cart/copyCartToOrder\", cartId);\n    // reassign the id, we'll get a new orderId\n    order.cartId = cart._id;\n\n    // a helper for guest login, we let guest add email afterwords\n    // for ease, we'll also add automatically for logged in users\n    if (order.userId && !order.email) {\n      const user = Collections.Accounts.findOne(order.userId);\n      // we could have a use case here when email is not defined by some reason,\n      // we could throw an error, but it's not pretty clever, so let it go w/o\n      // email\n      if (typeof user === \"object\" && user.emails) {\n        for (const email of user.emails) {\n          // alternate order email address\n          if (email.provides === \"orders\") {\n            order.email = email.address;\n          } else if (email.provides === \"default\") {\n            order.email = email.address;\n          }\n        }\n      }\n    }\n\n    // schema should provide order defaults\n    // so we'll delete the cart autovalues\n    delete order.createdAt; // autovalues\n    delete order.updatedAt;\n    delete order.cartCount;\n    delete order.cartShipping;\n    delete order.cartSubTotal;\n    delete order.cartTaxes;\n    delete order.cartDiscounts;\n    delete order.cartTotal;\n    delete order._id;\n\n    // `order.shipping` is array ?\n    if (Array.isArray(order.shipping)) {\n      if (order.shipping.length > 0) {\n        order.shipping[0].paymentId = order.billing[0]._id;\n\n        if (!Array.isArray(order.shipping[0].items)) {\n          order.shipping[0].items = [];\n        }\n      }\n    } else { // if not - create it\n      order.shipping = [];\n    }\n\n    // Add current exchange rate into order.billing.currency\n    // If user currenct === shop currency, exchange rate = 1.0\n    const currentUser = Meteor.user();\n    let userCurrency = Reaction.getShopCurrency();\n    let exchangeRate = \"1.00\";\n\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = Meteor.user().profile.currency;\n    }\n\n    if (userCurrency !== Reaction.getShopCurrency()) {\n      const userExchangeRate = Meteor.call(\"shop/getCurrencyRates\", userCurrency);\n\n      if (typeof userExchangeRate === \"number\") {\n        exchangeRate = userExchangeRate;\n      } else {\n        Logger.warn(\"Failed to get currency exchange rates. Setting exchange rate to null.\");\n        exchangeRate = null;\n      }\n    }\n\n    if (!order.billing[0].currency) {\n      order.billing[0].currency = {\n        userCurrency: userCurrency\n      };\n    }\n\n    _.each(order.items, (item) => {\n      if (order.shipping[0].items) {\n        order.shipping[0].items.push({\n          _id: item._id,\n          productId: item.productId,\n          shopId: item.shopId,\n          variantId: item.variants._id\n        });\n      }\n    });\n\n    order.shipping[0].items.packed = false;\n    order.shipping[0].items.shipped = false;\n    order.shipping[0].items.delivered = false;\n\n    order.billing[0].currency.exchangeRate = exchangeRate;\n    order.workflow.status = \"new\";\n    order.workflow.workflow = [\"coreOrderWorkflow/created\"];\n\n    // insert new reaction order\n    const orderId = Collections.Orders.insert(order);\n\n    if (orderId) {\n      Collections.Cart.remove({\n        _id: order.cartId\n      });\n      // create a new cart for the user\n      // even though this should be caught by\n      // subscription handler, it's not always working\n      const newCartExists = Collections.Cart.find({ userId: order.userId });\n      if (newCartExists.count() === 0) {\n        Meteor.call(\"cart/createCart\", this.userId, sessionId);\n        // after recreate new cart we need to make it looks like previous by\n        // updating `cart/workflow/status` to \"coreCheckoutShipping\"\n        // by calling `workflow/pushCartWorkflow` three times. This is the only\n        // way to do that without refactoring of `workflow/pushCartWorkflow`\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutAddressBook\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n      }\n\n      Logger.info(\"Transitioned cart \" + cartId + \" to order \" + orderId);\n      // catch send notification, we don't want\n      // to block because of notification errors\n\n      if (order.email) {\n        Meteor.call(\"orders/sendNotification\", Collections.Orders.findOne(orderId), (err) => {\n          if (err) {\n            Logger.error(err, `Error in orders/sendNotification for order ${orderId}`);\n          }\n        });\n      }\n\n      // order success\n      return orderId;\n    }\n    // we should not have made it here, throw error\n    throw new Meteor.Error(400, \"cart/copyCartToOrder: Invalid request\");\n  },\n\n  /**\n   * cart/setShipmentMethod\n   * @summary saves method as order default\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} method - shipmentMethod object\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setShipmentMethod\": function (cartId, method) {\n    check(cartId, String);\n    check(method, Object);\n    // get current cart\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: Meteor.userId()\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n\n    // temp hack until we build out multiple shipping handlers\n    let selector;\n    let update;\n    // temp hack until we build out multiple shipment handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (cart.shipping) {\n      selector = {\n        \"_id\": cartId,\n        \"shipping._id\": cart.shipping[0]._id\n      };\n      update = {\n        $set: {\n          \"shipping.$.shipmentMethod\": method\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          shipping: {\n            shipmentMethod: method\n          }\n        }\n      };\n    }\n\n    // update or insert method\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e, `Error adding rates to cart ${cartId}`);\n      throw new Meteor.Error(\"An error occurred saving the order\", e);\n    }\n\n    // this will transition to review\n    return Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n      \"coreCheckoutShipping\");\n  },\n\n  /**\n   * cart/setUserCurrency\n   * @summary saves user currency in cart, to be paired with order/setCurrencyExhange\n   * @param {String} cartId - cartId to apply setUserCurrency\n   * @param {String} userCurrency - userCurrency to set to cart\n   * @return {Number} update result\n   */\n  \"cart/setUserCurrency\": function (cartId, userCurrency) {\n    check(cartId, String);\n    check(userCurrency, String);\n    const cart = Collections.Cart.findOne({\n      _id: cartId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(\"Cart not found for user with such id\");\n    }\n\n    const userCurrencyString = {\n      userCurrency: userCurrency\n    };\n\n    let selector;\n    let update;\n\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.currency\": userCurrencyString\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            currency: userCurrencyString\n          }\n        }\n      };\n    }\n\n    // add / or set the shipping address\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred adding the currency\");\n    }\n\n    return true;\n  },\n\n  /**\n   * cart/resetShipmentMethod\n   * @summary removes `shipmentMethod` object from cart\n   * @param {String} cartId - cart _id\n   * @return {Number} update result\n   */\n  \"cart/resetShipmentMethod\": function (cartId) {\n    check(cartId, String);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        `Cart: ${cartId} not found for user: ${this.userId}`);\n    }\n\n    return Collections.Cart.update({ _id: cartId }, {\n      $unset: { \"shipping.0.shipmentMethod\": \"\" }\n    });\n  },\n\n  /**\n   * cart/setShipmentAddress\n   * @summary adds address book to cart shipping\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} address - addressBook object\n   * @return {Number} update result\n   */\n  \"cart/setShipmentAddress\": function (cartId, address) {\n    check(cartId, String);\n    check(address, Reaction.Schemas.Address);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple shipment handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (Array.isArray(cart.shipping) && cart.shipping.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"shipping._id\": cart.shipping[0]._id\n      };\n      update = {\n        $set: {\n          \"shipping.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          shipping: {\n            address: address\n          }\n        }\n      };\n    }\n\n    // add / or set the shipping address\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred adding the address\");\n    }\n\n    // refresh shipping quotes\n    Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n\n    if (typeof cart.workflow !== \"object\") {\n      throw new Meteor.Error(500, \"Internal Server Error\",\n        \"Cart workflow object not detected.\");\n    }\n\n    // ~~it's ok for this to be called multiple times~~\n    // call it only once when we at the `checkoutAddressBook` step\n    if (typeof cart.workflow.workflow === \"object\" &&\n      cart.workflow.workflow.length < 2) {\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"coreCheckoutShipping\");\n    }\n\n    // if we change default address during further steps, we need to revert\n    // workflow back to `coreCheckoutShipping` step\n    if (typeof cart.workflow.workflow === \"object\" &&\n      cart.workflow.workflow.length > 2) { // \"2\" index of\n      // `coreCheckoutShipping`\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    }\n\n    return true;\n  },\n\n  /**\n   * cart/setPaymentAddress\n   * @summary adds addressbook to cart payments\n   * @param {String} cartId - cartId to apply payment address\n   * @param {Object} address - addressBook object\n   * @todo maybe we need to rename this method to `cart/setBillingAddress`?\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setPaymentAddress\": function (cartId, address) {\n    check(cartId, String);\n    check(address, Reaction.Schemas.Address);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (Array.isArray(cart.billing) && cart.billing.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            address: address\n          }\n        }\n      };\n    }\n\n    return Collections.Cart.update(selector, update);\n  },\n\n  /**\n   * cart/unsetAddresses\n   * @description removes address from cart.\n   * @param {String} addressId - address._id\n   * @param {String} userId - cart owner _id\n   * @param {String} [type] - billing default or shipping default\n   * @since 0.10.1\n   * @todo check if no more address in cart as shipping, we should reset\n   * `cartWorkflow` to second step\n   * @return {Number|Object|Boolean} The number of removed documents or error\n   * object or `false` if we don't need to update cart\n   */\n  \"cart/unsetAddresses\": function (addressId, userId, type) {\n    check(addressId, String);\n    check(userId, String);\n    check(type, Match.Optional(String));\n\n    // do we actually need to change anything?\n    let needToUpdate = false;\n    // we need to revert the workflow after a \"shipping\" address was removed\n    let isShippingDeleting = false;\n    const cart = Collections.Cart.findOne({\n      userId: userId\n    });\n    const selector = {\n      _id: cart._id\n    };\n    const update = { $unset: {} };\n    // user could turn off the checkbox in address to not to be default, then we\n    // receive `type` arg\n    if (typeof type === \"string\") {\n      // we assume that the billing/shipping arrays can hold only one element [0]\n      if (cart[type] && typeof cart[type][0].address === \"object\" &&\n        cart[type][0].address._id === addressId) {\n        update.$unset[`${type}.0.address`] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = type === \"shipping\";\n      }\n    } else { // or if we remove address itself, when we run this part we assume\n      // that the billing/shipping arrays can hold only one element [0]\n      if (cart.billing && typeof cart.billing[0].address === \"object\" &&\n        cart.billing[0].address._id === addressId) {\n        update.$unset[\"billing.0.address\"] = \"\";\n        needToUpdate = true;\n      }\n      if (cart.shipping && typeof cart.shipping[0].address === \"object\" &&\n        cart.shipping[0].address._id === addressId) {\n        update.$unset[\"shipping.0.address\"] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = true;\n      }\n    }\n\n    if (needToUpdate) {\n      try {\n        Collections.Cart.update(selector, update);\n      } catch (e) {\n        Logger.error(e);\n        throw new Meteor.Error(\"Error updating cart\");\n      }\n\n      if (isShippingDeleting) {\n        // if we remove shipping address from cart, we need to revert\n        // `cartWorkflow` to the `checkoutAddressBook` step.\n        Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n      }\n    }\n    return true;\n  },\n\n  /**\n   * cart/submitPayment\n   * @summary saves a submitted payment to cart, triggers workflow\n   * and adds \"paymentSubmitted\" to cart workflow\n   * Note: this method also has a client stub, that forwards to cartCompleted\n   * @param {Object} paymentMethod - paymentMethod object\n   * directly within this method, just throw down though hooks\n   * @return {String} returns update result\n   */\n  \"cart/submitPayment\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n\n    const checkoutCart = Collections.Cart.findOne({\n      userId: Meteor.userId()\n    });\n\n    const cart = _.clone(checkoutCart);\n    const cartId = cart._id;\n    const invoice = {\n      shipping: cart.cartShipping(),\n      subtotal: cart.cartSubTotal(),\n      taxes: cart.cartTaxes(),\n      discounts: cart.cartDiscounts(),\n      total: cart.cartTotal()\n    };\n\n    // we won't actually close the order at this stage.\n    // we'll just update the workflow and billing data where\n    // method-hooks can process the workflow update.\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.paymentMethod\": paymentMethod,\n          \"billing.$.invoice\": invoice\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          \"billing.paymentMethod\": paymentMethod,\n          \"billing.invoice\": invoice\n        }\n      };\n    }\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred saving the order\");\n    }\n\n    return Collections.Cart.findOne(selector);\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/methods/core/cart.js.map","sourceFileName":"/server/methods/core/cart.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cart"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _clone = void 0;\n\nmodule.importSync(\"lodash/clone\", {\n  \"default\": function (v) {\n    _clone = v;\n  }\n}, 0);\n\nvar _each = void 0;\n\nmodule.importSync(\"lodash/each\", {\n  \"default\": function (v) {\n    _each = v;\n  }\n}, 1);\n\nvar _find = void 0;\n\nmodule.importSync(\"lodash/find\", {\n  \"default\": function (v) {\n    _find = v;\n  }\n}, 2);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 3);\nvar check = void 0;\nmodule.importSync(\"meteor/check\", {\n  check: function (v) {\n    check = v;\n  }\n}, 4);\nvar Collections = Object.create(null);\nmodule.importSync(\"/lib/collections\", {\n  \"*\": function (v, n) {\n    Collections[n] = v;\n  }\n}, 5);\nvar Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 6);\n\n/**\n * quantityProcessing\n * @summary perform calculations admissibility of adding product to cart\n * @param {Object} product - product to add to Cart\n * @param {Object} variant - product variant\n * @param {Number} itemQty - qty to add to cart, defaults to 1, deducts\n *  from inventory\n * @since 1.10.1\n * @return {Number} quantity - revised quantity to be added to cart\n */function quantityProcessing(product, variant) {\n  var itemQty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var quantity = itemQty;\n  var MIN = variant.minOrderQuantity || 1;\n  var MAX = variant.inventoryQuantity || Infinity;\n\n  if (MIN > MAX) {\n    Logger.debug(\"productId: \" + product._id + \", variantId \" + variant._id + \": inventoryQuantity lower then minimum order\");\n    throw new Meteor.Error(\"productId: \" + product._id + \", variantId \" + variant._id + \": inventoryQuantity lower then minimum order\");\n  } // TODO: think about #152 implementation here\n\n\n  switch (product.type) {\n    case \"not-in-stock\":\n      break;\n\n    default:\n      // type: `simple` // todo: maybe it should be \"variant\"\n      if (quantity < MIN) {\n        quantity = MIN;\n      } else if (variant.inventoryPolicy && quantity > MAX) {\n        quantity = MAX;\n      }\n\n  }\n\n  return quantity;\n} /**\n   * getSessionCarts\n   * @summary get Cart cursor with all session carts\n   * @param {String} userId - current user _id\n   * @param {String} sessionId - current user session id\n   * @param {String} shopId - shop id\n   * @since 0.10.2\n   * @return {Mongo.Cursor} with array of session carts\n   */\n\nfunction getSessionCarts(userId, sessionId, shopId) {\n  var carts = Collections.Cart.find({\n    $and: [{\n      userId: {\n        $ne: userId\n      }\n    }, {\n      sessionId: {\n        $eq: sessionId\n      }\n    }, {\n      shopId: {\n        $eq: shopId\n      }\n    }]\n  }); // we can't use Array.map here, because we need to reduce the number of array\n  // elements if element belongs to registered user, we should throw it.\n\n  var allowedCarts = []; // only anonymous user carts allowed\n\n  carts.forEach(function (cart) {\n    if (Roles.userIsInRole(cart.userId, \"anonymous\", shopId)) {\n      allowedCarts.push(cart);\n    }\n  });\n  return allowedCarts;\n} /**\n   * Reaction Cart Methods\n   */\n\nMeteor.methods({\n  /**\n   * cart/mergeCart\n   * @summary merge matching sessionId cart into specified userId cart\n   *\n   * There should be one cart for each independent, non logged in user session\n   * When a user logs in that cart now belongs to that user and we use the a\n   * single user cart.\n   * If they are logged in on more than one devices, regardless of session,the\n   * user cart will be used\n   * If they had more than one cart, on more than one device,logged in at\n   * separate times then merge the carts\n   *\n   * @param {String} cartId - cartId of the cart to merge matching session\n   * carts into.\n   * @param {String} [currentSessionId] - current client session id\n   * @todo I think this method should be moved out from methods to a Function\n   * Declaration to keep it more secure\n   * @return {Object|Boolean} cartId - cartId on success or false\n   */\"cart/mergeCart\": function (cartId, currentSessionId) {\n    var _this = this;\n\n    check(cartId, String);\n    check(currentSessionId, Match.Optional(String)); // we don't process current cart, but merge into it.\n\n    var currentCart = Collections.Cart.findOne(cartId);\n\n    if (!currentCart) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    } // just used to filter out the current cart\n    // we do additional check of cart exists here and if it not exist, next\n    // check supposed to throw 403 error\n\n\n    var userId = currentCart && currentCart.userId; // user should have an access to operate with only one - his - cart\n\n    if (this.userId !== null && userId !== this.userId) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    } // persistent sessions, see: publications/sessions.js\n    // this is the last place where we still need `Reaction.sessionId`.\n    // The use case is: on user log in. I don't know how pass `sessionId` down\n    // at that moment.\n\n\n    var sessionId = currentSessionId || Reaction.sessionId;\n    var shopId = Reaction.getShopId(); // no need to merge anonymous carts\n\n    if (Roles.userIsInRole(userId, \"anonymous\", shopId)) {\n      return false;\n    }\n\n    Logger.debug(\"merge cart: matching sessionId\");\n    Logger.debug(\"current userId:\", userId);\n    Logger.debug(\"sessionId:\", sessionId); // get session carts without current user cart cursor\n\n    var sessionCarts = getSessionCarts(userId, sessionId, shopId);\n    Logger.debug(\"merge cart: begin merge processing of session \" + sessionId + \" into: \" + currentCart._id); // loop through session carts and merge into user cart\n\n    sessionCarts.forEach(function (sessionCart) {\n      Logger.debug(\"merge cart: merge user userId: \" + userId + \", sessionCart.userId: \" + sessionCart.userId + \", sessionCart id: \" + sessionCart._id); // really if we have no items, there's nothing to merge\n\n      if (sessionCart.items) {\n        // if currentCart already have a cartWorkflow, we don't need to clean it\n        // up completely, just to `coreCheckoutShipping` stage. Also, we will\n        // need to recalculate shipping rates\n        if ((0, _typeof3.default)(currentCart.workflow) === \"object\" && (0, _typeof3.default)(currentCart.workflow.workflow) === \"object\") {\n          if (currentCart.workflow.workflow.length > 2) {\n            Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\"); // refresh shipping quotes\n\n            Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n          }\n        } else {\n          // if user logged in he doesn't need to show `checkoutLogin` step\n          Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n        } // We got an additional db call because of `workflow/revertCartWorkflow`\n        // call, but we also got things more cleaner in my opinion.\n        // merge session cart into current cart\n\n\n        Collections.Cart.update(currentCart._id, {\n          $addToSet: {\n            items: {\n              $each: sessionCart.items\n            }\n          }\n        });\n      } // cleanup session Carts after merge.\n\n\n      if (sessionCart.userId !== _this.userId) {\n        // clear the cart that was used for a session\n        // and we're also going to do some garbage Collection\n        Collections.Cart.remove(sessionCart._id); // cleanup user/accounts\n\n        Collections.Accounts.remove({\n          userId: sessionCart.userId\n        });\n        Meteor.users.remove(sessionCart.userId);\n        Logger.debug(\"merge cart: delete cart \" + sessionCart._id + \" and user: \" + sessionCart.userId);\n      }\n\n      Logger.debug(\"merge cart: processed merge for cartId \" + sessionCart._id);\n    }); // `checkoutLogin` should be used for anonymous only. Registered users\n    // no need see this.\n\n    if (currentCart.workflow.status === \"new\") {\n      // to call `workflow/pushCartWorkflow` two times is the only way to move\n      // from status \"new\" to \"checkoutAddressBook\" which I found without\n      // refactoring of `workflow/pushCartWorkflow`\n      // We send `cartId` as arguments because this method could be called from\n      // publication method and in half cases it could be so, that\n      // Meteor.userId() will be null.\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\", cartId);\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutAddressBook\", cartId);\n    }\n\n    return currentCart._id;\n  },\n  /**\n   * cart/createCart\n   * @description create new cart for user, but all checks for current cart's\n   * existence should go before this method will be called, to keep it clean\n   * @summary create and return new cart for user\n   * @param {String} userId - userId to create cart for\n   * @param {String} sessionId - current client session id\n   * @todo I think this method should be moved out from methods to a Function\n   * Declaration to keep it more secure\n   * @returns {String} cartId - users cartId\n   */\"cart/createCart\": function (userId, sessionId) {\n    check(userId, String);\n    check(sessionId, String);\n    var shopId = Reaction.getShopId(); // check if user has `anonymous` role.( this is a visitor)\n\n    var anonymousUser = Roles.userIsInRole(userId, \"anonymous\", shopId);\n    var sessionCartCount = getSessionCarts(userId, sessionId, shopId).length;\n    Logger.debug(\"create cart: shopId\", shopId);\n    Logger.debug(\"create cart: userId\", userId);\n    Logger.debug(\"create cart: sessionId\", sessionId);\n    Logger.debug(\"create cart: sessionCarts.count\", sessionCartCount);\n    Logger.debug(\"create cart: anonymousUser\", anonymousUser); // we need to create a user cart for the new authenticated user or\n    // anonymous.\n\n    var currentCartId = Collections.Cart.insert({\n      sessionId: sessionId,\n      userId: userId\n    });\n    Logger.debug(\"create cart: into new user cart. created: \" + currentCartId + \" for user \" + userId); // merge session carts into the current cart\n\n    if (sessionCartCount > 0 && !anonymousUser) {\n      Logger.debug(\"create cart: found existing cart. merge into \" + currentCartId + \" for user \" + userId);\n      Meteor.call(\"cart/mergeCart\", currentCartId, sessionId);\n    } // we should check for an default billing/shipping address in user account.\n    // this needed after submitting order, when user receives new cart\n\n\n    var account = Collections.Accounts.findOne(userId);\n\n    if (account && account.profile && account.profile.addressBook) {\n      account.profile.addressBook.forEach(function (address) {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", currentCartId, address);\n        }\n\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", currentCartId, address);\n        }\n      });\n    } // attach current user currency to cart\n\n\n    var currentUser = Meteor.user();\n    var userCurrency = Reaction.getShopCurrency(); // Check to see if the user has a custom currency saved to their profile\n    // Use it if they do\n\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = currentUser.profile.currency;\n    }\n\n    Meteor.call(\"cart/setUserCurrency\", currentCartId, userCurrency);\n    return currentCartId;\n  },\n  /**\n   *  cart/addToCart\n   *  @summary add items to a user cart\n   *  when we add an item to the cart, we want to break all relationships\n   *  with the existing item. We want to fix price, qty, etc into history\n   *  however, we could check reactively for price /qty etc, adjustments on\n   *  the original and notify them\n   *  @param {String} productId - productId to add to Cart\n   *  @param {String} variantId - product variant _id\n   *  @param {Number} [itemQty] - qty to add to cart\n   *  @return {Number|Object} Mongo insert response\n   */\"cart/addToCart\": function (productId, variantId, itemQty) {\n    check(productId, String);\n    check(variantId, String);\n    check(itemQty, Match.Optional(Number));\n    var cart = Collections.Cart.findOne({\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(\"Cart not found for user: \" + this.userId);\n      throw new Meteor.Error(404, \"Cart not found\", \"Cart not found for user with such id\");\n    } // With the flattened model we no longer need to work directly with the\n    // products. But product still could be necessary for a `quantityProcessing`\n    // TODO: need to understand: do we really need product inside\n    // `quantityProcessing`?\n\n\n    var product = void 0;\n    var variant = void 0;\n    Collections.Products.find({\n      _id: {\n        $in: [productId, variantId]\n      }\n    }).forEach(function (doc) {\n      if (doc.type === \"simple\") {\n        product = doc;\n      } else {\n        variant = doc;\n      }\n    }); // TODO: this lines still needed. We could uncomment them in future if\n    // decide to not completely remove product data from this method\n    // const product = Collections.Products.findOne(productId);\n    // const variant = Collections.Products.findOne(variantId);\n\n    if (!product) {\n      Logger.warn(\"Product: \" + productId + \" was not found in database\");\n      throw new Meteor.Error(404, \"Product not found\", \"Product with such id was not found!\");\n    }\n\n    if (!variant) {\n      Logger.warn(\"Product variant: \" + variantId + \" was not found in database\");\n      throw new Meteor.Error(404, \"ProductVariant not found\", \"ProductVariant with such id was not found!\");\n    } // performs calculations admissibility of adding product to cart\n\n\n    var quantity = quantityProcessing(product, variant, itemQty); // performs search of variant inside cart\n\n    var cartVariantExists = cart.items && cart.items.some(function (item) {\n      return item.variants._id === variantId;\n    });\n\n    if (cartVariantExists) {\n      return Collections.Cart.update({\n        \"_id\": cart._id,\n        \"items.variants._id\": variantId\n      }, {\n        $inc: {\n          \"items.$.quantity\": quantity\n        }\n      }, function (error, result) {\n        if (error) {\n          Logger.warn(\"error adding to cart\", Collections.Cart.simpleSchema().namedContext().invalidKeys());\n          return error;\n        } // refresh shipping quotes\n\n\n        Meteor.call(\"shipping/updateShipmentQuotes\", cart._id); // revert workflow to checkout shipping step.\n\n        Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\"); // reset selected shipment method\n\n        Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n        Logger.debug(\"cart: increment variant \" + variantId + \" quantity by \" + quantity);\n        return result;\n      });\n    } // cart variant doesn't exist\n\n\n    return Collections.Cart.update({\n      _id: cart._id\n    }, {\n      $addToSet: {\n        items: {\n          _id: Random.id(),\n          shopId: product.shopId,\n          productId: productId,\n          quantity: quantity,\n          variants: variant,\n          title: product.title,\n          type: product.type,\n          parcel: product.parcel || null\n        }\n      }\n    }, function (error, result) {\n      if (error) {\n        Logger.error(error);\n        Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(), \"Invalid keys. Error adding to cart.\");\n        return error;\n      } // refresh shipping quotes\n\n\n      Meteor.call(\"shipping/updateShipmentQuotes\", cart._id); // revert workflow to checkout shipping step.\n\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\"); // reset selected shipment method\n\n      Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n      Logger.debug(\"cart: add variant \" + variantId + \" to cartId \" + cart._id);\n      return result;\n    });\n  },\n  /**\n   * cart/removeFromCart\n   * @summary removes or adjust quantity of a variant from the cart\n   * @param {String} itemId - cart item _id\n   * @param {Number} [quantity] - if provided will adjust increment by quantity\n   * @returns {Number} returns Mongo update result\n   */\"cart/removeFromCart\": function (itemId, quantity) {\n    check(itemId, String);\n    check(quantity, Match.Optional(Number));\n    var userId = Meteor.userId();\n    var cart = Collections.Cart.findOne({\n      userId: userId\n    });\n\n    if (!cart) {\n      Logger.error(\"Cart not found for user: \" + this.userId);\n      throw new Meteor.Error(\"cart-not-found\", \"Cart not found for user with such id\");\n    }\n\n    var cartItem = void 0;\n\n    if (cart.items) {\n      cartItem = _find(cart.items, function (item) {\n        return item._id === itemId;\n      });\n    } // extra check of item exists\n\n\n    if ((typeof cartItem === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(cartItem)) !== \"object\") {\n      Logger.error(\"Unable to find an item: \" + itemId + \" within the cart: \" + cart._id);\n      throw new Meteor.Error(\"cart-item-not-found\", \"Unable to find an item with such id in cart.\");\n    } // refresh shipping quotes\n\n\n    Meteor.call(\"shipping/updateShipmentQuotes\", cart._id); // revert workflow to checkout shipping step.\n\n    Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\"); // reset selected shipment method\n\n    Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n    if (!quantity || quantity >= cartItem.quantity) {\n      return Collections.Cart.update({\n        _id: cart._id\n      }, {\n        $pull: {\n          items: {\n            _id: itemId\n          }\n        }\n      }, function (error, result) {\n        if (error) {\n          Logger.error(error);\n          Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(), \"error removing from cart\");\n          return error;\n        }\n\n        Logger.debug(\"cart: deleted cart item variant id \" + cartItem.variants._id);\n        return result;\n      });\n    } // if quantity lets convert to negative and increment\n\n\n    var removeQuantity = Math.abs(quantity) * -1;\n    return Collections.Cart.update({\n      \"_id\": cart._id,\n      \"items._id\": cartItem._id\n    }, {\n      $inc: {\n        \"items.$.quantity\": removeQuantity\n      }\n    }, function (error, result) {\n      if (error) {\n        Logger.error(error);\n        Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(), \"error removing from cart\");\n        return error;\n      }\n\n      Logger.debug(\"cart: removed variant \" + cartItem._id + \" quantity of \" + quantity);\n      return result;\n    });\n  },\n  /**\n   * cart/copyCartToOrder\n   * @summary transform cart to order when a payment is processed we want to\n   * copy the cart over to an order object, and give the user a new empty\n   * cart. reusing the cart schema makes sense, but integrity of the order, we\n   * don't want to just make another cart item\n   * @todo:  Partial order processing, shopId processing\n   * @todo:  Review Security on this method\n   * @param {String} cartId - cartId to transform to order\n   * @return {String} returns orderId\n   */\"cart/copyCartToOrder\": function (cartId) {\n    check(cartId, String);\n    var cart = Collections.Cart.findOne(cartId); // security check\n\n    if (cart.userId !== this.userId) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    var order = Object.assign({}, cart);\n    var sessionId = cart.sessionId;\n\n    if (!order.items || order.items.length === 0) {\n      var msg = \"An error occurred saving the order. Missing cart items.\";\n      Logger.error(msg);\n      throw new Meteor.Error(\"no-cart-items\", msg);\n    }\n\n    Logger.debug(\"cart/copyCartToOrder\", cartId); // reassign the id, we'll get a new orderId\n\n    order.cartId = cart._id; // a helper for guest login, we let guest add email afterwords\n    // for ease, we'll also add automatically for logged in users\n\n    if (order.userId && !order.email) {\n      var user = Collections.Accounts.findOne(order.userId); // we could have a use case here when email is not defined by some reason,\n      // we could throw an error, but it's not pretty clever, so let it go w/o\n      // email\n\n      if ((typeof user === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(user)) === \"object\" && user.emails) {\n        for (var _iterator = user.emails, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var email = _ref;\n\n          // alternate order email address\n          if (email.provides === \"orders\") {\n            order.email = email.address;\n          } else if (email.provides === \"default\") {\n            order.email = email.address;\n          }\n        }\n      }\n    } // schema should provide order defaults\n    // so we'll delete the cart autovalues\n\n\n    delete order.createdAt; // autovalues\n\n    delete order.updatedAt;\n    delete order.cartCount;\n    delete order.cartShipping;\n    delete order.cartSubTotal;\n    delete order.cartTaxes;\n    delete order.cartDiscounts;\n    delete order.cartTotal;\n    delete order._id; // `order.shipping` is array ?\n\n    if (Array.isArray(order.shipping)) {\n      if (order.shipping.length > 0) {\n        order.shipping[0].paymentId = order.billing[0]._id;\n\n        if (!Array.isArray(order.shipping[0].items)) {\n          order.shipping[0].items = [];\n        }\n      }\n    } else {\n      // if not - create it\n      order.shipping = [];\n    } // Add current exchange rate into order.billing.currency\n    // If user currenct === shop currency, exchange rate = 1.0\n\n\n    var currentUser = Meteor.user();\n    var userCurrency = Reaction.getShopCurrency();\n    var exchangeRate = \"1.00\";\n\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = Meteor.user().profile.currency;\n    }\n\n    if (userCurrency !== Reaction.getShopCurrency()) {\n      var userExchangeRate = Meteor.call(\"shop/getCurrencyRates\", userCurrency);\n\n      if (typeof userExchangeRate === \"number\") {\n        exchangeRate = userExchangeRate;\n      } else {\n        Logger.warn(\"Failed to get currency exchange rates. Setting exchange rate to null.\");\n        exchangeRate = null;\n      }\n    }\n\n    if (!order.billing[0].currency) {\n      order.billing[0].currency = {\n        userCurrency: userCurrency\n      };\n    }\n\n    _each(order.items, function (item) {\n      if (order.shipping[0].items) {\n        order.shipping[0].items.push({\n          _id: item._id,\n          productId: item.productId,\n          shopId: item.shopId,\n          variantId: item.variants._id\n        });\n      }\n    });\n\n    order.shipping[0].items.packed = false;\n    order.shipping[0].items.shipped = false;\n    order.shipping[0].items.delivered = false;\n    order.billing[0].currency.exchangeRate = exchangeRate;\n    order.workflow.status = \"new\";\n    order.workflow.workflow = [\"coreOrderWorkflow/created\"]; // insert new reaction order\n\n    var orderId = Collections.Orders.insert(order);\n\n    if (orderId) {\n      Collections.Cart.remove({\n        _id: order.cartId\n      }); // create a new cart for the user\n      // even though this should be caught by\n      // subscription handler, it's not always working\n\n      var newCartExists = Collections.Cart.find({\n        userId: order.userId\n      });\n\n      if (newCartExists.count() === 0) {\n        Meteor.call(\"cart/createCart\", this.userId, sessionId); // after recreate new cart we need to make it looks like previous by\n        // updating `cart/workflow/status` to \"coreCheckoutShipping\"\n        // by calling `workflow/pushCartWorkflow` three times. This is the only\n        // way to do that without refactoring of `workflow/pushCartWorkflow`\n\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutAddressBook\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n      }\n\n      Logger.info(\"Transitioned cart \" + cartId + \" to order \" + orderId); // catch send notification, we don't want\n      // to block because of notification errors\n\n      if (order.email) {\n        Meteor.call(\"orders/sendNotification\", Collections.Orders.findOne(orderId), function (err) {\n          if (err) {\n            Logger.error(err, \"Error in orders/sendNotification for order \" + orderId);\n          }\n        });\n      } // order success\n\n\n      return orderId;\n    } // we should not have made it here, throw error\n\n\n    throw new Meteor.Error(400, \"cart/copyCartToOrder: Invalid request\");\n  },\n  /**\n   * cart/setShipmentMethod\n   * @summary saves method as order default\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} method - shipmentMethod object\n   * @return {Number} return Mongo update result\n   */\"cart/setShipmentMethod\": function (cartId, method) {\n    check(cartId, String);\n    check(method, Object); // get current cart\n\n    var cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: Meteor.userId()\n    });\n\n    if (!cart) {\n      Logger.error(\"Cart not found for user: \" + this.userId);\n      throw new Meteor.Error(404, \"Cart not found\", \"Cart not found for user with such id\");\n    } // temp hack until we build out multiple shipping handlers\n\n\n    var selector = void 0;\n    var update = void 0; // temp hack until we build out multiple shipment handlers\n    // if we have an existing item update it, otherwise add to set.\n\n    if (cart.shipping) {\n      selector = {\n        \"_id\": cartId,\n        \"shipping._id\": cart.shipping[0]._id\n      };\n      update = {\n        $set: {\n          \"shipping.$.shipmentMethod\": method\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          shipping: {\n            shipmentMethod: method\n          }\n        }\n      };\n    } // update or insert method\n\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e, \"Error adding rates to cart \" + cartId);\n      throw new Meteor.Error(\"An error occurred saving the order\", e);\n    } // this will transition to review\n\n\n    return Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n  },\n  /**\n   * cart/setUserCurrency\n   * @summary saves user currency in cart, to be paired with order/setCurrencyExhange\n   * @param {String} cartId - cartId to apply setUserCurrency\n   * @param {String} userCurrency - userCurrency to set to cart\n   * @return {Number} update result\n   */\"cart/setUserCurrency\": function (cartId, userCurrency) {\n    check(cartId, String);\n    check(userCurrency, String);\n    var cart = Collections.Cart.findOne({\n      _id: cartId\n    });\n\n    if (!cart) {\n      Logger.error(\"Cart not found for user: \" + this.userId);\n      throw new Meteor.Error(\"Cart not found for user with such id\");\n    }\n\n    var userCurrencyString = {\n      userCurrency: userCurrency\n    };\n    var selector = void 0;\n    var update = void 0;\n\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.currency\": userCurrencyString\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            currency: userCurrencyString\n          }\n        }\n      };\n    } // add / or set the shipping address\n\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred adding the currency\");\n    }\n\n    return true;\n  },\n  /**\n   * cart/resetShipmentMethod\n   * @summary removes `shipmentMethod` object from cart\n   * @param {String} cartId - cart _id\n   * @return {Number} update result\n   */\"cart/resetShipmentMethod\": function (cartId) {\n    check(cartId, String);\n    var cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(\"Cart not found for user: \" + this.userId);\n      throw new Meteor.Error(404, \"Cart not found\", \"Cart: \" + cartId + \" not found for user: \" + this.userId);\n    }\n\n    return Collections.Cart.update({\n      _id: cartId\n    }, {\n      $unset: {\n        \"shipping.0.shipmentMethod\": \"\"\n      }\n    });\n  },\n  /**\n   * cart/setShipmentAddress\n   * @summary adds address book to cart shipping\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} address - addressBook object\n   * @return {Number} update result\n   */\"cart/setShipmentAddress\": function (cartId, address) {\n    check(cartId, String);\n    check(address, Reaction.Schemas.Address);\n    var cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(\"Cart not found for user: \" + this.userId);\n      throw new Meteor.Error(404, \"Cart not found\", \"Cart not found for user with such id\");\n    }\n\n    var selector = void 0;\n    var update = void 0; // temp hack until we build out multiple shipment handlers\n    // if we have an existing item update it, otherwise add to set.\n\n    if (Array.isArray(cart.shipping) && cart.shipping.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"shipping._id\": cart.shipping[0]._id\n      };\n      update = {\n        $set: {\n          \"shipping.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          shipping: {\n            address: address\n          }\n        }\n      };\n    } // add / or set the shipping address\n\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred adding the address\");\n    } // refresh shipping quotes\n\n\n    Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n\n    if ((0, _typeof3.default)(cart.workflow) !== \"object\") {\n      throw new Meteor.Error(500, \"Internal Server Error\", \"Cart workflow object not detected.\");\n    } // ~~it's ok for this to be called multiple times~~\n    // call it only once when we at the `checkoutAddressBook` step\n\n\n    if ((0, _typeof3.default)(cart.workflow.workflow) === \"object\" && cart.workflow.workflow.length < 2) {\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n    } // if we change default address during further steps, we need to revert\n    // workflow back to `coreCheckoutShipping` step\n\n\n    if ((0, _typeof3.default)(cart.workflow.workflow) === \"object\" && cart.workflow.workflow.length > 2) {\n      // \"2\" index of\n      // `coreCheckoutShipping`\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    }\n\n    return true;\n  },\n  /**\n   * cart/setPaymentAddress\n   * @summary adds addressbook to cart payments\n   * @param {String} cartId - cartId to apply payment address\n   * @param {Object} address - addressBook object\n   * @todo maybe we need to rename this method to `cart/setBillingAddress`?\n   * @return {Number} return Mongo update result\n   */\"cart/setPaymentAddress\": function (cartId, address) {\n    check(cartId, String);\n    check(address, Reaction.Schemas.Address);\n    var cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(\"Cart not found for user: \" + this.userId);\n      throw new Meteor.Error(404, \"Cart not found\", \"Cart not found for user with such id\");\n    }\n\n    var selector = void 0;\n    var update = void 0; // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n\n    if (Array.isArray(cart.billing) && cart.billing.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            address: address\n          }\n        }\n      };\n    }\n\n    return Collections.Cart.update(selector, update);\n  },\n  /**\n   * cart/unsetAddresses\n   * @description removes address from cart.\n   * @param {String} addressId - address._id\n   * @param {String} userId - cart owner _id\n   * @param {String} [type] - billing default or shipping default\n   * @since 0.10.1\n   * @todo check if no more address in cart as shipping, we should reset\n   * `cartWorkflow` to second step\n   * @return {Number|Object|Boolean} The number of removed documents or error\n   * object or `false` if we don't need to update cart\n   */\"cart/unsetAddresses\": function (addressId, userId, type) {\n    check(addressId, String);\n    check(userId, String);\n    check(type, Match.Optional(String)); // do we actually need to change anything?\n\n    var needToUpdate = false; // we need to revert the workflow after a \"shipping\" address was removed\n\n    var isShippingDeleting = false;\n    var cart = Collections.Cart.findOne({\n      userId: userId\n    });\n    var selector = {\n      _id: cart._id\n    };\n    var update = {\n      $unset: {}\n    }; // user could turn off the checkbox in address to not to be default, then we\n    // receive `type` arg\n\n    if (typeof type === \"string\") {\n      // we assume that the billing/shipping arrays can hold only one element [0]\n      if (cart[type] && (0, _typeof3.default)(cart[type][0].address) === \"object\" && cart[type][0].address._id === addressId) {\n        update.$unset[type + \".0.address\"] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = type === \"shipping\";\n      }\n    } else {\n      // or if we remove address itself, when we run this part we assume\n      // that the billing/shipping arrays can hold only one element [0]\n      if (cart.billing && (0, _typeof3.default)(cart.billing[0].address) === \"object\" && cart.billing[0].address._id === addressId) {\n        update.$unset[\"billing.0.address\"] = \"\";\n        needToUpdate = true;\n      }\n\n      if (cart.shipping && (0, _typeof3.default)(cart.shipping[0].address) === \"object\" && cart.shipping[0].address._id === addressId) {\n        update.$unset[\"shipping.0.address\"] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = true;\n      }\n    }\n\n    if (needToUpdate) {\n      try {\n        Collections.Cart.update(selector, update);\n      } catch (e) {\n        Logger.error(e);\n        throw new Meteor.Error(\"Error updating cart\");\n      }\n\n      if (isShippingDeleting) {\n        // if we remove shipping address from cart, we need to revert\n        // `cartWorkflow` to the `checkoutAddressBook` step.\n        Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n      }\n    }\n\n    return true;\n  },\n  /**\n   * cart/submitPayment\n   * @summary saves a submitted payment to cart, triggers workflow\n   * and adds \"paymentSubmitted\" to cart workflow\n   * Note: this method also has a client stub, that forwards to cartCompleted\n   * @param {Object} paymentMethod - paymentMethod object\n   * directly within this method, just throw down though hooks\n   * @return {String} returns update result\n   */\"cart/submitPayment\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    var checkoutCart = Collections.Cart.findOne({\n      userId: Meteor.userId()\n    });\n\n    var cart = _clone(checkoutCart);\n\n    var cartId = cart._id;\n    var invoice = {\n      shipping: cart.cartShipping(),\n      subtotal: cart.cartSubTotal(),\n      taxes: cart.cartTaxes(),\n      discounts: cart.cartDiscounts(),\n      total: cart.cartTotal()\n    }; // we won't actually close the order at this stage.\n    // we'll just update the workflow and billing data where\n    // method-hooks can process the workflow update.\n\n    var selector = void 0;\n    var update = void 0; // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.paymentMethod\": paymentMethod,\n          \"billing.$.invoice\": invoice\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          \"billing.paymentMethod\": paymentMethod,\n          \"billing.invoice\": invoice\n        }\n      };\n    }\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred saving the order\");\n    }\n\n    return Collections.Cart.findOne(selector);\n  }\n});","map":{"version":3,"sources":["/server/methods/core/cart.js"],"names":["Meteor","check","Collections","Logger","Reaction","quantityProcessing","product","variant","itemQty","quantity","MIN","minOrderQuantity","MAX","inventoryQuantity","Infinity","debug","_id","Error","type","inventoryPolicy","getSessionCarts","userId","sessionId","shopId","carts","Cart","find","$and","$ne","$eq","allowedCarts","forEach","cart","Roles","userIsInRole","push","methods","cartId","currentSessionId","String","Match","Optional","currentCart","findOne","getShopId","sessionCarts","sessionCart","items","workflow","length","call","update","$addToSet","$each","remove","Accounts","users","status","anonymousUser","sessionCartCount","currentCartId","insert","account","profile","addressBook","address","isBillingDefault","isShippingDefault","currentUser","user","userCurrency","getShopCurrency","currency","productId","variantId","Number","error","Products","$in","doc","warn","cartVariantExists","some","item","variants","$inc","result","simpleSchema","namedContext","invalidKeys","Random","id","title","parcel","itemId","cartItem","$pull","removeQuantity","Math","abs","order","Object","assign","msg","email","emails","provides","createdAt","updatedAt","cartCount","cartShipping","cartSubTotal","cartTaxes","cartDiscounts","cartTotal","Array","isArray","shipping","paymentId","billing","exchangeRate","userExchangeRate","packed","shipped","delivered","orderId","Orders","newCartExists","count","info","err","method","selector","$set","shipmentMethod","e","userCurrencyString","$unset","Schemas","Address","addressId","needToUpdate","isShippingDeleting","paymentMethod","PaymentMethod","checkoutCart","invoice","subtotal","taxes","discounts","total"],"mappings":"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","file":"/server/methods/core/cart.js.map","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport * as Collections from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * quantityProcessing\n * @summary perform calculations admissibility of adding product to cart\n * @param {Object} product - product to add to Cart\n * @param {Object} variant - product variant\n * @param {Number} itemQty - qty to add to cart, defaults to 1, deducts\n *  from inventory\n * @since 1.10.1\n * @return {Number} quantity - revised quantity to be added to cart\n */\nfunction quantityProcessing(product, variant, itemQty = 1) {\n  let quantity = itemQty;\n  const MIN = variant.minOrderQuantity || 1;\n  const MAX = variant.inventoryQuantity || Infinity;\n\n  if (MIN > MAX) {\n    Logger.debug(`productId: ${product._id}, variantId ${variant._id\n      }: inventoryQuantity lower then minimum order`);\n    throw new Meteor.Error(`productId: ${product._id}, variantId ${variant._id\n      }: inventoryQuantity lower then minimum order`);\n  }\n\n  // TODO: think about #152 implementation here\n  switch (product.type) {\n    case \"not-in-stock\":\n      break;\n    default: // type: `simple` // todo: maybe it should be \"variant\"\n      if (quantity < MIN) {\n        quantity = MIN;\n      } else if (variant.inventoryPolicy && quantity > MAX) {\n        quantity = MAX;\n      }\n  }\n\n  return quantity;\n}\n\n/**\n * getSessionCarts\n * @summary get Cart cursor with all session carts\n * @param {String} userId - current user _id\n * @param {String} sessionId - current user session id\n * @param {String} shopId - shop id\n * @since 0.10.2\n * @return {Mongo.Cursor} with array of session carts\n */\nfunction getSessionCarts(userId, sessionId, shopId) {\n  const carts = Collections.Cart.find({\n    $and: [{\n      userId: {\n        $ne: userId\n      }\n    }, {\n      sessionId: {\n        $eq: sessionId\n      }\n    }, {\n      shopId: {\n        $eq: shopId\n      }\n    }]\n  });\n\n  // we can't use Array.map here, because we need to reduce the number of array\n  // elements if element belongs to registered user, we should throw it.\n  const allowedCarts = [];\n\n  // only anonymous user carts allowed\n  carts.forEach(cart => {\n    if (Roles.userIsInRole(cart.userId, \"anonymous\", shopId)) {\n      allowedCarts.push(cart);\n    }\n  });\n\n  return allowedCarts;\n}\n\n/**\n * Reaction Cart Methods\n */\n\n\nMeteor.methods({\n  /**\n   * cart/mergeCart\n   * @summary merge matching sessionId cart into specified userId cart\n   *\n   * There should be one cart for each independent, non logged in user session\n   * When a user logs in that cart now belongs to that user and we use the a\n   * single user cart.\n   * If they are logged in on more than one devices, regardless of session,the\n   * user cart will be used\n   * If they had more than one cart, on more than one device,logged in at\n   * separate times then merge the carts\n   *\n   * @param {String} cartId - cartId of the cart to merge matching session\n   * carts into.\n   * @param {String} [currentSessionId] - current client session id\n   * @todo I think this method should be moved out from methods to a Function\n   * Declaration to keep it more secure\n   * @return {Object|Boolean} cartId - cartId on success or false\n   */\n  \"cart/mergeCart\": function (cartId, currentSessionId) {\n    check(cartId, String);\n    check(currentSessionId, Match.Optional(String));\n\n    // we don't process current cart, but merge into it.\n    const currentCart = Collections.Cart.findOne(cartId);\n    if (!currentCart) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    // just used to filter out the current cart\n    // we do additional check of cart exists here and if it not exist, next\n    // check supposed to throw 403 error\n    const userId = currentCart && currentCart.userId;\n    // user should have an access to operate with only one - his - cart\n    if (this.userId !== null && userId !== this.userId) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // persistent sessions, see: publications/sessions.js\n    // this is the last place where we still need `Reaction.sessionId`.\n    // The use case is: on user log in. I don't know how pass `sessionId` down\n    // at that moment.\n    const sessionId = currentSessionId || Reaction.sessionId;\n    const shopId = Reaction.getShopId();\n\n    // no need to merge anonymous carts\n    if (Roles.userIsInRole(userId, \"anonymous\", shopId)) {\n      return false;\n    }\n    Logger.debug(\"merge cart: matching sessionId\");\n    Logger.debug(\"current userId:\", userId);\n    Logger.debug(\"sessionId:\", sessionId);\n    // get session carts without current user cart cursor\n    const sessionCarts = getSessionCarts(userId, sessionId, shopId);\n\n    Logger.debug(\n      `merge cart: begin merge processing of session ${\n      sessionId} into: ${currentCart._id}`\n    );\n    // loop through session carts and merge into user cart\n    sessionCarts.forEach(sessionCart => {\n      Logger.debug(\n        `merge cart: merge user userId: ${userId}, sessionCart.userId: ${\n          sessionCart.userId}, sessionCart id: ${sessionCart._id}`\n      );\n      // really if we have no items, there's nothing to merge\n      if (sessionCart.items) {\n        // if currentCart already have a cartWorkflow, we don't need to clean it\n        // up completely, just to `coreCheckoutShipping` stage. Also, we will\n        // need to recalculate shipping rates\n        if (typeof currentCart.workflow === \"object\" &&\n        typeof currentCart.workflow.workflow === \"object\") {\n          if (currentCart.workflow.workflow.length > 2) {\n            Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n            // refresh shipping quotes\n            Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n          }\n        } else {\n          // if user logged in he doesn't need to show `checkoutLogin` step\n          Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n        }\n\n        // We got an additional db call because of `workflow/revertCartWorkflow`\n        // call, but we also got things more cleaner in my opinion.\n        // merge session cart into current cart\n        Collections.Cart.update(currentCart._id, {\n          $addToSet: {\n            items: {\n              $each: sessionCart.items\n            }\n          }\n        });\n      }\n\n      // cleanup session Carts after merge.\n      if (sessionCart.userId !== this.userId) {\n        // clear the cart that was used for a session\n        // and we're also going to do some garbage Collection\n        Collections.Cart.remove(sessionCart._id);\n        // cleanup user/accounts\n        Collections.Accounts.remove({\n          userId: sessionCart.userId\n        });\n        Meteor.users.remove(sessionCart.userId);\n        Logger.debug(\n          `merge cart: delete cart ${\n          sessionCart._id} and user: ${sessionCart.userId}`\n        );\n      }\n      Logger.debug(\n        `merge cart: processed merge for cartId ${sessionCart._id}`\n      );\n    });\n\n    // `checkoutLogin` should be used for anonymous only. Registered users\n    // no need see this.\n    if (currentCart.workflow.status === \"new\") {\n      // to call `workflow/pushCartWorkflow` two times is the only way to move\n      // from status \"new\" to \"checkoutAddressBook\" which I found without\n      // refactoring of `workflow/pushCartWorkflow`\n      // We send `cartId` as arguments because this method could be called from\n      // publication method and in half cases it could be so, that\n      // Meteor.userId() will be null.\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"checkoutLogin\", cartId);\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"checkoutAddressBook\", cartId);\n    }\n\n    return currentCart._id;\n  },\n\n  /**\n   * cart/createCart\n   * @description create new cart for user, but all checks for current cart's\n   * existence should go before this method will be called, to keep it clean\n   * @summary create and return new cart for user\n   * @param {String} userId - userId to create cart for\n   * @param {String} sessionId - current client session id\n   * @todo I think this method should be moved out from methods to a Function\n   * Declaration to keep it more secure\n   * @returns {String} cartId - users cartId\n   */\n  \"cart/createCart\": function (userId, sessionId) {\n    check(userId, String);\n    check(sessionId, String);\n\n    const shopId = Reaction.getShopId();\n    // check if user has `anonymous` role.( this is a visitor)\n    const anonymousUser = Roles.userIsInRole(userId, \"anonymous\", shopId);\n    const sessionCartCount = getSessionCarts(userId, sessionId, shopId).length;\n\n    Logger.debug(\"create cart: shopId\", shopId);\n    Logger.debug(\"create cart: userId\", userId);\n    Logger.debug(\"create cart: sessionId\", sessionId);\n    Logger.debug(\"create cart: sessionCarts.count\", sessionCartCount);\n    Logger.debug(\"create cart: anonymousUser\", anonymousUser);\n\n    // we need to create a user cart for the new authenticated user or\n    // anonymous.\n    const currentCartId = Collections.Cart.insert({\n      sessionId: sessionId,\n      userId: userId\n    });\n    Logger.debug(\"create cart: into new user cart. created: \" +  currentCartId +\n      \" for user \" + userId);\n\n    // merge session carts into the current cart\n    if (sessionCartCount > 0 && !anonymousUser) {\n      Logger.debug(\"create cart: found existing cart. merge into \" + currentCartId\n        + \" for user \" + userId);\n      Meteor.call(\"cart/mergeCart\", currentCartId, sessionId);\n    }\n\n    // we should check for an default billing/shipping address in user account.\n    // this needed after submitting order, when user receives new cart\n    const account = Collections.Accounts.findOne(userId);\n    if (account && account.profile && account.profile.addressBook) {\n      account.profile.addressBook.forEach(address => {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", currentCartId, address);\n        }\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", currentCartId, address);\n        }\n      });\n    }\n\n    // attach current user currency to cart\n    const currentUser = Meteor.user();\n    let userCurrency = Reaction.getShopCurrency();\n\n    // Check to see if the user has a custom currency saved to their profile\n    // Use it if they do\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = currentUser.profile.currency;\n    }\n    Meteor.call(\"cart/setUserCurrency\", currentCartId, userCurrency);\n\n    return currentCartId;\n  },\n\n  /**\n   *  cart/addToCart\n   *  @summary add items to a user cart\n   *  when we add an item to the cart, we want to break all relationships\n   *  with the existing item. We want to fix price, qty, etc into history\n   *  however, we could check reactively for price /qty etc, adjustments on\n   *  the original and notify them\n   *  @param {String} productId - productId to add to Cart\n   *  @param {String} variantId - product variant _id\n   *  @param {Number} [itemQty] - qty to add to cart\n   *  @return {Number|Object} Mongo insert response\n   */\n  \"cart/addToCart\": function (productId, variantId, itemQty) {\n    check(productId, String);\n    check(variantId, String);\n    check(itemQty, Match.Optional(Number));\n\n    const cart = Collections.Cart.findOne({ userId: this.userId });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n    // With the flattened model we no longer need to work directly with the\n    // products. But product still could be necessary for a `quantityProcessing`\n    // TODO: need to understand: do we really need product inside\n    // `quantityProcessing`?\n    let product;\n    let variant;\n    Collections.Products.find({ _id: { $in: [\n      productId,\n      variantId\n    ] } }).forEach(doc => {\n      if (doc.type === \"simple\") {\n        product = doc;\n      } else {\n        variant = doc;\n      }\n    });\n\n    // TODO: this lines still needed. We could uncomment them in future if\n    // decide to not completely remove product data from this method\n    // const product = Collections.Products.findOne(productId);\n    // const variant = Collections.Products.findOne(variantId);\n    if (!product) {\n      Logger.warn(`Product: ${ productId } was not found in database`);\n      throw new Meteor.Error(404, \"Product not found\",\n        \"Product with such id was not found!\");\n    }\n    if (!variant) {\n      Logger.warn(`Product variant: ${ variantId } was not found in database`);\n      throw new Meteor.Error(404, \"ProductVariant not found\",\n        \"ProductVariant with such id was not found!\");\n    }\n    // performs calculations admissibility of adding product to cart\n    const quantity = quantityProcessing(product, variant, itemQty);\n    // performs search of variant inside cart\n    const cartVariantExists = cart.items && cart.items\n      .some(item => item.variants._id === variantId);\n\n    if (cartVariantExists) {\n      return Collections.Cart.update({\n        \"_id\": cart._id,\n        \"items.variants._id\": variantId\n      }, {\n        $inc: {\n          \"items.$.quantity\": quantity\n        }\n      }, function (error, result) {\n        if (error) {\n          Logger.warn(\"error adding to cart\",\n            Collections.Cart.simpleSchema().namedContext().invalidKeys());\n          return error;\n        }\n\n        // refresh shipping quotes\n        Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n        // revert workflow to checkout shipping step.\n        Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n        // reset selected shipment method\n        Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n        Logger.debug(`cart: increment variant ${variantId} quantity by ${\n          quantity}`);\n\n        return result;\n      });\n    }\n\n    // cart variant doesn't exist\n    return Collections.Cart.update({\n      _id: cart._id\n    }, {\n      $addToSet: {\n        items: {\n          _id: Random.id(),\n          shopId: product.shopId,\n          productId: productId,\n          quantity: quantity,\n          variants: variant,\n          title: product.title,\n          type: product.type,\n          parcel: product.parcel || null\n        }\n      }\n    }, function (error, result) {\n      if (error) {\n        Logger.error(error);\n        Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(),\n          \"Invalid keys. Error adding to cart.\");\n        return error;\n      }\n\n      // refresh shipping quotes\n      Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n      // revert workflow to checkout shipping step.\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n      // reset selected shipment method\n      Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n      Logger.debug(`cart: add variant ${variantId} to cartId ${cart._id}`);\n\n      return result;\n    });\n  },\n\n  /**\n   * cart/removeFromCart\n   * @summary removes or adjust quantity of a variant from the cart\n   * @param {String} itemId - cart item _id\n   * @param {Number} [quantity] - if provided will adjust increment by quantity\n   * @returns {Number} returns Mongo update result\n   */\n  \"cart/removeFromCart\": function (itemId, quantity) {\n    check(itemId, String);\n    check(quantity, Match.Optional(Number));\n\n    const userId = Meteor.userId();\n    const cart = Collections.Cart.findOne({\n      userId: userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"cart-not-found\", \"Cart not found for user with such id\");\n    }\n\n    let cartItem;\n\n    if (cart.items) {\n      cartItem = _.find(cart.items, (item) => item._id === itemId);\n    }\n\n    // extra check of item exists\n    if (typeof cartItem !== \"object\") {\n      Logger.error(`Unable to find an item: ${itemId} within the cart: ${cart._id}`);\n      throw new Meteor.Error(\"cart-item-not-found\", \"Unable to find an item with such id in cart.\");\n    }\n\n    // refresh shipping quotes\n    Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n    // revert workflow to checkout shipping step.\n    Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    // reset selected shipment method\n    Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n    if (!quantity || quantity >= cartItem.quantity) {\n      return Collections.Cart.update({\n        _id: cart._id\n      }, {\n        $pull: {\n          items: {\n            _id: itemId\n          }\n        }\n      }, (error, result) => {\n        if (error) {\n          Logger.error(error);\n          Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(),\n            \"error removing from cart\");\n          return error;\n        }\n        Logger.debug(`cart: deleted cart item variant id ${cartItem.variants._id}`);\n        return result;\n      });\n    }\n\n    // if quantity lets convert to negative and increment\n    const removeQuantity = Math.abs(quantity) * -1;\n    return Collections.Cart.update({\n      \"_id\": cart._id,\n      \"items._id\": cartItem._id\n    }, {\n      $inc: {\n        \"items.$.quantity\": removeQuantity\n      }\n    }, (error, result) => {\n      if (error) {\n        Logger.error(error);\n        Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(),\n          \"error removing from cart\");\n        return error;\n      }\n      Logger.debug(`cart: removed variant ${cartItem._id} quantity of ${quantity}`);\n      return result;\n    });\n  },\n\n  /**\n   * cart/copyCartToOrder\n   * @summary transform cart to order when a payment is processed we want to\n   * copy the cart over to an order object, and give the user a new empty\n   * cart. reusing the cart schema makes sense, but integrity of the order, we\n   * don't want to just make another cart item\n   * @todo:  Partial order processing, shopId processing\n   * @todo:  Review Security on this method\n   * @param {String} cartId - cartId to transform to order\n   * @return {String} returns orderId\n   */\n  \"cart/copyCartToOrder\": function (cartId) {\n    check(cartId, String);\n    const cart = Collections.Cart.findOne(cartId);\n    // security check\n    if (cart.userId !== this.userId) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const order = Object.assign({}, cart);\n    const sessionId = cart.sessionId;\n\n    if (!order.items || order.items.length === 0) {\n      const msg = \"An error occurred saving the order. Missing cart items.\";\n      Logger.error(msg);\n      throw new Meteor.Error(\"no-cart-items\", msg);\n    }\n\n    Logger.debug(\"cart/copyCartToOrder\", cartId);\n    // reassign the id, we'll get a new orderId\n    order.cartId = cart._id;\n\n    // a helper for guest login, we let guest add email afterwords\n    // for ease, we'll also add automatically for logged in users\n    if (order.userId && !order.email) {\n      const user = Collections.Accounts.findOne(order.userId);\n      // we could have a use case here when email is not defined by some reason,\n      // we could throw an error, but it's not pretty clever, so let it go w/o\n      // email\n      if (typeof user === \"object\" && user.emails) {\n        for (const email of user.emails) {\n          // alternate order email address\n          if (email.provides === \"orders\") {\n            order.email = email.address;\n          } else if (email.provides === \"default\") {\n            order.email = email.address;\n          }\n        }\n      }\n    }\n\n    // schema should provide order defaults\n    // so we'll delete the cart autovalues\n    delete order.createdAt; // autovalues\n    delete order.updatedAt;\n    delete order.cartCount;\n    delete order.cartShipping;\n    delete order.cartSubTotal;\n    delete order.cartTaxes;\n    delete order.cartDiscounts;\n    delete order.cartTotal;\n    delete order._id;\n\n    // `order.shipping` is array ?\n    if (Array.isArray(order.shipping)) {\n      if (order.shipping.length > 0) {\n        order.shipping[0].paymentId = order.billing[0]._id;\n\n        if (!Array.isArray(order.shipping[0].items)) {\n          order.shipping[0].items = [];\n        }\n      }\n    } else { // if not - create it\n      order.shipping = [];\n    }\n\n    // Add current exchange rate into order.billing.currency\n    // If user currenct === shop currency, exchange rate = 1.0\n    const currentUser = Meteor.user();\n    let userCurrency = Reaction.getShopCurrency();\n    let exchangeRate = \"1.00\";\n\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = Meteor.user().profile.currency;\n    }\n\n    if (userCurrency !== Reaction.getShopCurrency()) {\n      const userExchangeRate = Meteor.call(\"shop/getCurrencyRates\", userCurrency);\n\n      if (typeof userExchangeRate === \"number\") {\n        exchangeRate = userExchangeRate;\n      } else {\n        Logger.warn(\"Failed to get currency exchange rates. Setting exchange rate to null.\");\n        exchangeRate = null;\n      }\n    }\n\n    if (!order.billing[0].currency) {\n      order.billing[0].currency = {\n        userCurrency: userCurrency\n      };\n    }\n\n    _.each(order.items, (item) => {\n      if (order.shipping[0].items) {\n        order.shipping[0].items.push({\n          _id: item._id,\n          productId: item.productId,\n          shopId: item.shopId,\n          variantId: item.variants._id\n        });\n      }\n    });\n\n    order.shipping[0].items.packed = false;\n    order.shipping[0].items.shipped = false;\n    order.shipping[0].items.delivered = false;\n\n    order.billing[0].currency.exchangeRate = exchangeRate;\n    order.workflow.status = \"new\";\n    order.workflow.workflow = [\"coreOrderWorkflow/created\"];\n\n    // insert new reaction order\n    const orderId = Collections.Orders.insert(order);\n\n    if (orderId) {\n      Collections.Cart.remove({\n        _id: order.cartId\n      });\n      // create a new cart for the user\n      // even though this should be caught by\n      // subscription handler, it's not always working\n      const newCartExists = Collections.Cart.find({ userId: order.userId });\n      if (newCartExists.count() === 0) {\n        Meteor.call(\"cart/createCart\", this.userId, sessionId);\n        // after recreate new cart we need to make it looks like previous by\n        // updating `cart/workflow/status` to \"coreCheckoutShipping\"\n        // by calling `workflow/pushCartWorkflow` three times. This is the only\n        // way to do that without refactoring of `workflow/pushCartWorkflow`\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutAddressBook\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n      }\n\n      Logger.info(\"Transitioned cart \" + cartId + \" to order \" + orderId);\n      // catch send notification, we don't want\n      // to block because of notification errors\n\n      if (order.email) {\n        Meteor.call(\"orders/sendNotification\", Collections.Orders.findOne(orderId), (err) => {\n          if (err) {\n            Logger.error(err, `Error in orders/sendNotification for order ${orderId}`);\n          }\n        });\n      }\n\n      // order success\n      return orderId;\n    }\n    // we should not have made it here, throw error\n    throw new Meteor.Error(400, \"cart/copyCartToOrder: Invalid request\");\n  },\n\n  /**\n   * cart/setShipmentMethod\n   * @summary saves method as order default\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} method - shipmentMethod object\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setShipmentMethod\": function (cartId, method) {\n    check(cartId, String);\n    check(method, Object);\n    // get current cart\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: Meteor.userId()\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n\n    // temp hack until we build out multiple shipping handlers\n    let selector;\n    let update;\n    // temp hack until we build out multiple shipment handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (cart.shipping) {\n      selector = {\n        \"_id\": cartId,\n        \"shipping._id\": cart.shipping[0]._id\n      };\n      update = {\n        $set: {\n          \"shipping.$.shipmentMethod\": method\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          shipping: {\n            shipmentMethod: method\n          }\n        }\n      };\n    }\n\n    // update or insert method\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e, `Error adding rates to cart ${cartId}`);\n      throw new Meteor.Error(\"An error occurred saving the order\", e);\n    }\n\n    // this will transition to review\n    return Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n      \"coreCheckoutShipping\");\n  },\n\n  /**\n   * cart/setUserCurrency\n   * @summary saves user currency in cart, to be paired with order/setCurrencyExhange\n   * @param {String} cartId - cartId to apply setUserCurrency\n   * @param {String} userCurrency - userCurrency to set to cart\n   * @return {Number} update result\n   */\n  \"cart/setUserCurrency\": function (cartId, userCurrency) {\n    check(cartId, String);\n    check(userCurrency, String);\n    const cart = Collections.Cart.findOne({\n      _id: cartId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(\"Cart not found for user with such id\");\n    }\n\n    const userCurrencyString = {\n      userCurrency: userCurrency\n    };\n\n    let selector;\n    let update;\n\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.currency\": userCurrencyString\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            currency: userCurrencyString\n          }\n        }\n      };\n    }\n\n    // add / or set the shipping address\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred adding the currency\");\n    }\n\n    return true;\n  },\n\n  /**\n   * cart/resetShipmentMethod\n   * @summary removes `shipmentMethod` object from cart\n   * @param {String} cartId - cart _id\n   * @return {Number} update result\n   */\n  \"cart/resetShipmentMethod\": function (cartId) {\n    check(cartId, String);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        `Cart: ${cartId} not found for user: ${this.userId}`);\n    }\n\n    return Collections.Cart.update({ _id: cartId }, {\n      $unset: { \"shipping.0.shipmentMethod\": \"\" }\n    });\n  },\n\n  /**\n   * cart/setShipmentAddress\n   * @summary adds address book to cart shipping\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} address - addressBook object\n   * @return {Number} update result\n   */\n  \"cart/setShipmentAddress\": function (cartId, address) {\n    check(cartId, String);\n    check(address, Reaction.Schemas.Address);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple shipment handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (Array.isArray(cart.shipping) && cart.shipping.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"shipping._id\": cart.shipping[0]._id\n      };\n      update = {\n        $set: {\n          \"shipping.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          shipping: {\n            address: address\n          }\n        }\n      };\n    }\n\n    // add / or set the shipping address\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred adding the address\");\n    }\n\n    // refresh shipping quotes\n    Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n\n    if (typeof cart.workflow !== \"object\") {\n      throw new Meteor.Error(500, \"Internal Server Error\",\n        \"Cart workflow object not detected.\");\n    }\n\n    // ~~it's ok for this to be called multiple times~~\n    // call it only once when we at the `checkoutAddressBook` step\n    if (typeof cart.workflow.workflow === \"object\" &&\n      cart.workflow.workflow.length < 2) {\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"coreCheckoutShipping\");\n    }\n\n    // if we change default address during further steps, we need to revert\n    // workflow back to `coreCheckoutShipping` step\n    if (typeof cart.workflow.workflow === \"object\" &&\n      cart.workflow.workflow.length > 2) { // \"2\" index of\n      // `coreCheckoutShipping`\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    }\n\n    return true;\n  },\n\n  /**\n   * cart/setPaymentAddress\n   * @summary adds addressbook to cart payments\n   * @param {String} cartId - cartId to apply payment address\n   * @param {Object} address - addressBook object\n   * @todo maybe we need to rename this method to `cart/setBillingAddress`?\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setPaymentAddress\": function (cartId, address) {\n    check(cartId, String);\n    check(address, Reaction.Schemas.Address);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (Array.isArray(cart.billing) && cart.billing.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            address: address\n          }\n        }\n      };\n    }\n\n    return Collections.Cart.update(selector, update);\n  },\n\n  /**\n   * cart/unsetAddresses\n   * @description removes address from cart.\n   * @param {String} addressId - address._id\n   * @param {String} userId - cart owner _id\n   * @param {String} [type] - billing default or shipping default\n   * @since 0.10.1\n   * @todo check if no more address in cart as shipping, we should reset\n   * `cartWorkflow` to second step\n   * @return {Number|Object|Boolean} The number of removed documents or error\n   * object or `false` if we don't need to update cart\n   */\n  \"cart/unsetAddresses\": function (addressId, userId, type) {\n    check(addressId, String);\n    check(userId, String);\n    check(type, Match.Optional(String));\n\n    // do we actually need to change anything?\n    let needToUpdate = false;\n    // we need to revert the workflow after a \"shipping\" address was removed\n    let isShippingDeleting = false;\n    const cart = Collections.Cart.findOne({\n      userId: userId\n    });\n    const selector = {\n      _id: cart._id\n    };\n    const update = { $unset: {} };\n    // user could turn off the checkbox in address to not to be default, then we\n    // receive `type` arg\n    if (typeof type === \"string\") {\n      // we assume that the billing/shipping arrays can hold only one element [0]\n      if (cart[type] && typeof cart[type][0].address === \"object\" &&\n        cart[type][0].address._id === addressId) {\n        update.$unset[`${type}.0.address`] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = type === \"shipping\";\n      }\n    } else { // or if we remove address itself, when we run this part we assume\n      // that the billing/shipping arrays can hold only one element [0]\n      if (cart.billing && typeof cart.billing[0].address === \"object\" &&\n        cart.billing[0].address._id === addressId) {\n        update.$unset[\"billing.0.address\"] = \"\";\n        needToUpdate = true;\n      }\n      if (cart.shipping && typeof cart.shipping[0].address === \"object\" &&\n        cart.shipping[0].address._id === addressId) {\n        update.$unset[\"shipping.0.address\"] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = true;\n      }\n    }\n\n    if (needToUpdate) {\n      try {\n        Collections.Cart.update(selector, update);\n      } catch (e) {\n        Logger.error(e);\n        throw new Meteor.Error(\"Error updating cart\");\n      }\n\n      if (isShippingDeleting) {\n        // if we remove shipping address from cart, we need to revert\n        // `cartWorkflow` to the `checkoutAddressBook` step.\n        Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n      }\n    }\n    return true;\n  },\n\n  /**\n   * cart/submitPayment\n   * @summary saves a submitted payment to cart, triggers workflow\n   * and adds \"paymentSubmitted\" to cart workflow\n   * Note: this method also has a client stub, that forwards to cartCompleted\n   * @param {Object} paymentMethod - paymentMethod object\n   * directly within this method, just throw down though hooks\n   * @return {String} returns update result\n   */\n  \"cart/submitPayment\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n\n    const checkoutCart = Collections.Cart.findOne({\n      userId: Meteor.userId()\n    });\n\n    const cart = _.clone(checkoutCart);\n    const cartId = cart._id;\n    const invoice = {\n      shipping: cart.cartShipping(),\n      subtotal: cart.cartSubTotal(),\n      taxes: cart.cartTaxes(),\n      discounts: cart.cartDiscounts(),\n      total: cart.cartTotal()\n    };\n\n    // we won't actually close the order at this stage.\n    // we'll just update the workflow and billing data where\n    // method-hooks can process the workflow update.\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.paymentMethod\": paymentMethod,\n          \"billing.$.invoice\": invoice\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          \"billing.paymentMethod\": paymentMethod,\n          \"billing.invoice\": invoice\n        }\n      };\n    }\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred saving the order\");\n    }\n\n    return Collections.Cart.findOne(selector);\n  }\n});\n"]},"hash":"408b1c21c2ecdf3c71160cb453271ce6cf52e2d0"}
