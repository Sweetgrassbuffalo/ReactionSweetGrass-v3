{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/api/core/rightJoin.js","filenameRelative":"/server/api/core/rightJoin.js","inputSourceMap":{"version":3,"sources":["/server/api/core/rightJoin.js"],"names":["doRightJoinNoIntersection","leftSet","rightSet","rightJoin","Array","isArray","findRightOnlyProperties","Object","keys","filter","key","hasOwnProperty","Error","rightSubJoin","obj","length","assign","push"],"mappings":";;;;;;AAAA;;;;;;;;;;;;OAcE,AAAI,AAAa,AAAM,AAAO,sCAAP,mBAEvB;MAAA,AAAI,0BACJ;MAAA,AAAI,AAAM,AAAQ,AAAW,AAC3B;;YAAA,AAAY,mBADd,AAEC;AAAM,gBACL;SAAA,AAAY,AACb;;AACD;;MAAM,0BAA0B,YAAM,AACpC;kBAAO,AAAO,KAAP,AAAY,UAAZ,AAAsB,OAAO,UAAA,AAAU;UACxC,sBAAO,SAAP,AAAO,AAAS,AAAU,UAA9B,AAAI,AACF,AAAC,AAAM,AAAQ,AAAS,AAAO,AAC/B,2CACA;AAJ+C,AAI/C,AAAO,AACR;AACD;OANiD,AACjD,CAMA;;;aAAO,CAAC,QAAA,AAAQ,eAAhB,AAAQ,AAAuB,AAChC;AARD,AAAO,AASR,KATQ;AADT,AAYA;;AAAK,uBAAL,AAAkB;AAA2B,AAC3C;;;;;;;;;;;QADF,AAAW;;QACL,sBAAO,SAAP,AAAO,AAAS,AAAU,UAA9B,AAAwC,UACtC;AACA;UAAI,QAAA,AAAQ,eAAR,AAAuB,SAAS,sBAAO,QAAP,AAAO,AAAQ,AAAU,UAA7D,AAAI,AAAgC,AAC/B,AAAM,AAAQ,AAAQ,AAAU,AAAM,AAAQ,AAAU,AAAS,AACpE,2EACA;AAAA,AAAM,AAAI,AACR,AACA,AAA+B,AAElC;wBACD,+DAAM,AAAe,+BAArB,AAAqB,AACnB,AAAQ,AAAe,AAAO,AAAQ,AAAO,AAC7C,AAAS,AAGX,AAAM,AAAM;AACZ;;AAAI,yBAAJ,AAAqB,AAAM,AACzB,0BAAA,AAAI,QAAJ,AAAW,qCADb,AAEC,IAAM,SAAA,AAAI,AAAO,AAAK,AAAc,AAAW,AACrC,AAAM,AAAQ,AAAe,AACtC,AACA,AAAI,AAAO,AACZ;;;iCACD;YAAY,OAvBd,AAuBE,AAAY,AAAO,AAAO,AAAW,AACtC;AAAM,sDACL,kCACA;AAAA,AAAI,AAAM,AAAQ,AAAW,AAC3B;YAAU,OAAV,AAAe,AAAS,AACzB;AAFD,AAEO,AACL;;AAAM,kBAAN,AAAY,yBACZ;WAAA,AAAI,AAAO,AAAS,AACpB;AAAA,AAAY,AAAO,AAAO,AAAW,AACtC;mCACF;gCACF;;mBACD;AAAO,aAAP,gBAzDF,AA0DC;;AAED;AAAA,AAAe;;;;CA3Db;;iCADF,AAAM,AAA4B,AAAC,AAAS,AAAa","file":"/server/api/core/rightJoin.js.map","sourcesContent":["/**\n * @summary Returns an disjoint object as right join. For a visualization, see:\n *          http://www.codeproject.com/KB/database/Visual_SQL_Joins/Visual_SQL_JOINS_orig.jpg\n *          Additionally, the join is done recursively on properties of\n *          nested objects as well. Nested arrays are handled like\n *          primitive values.\n * @author Tom De Caluwé\n * @param {Object} leftSet An object that can contain nested sub-objects\n * @param {Object} rightSet An object that can contain nested sub-objects\n * @returns {Object} The disjoint object that does only contain properties\n *                   from the rightSet. But only those, that were not present\n *                   in the leftSet.\n */\nconst doRightJoinNoIntersection = (leftSet, rightSet) => {\n  if (rightSet === null) return null;\n\n  let rightJoin;\n  if (Array.isArray(rightSet)) {\n    rightJoin = [];\n  } else {\n    rightJoin = {};\n  }\n  const findRightOnlyProperties = () => {\n    return Object.keys(rightSet).filter(function (key) {\n      if (typeof(rightSet[key]) === \"object\" &&\n        !Array.isArray(rightSet[key])) {\n        // Nested objects are always considered\n        return true;\n      }\n      // Array or primitive value\n      return !leftSet.hasOwnProperty(key);\n    });\n  };\n\n  for (const key of findRightOnlyProperties()) {\n    if (typeof(rightSet[key]) === \"object\") {\n      // subobject or array\n      if (leftSet.hasOwnProperty(key) && (typeof(leftSet[key]) !== \"object\" ||\n           Array.isArray(leftSet[key]) !== Array.isArray(rightSet[ key ]))) {\n        // This is not expected!\n        throw new Error(\n          \"Left object and right object's internal structure must be \" +\n          \"congruent! Offending key: \" + key\n        );\n      }\n      const rightSubJoin = doRightJoinNoIntersection(\n        leftSet.hasOwnProperty(key) ? leftSet[key] : {},\n        rightSet[key]\n      );\n\n      const obj = {};\n      if (rightSubJoin === null) {\n        obj[key] = null;\n      } else if (Object.keys(rightSubJoin).length !== 0 ||\n                 Array.isArray(rightSubJoin)) {\n        // object or (empty) array\n        obj[key] = rightSubJoin;\n      }\n      rightJoin = Object.assign(rightJoin, obj);\n    } else {\n      // primitive value (or array)\n      if (Array.isArray(rightSet)) {\n        rightJoin.push(rightSet[key]);\n      } else {\n        const obj = {};\n        obj[key] = rightSet[key];\n        rightJoin = Object.assign(rightJoin, obj);\n      }\n    }\n  }\n  return rightJoin;\n};\n\nexport default doRightJoinNoIntersection;\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/api/core/rightJoin.js.map","sourceFileName":"/server/api/core/rightJoin.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"rightJoin"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * @summary Returns an disjoint object as right join. For a visualization, see:\n *          http://www.codeproject.com/KB/database/Visual_SQL_Joins/Visual_SQL_JOINS_orig.jpg\n *          Additionally, the join is done recursively on properties of\n *          nested objects as well. Nested arrays are handled like\n *          primitive values.\n * @author Tom De Caluwé\n * @param {Object} leftSet An object that can contain nested sub-objects\n * @param {Object} rightSet An object that can contain nested sub-objects\n * @returns {Object} The disjoint object that does only contain properties\n *                   from the rightSet. But only those, that were not present\n *                   in the leftSet.\n */var doRightJoinNoIntersection = function (leftSet, rightSet) {\n  if (rightSet === null) return null;\n  var rightJoin = void 0;\n\n  if (Array.isArray(rightSet)) {\n    rightJoin = [];\n  } else {\n    rightJoin = {};\n  }\n\n  var findRightOnlyProperties = function () {\n    return Object.keys(rightSet).filter(function (key) {\n      if ((0, _typeof3.default)(rightSet[key]) === \"object\" && !Array.isArray(rightSet[key])) {\n        // Nested objects are always considered\n        return true;\n      } // Array or primitive value\n\n\n      return !leftSet.hasOwnProperty(key);\n    });\n  };\n\n  for (var _iterator = findRightOnlyProperties(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var key = _ref;\n\n    if ((0, _typeof3.default)(rightSet[key]) === \"object\") {\n      // subobject or array\n      if (leftSet.hasOwnProperty(key) && ((0, _typeof3.default)(leftSet[key]) !== \"object\" || Array.isArray(leftSet[key]) !== Array.isArray(rightSet[key]))) {\n        // This is not expected!\n        throw new Error(\"Left object and right object's internal structure must be \" + \"congruent! Offending key: \" + key);\n      }\n\n      var rightSubJoin = doRightJoinNoIntersection(leftSet.hasOwnProperty(key) ? leftSet[key] : {}, rightSet[key]);\n      var obj = {};\n\n      if (rightSubJoin === null) {\n        obj[key] = null;\n      } else if (Object.keys(rightSubJoin).length !== 0 || Array.isArray(rightSubJoin)) {\n        // object or (empty) array\n        obj[key] = rightSubJoin;\n      }\n\n      rightJoin = Object.assign(rightJoin, obj);\n    } else {\n      // primitive value (or array)\n      if (Array.isArray(rightSet)) {\n        rightJoin.push(rightSet[key]);\n      } else {\n        var _obj = {};\n        _obj[key] = rightSet[key];\n        rightJoin = Object.assign(rightJoin, _obj);\n      }\n    }\n  }\n\n  return rightJoin;\n};\n\nmodule.export(\"default\", exports.default = doRightJoinNoIntersection);","map":{"version":3,"sources":["/server/api/core/rightJoin.js"],"names":["doRightJoinNoIntersection","leftSet","rightSet","rightJoin","Array","isArray","findRightOnlyProperties","Object","keys","filter","key","hasOwnProperty","Error","rightSubJoin","obj","length","assign","push"],"mappings":";;;;;;AAAA;;;;;;;;;;;;OAcE,AAAI,AAAa,AAAM,AAAO,sCAAP,mBAEvB;MAAA,AAAI,0BACJ;MAAA,AAAI,AAAM,AAAQ,AAAW,AAC3B;;YAAA,AAAY,mBADd,AAEC;AAAM,gBACL;SAAA,AAAY,AACb;;AACD;;MAAM,0BAA0B,YAAM,AACpC;kBAAO,AAAO,KAAP,AAAY,UAAZ,AAAsB,OAAO,UAAA,AAAU;UACxC,sBAAO,SAAP,AAAO,AAAS,AAAU,UAA9B,AAAI,AACF,AAAC,AAAM,AAAQ,AAAS,AAAO,AAC/B,2CACA;AAJ+C,AAI/C,AAAO,AACR;AACD;OANiD,AACjD,CAMA;;;aAAO,CAAC,QAAA,AAAQ,eAAhB,AAAQ,AAAuB,AAChC;AARD,AAAO,AASR,KATQ;AADT,AAYA;;AAAK,uBAAL,AAAkB;AAA2B,AAC3C;;;;;;;;;;;QADF,AAAW;;QACL,sBAAO,SAAP,AAAO,AAAS,AAAU,UAA9B,AAAwC,UACtC;AACA;UAAI,QAAA,AAAQ,eAAR,AAAuB,SAAS,sBAAO,QAAP,AAAO,AAAQ,AAAU,UAA7D,AAAI,AAAgC,AAC/B,AAAM,AAAQ,AAAQ,AAAU,AAAM,AAAQ,AAAU,AAAS,AACpE,2EACA;AAAA,AAAM,AAAI,AACR,AACA,AAA+B,AAElC;wBACD,+DAAM,AAAe,+BAArB,AAAqB,AACnB,AAAQ,AAAe,AAAO,AAAQ,AAAO,AAC7C,AAAS,AAGX,AAAM,AAAM;AACZ;;AAAI,yBAAJ,AAAqB,AAAM,AACzB,0BAAA,AAAI,QAAJ,AAAW,qCADb,AAEC,IAAM,SAAA,AAAI,AAAO,AAAK,AAAc,AAAW,AACrC,AAAM,AAAQ,AAAe,AACtC,AACA,AAAI,AAAO,AACZ;;;iCACD;YAAY,OAvBd,AAuBE,AAAY,AAAO,AAAO,AAAW,AACtC;AAAM,sDACL,kCACA;AAAA,AAAI,AAAM,AAAQ,AAAW,AAC3B;YAAU,OAAV,AAAe,AAAS,AACzB;AAFD,AAEO,AACL;;AAAM,kBAAN,AAAY,yBACZ;WAAA,AAAI,AAAO,AAAS,AACpB;AAAA,AAAY,AAAO,AAAO,AAAW,AACtC;mCACF;gCACF;;mBACD;AAAO,aAAP,gBAzDF,AA0DC;;AAED;AAAA,AAAe;;;;CA3Db;;iCADF,AAAM,AAA4B,AAAC,AAAS,AAAa","file":"/server/api/core/rightJoin.js.map","sourcesContent":["/**\n * @summary Returns an disjoint object as right join. For a visualization, see:\n *          http://www.codeproject.com/KB/database/Visual_SQL_Joins/Visual_SQL_JOINS_orig.jpg\n *          Additionally, the join is done recursively on properties of\n *          nested objects as well. Nested arrays are handled like\n *          primitive values.\n * @author Tom De Caluwé\n * @param {Object} leftSet An object that can contain nested sub-objects\n * @param {Object} rightSet An object that can contain nested sub-objects\n * @returns {Object} The disjoint object that does only contain properties\n *                   from the rightSet. But only those, that were not present\n *                   in the leftSet.\n */\nconst doRightJoinNoIntersection = (leftSet, rightSet) => {\n  if (rightSet === null) return null;\n\n  let rightJoin;\n  if (Array.isArray(rightSet)) {\n    rightJoin = [];\n  } else {\n    rightJoin = {};\n  }\n  const findRightOnlyProperties = () => {\n    return Object.keys(rightSet).filter(function (key) {\n      if (typeof(rightSet[key]) === \"object\" &&\n        !Array.isArray(rightSet[key])) {\n        // Nested objects are always considered\n        return true;\n      }\n      // Array or primitive value\n      return !leftSet.hasOwnProperty(key);\n    });\n  };\n\n  for (const key of findRightOnlyProperties()) {\n    if (typeof(rightSet[key]) === \"object\") {\n      // subobject or array\n      if (leftSet.hasOwnProperty(key) && (typeof(leftSet[key]) !== \"object\" ||\n           Array.isArray(leftSet[key]) !== Array.isArray(rightSet[ key ]))) {\n        // This is not expected!\n        throw new Error(\n          \"Left object and right object's internal structure must be \" +\n          \"congruent! Offending key: \" + key\n        );\n      }\n      const rightSubJoin = doRightJoinNoIntersection(\n        leftSet.hasOwnProperty(key) ? leftSet[key] : {},\n        rightSet[key]\n      );\n\n      const obj = {};\n      if (rightSubJoin === null) {\n        obj[key] = null;\n      } else if (Object.keys(rightSubJoin).length !== 0 ||\n                 Array.isArray(rightSubJoin)) {\n        // object or (empty) array\n        obj[key] = rightSubJoin;\n      }\n      rightJoin = Object.assign(rightJoin, obj);\n    } else {\n      // primitive value (or array)\n      if (Array.isArray(rightSet)) {\n        rightJoin.push(rightSet[key]);\n      } else {\n        const obj = {};\n        obj[key] = rightSet[key];\n        rightJoin = Object.assign(rightJoin, obj);\n      }\n    }\n  }\n  return rightJoin;\n};\n\nexport default doRightJoinNoIntersection;\n"]},"hash":"f0376a52f3d25122d4a88c132573be2cc7eba5be"}
