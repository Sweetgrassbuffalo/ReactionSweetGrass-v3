{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"later","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"later"}]},{"source":"/lib/collections","imported":["Jobs"],"specifiers":[{"kind":"named","imported":"Jobs","local":"Jobs"}]},{"source":"/server/api","imported":["Hooks","Logger","Reaction"],"specifiers":[{"kind":"named","imported":"Hooks","local":"Hooks"},{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/plugins/included/jobcontrol/server/jobs/exchangerates.js","filenameRelative":"/imports/plugins/included/jobcontrol/server/jobs/exchangerates.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/included/jobcontrol/server/jobs/exchangerates.js"],"names":["later","Jobs","Hooks","Logger","Reaction","Events","add","settings","getShopSettings","exchangeConfig","openexchangerates","appId","refreshPeriod","debug","Job","priority","retry","retries","wait","backoff","repeat","schedule","parse","text","save","cancelRepeats","warn","fetchCurrencyRates","processJobs","pollInterval","workTimeout","job","callback","Meteor","call","error","message","done","repeatId","toString","success","find","type","status","observe","added","trigger","flushCurrencyRates"],"mappings":"AAAA;AAAA,OAAkB;;;;;;;;;;;;;;;;;;;;;;;;GAClB,A,AAAS,AAAY,AACrB,AAAS,AAAO,AAAQ,AAAgB,AAExC,AACA;;AACA,AAAM,AAAO,AAAI,AAAiB,AAAM;AACtC,MAAM,WAAW,AAAS,6BAA1B,AAAiB,AACjB;MAAM,WAAiB,SAAvB,AAAuB,AAAS,AAAqB;qDAErD,AAAI,AAAe,AAAO,AACxB;;MAAM,eAAgB,OAAtB,AAAsB,AAAe,AAAiB,AACtD;QAAA,AAAO,AAAO,gDAAd,AAAsE,AAAc,AACpF;AAAI,WAAJ,AAAQ,AAAM,AAA2B,AACtC,AAAS,AACT,iEAAM,AACL;YADK,AACI,iCACT,IAAM,SAFD,AAGL;eALJ,AAES,AAKN;AAPH,YAOU,AACN;AAAU,eAAA,AAAM,AAAM,cAR1B,AAOU,AACI,AAAiB,AAE5B,AAAK,AACJ;;AATK,AAGI,AAAc;iCAL3B,AAUQ,AAGJ,AAAe;AADf;AAGC,AACL;AAAA,AAAO,AAAK,AACb;qBAxBH,AAyBC,AAED;AAvBE,AAkBC;AAKG,SAAN,AAAa,AAAI,AAAiB,AAAM,AACtC;AAAM,gBAAN,AAAiB,AAAS,AAC1B;AAAA,AAAM,AAAiB,AAAS,AAAqB;AAErD,AAAI,AAAe,AAAO;AACxB,MAAO,OAAP,IAAa,6BADW,AACxB,AACA;0BACA;MAAM,iBAAgB,SAAtB,qBACA,AAAI,AAAI,AAAM,AAA2B,AACtC,AAAS,AACT,AAAM,AACL;;MADK,AACI,sBACT;WAAM,MAFD,AAGL,iDAHK,AAGI;;AALb,AAOG,QAPH,AAOU,gBACN;YAAU,MAAA,AAAM,AAAM,AAAK,2BAR/B,AAOU,AACI,IARd,AAUG,AAAK,SACJ;eAfN,AAiBC;AAAM,YACL;AAAA,AAAO,AAAK,eAtBhB,AAsBI,AACD,AACF;AAhBG,AAUQ,AACW;AAQR,sBAAY,WACzB,AAAM,AAAqB,AAAK,AAAY,AAA2B,AACrE;AAFJ;qBACyE,AAErE,AAAa,AAAM;AAFkD,AACvD,AAAK,AAAK,AAAM;AADL,AAGxB,AAAC,SAAD,AAAM,AAAa,AACpB;WAAA,AAAO,KAAP,AAAY,AAA0B,AAAC,AAAU,AAC/C;AAAA,AAAI,AAAO,AACT;AAAA,AAAI,AAAM,AAAU,AAAiB,AACnC,AAAO,AAAM,AAAM,AACnB,AAAI,AAAK,AAAM,AAAS,AAAE;OArE7B,kBAAP,kBAqE8C,YAAZ;MAAxB;AAFF,AAGO;AACL;AAAI,iBAAJ,AAAS,MAAT,AAAS,AAAM,AAAY,AAAE;AAD9B,oBACwC,UAAZ;WAA3B,gDACD;iBANH,AAOC;YAAM,iCACL;6BACA;;sBACA;;eACA;;sBACA;;AACA;aACA;AAAA,AAAM,AAAU,AAChB;AAAA,AAAO,AAAM,AACb;AAAA,AAAI,AAAK,AAAS,AAAE;AAAF,AAAY;AAA9B,AACD;AAlBH,AAmBC;sBACD;qBAxBF,AAA2B,AAyB1B;;oBAED;;AAAA,AAAK,AAAK,AACR;AADQ,AACF,AACN;AAFQ,AAEA;AAFV,AAGG,AAAQ,AACT,AAAQ,AACN;;;YALJ,AAGW;AAEP,AAAO,AAAmB,AAC3B;AAIG,uBAAqB,AAAK,AAC9B,AAA2B,AACzB;aAAc,AAAK,AAAK,mBADC,AACK;AAFP,AACE,AAEzB,AAAa,AAAM,AAErB,AAAC,AAAK,AAAa,AACjB,AAAO,AAAK,AAA0B,AAAS,AAC7C;AAPN;MAOM,AAAI,AAAO,0BACT,YAAI,AAAM,AAAU;AACX,kBAAP,AAAa,KAAM;AAAnB,AACA;AAAA,AAAI,iBAAK,MAAT,AAAe,AAAS,AAAE,AAAU;AAFtC,AAAiC,AAC/B,oBACA,UACD;AAHD,WAGO,gDACL;iBACA;YAAA,AAAI,AAAK,MAAM,UAAf,AAAS,AAAkB,aAAE;iBAAU,YAAvC,AAA2B;;sBAC5B;;eAPH,AAQC;AAAM,AACL;;sBACA;;AACA;AAAM,aAAN,AAAgB,AAChB;AAAA,AAAO,AAAM,AACb;AAAA,AAAI,AAAK,AAAS,AAAE;YAAU,UAA9B,AAAkB;qBACnB;;oBAfH,AAgBC;;AACD;AAvBJ,AAA2B,AAwBxB;AAGH;AAAA,AAAK,AAAK,AACR,AAAM,AACN,AAAQ;AAFV,AAGG;UACO,AACN;YAAA,AAAO,AAAmB,AAC3B;AANH,AAGW,AACT;uBAJF,AAGW;gCAKZ","file":"/imports/plugins/included/jobcontrol/server/jobs/exchangerates.js.map","sourcesContent":["import later from \"later\";\nimport { Jobs } from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\n// While we don't necessarily need to wait for anything to add a job\n// in this case we need to have packages loaded so we can check for the OER API key\nHooks.Events.add(\"afterCoreInit\", () => {\n  const settings = Reaction.getShopSettings();\n  const exchangeConfig = settings.openexchangerates || {};\n\n  if (exchangeConfig.appId) {\n    const refreshPeriod = exchangeConfig.refreshPeriod || \"every 4 hours\";\n    Logger.debug(`Adding shop/fetchCurrencyRates to JobControl. Refresh ${refreshPeriod}`);\n    new Job(Jobs, \"shop/fetchCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\" // delay by twice as long for each subsequent retry\n      })\n      .repeat({\n        schedule: later.parse.text(refreshPeriod)\n      })\n      .save({\n        // Cancel any jobs of the same type,\n        // but only if this job repeats forever.\n        cancelRepeats: true\n      });\n  } else {\n    Logger.warn(\"OpenExchangeRates API not configured. Not adding fetchRates job\");\n  }\n});\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  const settings = Reaction.getShopSettings();\n  const exchangeConfig = settings.openexchangerates || {};\n\n  if (exchangeConfig.appId) {\n    Logger.debug(\"Adding shop/flushCurrencyRates to JobControl\");\n    // TODO: Add this as a configurable option\n    const refreshPeriod = \"Every 24 hours\";\n    new Job(Jobs, \"shop/flushCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\"\n      })\n      .repeat({\n        schedule: later.parse.text(refreshPeriod)\n      })\n      .save({\n        cancelRepeats: true\n      });\n  } else {\n    Logger.warn(\"OpenExchangeRates API not configured. Not adding flushRates job\");\n  }\n});\n\n\nexport default function () {\n  const fetchCurrencyRates = Jobs.processJobs(\"shop/fetchCurrencyRates\", {\n    pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n    workTimeout: 180 * 1000\n  }, (job, callback) => {\n    Meteor.call(\"shop/fetchCurrencyRate\", (error) => {\n      if (error) {\n        if (error.error === \"notConfigured\") {\n          Logger.error(error.message);\n          job.done(error.message, { repeatId: true });\n        } else {\n          job.done(error.toString(), { repeatId: true });\n        }\n      } else {\n        // we should always return \"completed\" job here, because errors are fine\n        // result for this task, so that's why we show message if error happens\n        // and return job.done();\n        // you can read more about job.repeat() here:\n        // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n        // -job-will-be-automatically-re-run-by-the-job-collection\n        const success = \"Latest exchange rates were fetched successfully.\";\n        Logger.debug(success);\n        job.done(success, { repeatId: true });\n      }\n    });\n    callback();\n  });\n\n  Jobs.find({\n    type: \"shop/fetchCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return fetchCurrencyRates.trigger();\n    }\n  });\n\n\n  const flushCurrencyRates = Jobs.processJobs(\n    \"shop/flushCurrencyRates\", {\n      pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n      workTimeout: 180 * 1000\n    },\n    (job, callback) => {\n      Meteor.call(\"shop/flushCurrencyRate\", error => {\n        if (error) {\n          if (error.error === \"notExists\") {\n            Logger.error(error.message);\n            job.done(error.message, { repeatId: true });\n          } else {\n            // Logger.error(error.toString());\n            job.done(error.toString(), { repeatId: true });\n          }\n        } else {\n          // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n          // -job-will-be-automatically-re-run-by-the-job-collection\n          const success = \"Stale exchange rates were flushed.\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n        }\n      });\n      callback();\n    }\n  );\n\n  Jobs.find({\n    type: \"shop/flushCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return flushCurrencyRates.trigger();\n    }\n  });\n}\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/included/jobcontrol/server/jobs/exchangerates.js.map","sourceFileName":"/imports/plugins/included/jobcontrol/server/jobs/exchangerates.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"exchangerates"},"ignored":false,"code":"var later = void 0;\nmodule.importSync(\"later\", {\n  \"default\": function (v) {\n    later = v;\n  }\n}, 0);\nvar Jobs = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Jobs: function (v) {\n    Jobs = v;\n  }\n}, 1);\nvar Hooks = void 0,\n    Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Hooks: function (v) {\n    Hooks = v;\n  },\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 2);\n// While we don't necessarily need to wait for anything to add a job\n// in this case we need to have packages loaded so we can check for the OER API key\nHooks.Events.add(\"afterCoreInit\", function () {\n  var settings = Reaction.getShopSettings();\n  var exchangeConfig = settings.openexchangerates || {};\n\n  if (exchangeConfig.appId) {\n    var refreshPeriod = exchangeConfig.refreshPeriod || \"every 4 hours\";\n    Logger.debug(\"Adding shop/fetchCurrencyRates to JobControl. Refresh \" + refreshPeriod);\n    new Job(Jobs, \"shop/fetchCurrencyRates\", {}).priority(\"normal\").retry({\n      retries: 5,\n      wait: 60000,\n      backoff: \"exponential\" // delay by twice as long for each subsequent retry\n\n    }).repeat({\n      schedule: later.parse.text(refreshPeriod)\n    }).save({\n      // Cancel any jobs of the same type,\n      // but only if this job repeats forever.\n      cancelRepeats: true\n    });\n  } else {\n    Logger.warn(\"OpenExchangeRates API not configured. Not adding fetchRates job\");\n  }\n});\nHooks.Events.add(\"afterCoreInit\", function () {\n  var settings = Reaction.getShopSettings();\n  var exchangeConfig = settings.openexchangerates || {};\n\n  if (exchangeConfig.appId) {\n    Logger.debug(\"Adding shop/flushCurrencyRates to JobControl\"); // TODO: Add this as a configurable option\n\n    var refreshPeriod = \"Every 24 hours\";\n    new Job(Jobs, \"shop/flushCurrencyRates\", {}).priority(\"normal\").retry({\n      retries: 5,\n      wait: 60000,\n      backoff: \"exponential\"\n    }).repeat({\n      schedule: later.parse.text(refreshPeriod)\n    }).save({\n      cancelRepeats: true\n    });\n  } else {\n    Logger.warn(\"OpenExchangeRates API not configured. Not adding flushRates job\");\n  }\n});\nmodule.export(\"default\", exports.default = function () {\n  var fetchCurrencyRates = Jobs.processJobs(\"shop/fetchCurrencyRates\", {\n    pollInterval: 60 * 60 * 1000,\n    // backup polling, see observer below\n    workTimeout: 180 * 1000\n  }, function (job, callback) {\n    Meteor.call(\"shop/fetchCurrencyRate\", function (error) {\n      if (error) {\n        if (error.error === \"notConfigured\") {\n          Logger.error(error.message);\n          job.done(error.message, {\n            repeatId: true\n          });\n        } else {\n          job.done(error.toString(), {\n            repeatId: true\n          });\n        }\n      } else {\n        // we should always return \"completed\" job here, because errors are fine\n        // result for this task, so that's why we show message if error happens\n        // and return job.done();\n        // you can read more about job.repeat() here:\n        // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n        // -job-will-be-automatically-re-run-by-the-job-collection\n        var success = \"Latest exchange rates were fetched successfully.\";\n        Logger.debug(success);\n        job.done(success, {\n          repeatId: true\n        });\n      }\n    });\n    callback();\n  });\n  Jobs.find({\n    type: \"shop/fetchCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added: function () {\n      return fetchCurrencyRates.trigger();\n    }\n  });\n  var flushCurrencyRates = Jobs.processJobs(\"shop/flushCurrencyRates\", {\n    pollInterval: 60 * 60 * 1000,\n    // backup polling, see observer below\n    workTimeout: 180 * 1000\n  }, function (job, callback) {\n    Meteor.call(\"shop/flushCurrencyRate\", function (error) {\n      if (error) {\n        if (error.error === \"notExists\") {\n          Logger.error(error.message);\n          job.done(error.message, {\n            repeatId: true\n          });\n        } else {\n          // Logger.error(error.toString());\n          job.done(error.toString(), {\n            repeatId: true\n          });\n        }\n      } else {\n        // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n        // -job-will-be-automatically-re-run-by-the-job-collection\n        var success = \"Stale exchange rates were flushed.\";\n        Logger.debug(success);\n        job.done(success, {\n          repeatId: true\n        });\n      }\n    });\n    callback();\n  });\n  Jobs.find({\n    type: \"shop/flushCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added: function () {\n      return flushCurrencyRates.trigger();\n    }\n  });\n});","map":{"version":3,"sources":["/imports/plugins/included/jobcontrol/server/jobs/exchangerates.js"],"names":["later","Jobs","Hooks","Logger","Reaction","Events","add","settings","getShopSettings","exchangeConfig","openexchangerates","appId","refreshPeriod","debug","Job","priority","retry","retries","wait","backoff","repeat","schedule","parse","text","save","cancelRepeats","warn","fetchCurrencyRates","processJobs","pollInterval","workTimeout","job","callback","Meteor","call","error","message","done","repeatId","toString","success","find","type","status","observe","added","trigger","flushCurrencyRates"],"mappings":"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","file":"/imports/plugins/included/jobcontrol/server/jobs/exchangerates.js.map","sourcesContent":["import later from \"later\";\nimport { Jobs } from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\n// While we don't necessarily need to wait for anything to add a job\n// in this case we need to have packages loaded so we can check for the OER API key\nHooks.Events.add(\"afterCoreInit\", () => {\n  const settings = Reaction.getShopSettings();\n  const exchangeConfig = settings.openexchangerates || {};\n\n  if (exchangeConfig.appId) {\n    const refreshPeriod = exchangeConfig.refreshPeriod || \"every 4 hours\";\n    Logger.debug(`Adding shop/fetchCurrencyRates to JobControl. Refresh ${refreshPeriod}`);\n    new Job(Jobs, \"shop/fetchCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\" // delay by twice as long for each subsequent retry\n      })\n      .repeat({\n        schedule: later.parse.text(refreshPeriod)\n      })\n      .save({\n        // Cancel any jobs of the same type,\n        // but only if this job repeats forever.\n        cancelRepeats: true\n      });\n  } else {\n    Logger.warn(\"OpenExchangeRates API not configured. Not adding fetchRates job\");\n  }\n});\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  const settings = Reaction.getShopSettings();\n  const exchangeConfig = settings.openexchangerates || {};\n\n  if (exchangeConfig.appId) {\n    Logger.debug(\"Adding shop/flushCurrencyRates to JobControl\");\n    // TODO: Add this as a configurable option\n    const refreshPeriod = \"Every 24 hours\";\n    new Job(Jobs, \"shop/flushCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\"\n      })\n      .repeat({\n        schedule: later.parse.text(refreshPeriod)\n      })\n      .save({\n        cancelRepeats: true\n      });\n  } else {\n    Logger.warn(\"OpenExchangeRates API not configured. Not adding flushRates job\");\n  }\n});\n\n\nexport default function () {\n  const fetchCurrencyRates = Jobs.processJobs(\"shop/fetchCurrencyRates\", {\n    pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n    workTimeout: 180 * 1000\n  }, (job, callback) => {\n    Meteor.call(\"shop/fetchCurrencyRate\", (error) => {\n      if (error) {\n        if (error.error === \"notConfigured\") {\n          Logger.error(error.message);\n          job.done(error.message, { repeatId: true });\n        } else {\n          job.done(error.toString(), { repeatId: true });\n        }\n      } else {\n        // we should always return \"completed\" job here, because errors are fine\n        // result for this task, so that's why we show message if error happens\n        // and return job.done();\n        // you can read more about job.repeat() here:\n        // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n        // -job-will-be-automatically-re-run-by-the-job-collection\n        const success = \"Latest exchange rates were fetched successfully.\";\n        Logger.debug(success);\n        job.done(success, { repeatId: true });\n      }\n    });\n    callback();\n  });\n\n  Jobs.find({\n    type: \"shop/fetchCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return fetchCurrencyRates.trigger();\n    }\n  });\n\n\n  const flushCurrencyRates = Jobs.processJobs(\n    \"shop/flushCurrencyRates\", {\n      pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n      workTimeout: 180 * 1000\n    },\n    (job, callback) => {\n      Meteor.call(\"shop/flushCurrencyRate\", error => {\n        if (error) {\n          if (error.error === \"notExists\") {\n            Logger.error(error.message);\n            job.done(error.message, { repeatId: true });\n          } else {\n            // Logger.error(error.toString());\n            job.done(error.toString(), { repeatId: true });\n          }\n        } else {\n          // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n          // -job-will-be-automatically-re-run-by-the-job-collection\n          const success = \"Stale exchange rates were flushed.\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n        }\n      });\n      callback();\n    }\n  );\n\n  Jobs.find({\n    type: \"shop/flushCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return flushCurrencyRates.trigger();\n    }\n  });\n}\n"]},"hash":"3ba547982f320ea081c6dff51cbf94a88d6affc6"}
