{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/check","imported":["Match","check"],"specifiers":[{"kind":"named","imported":"Match","local":"Match"},{"kind":"named","imported":"check","local":"check"}]},{"source":"/server/api","imported":["Reaction"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"}]},{"source":"/lib/collections","imported":["Cart"],"specifiers":[{"kind":"named","imported":"Cart","local":"Cart"}]},{"source":"/imports/plugins/core/discounts/lib/collections","imported":["Discounts"],"specifiers":[{"kind":"named","imported":"Discounts","local":"Discounts"}]},{"source":"../../lib/collections/schemas","imported":["DiscountCodes"],"specifiers":[{"kind":"named","imported":"DiscountCodes","local":"DiscountSchema"}]}],"exports":{"exported":["methods"],"specifiers":[{"kind":"local","local":"methods","exported":"methods"}]}}},"options":{"filename":"/imports/plugins/included/discount-codes/server/methods/methods.js","filenameRelative":"/imports/plugins/included/discount-codes/server/methods/methods.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/included/discount-codes/server/methods/methods.js"],"names":["Meteor","Match","check","Reaction","Cart","Discounts","DiscountCodes","DiscountSchema","attachSchema","selector","discountMethod","methods","cartId","discountId","String","discount","findOne","cart","item","items","preDiscount","quantity","variants","price","preDiscountItemTotal","salePriceItemTotal","Math","max","shipping","shipmentMethod","name","rate","modifier","docId","Object","OneOf","undefined","hasPermission","Error","insert","update","id","codeId","collection","Collection","Collections","hasInvoice","currentDiscount","billing","paymentMethod","processor","_id","parseFloat","amount","invoice","$set","$pull","multi","code","userCount","orderCount","conditions","accountLimitExceeded","discountLimitExceeded","transactions","users","Array","from","t","userId","transactionCount","Map","Set","map","x","filter","y","length","orders","get","accountLimit","redemptionLimit","i18nKeyLabel","i18nKey","method","calculation","transactionId","Random","status","call"],"mappings":"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","file":"/imports/plugins/included/discount-codes/server/methods/methods.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Reaction } from \"/server/api\";\nimport { Cart } from \"/lib/collections\";\nimport { Discounts } from  \"/imports/plugins/core/discounts/lib/collections\";\nimport { DiscountCodes as DiscountSchema } from \"../../lib/collections/schemas\";\n\n// attach discount code specific schema\nDiscounts.attachSchema(DiscountSchema, { selector: { discountMethod: \"code\" } });\n\n//\n// make all discount methods available\n//\nexport const methods = {\n  /**\n   * discounts/codes/discount\n   * calculates percentage off discount rates\n   * we intentionally passed ids, instead\n   * of the cart,discount Object\n   * for a smaller request providing an\n   * additional level of validation.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/discount\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    for (const item of cart.items) {\n      const preDiscount = item.quantity * item.variants.price;\n      discount += preDiscount * discountMethod.discount / 100;\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/credit\n   * calculates a credit off cart\n   * for discount codes\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/credit\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    discount = discountMethod.discount;\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/sale\n   * calculates a new price for an item\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/sale\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    // TODO add item specific conditions to sale calculations.\n    for (const item of cart.items) {\n      const preDiscountItemTotal = item.quantity * item.variants.price;\n      const salePriceItemTotal = item.quantity * discountMethod.discount;\n      // we if the sale is below 0, we won't discount at all. that's invalid.\n      discount += Math.max(0, preDiscountItemTotal - salePriceItemTotal);\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/shipping\n   * calculates a discount based on the value\n   * of a calculated shipping rate in the cart.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/shipping\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    for (const shipping of cart.shipping) {\n      if (shipping.shipmentMethod && shipping.shipmentMethod.name === discountMethod.discount) {\n        discount += Math.max(0, shipping.shipmentMethod.rate);\n      }\n    }\n\n    return discount;\n  },\n  /**\n   * discounts/addCode\n   * @param  {String} modifier update statement\n   * @param  {String} docId discount docId\n   * @param  {String} qty create this many additional codes\n   * @return {String} returns update/insert result\n   */\n  \"discounts/addCode\": function (modifier, docId) {\n    check(modifier, Object);\n    check(docId, Match.OneOf(String, null, undefined));\n\n    // check permissions to add\n    if (!Reaction.hasPermission(\"discount-codes\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // if no doc, insert\n    if (!docId) {\n      return Discounts.insert(modifier);\n    }\n    // else update and return\n    return Discounts.update(docId, modifier);\n  },\n  /**\n   * discounts/codes/remove\n   * removes discounts that have been previously applied\n   * to a cart.\n   * @param  {String} id cart id of which to remove a code\n   * @param  {String} codeId discount Id from cart.billing\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {String} returns update/insert result\n   */\n  \"discounts/codes/remove\": function (id, codeId, collection = \"Cart\") {\n    check(id, String);\n    check(codeId, String);\n    check(collection, String);\n    const Collection = Reaction.Collections[collection];\n    //\n    // delete code from cart\n    //\n    const cart = Collection.findOne(id);\n    let hasInvoice = false;\n    let currentDiscount = 0;\n    for (const billing of cart.billing) {\n      if (billing.paymentMethod && billing.paymentMethod.processor === \"code\" && billing._id !== codeId) {\n        currentDiscount += parseFloat(billing.paymentMethod.amount);\n      }\n      if (billing.paymentMethod && billing.invoice) {\n        hasInvoice = true;\n      }\n    }\n    // only if this is an order\n    if (hasInvoice) {\n      const selector = {\n        \"_id\": id,\n        \"billing._id\": cart.billing[0]._id\n      };\n      const update = {\n        $set: {\n          \"billing.$.invoice.discounts\": currentDiscount\n        }\n      };\n      Collection.update(selector, update);\n    }\n    // TODO: update a history record of transaction\n    // TODO: recalculate cart discounts (not simply 0)\n    return Collection.update(\n      { _id: id },\n      { $set: { discount: currentDiscount }, $pull: { billing: { _id: codeId } } },\n      { multi: true }\n    );\n  },\n  /**\n   * discounts/codes/apply\n   * checks validity of code conditions and then\n   * applies a discount as a paymentMethod to cart\n   * @param  {String} id cart/order id of which to remove a code\n   * @param  {String} code valid discount code\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {Boolean} returns true if successfully applied\n   */\n  \"discounts/codes/apply\": function (id, code, collection = \"Cart\") {\n    check(id, String);\n    check(code, String);\n    check(collection, String);\n    let userCount = 0;\n    let orderCount = 0;\n\n    // TODO: further expand to meet all condition rules\n    // const conditions = {\n    //   enabled: true\n    // };\n\n    // TODO: add  conditions: conditions\n    const discount = Discounts.findOne({ code: code });\n\n    // TODO: check usage limit\n    // don't apply if cart has exceeded usage limit\n    // will also need to check all time usage.\n    // which means storing the use data with the Discounts\n    // or searching all user's order history\n    // and if a user cancels an order,\n    // is the discount now re-activated\n\n    if (discount) {\n      const { conditions } = discount;\n      let accountLimitExceeded = false;\n      let discountLimitExceeded = false;\n\n      // existing usage count\n      if (discount.transactions) {\n        const users = Array.from(discount.transactions, (t) => t.userId);\n        const transactionCount = new Map([...new Set(users)].map(\n          x => [x, users.filter(y => y === x).length]\n        ));\n        const orders = Array.from(discount.transactions, (t) => t.cartId);\n        userCount = transactionCount.get(Meteor.userId());\n        orderCount = orders.length;\n      }\n      // check limits\n      if (conditions) {\n        if (conditions.accountLimit) accountLimitExceeded = conditions.accountLimit <= userCount;\n        if (conditions.redemptionLimit) discountLimitExceeded = conditions.redemptionLimit <= orderCount;\n      }\n\n      // validate basic limit handling\n      if (accountLimitExceeded === true || discountLimitExceeded === true) {\n        return { i18nKeyLabel: \"Code is expired\", i18nKey: \"discounts.codeIsExpired\" };\n      }\n\n      // save to payment methods\n      // and update status in Discounts\n      // payment methods can be debit or credit.\n      const paymentMethod = {\n        id: discount._id,\n        processor: discount.discountMethod,\n        method: discount.calculation.method,\n        code: discount.code,\n        transactionId: Random.id(),\n        amount: discount.discount, // pre-process to amount.\n        status: \"created\"\n      };\n      return Meteor.call(\"payments/apply\", id, paymentMethod, collection);\n    }\n  }\n};\n\n// export methods to Meteor\nMeteor.methods(methods);\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/included/discount-codes/server/methods/methods.js.map","sourceFileName":"/imports/plugins/included/discount-codes/server/methods/methods.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"methods"},"ignored":false,"code":"function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nmodule.export({\n  methods: function () {\n    return methods;\n  }\n});\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar Match = void 0,\n    check = void 0;\nmodule.importSync(\"meteor/check\", {\n  Match: function (v) {\n    Match = v;\n  },\n  check: function (v) {\n    check = v;\n  }\n}, 1);\nvar Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 2);\nvar Cart = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Cart: function (v) {\n    Cart = v;\n  }\n}, 3);\nvar Discounts = void 0;\nmodule.importSync(\"/imports/plugins/core/discounts/lib/collections\", {\n  Discounts: function (v) {\n    Discounts = v;\n  }\n}, 4);\nvar DiscountSchema = void 0;\nmodule.importSync(\"../../lib/collections/schemas\", {\n  DiscountCodes: function (v) {\n    DiscountSchema = v;\n  }\n}, 5);\n// attach discount code specific schema\nDiscounts.attachSchema(DiscountSchema, {\n  selector: {\n    discountMethod: \"code\"\n  }\n}); //\n// make all discount methods available\n//\n\nvar methods = {\n  /**\n   * discounts/codes/discount\n   * calculates percentage off discount rates\n   * we intentionally passed ids, instead\n   * of the cart,discount Object\n   * for a smaller request providing an\n   * additional level of validation.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\"discounts/codes/discount\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    var discount = 0;\n    var discountMethod = Discounts.findOne(discountId);\n    var cart = Cart.findOne(cartId);\n\n    for (var _iterator = cart.items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var item = _ref;\n      var preDiscount = item.quantity * item.variants.price;\n      discount += preDiscount * discountMethod.discount / 100;\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/credit\n   * calculates a credit off cart\n   * for discount codes\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\"discounts/codes/credit\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    var discount = 0;\n    var discountMethod = Discounts.findOne(discountId);\n    discount = discountMethod.discount;\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/sale\n   * calculates a new price for an item\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\"discounts/codes/sale\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    var discount = 0;\n    var discountMethod = Discounts.findOne(discountId);\n    var cart = Cart.findOne(cartId); // TODO add item specific conditions to sale calculations.\n\n    for (var _iterator2 = cart.items, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var item = _ref2;\n      var preDiscountItemTotal = item.quantity * item.variants.price;\n      var salePriceItemTotal = item.quantity * discountMethod.discount; // we if the sale is below 0, we won't discount at all. that's invalid.\n\n      discount += Math.max(0, preDiscountItemTotal - salePriceItemTotal);\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/shipping\n   * calculates a discount based on the value\n   * of a calculated shipping rate in the cart.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\"discounts/codes/shipping\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    var discount = 0;\n    var discountMethod = Discounts.findOne(discountId);\n    var cart = Cart.findOne(cartId);\n\n    for (var _iterator3 = cart.shipping, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var shipping = _ref3;\n\n      if (shipping.shipmentMethod && shipping.shipmentMethod.name === discountMethod.discount) {\n        discount += Math.max(0, shipping.shipmentMethod.rate);\n      }\n    }\n\n    return discount;\n  },\n  /**\n   * discounts/addCode\n   * @param  {String} modifier update statement\n   * @param  {String} docId discount docId\n   * @param  {String} qty create this many additional codes\n   * @return {String} returns update/insert result\n   */\"discounts/addCode\": function (modifier, docId) {\n    check(modifier, Object);\n    check(docId, Match.OneOf(String, null, undefined)); // check permissions to add\n\n    if (!Reaction.hasPermission(\"discount-codes\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    } // if no doc, insert\n\n\n    if (!docId) {\n      return Discounts.insert(modifier);\n    } // else update and return\n\n\n    return Discounts.update(docId, modifier);\n  },\n  /**\n   * discounts/codes/remove\n   * removes discounts that have been previously applied\n   * to a cart.\n   * @param  {String} id cart id of which to remove a code\n   * @param  {String} codeId discount Id from cart.billing\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {String} returns update/insert result\n   */\"discounts/codes/remove\": function (id, codeId) {\n    var collection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Cart\";\n    check(id, String);\n    check(codeId, String);\n    check(collection, String);\n    var Collection = Reaction.Collections[collection]; //\n    // delete code from cart\n    //\n\n    var cart = Collection.findOne(id);\n    var hasInvoice = false;\n    var currentDiscount = 0;\n\n    for (var _iterator4 = cart.billing, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var billing = _ref4;\n\n      if (billing.paymentMethod && billing.paymentMethod.processor === \"code\" && billing._id !== codeId) {\n        currentDiscount += parseFloat(billing.paymentMethod.amount);\n      }\n\n      if (billing.paymentMethod && billing.invoice) {\n        hasInvoice = true;\n      }\n    } // only if this is an order\n\n\n    if (hasInvoice) {\n      var selector = {\n        \"_id\": id,\n        \"billing._id\": cart.billing[0]._id\n      };\n      var update = {\n        $set: {\n          \"billing.$.invoice.discounts\": currentDiscount\n        }\n      };\n      Collection.update(selector, update);\n    } // TODO: update a history record of transaction\n    // TODO: recalculate cart discounts (not simply 0)\n\n\n    return Collection.update({\n      _id: id\n    }, {\n      $set: {\n        discount: currentDiscount\n      },\n      $pull: {\n        billing: {\n          _id: codeId\n        }\n      }\n    }, {\n      multi: true\n    });\n  },\n  /**\n   * discounts/codes/apply\n   * checks validity of code conditions and then\n   * applies a discount as a paymentMethod to cart\n   * @param  {String} id cart/order id of which to remove a code\n   * @param  {String} code valid discount code\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {Boolean} returns true if successfully applied\n   */\"discounts/codes/apply\": function (id, code) {\n    var collection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Cart\";\n    check(id, String);\n    check(code, String);\n    check(collection, String);\n    var userCount = 0;\n    var orderCount = 0; // TODO: further expand to meet all condition rules\n    // const conditions = {\n    //   enabled: true\n    // };\n    // TODO: add  conditions: conditions\n\n    var discount = Discounts.findOne({\n      code: code\n    }); // TODO: check usage limit\n    // don't apply if cart has exceeded usage limit\n    // will also need to check all time usage.\n    // which means storing the use data with the Discounts\n    // or searching all user's order history\n    // and if a user cancels an order,\n    // is the discount now re-activated\n\n    if (discount) {\n      var conditions = discount.conditions;\n      var accountLimitExceeded = false;\n      var discountLimitExceeded = false; // existing usage count\n\n      if (discount.transactions) {\n        var users = Array.from(discount.transactions, function (t) {\n          return t.userId;\n        });\n        var transactionCount = new Map([].concat(_toConsumableArray(new Set(users))).map(function (x) {\n          return [x, users.filter(function (y) {\n            return y === x;\n          }).length];\n        }));\n        var orders = Array.from(discount.transactions, function (t) {\n          return t.cartId;\n        });\n        userCount = transactionCount.get(Meteor.userId());\n        orderCount = orders.length;\n      } // check limits\n\n\n      if (conditions) {\n        if (conditions.accountLimit) accountLimitExceeded = conditions.accountLimit <= userCount;\n        if (conditions.redemptionLimit) discountLimitExceeded = conditions.redemptionLimit <= orderCount;\n      } // validate basic limit handling\n\n\n      if (accountLimitExceeded === true || discountLimitExceeded === true) {\n        return {\n          i18nKeyLabel: \"Code is expired\",\n          i18nKey: \"discounts.codeIsExpired\"\n        };\n      } // save to payment methods\n      // and update status in Discounts\n      // payment methods can be debit or credit.\n\n\n      var paymentMethod = {\n        id: discount._id,\n        processor: discount.discountMethod,\n        method: discount.calculation.method,\n        code: discount.code,\n        transactionId: Random.id(),\n        amount: discount.discount,\n        // pre-process to amount.\n        status: \"created\"\n      };\n      return Meteor.call(\"payments/apply\", id, paymentMethod, collection);\n    }\n  }\n};\n// export methods to Meteor\nMeteor.methods(methods);","map":{"version":3,"sources":["/imports/plugins/included/discount-codes/server/methods/methods.js"],"names":["Meteor","Match","check","Reaction","Cart","Discounts","DiscountCodes","DiscountSchema","attachSchema","selector","discountMethod","methods","cartId","discountId","String","discount","findOne","cart","item","items","preDiscount","quantity","variants","price","preDiscountItemTotal","salePriceItemTotal","Math","max","shipping","shipmentMethod","name","rate","modifier","docId","Object","OneOf","undefined","hasPermission","Error","insert","update","id","codeId","collection","Collection","Collections","hasInvoice","currentDiscount","billing","paymentMethod","processor","_id","parseFloat","amount","invoice","$set","$pull","multi","code","userCount","orderCount","conditions","accountLimitExceeded","discountLimitExceeded","transactions","users","Array","from","t","userId","transactionCount","Map","Set","map","x","filter","y","length","orders","get","accountLimit","redemptionLimit","i18nKeyLabel","i18nKey","method","calculation","transactionId","Random","status","call"],"mappings":"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","file":"/imports/plugins/included/discount-codes/server/methods/methods.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Reaction } from \"/server/api\";\nimport { Cart } from \"/lib/collections\";\nimport { Discounts } from  \"/imports/plugins/core/discounts/lib/collections\";\nimport { DiscountCodes as DiscountSchema } from \"../../lib/collections/schemas\";\n\n// attach discount code specific schema\nDiscounts.attachSchema(DiscountSchema, { selector: { discountMethod: \"code\" } });\n\n//\n// make all discount methods available\n//\nexport const methods = {\n  /**\n   * discounts/codes/discount\n   * calculates percentage off discount rates\n   * we intentionally passed ids, instead\n   * of the cart,discount Object\n   * for a smaller request providing an\n   * additional level of validation.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/discount\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    for (const item of cart.items) {\n      const preDiscount = item.quantity * item.variants.price;\n      discount += preDiscount * discountMethod.discount / 100;\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/credit\n   * calculates a credit off cart\n   * for discount codes\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/credit\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    discount = discountMethod.discount;\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/sale\n   * calculates a new price for an item\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/sale\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    // TODO add item specific conditions to sale calculations.\n    for (const item of cart.items) {\n      const preDiscountItemTotal = item.quantity * item.variants.price;\n      const salePriceItemTotal = item.quantity * discountMethod.discount;\n      // we if the sale is below 0, we won't discount at all. that's invalid.\n      discount += Math.max(0, preDiscountItemTotal - salePriceItemTotal);\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/shipping\n   * calculates a discount based on the value\n   * of a calculated shipping rate in the cart.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/shipping\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    for (const shipping of cart.shipping) {\n      if (shipping.shipmentMethod && shipping.shipmentMethod.name === discountMethod.discount) {\n        discount += Math.max(0, shipping.shipmentMethod.rate);\n      }\n    }\n\n    return discount;\n  },\n  /**\n   * discounts/addCode\n   * @param  {String} modifier update statement\n   * @param  {String} docId discount docId\n   * @param  {String} qty create this many additional codes\n   * @return {String} returns update/insert result\n   */\n  \"discounts/addCode\": function (modifier, docId) {\n    check(modifier, Object);\n    check(docId, Match.OneOf(String, null, undefined));\n\n    // check permissions to add\n    if (!Reaction.hasPermission(\"discount-codes\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // if no doc, insert\n    if (!docId) {\n      return Discounts.insert(modifier);\n    }\n    // else update and return\n    return Discounts.update(docId, modifier);\n  },\n  /**\n   * discounts/codes/remove\n   * removes discounts that have been previously applied\n   * to a cart.\n   * @param  {String} id cart id of which to remove a code\n   * @param  {String} codeId discount Id from cart.billing\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {String} returns update/insert result\n   */\n  \"discounts/codes/remove\": function (id, codeId, collection = \"Cart\") {\n    check(id, String);\n    check(codeId, String);\n    check(collection, String);\n    const Collection = Reaction.Collections[collection];\n    //\n    // delete code from cart\n    //\n    const cart = Collection.findOne(id);\n    let hasInvoice = false;\n    let currentDiscount = 0;\n    for (const billing of cart.billing) {\n      if (billing.paymentMethod && billing.paymentMethod.processor === \"code\" && billing._id !== codeId) {\n        currentDiscount += parseFloat(billing.paymentMethod.amount);\n      }\n      if (billing.paymentMethod && billing.invoice) {\n        hasInvoice = true;\n      }\n    }\n    // only if this is an order\n    if (hasInvoice) {\n      const selector = {\n        \"_id\": id,\n        \"billing._id\": cart.billing[0]._id\n      };\n      const update = {\n        $set: {\n          \"billing.$.invoice.discounts\": currentDiscount\n        }\n      };\n      Collection.update(selector, update);\n    }\n    // TODO: update a history record of transaction\n    // TODO: recalculate cart discounts (not simply 0)\n    return Collection.update(\n      { _id: id },\n      { $set: { discount: currentDiscount }, $pull: { billing: { _id: codeId } } },\n      { multi: true }\n    );\n  },\n  /**\n   * discounts/codes/apply\n   * checks validity of code conditions and then\n   * applies a discount as a paymentMethod to cart\n   * @param  {String} id cart/order id of which to remove a code\n   * @param  {String} code valid discount code\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {Boolean} returns true if successfully applied\n   */\n  \"discounts/codes/apply\": function (id, code, collection = \"Cart\") {\n    check(id, String);\n    check(code, String);\n    check(collection, String);\n    let userCount = 0;\n    let orderCount = 0;\n\n    // TODO: further expand to meet all condition rules\n    // const conditions = {\n    //   enabled: true\n    // };\n\n    // TODO: add  conditions: conditions\n    const discount = Discounts.findOne({ code: code });\n\n    // TODO: check usage limit\n    // don't apply if cart has exceeded usage limit\n    // will also need to check all time usage.\n    // which means storing the use data with the Discounts\n    // or searching all user's order history\n    // and if a user cancels an order,\n    // is the discount now re-activated\n\n    if (discount) {\n      const { conditions } = discount;\n      let accountLimitExceeded = false;\n      let discountLimitExceeded = false;\n\n      // existing usage count\n      if (discount.transactions) {\n        const users = Array.from(discount.transactions, (t) => t.userId);\n        const transactionCount = new Map([...new Set(users)].map(\n          x => [x, users.filter(y => y === x).length]\n        ));\n        const orders = Array.from(discount.transactions, (t) => t.cartId);\n        userCount = transactionCount.get(Meteor.userId());\n        orderCount = orders.length;\n      }\n      // check limits\n      if (conditions) {\n        if (conditions.accountLimit) accountLimitExceeded = conditions.accountLimit <= userCount;\n        if (conditions.redemptionLimit) discountLimitExceeded = conditions.redemptionLimit <= orderCount;\n      }\n\n      // validate basic limit handling\n      if (accountLimitExceeded === true || discountLimitExceeded === true) {\n        return { i18nKeyLabel: \"Code is expired\", i18nKey: \"discounts.codeIsExpired\" };\n      }\n\n      // save to payment methods\n      // and update status in Discounts\n      // payment methods can be debit or credit.\n      const paymentMethod = {\n        id: discount._id,\n        processor: discount.discountMethod,\n        method: discount.calculation.method,\n        code: discount.code,\n        transactionId: Random.id(),\n        amount: discount.discount, // pre-process to amount.\n        status: \"created\"\n      };\n      return Meteor.call(\"payments/apply\", id, paymentMethod, collection);\n    }\n  }\n};\n\n// export methods to Meteor\nMeteor.methods(methods);\n"]},"hash":"0b250ad4d3c8cf268c5e78af2766e2612801d564"}
