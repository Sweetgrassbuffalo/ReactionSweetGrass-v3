{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"/lib/collections","imported":["Products"],"specifiers":[{"kind":"named","imported":"Products","local":"Products"}]},{"source":"/lib/api/products","imported":["applyProductRevision"],"specifiers":[{"kind":"named","imported":"applyProductRevision","local":"applyProductRevision"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/lib/api/catalog.js","filenameRelative":"/lib/api/catalog.js","inputSourceMap":{"version":3,"sources":["/lib/api/catalog.js"],"names":["Products","applyProductRevision","Catalog","setProduct","currentProductId","currentVariantId","productId","variantId","match","product","findOne","handle","toLowerCase","_id","setCurrentProduct","setCurrentVariant","getProductPriceRange","variants","getTopVariants","visibileVariant","filter","variant","isVisible","length","variantPrices","forEach","range","getVariantPriceRange","firstPrice","parseFloat","substr","indexOf","lastPrice","lastIndexOf","push","priceMin","_","min","priceMax","max","priceRange","toString","priceObject","price","children","getVariants","visibleChildren","child","topVariant","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","map","getVariantQuantity","options","reduce","sum","option","inventoryQuantity","getPublishedOrRevision","id","type","find","ancestors","$in"],"mappings":"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","file":"/lib/api/catalog.js.map","sourcesContent":["import { Products } from \"/lib/collections\";\nimport { applyProductRevision } from \"/lib/api/products\";\n\nexport default Catalog = {\n  /**\n   * setProduct\n   * @summary method to set default/parameterized product variant\n   * @param {String} currentProductId - set current productId\n   * @param {String} currentVariantId - set current variantId\n   * @return {undefined} return nothing, sets in session\n   */\n  setProduct(currentProductId, currentVariantId) {\n    let productId = currentProductId;\n    const variantId = currentVariantId;\n    if (!productId.match(/^[A-Za-z0-9]{17}$/)) {\n      const product = Products.findOne({\n        handle: productId.toLowerCase()\n      });\n      if (product) {\n        productId = product._id;\n      }\n    }\n    setCurrentProduct(productId);\n    setCurrentVariant(variantId);\n  },\n\n  /**\n   * getProductPriceRange\n   * @summary get price range of a product\n   * if no only one price available, return it\n   * otherwise return a string range\n   * @todo remove string return and replace with object\n   * @todo move all this methods this to export function after 1.3\n   * @param {String} [productId] - current product _id\n   * @return {Object} range, min, max\n   */\n  getProductPriceRange(productId) {\n    const product = applyProductRevision(Products.findOne(productId));\n    if (!product) {\n      return \"\";\n    }\n    const variants = this.getTopVariants(product._id);\n    // if we have variants we have a price range.\n    // this processing will default on the server\n    const visibileVariant = variants.filter(variant => variant.isVisible === true);\n\n    if (visibileVariant.length > 0) {\n      const variantPrices = [];\n      variants.forEach(variant => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n      const priceMin = _.min(variantPrices);\n      const priceMax = _.max(variantPrices);\n      let priceRange = `${priceMin} - ${priceMax}`;\n      // if we don't have a range\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n      const priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    }\n    // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n    return product.price;\n  },\n\n  /**\n   * getVariantPriceRange\n   * @summary get price range of a variant if it has child options.\n   * if no child options, return main price value\n   * @todo remove string return and replace with object\n   * @param {String} [variantId] - current variant _Id\n   * @return {String} formatted price or price range\n   */\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter(child => child.isVisible);\n\n    switch (visibleChildren.length) {\n      case 0:\n        const topVariant = applyProductRevision(Products.findOne(variantId));\n        // topVariant could be undefined when we removing last top variant\n        return topVariant && topVariant.price;\n      case 1:\n        return visibleChildren[0].price;\n      default:\n        let priceMin = Number.POSITIVE_INFINITY;\n        let priceMax = Number.NEGATIVE_INFINITY;\n\n        children.map(child => {\n          if (child.isVisible === true) {\n            if (child.price < priceMin) {\n              priceMin = child.price;\n            }\n            if (child.price > priceMax) {\n              priceMax = child.price;\n            }\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n        return `${priceMin} - ${priceMax}`;\n    }\n  },\n\n  /**\n   * getVariantQuantity\n   * @description calculate a sum of descendants `inventoryQuantity`\n   * @param {Object} variant - top-level variant\n   * @return {Number} summary of options quantity\n   */\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n    if (options && options.length) {\n      return options.reduce((sum, option) =>\n      sum + option.inventoryQuantity || 0, 0);\n    }\n    return variant.inventoryQuantity || 0;\n  },\n\n  /**\n   * @method getPublishedOrRevision\n   * @description return top product revision if available\n   * @param {Object} product product or variant document\n   * @return {Object} product document\n   */\n  getPublishedOrRevision(product) {\n    return applyProductRevision(product);\n  },\n\n  /**\n   * @method getVariants\n   * @description Get all parent variants\n   * @summary could be useful for products and for top level variants\n   * @param {String} [id] - product _id\n   * @param {String} [type] - type of variant\n   * @return {Array} Parent variants or empty array\n   */\n  getVariants(id, type) {\n    return Products.find({\n      ancestors: { $in: [id] },\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getTopVariants\n   * @description Get only product top level variants\n   * @param {String} [id] - product _id\n   * @return {Array} Product top level variants or empty array\n   */\n  getTopVariants(id) {\n    return Products.find({\n      ancestors: [id],\n      type: \"variant\"\n    }).map(this.getPublishedOrRevision);\n  }\n};\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/lib/api/catalog.js.map","sourceFileName":"/lib/api/catalog.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"catalog"},"ignored":false,"code":"var Products = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Products: function (v) {\n    Products = v;\n  }\n}, 0);\nvar applyProductRevision = void 0;\nmodule.importSync(\"/lib/api/products\", {\n  applyProductRevision: function (v) {\n    applyProductRevision = v;\n  }\n}, 1);\nmodule.export(\"default\", exports.default = Catalog = {\n  /**\n   * setProduct\n   * @summary method to set default/parameterized product variant\n   * @param {String} currentProductId - set current productId\n   * @param {String} currentVariantId - set current variantId\n   * @return {undefined} return nothing, sets in session\n   */setProduct: function (currentProductId, currentVariantId) {\n    var productId = currentProductId;\n    var variantId = currentVariantId;\n\n    if (!productId.match(/^[A-Za-z0-9]{17}$/)) {\n      var product = Products.findOne({\n        handle: productId.toLowerCase()\n      });\n\n      if (product) {\n        productId = product._id;\n      }\n    }\n\n    setCurrentProduct(productId);\n    setCurrentVariant(variantId);\n  },\n  /**\n   * getProductPriceRange\n   * @summary get price range of a product\n   * if no only one price available, return it\n   * otherwise return a string range\n   * @todo remove string return and replace with object\n   * @todo move all this methods this to export function after 1.3\n   * @param {String} [productId] - current product _id\n   * @return {Object} range, min, max\n   */getProductPriceRange: function (productId) {\n    var _this = this;\n\n    var product = applyProductRevision(Products.findOne(productId));\n\n    if (!product) {\n      return \"\";\n    }\n\n    var variants = this.getTopVariants(product._id); // if we have variants we have a price range.\n    // this processing will default on the server\n\n    var visibileVariant = variants.filter(function (variant) {\n      return variant.isVisible === true;\n    });\n\n    if (visibileVariant.length > 0) {\n      var variantPrices = [];\n      variants.forEach(function (variant) {\n        if (variant.isVisible === true) {\n          var range = _this.getVariantPriceRange(variant._id);\n\n          if (typeof range === \"string\") {\n            var firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            var lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n\n      var priceMin = _.min(variantPrices);\n\n      var priceMax = _.max(variantPrices);\n\n      var priceRange = priceMin + \" - \" + priceMax; // if we don't have a range\n\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n\n      var priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    } // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n\n\n    return product.price;\n  },\n  /**\n   * getVariantPriceRange\n   * @summary get price range of a variant if it has child options.\n   * if no child options, return main price value\n   * @todo remove string return and replace with object\n   * @param {String} [variantId] - current variant _Id\n   * @return {String} formatted price or price range\n   */getVariantPriceRange: function (variantId) {\n    var children = this.getVariants(variantId);\n    var visibleChildren = children.filter(function (child) {\n      return child.isVisible;\n    });\n\n    switch (visibleChildren.length) {\n      case 0:\n        var topVariant = applyProductRevision(Products.findOne(variantId)); // topVariant could be undefined when we removing last top variant\n\n        return topVariant && topVariant.price;\n\n      case 1:\n        return visibleChildren[0].price;\n\n      default:\n        var priceMin = Number.POSITIVE_INFINITY;\n        var priceMax = Number.NEGATIVE_INFINITY;\n        children.map(function (child) {\n          if (child.isVisible === true) {\n            if (child.price < priceMin) {\n              priceMin = child.price;\n            }\n\n            if (child.price > priceMax) {\n              priceMax = child.price;\n            }\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n\n        return priceMin + \" - \" + priceMax;\n    }\n  },\n  /**\n   * getVariantQuantity\n   * @description calculate a sum of descendants `inventoryQuantity`\n   * @param {Object} variant - top-level variant\n   * @return {Number} summary of options quantity\n   */getVariantQuantity: function (variant) {\n    var options = this.getVariants(variant._id);\n\n    if (options && options.length) {\n      return options.reduce(function (sum, option) {\n        return sum + option.inventoryQuantity || 0;\n      }, 0);\n    }\n\n    return variant.inventoryQuantity || 0;\n  },\n  /**\n   * @method getPublishedOrRevision\n   * @description return top product revision if available\n   * @param {Object} product product or variant document\n   * @return {Object} product document\n   */getPublishedOrRevision: function (product) {\n    return applyProductRevision(product);\n  },\n  /**\n   * @method getVariants\n   * @description Get all parent variants\n   * @summary could be useful for products and for top level variants\n   * @param {String} [id] - product _id\n   * @param {String} [type] - type of variant\n   * @return {Array} Parent variants or empty array\n   */getVariants: function (id, type) {\n    return Products.find({\n      ancestors: {\n        $in: [id]\n      },\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n  /**\n   * @method getTopVariants\n   * @description Get only product top level variants\n   * @param {String} [id] - product _id\n   * @return {Array} Product top level variants or empty array\n   */getTopVariants: function (id) {\n    return Products.find({\n      ancestors: [id],\n      type: \"variant\"\n    }).map(this.getPublishedOrRevision);\n  }\n});","map":{"version":3,"sources":["/lib/api/catalog.js"],"names":["Products","applyProductRevision","Catalog","setProduct","currentProductId","currentVariantId","productId","variantId","match","product","findOne","handle","toLowerCase","_id","setCurrentProduct","setCurrentVariant","getProductPriceRange","variants","getTopVariants","visibileVariant","filter","variant","isVisible","length","variantPrices","forEach","range","getVariantPriceRange","firstPrice","parseFloat","substr","indexOf","lastPrice","lastIndexOf","push","priceMin","_","min","priceMax","max","priceRange","toString","priceObject","price","children","getVariants","visibleChildren","child","topVariant","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","map","getVariantQuantity","options","reduce","sum","option","inventoryQuantity","getPublishedOrRevision","id","type","find","ancestors","$in"],"mappings":"AAAA;;;;;;;;;;;GACA,AAAS,AAA4B,AAErC,AAAe,AAAU,AACvB;OAJO,OAAT,WAAyB,QAAzB;AAWE,AAAW,AAAkB,AAAkB,AAC7C,AAAI,AAAY,AAChB;;;;;;KAAM,sBAAY,kBAAlB;oBACA;AAAI,AAAC,QAAU,YAAf,AAAK,AAAgB,AAAsB,AACzC;;SAAM,UAAU,MAAA,AAAS,AAAQ,sBAC/B;UAAQ,mBAAA;AADV,0BAGA;AAHgB,AAAiB,OACb;;UAEpB,AAAI,SAAS,AACX;oBAAY,QAAZ,AAAoB,AACrB;AACF;;;sBACD;sBAAA,AAAkB,AAClB;AApBqB,AAoBrB,AAAkB,AACnB;AAED;;;;;;;;;KAUA,gCAAqB;AAArB,AAAgC,AAC9B;;QAAM,UAAU,qBAAqB,SAAA,AAAS,QAA9C,AAAgB,AAAqB,AAAiB;;kBACtD;AAAI,AAAC,aAAL,AAAc,AACZ;AAAA,AAAO,AACR;;qDACD;AAL8B,AAK9B,AAAM,AAAW,AAAK,AAAe,AAAQ,AAC7C,AACA;;;mCACA;;;QAAM,gBAAkB,YAAxB,AAAwB,AAAS,AAAO,AAAW,AAAQ,AAAc;0BAEzE;AAAI,uBAAA,AAAgB,AAAS,mBAA7B,AAAgC,AAC9B;YAAM,QAAN,AAAsB,oBACtB;AAAS,cAAT,AAAiB,cAAW,6BAC1B;;AAAI,cAAQ,OAAR,UAAJ,AAA0B,AAAM,UAC9B;AAAM,gBAAQ,AAAK,8BAAL,AAA0B,UAAxC,AAAc,AAAkC;6EAChD;AAAI,AAAO,0BAAP,KAAJ,AAAqB,AAAU,YAC7B;iBAAA,AAAM,AAAa,AAAW,AAAM,AAAO,AAAG,AAAM,AAAQ,AAC5D;AAAM,0BAAY,KAAlB,AAAkB,AAAW,AAAM,AAAO,AAAM,AAAY,AAAO,AACnE;AAAA,AAAc,AAAK,AAAY,AAChC;AAJD,eAIO,AACL;wBAAc,KAAd,AAAmB,GAAnB,AACD;AACF;AATD,AASO,AACL;;qBAAc,EAAd,IAAA,AAAmB,AAAG,AACvB;;2BACF;;AAbD,oDAcA;;UAAM,aAAW,AAAE,AAAI,UAAvB,AAAiB;8BACjB;AAAA,AAAM,AAAW,AAAE,AAAI;;;AACnB,eAlB0B,AAkB9B,AAAkB,AAAE,AAAS,AAAK,AAAS,AAC3C;aACA;AAAI,aAAJ,AAAiB,AAAU,AACzB,AAAa,AAAS,AACvB;AAJD;;AAKA,MAAM,AAAc,AAClB;AADkB,AACX,AACP;;;WAAK,QAFa,AAGlB;AAHF,AAAoB,AAGb,AAEP;AAvEmB,AAiCS,AAsC5B,AAAO,AACR,AACD,AACA,AACA,AAAO,AAAQ,AAChB,AAED;;;;;;;;;;;;;;;+DAQA,aAAA,AAAqB,AAAW,AAC9B;;AAAM,eAAW,AAAK,cAAL,AAAiB,WAAlC,AAAiB,AACjB;;AAAM,WAAN,AAAwB,AAAS,AAAO,AAAS,AAAM;kCAEvD;;AAAA,AAAQ,AAAgB,AACtB;AAAK,YAAL,kBACE;YAAM,WAAa,OADrB,AACE,AAAmB,AAAqB,AAAS,AAAQ,AACzD,AACA;AAAO,qBAAc,iBAArB,AAAgC;wCAClC,AAAK;AAAL,wCACE;AAAO,+BAAP,AAAO,AAAgB,AAAG;AAC5B;;wCACE,AAAI;AAAW,yBAAO,MAAtB,AACA,AAAI;AAAJ,AAAe,AAAO,AAEtB;AAAA,AAAS,AAAI,AAAS,AACpB;AAAA,AAAI,AAAM,AAAc,AAAM,AAC5B,AAAI,AAAM,AAAQ,AAAU,AAC1B;;yBAAW,AAAM,UAAjB,AACD;;0BACD;AAAA,AAAI,AAAM,AAAQ,AAAU,AAC1B;;eAAW,AAAM,mBAAjB,AACD,AACF;;AARH,AASC;AAED,AAAI,AAAa,AAAU,AACzB,AACA,AAAO,AAAS,AACjB,AACD;;;;;KAAQ,AAAE,8BAAS,SA1BvB,AA0BI,AAAwB,AAAS;2CApHhB,AAsHtB;;;2CAED;;;;;;;AAMA,AAAmB,AAAS,AAC1B,AAAM,AAAU,AAAK,AAAY,AAAQ,AACzC,AAAI,AAAW,AAAQ,AAAQ,AAC7B,AAAO,AAAQ,AAAO,AAAC,AAAK,AAC5B,AAAM,AAAO,AAAqB,AAAG,AACtC;;;;;gDACD;WAAO,AAAQ,qBAAf,AAAO,AAA6B,AACrC;AArIsB,AAuIvB;AAvIuB,AA6IvB,AAAuB,AAAS,AAC9B,AAAO,AAAqB,AAC7B;;;;;;;sCAED;;;;;;;;AAQA,AAAY,AAAI,AAAM,AACpB,AAAO,AAAS,AAAK,AACnB,AAAW,AAAE,AAAK,AAAC,AACnB;;;;;KAAM,0BAAQ,IAFK;AAAd,AAGJ;;YAGL;AAhKuB,AA0JrB,AAAO,AAIR,KADQ,AAAK;AA7JhB,AAAyB,AAsKvB,AAAe,AAAI,AACjB,AAAO,AAAS,AAAK,AACnB,AAAW,AAAC,AACZ,AAAM,AACL,AAAI,AAAK,AACb","file":"/lib/api/catalog.js.map","sourcesContent":["import { Products } from \"/lib/collections\";\nimport { applyProductRevision } from \"/lib/api/products\";\n\nexport default Catalog = {\n  /**\n   * setProduct\n   * @summary method to set default/parameterized product variant\n   * @param {String} currentProductId - set current productId\n   * @param {String} currentVariantId - set current variantId\n   * @return {undefined} return nothing, sets in session\n   */\n  setProduct(currentProductId, currentVariantId) {\n    let productId = currentProductId;\n    const variantId = currentVariantId;\n    if (!productId.match(/^[A-Za-z0-9]{17}$/)) {\n      const product = Products.findOne({\n        handle: productId.toLowerCase()\n      });\n      if (product) {\n        productId = product._id;\n      }\n    }\n    setCurrentProduct(productId);\n    setCurrentVariant(variantId);\n  },\n\n  /**\n   * getProductPriceRange\n   * @summary get price range of a product\n   * if no only one price available, return it\n   * otherwise return a string range\n   * @todo remove string return and replace with object\n   * @todo move all this methods this to export function after 1.3\n   * @param {String} [productId] - current product _id\n   * @return {Object} range, min, max\n   */\n  getProductPriceRange(productId) {\n    const product = applyProductRevision(Products.findOne(productId));\n    if (!product) {\n      return \"\";\n    }\n    const variants = this.getTopVariants(product._id);\n    // if we have variants we have a price range.\n    // this processing will default on the server\n    const visibileVariant = variants.filter(variant => variant.isVisible === true);\n\n    if (visibileVariant.length > 0) {\n      const variantPrices = [];\n      variants.forEach(variant => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n      const priceMin = _.min(variantPrices);\n      const priceMax = _.max(variantPrices);\n      let priceRange = `${priceMin} - ${priceMax}`;\n      // if we don't have a range\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n      const priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    }\n    // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n    return product.price;\n  },\n\n  /**\n   * getVariantPriceRange\n   * @summary get price range of a variant if it has child options.\n   * if no child options, return main price value\n   * @todo remove string return and replace with object\n   * @param {String} [variantId] - current variant _Id\n   * @return {String} formatted price or price range\n   */\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter(child => child.isVisible);\n\n    switch (visibleChildren.length) {\n      case 0:\n        const topVariant = applyProductRevision(Products.findOne(variantId));\n        // topVariant could be undefined when we removing last top variant\n        return topVariant && topVariant.price;\n      case 1:\n        return visibleChildren[0].price;\n      default:\n        let priceMin = Number.POSITIVE_INFINITY;\n        let priceMax = Number.NEGATIVE_INFINITY;\n\n        children.map(child => {\n          if (child.isVisible === true) {\n            if (child.price < priceMin) {\n              priceMin = child.price;\n            }\n            if (child.price > priceMax) {\n              priceMax = child.price;\n            }\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n        return `${priceMin} - ${priceMax}`;\n    }\n  },\n\n  /**\n   * getVariantQuantity\n   * @description calculate a sum of descendants `inventoryQuantity`\n   * @param {Object} variant - top-level variant\n   * @return {Number} summary of options quantity\n   */\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n    if (options && options.length) {\n      return options.reduce((sum, option) =>\n      sum + option.inventoryQuantity || 0, 0);\n    }\n    return variant.inventoryQuantity || 0;\n  },\n\n  /**\n   * @method getPublishedOrRevision\n   * @description return top product revision if available\n   * @param {Object} product product or variant document\n   * @return {Object} product document\n   */\n  getPublishedOrRevision(product) {\n    return applyProductRevision(product);\n  },\n\n  /**\n   * @method getVariants\n   * @description Get all parent variants\n   * @summary could be useful for products and for top level variants\n   * @param {String} [id] - product _id\n   * @param {String} [type] - type of variant\n   * @return {Array} Parent variants or empty array\n   */\n  getVariants(id, type) {\n    return Products.find({\n      ancestors: { $in: [id] },\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getTopVariants\n   * @description Get only product top level variants\n   * @param {String} [id] - product _id\n   * @return {Array} Product top level variants or empty array\n   */\n  getTopVariants(id) {\n    return Products.find({\n      ancestors: [id],\n      type: \"variant\"\n    }).map(this.getPublishedOrRevision);\n  }\n};\n"]},"hash":"18767ecb376033ba7da2a2616e7cd0edb9b9ff42"}
