{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"/lib/collections","imported":["Tags"],"specifiers":[{"kind":"named","imported":"Tags","local":"Tags"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/session","imported":["Session"],"specifiers":[{"kind":"named","imported":"Session","local":"Session"}]},{"source":"meteor/templating","imported":["Template"],"specifiers":[{"kind":"named","imported":"Template","local":"Template"}]}],"exports":{"exported":["TagHelpers"],"specifiers":[{"kind":"local","local":"TagHelpers","exported":"TagHelpers"}]}}},"options":{"filename":"/imports/plugins/core/ui-tagnav/client/helpers/tags.js","filenameRelative":"/imports/plugins/core/ui-tagnav/client/helpers/tags.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/core/ui-tagnav/client/helpers/tags.js"],"names":["Tags","Meteor","Session","Template","TagHelpers","moveItem","oldArray","fromIndex","toIndex","newArray","splice","subTags","parentTag","_","isArray","relatedTagIds","tags","find","isTopLevel","_id","$in","fetch","map","tagId","tagObject","currentTag","get","getTags","sort","position","tag","set","createTag","tagName","parentTagId","call","error","Alerts","toast","i18next","t","updateTag","moveTagToNewParent","movedTagId","toListId","ofList","result","update","$addToSet","$set","sortTags","tagIds","isEmpty","indexOf","compact","removeTag","$pullAll","registerHelper"],"mappings":"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","file":"/imports/plugins/core/ui-tagnav/client/helpers/tags.js.map","sourcesContent":["import { Tags } from \"/lib/collections\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Session } from \"meteor/session\";\nimport { Template } from \"meteor/templating\";\n\n/**\n * Reaction TagNav shared helpers\n * @type {Object}\n */\nexport const TagHelpers = {\n  moveItem(oldArray, fromIndex, toIndex) {\n    const newArray = [...oldArray];\n    newArray.splice(toIndex, 0, newArray.splice(fromIndex, 1)[0]);\n    return newArray;\n  },\n\n  subTags(parentTag) {\n    if (_.isArray(parentTag.relatedTagIds)) {\n      const tags = Tags.find({\n        isTopLevel: false,\n        _id: {\n          $in: parentTag.relatedTagIds\n        }\n      }).fetch();\n\n      const subTags = parentTag.relatedTagIds.map((tagId) => {\n        return _.find(tags, (tagObject) => {\n          return tagObject._id === tagId;\n        });\n      });\n\n      return subTags;\n    }\n\n    return false;\n  },\n\n  currentTag() {\n    return Session.get(\"currentTag\");\n  },\n\n  getTags() {\n    let tags = [];\n\n    tags = Tags.find({\n      isTopLevel: true\n    }, {\n      sort: {\n        position: 1\n      }\n    }).fetch();\n    /*\n    if (this.tagIds) {\n      for (let relatedTagId of this.tagIds) {\n        if (!_.find(tags, {\n          _id: relatedTagId\n        })) {\n          tags.push(Tags.findOne(relatedTagId));\n        }\n      }\n    }*/\n\n    if (this.tag) {\n      Session.set(\"currentTag\", this.tag._id);\n    } else {\n      Session.set(\"currentTag\", \"\");\n    }\n\n    return tags;\n    // there are cases where\n    // we'll have no tags, and sort will error\n    // so we check length for safety\n    // if (tags) {\n    //   tags.sort(function (a, b) {\n    //     return a.position - b.position;\n    //   });\n    //   return tags;\n    // }\n  },\n\n  createTag(tagName, tagId, parentTag) {\n    let parentTagId;\n\n    if (parentTag) {\n      parentTagId = parentTag._id;\n    }\n\n    Meteor.call(\"shop/updateHeaderTags\", tagName, null, parentTagId,\n      function (error) {\n        if (error) {\n          Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n        }\n      });\n  },\n\n  updateTag(tagId, tagName, parentTagId) {\n    Meteor.call(\"shop/updateHeaderTags\", tagName, tagId, parentTagId,\n      function (error) {\n        if (error) {\n          Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n        }\n      });\n  },\n\n  /* eslint no-unused-vars: 0 */\n  //\n  //   TODO review toIndex, ofList variable implementation in tags.js moveTagToNewParent\n  //\n  moveTagToNewParent(movedTagId, toListId, toIndex, ofList) {\n    if (movedTagId) {\n      if (toListId) {\n        const result = Tags.update(toListId,\n          {\n            $addToSet: {\n              relatedTagIds: movedTagId\n            }\n          }\n        );\n\n        return result;\n      }\n\n      const result = Tags.update(movedTagId,\n        {\n          $set: {\n            isTopLevel: true\n          }\n        }\n      );\n\n      return result;\n    }\n    return 0;\n  },\n\n  sortTags(tagIds, parentTag) {\n    if (_.isArray(tagIds)) {\n      if (_.isEmpty(parentTag)) {\n        // Top level tags\n        for (const tagId of tagIds) {\n          Tags.update(tagId, {\n            $set: {\n              position: tagIds.indexOf(tagId)\n            }\n          });\n        }\n      } else {\n        // Sub tags\n        Tags.update(parentTag._id, {\n          $set: {\n            relatedTagIds: _.compact(tagIds)\n          }\n        });\n      }\n    }\n  },\n\n  removeTag(tag, parentTag) {\n    if (_.isEmpty(parentTag) === false) {\n      Tags.update(parentTag._id,\n        {\n          $pullAll: {\n            relatedTagIds: [tag._id]\n          }\n        }\n      );\n    } else if (tag.isTopLevel === true) {\n      Tags.update(tag._id,\n        {\n          $set: {\n            isTopLevel: false\n          }\n        }\n      );\n    }\n  }\n};\n\nTemplate.registerHelper(\"reactionSubTags\", TagHelpers.subTags);\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/core/ui-tagnav/client/helpers/tags.js.map","sourceFileName":"/imports/plugins/core/ui-tagnav/client/helpers/tags.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"tags"},"ignored":false,"code":"function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nmodule.export({\n  TagHelpers: function () {\n    return TagHelpers;\n  }\n});\nvar Tags = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Tags: function (v) {\n    Tags = v;\n  }\n}, 0);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 1);\nvar Session = void 0;\nmodule.importSync(\"meteor/session\", {\n  Session: function (v) {\n    Session = v;\n  }\n}, 2);\nvar Template = void 0;\nmodule.importSync(\"meteor/templating\", {\n  Template: function (v) {\n    Template = v;\n  }\n}, 3);\nvar TagHelpers = {\n  moveItem: function (oldArray, fromIndex, toIndex) {\n    var newArray = [].concat(_toConsumableArray(oldArray));\n    newArray.splice(toIndex, 0, newArray.splice(fromIndex, 1)[0]);\n    return newArray;\n  },\n  subTags: function (parentTag) {\n    if (_.isArray(parentTag.relatedTagIds)) {\n      var tags = Tags.find({\n        isTopLevel: false,\n        _id: {\n          $in: parentTag.relatedTagIds\n        }\n      }).fetch();\n      var subTags = parentTag.relatedTagIds.map(function (tagId) {\n        return _.find(tags, function (tagObject) {\n          return tagObject._id === tagId;\n        });\n      });\n      return subTags;\n    }\n\n    return false;\n  },\n  currentTag: function () {\n    return Session.get(\"currentTag\");\n  },\n  getTags: function () {\n    var tags = [];\n    tags = Tags.find({\n      isTopLevel: true\n    }, {\n      sort: {\n        position: 1\n      }\n    }).fetch(); /*\n                if (this.tagIds) {\n                  for (let relatedTagId of this.tagIds) {\n                    if (!_.find(tags, {\n                      _id: relatedTagId\n                    })) {\n                      tags.push(Tags.findOne(relatedTagId));\n                    }\n                  }\n                }*/\n\n    if (this.tag) {\n      Session.set(\"currentTag\", this.tag._id);\n    } else {\n      Session.set(\"currentTag\", \"\");\n    }\n\n    return tags; // there are cases where\n    // we'll have no tags, and sort will error\n    // so we check length for safety\n    // if (tags) {\n    //   tags.sort(function (a, b) {\n    //     return a.position - b.position;\n    //   });\n    //   return tags;\n    // }\n  },\n  createTag: function (tagName, tagId, parentTag) {\n    var parentTagId = void 0;\n\n    if (parentTag) {\n      parentTagId = parentTag._id;\n    }\n\n    Meteor.call(\"shop/updateHeaderTags\", tagName, null, parentTagId, function (error) {\n      if (error) {\n        Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n      }\n    });\n  },\n  updateTag: function (tagId, tagName, parentTagId) {\n    Meteor.call(\"shop/updateHeaderTags\", tagName, tagId, parentTagId, function (error) {\n      if (error) {\n        Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n      }\n    });\n  },\n  /* eslint no-unused-vars: 0 */ //\n  //   TODO review toIndex, ofList variable implementation in tags.js moveTagToNewParent\n  //\n  moveTagToNewParent: function (movedTagId, toListId, toIndex, ofList) {\n    if (movedTagId) {\n      if (toListId) {\n        var _result = Tags.update(toListId, {\n          $addToSet: {\n            relatedTagIds: movedTagId\n          }\n        });\n\n        return _result;\n      }\n\n      var result = Tags.update(movedTagId, {\n        $set: {\n          isTopLevel: true\n        }\n      });\n      return result;\n    }\n\n    return 0;\n  },\n  sortTags: function (tagIds, parentTag) {\n    if (_.isArray(tagIds)) {\n      if (_.isEmpty(parentTag)) {\n        // Top level tags\n        for (var _iterator = tagIds, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var tagId = _ref;\n          Tags.update(tagId, {\n            $set: {\n              position: tagIds.indexOf(tagId)\n            }\n          });\n        }\n      } else {\n        // Sub tags\n        Tags.update(parentTag._id, {\n          $set: {\n            relatedTagIds: _.compact(tagIds)\n          }\n        });\n      }\n    }\n  },\n  removeTag: function (tag, parentTag) {\n    if (_.isEmpty(parentTag) === false) {\n      Tags.update(parentTag._id, {\n        $pullAll: {\n          relatedTagIds: [tag._id]\n        }\n      });\n    } else if (tag.isTopLevel === true) {\n      Tags.update(tag._id, {\n        $set: {\n          isTopLevel: false\n        }\n      });\n    }\n  }\n};\nTemplate.registerHelper(\"reactionSubTags\", TagHelpers.subTags);","map":{"version":3,"sources":["/imports/plugins/core/ui-tagnav/client/helpers/tags.js"],"names":["Tags","Meteor","Session","Template","TagHelpers","moveItem","oldArray","fromIndex","toIndex","newArray","splice","subTags","parentTag","_","isArray","relatedTagIds","tags","find","isTopLevel","_id","$in","fetch","map","tagId","tagObject","currentTag","get","getTags","sort","position","tag","set","createTag","tagName","parentTagId","call","error","Alerts","toast","i18next","t","updateTag","moveTagToNewParent","movedTagId","toListId","ofList","result","update","$addToSet","$set","sortTags","tagIds","isEmpty","indexOf","compact","removeTag","$pullAll","registerHelper"],"mappings":"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","file":"/imports/plugins/core/ui-tagnav/client/helpers/tags.js.map","sourcesContent":["import { Tags } from \"/lib/collections\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Session } from \"meteor/session\";\nimport { Template } from \"meteor/templating\";\n\n/**\n * Reaction TagNav shared helpers\n * @type {Object}\n */\nexport const TagHelpers = {\n  moveItem(oldArray, fromIndex, toIndex) {\n    const newArray = [...oldArray];\n    newArray.splice(toIndex, 0, newArray.splice(fromIndex, 1)[0]);\n    return newArray;\n  },\n\n  subTags(parentTag) {\n    if (_.isArray(parentTag.relatedTagIds)) {\n      const tags = Tags.find({\n        isTopLevel: false,\n        _id: {\n          $in: parentTag.relatedTagIds\n        }\n      }).fetch();\n\n      const subTags = parentTag.relatedTagIds.map((tagId) => {\n        return _.find(tags, (tagObject) => {\n          return tagObject._id === tagId;\n        });\n      });\n\n      return subTags;\n    }\n\n    return false;\n  },\n\n  currentTag() {\n    return Session.get(\"currentTag\");\n  },\n\n  getTags() {\n    let tags = [];\n\n    tags = Tags.find({\n      isTopLevel: true\n    }, {\n      sort: {\n        position: 1\n      }\n    }).fetch();\n    /*\n    if (this.tagIds) {\n      for (let relatedTagId of this.tagIds) {\n        if (!_.find(tags, {\n          _id: relatedTagId\n        })) {\n          tags.push(Tags.findOne(relatedTagId));\n        }\n      }\n    }*/\n\n    if (this.tag) {\n      Session.set(\"currentTag\", this.tag._id);\n    } else {\n      Session.set(\"currentTag\", \"\");\n    }\n\n    return tags;\n    // there are cases where\n    // we'll have no tags, and sort will error\n    // so we check length for safety\n    // if (tags) {\n    //   tags.sort(function (a, b) {\n    //     return a.position - b.position;\n    //   });\n    //   return tags;\n    // }\n  },\n\n  createTag(tagName, tagId, parentTag) {\n    let parentTagId;\n\n    if (parentTag) {\n      parentTagId = parentTag._id;\n    }\n\n    Meteor.call(\"shop/updateHeaderTags\", tagName, null, parentTagId,\n      function (error) {\n        if (error) {\n          Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n        }\n      });\n  },\n\n  updateTag(tagId, tagName, parentTagId) {\n    Meteor.call(\"shop/updateHeaderTags\", tagName, tagId, parentTagId,\n      function (error) {\n        if (error) {\n          Alerts.toast(i18next.t(\"productDetail.tagExists\"), \"error\");\n        }\n      });\n  },\n\n  /* eslint no-unused-vars: 0 */\n  //\n  //   TODO review toIndex, ofList variable implementation in tags.js moveTagToNewParent\n  //\n  moveTagToNewParent(movedTagId, toListId, toIndex, ofList) {\n    if (movedTagId) {\n      if (toListId) {\n        const result = Tags.update(toListId,\n          {\n            $addToSet: {\n              relatedTagIds: movedTagId\n            }\n          }\n        );\n\n        return result;\n      }\n\n      const result = Tags.update(movedTagId,\n        {\n          $set: {\n            isTopLevel: true\n          }\n        }\n      );\n\n      return result;\n    }\n    return 0;\n  },\n\n  sortTags(tagIds, parentTag) {\n    if (_.isArray(tagIds)) {\n      if (_.isEmpty(parentTag)) {\n        // Top level tags\n        for (const tagId of tagIds) {\n          Tags.update(tagId, {\n            $set: {\n              position: tagIds.indexOf(tagId)\n            }\n          });\n        }\n      } else {\n        // Sub tags\n        Tags.update(parentTag._id, {\n          $set: {\n            relatedTagIds: _.compact(tagIds)\n          }\n        });\n      }\n    }\n  },\n\n  removeTag(tag, parentTag) {\n    if (_.isEmpty(parentTag) === false) {\n      Tags.update(parentTag._id,\n        {\n          $pullAll: {\n            relatedTagIds: [tag._id]\n          }\n        }\n      );\n    } else if (tag.isTopLevel === true) {\n      Tags.update(tag._id,\n        {\n          $set: {\n            isTopLevel: false\n          }\n        }\n      );\n    }\n  }\n};\n\nTemplate.registerHelper(\"reactionSubTags\", TagHelpers.subTags);\n"]},"hash":"6fdee08c15dfc56c2f03756efda2fce30c7d2ec4"}
