{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"accounting-js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"accounting"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/check","imported":["check","Match"],"specifiers":[{"kind":"named","imported":"check","local":"check"},{"kind":"named","imported":"Match","local":"Match"}]},{"source":"/server/api","imported":["Reaction","Logger"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"},{"kind":"named","imported":"Logger","local":"Logger"}]},{"source":"./stripeapi","imported":["StripeApi"],"specifiers":[{"kind":"named","imported":"StripeApi","local":"StripeApi"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/plugins/included/payments-stripe/server/methods/stripe.js","filenameRelative":"/imports/plugins/included/payments-stripe/server/methods/stripe.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/included/payments-stripe/server/methods/stripe.js"],"names":["accounting","Meteor","check","Match","Reaction","Logger","StripeApi","luhnValid","x","reverse","reduce","sum","c","i","d","parseInt","ValidCardNumber","Where","test","ValidExpireMonth","ValidExpireYear","ValidCVV","parseCardData","data","number","name","cvc","cvv2","exp_month","expire_month","exp_year","expire_year","formatForStripe","amount","Math","round","unformatFromStripe","stripeCaptureCharge","paymentMethod","result","captureDetails","captureResult","methods","captureCharge","call","transactionId","status","saved","response","error","transactionType","cardData","paymentData","String","type","total","currency","chargeObj","card","capture","chargeResult","createCharge","debug","message","e","Error","Schemas","PaymentMethod","unformat","voidedAmount","transactions","reason","Number","refundDetails","charge","refundResult","createRefund","object","warn","fatal","refunds","listRefunds","refund","push","created","raw"],"mappings":"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","file":"/imports/plugins/included/payments-stripe/server/methods/stripe.js.map","sourcesContent":["import accounting from \"accounting-js\";\n/* eslint camelcase: 0 */\n// meteor modules\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\n// reaction modules\nimport { Reaction, Logger } from \"/server/api\";\nimport { StripeApi } from \"./stripeapi\";\n\nfunction luhnValid(x) {\n  return [...x].reverse().reduce((sum, c, i) => {\n    let d = parseInt(c, 10);\n    if (i % 2 !== 0) { d *= 2; }\n    if (d > 9) { d -= 9; }\n    return sum + d;\n  }, 0) % 10 === 0;\n}\n\nconst ValidCardNumber = Match.Where(function (x) {\n  return /^[0-9]{13,16}$/.test(x) && luhnValid(x);\n});\n\nconst ValidExpireMonth = Match.Where(function (x) {\n  return /^[0-9]{1,2}$/.test(x);\n});\n\nconst ValidExpireYear = Match.Where(function (x) {\n  return /^[0-9]{4}$/.test(x);\n});\n\nconst ValidCVV = Match.Where(function (x) {\n  return /^[0-9]{3,4}$/.test(x);\n});\n\nfunction parseCardData(data) {\n  return {\n    number: data.number,\n    name: data.name,\n    cvc: data.cvv2,\n    exp_month: data.expire_month,\n    exp_year: data.expire_year\n  };\n}\n\n// Stripe uses a \"Decimal-less\" format so 10.00 becomes 1000\nfunction formatForStripe(amount) {\n  return Math.round(amount * 100);\n}\nfunction unformatFromStripe(amount) {\n  return (amount / 100);\n}\n\nfunction stripeCaptureCharge(paymentMethod) {\n  let result;\n  const captureDetails = {\n    amount: formatForStripe(paymentMethod.amount)\n  };\n\n  try {\n    const captureResult = StripeApi.methods.captureCharge.call({\n      transactionId: paymentMethod.transactionId,\n      captureDetails: captureDetails\n    });\n    if (captureResult.status === \"succeeded\") {\n      result = {\n        saved: true,\n        response: captureResult\n      };\n    } else {\n      result = {\n        saved: false,\n        response: captureResult\n      };\n    }\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: error\n    };\n    return { error, result };\n  }\n  return result;\n}\n\n\nMeteor.methods({\n  \"stripeSubmit\": function (transactionType, cardData, paymentData) {\n    check(transactionType, String);\n    check(cardData, {\n      name: String,\n      number: ValidCardNumber,\n      expire_month: ValidExpireMonth,\n      expire_year: ValidExpireYear,\n      cvv2: ValidCVV,\n      type: String\n    });\n    check(paymentData, {\n      total: String,\n      currency: String\n    });\n\n    const chargeObj = {\n      amount: \"\",\n      currency: \"\",\n      card: {},\n      capture: true\n    };\n\n    if (transactionType === \"authorize\") {\n      chargeObj.capture = false;\n    }\n    chargeObj.card = parseCardData(cardData);\n    chargeObj.amount = formatForStripe(paymentData.total);\n    chargeObj.currency = paymentData.currency;\n    let result;\n    let chargeResult;\n\n    try {\n      chargeResult = StripeApi.methods.createCharge.call({ chargeObj });\n      if (chargeResult && chargeResult.status === \"succeeded\") {\n        result = {\n          saved: true,\n          response: chargeResult\n        };\n      } else {\n        Logger.debug(\"Stripe Call succeeded but charge failed\");\n        result = {\n          saved: false,\n          error: chargeResult.error.message\n        };\n      }\n      return result;\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"error\", e.message);\n    }\n  },\n\n  /**\n   * Capture a Stripe charge\n   * @see https://stripe.com/docs/api#capture_charge\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {Object} results from Stripe normalized\n   */\n  \"stripe/payment/capture\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    // let result;\n    const captureDetails = {\n      amount: formatForStripe(paymentMethod.amount)\n    };\n\n    // 100% discounts are not valid when using Stripe\n    // If discount is 100%, capture 100% and then refund 100% of transaction\n    if (captureDetails.amount === accounting.unformat(0)) {\n      const voidedAmount = unformatFromStripe(paymentMethod.transactions[0].amount);\n      stripeCaptureCharge(paymentMethod);\n\n      return Meteor.call(\"stripe/refund/create\", paymentMethod, voidedAmount);\n    }\n    return stripeCaptureCharge(paymentMethod);\n  },\n\n  /**\n   * Issue a refund against a previously captured transaction\n   * @see https://stripe.com/docs/api#refunds\n   * @param  {Object} paymentMethod object\n   * @param  {Number} amount to be refunded\n   * @param  {String} reason refund was issued (currently unused by client)\n   * @return {Object} result\n   */\n  \"stripe/refund/create\": function (paymentMethod, amount, reason = \"requested_by_customer\") {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n    check(reason, String);\n\n    const refundDetails = {\n      charge: paymentMethod.transactionId,\n      amount: formatForStripe(amount),\n      reason\n    };\n\n    let result;\n    try {\n      const refundResult = StripeApi.methods.createRefund.call({ refundDetails });\n      Logger.debug(refundResult);\n      if (refundResult && refundResult.object === \"refund\") {\n        result = {\n          saved: true,\n          response: refundResult\n        };\n      } else {\n        result = {\n          saved: false,\n          response: refundResult\n        };\n        Logger.warn(\"Stripe call succeeded but refund not issued\");\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = {\n        saved: false,\n        error: `Cannot issue refund: ${error.message}`\n      };\n      Logger.fatal(\"Stripe call failed, refund was not issued\");\n    }\n    return result;\n  },\n\n  /**\n   * List refunds\n   * @param  {Object} paymentMethod object\n   * @return {Object} result\n   */\n  \"stripe/refund/list\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    let result;\n    try {\n      const refunds = StripeApi.methods.listRefunds.call({ transactionId: paymentMethod.transactionId });\n      result = [];\n      for (const refund of refunds.data) {\n        result.push({\n          type: refund.object,\n          amount: refund.amount / 100,\n          created: refund.created * 1000,\n          currency: refund.currency,\n          raw: refund\n        });\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = { error };\n    }\n    return result;\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/included/payments-stripe/server/methods/stripe.js.map","sourceFileName":"/imports/plugins/included/payments-stripe/server/methods/stripe.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"stripe"},"ignored":false,"code":"function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar accounting = void 0;\nmodule.importSync(\"accounting-js\", {\n  \"default\": function (v) {\n    accounting = v;\n  }\n}, 0);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 1);\nvar check = void 0,\n    Match = void 0;\nmodule.importSync(\"meteor/check\", {\n  check: function (v) {\n    check = v;\n  },\n  Match: function (v) {\n    Match = v;\n  }\n}, 2);\nvar Reaction = void 0,\n    Logger = void 0;\nmodule.importSync(\"/server/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  },\n  Logger: function (v) {\n    Logger = v;\n  }\n}, 3);\nvar StripeApi = void 0;\nmodule.importSync(\"./stripeapi\", {\n  StripeApi: function (v) {\n    StripeApi = v;\n  }\n}, 4);\n\nfunction luhnValid(x) {\n  return [].concat(_toConsumableArray(x)).reverse().reduce(function (sum, c, i) {\n    var d = parseInt(c, 10);\n\n    if (i % 2 !== 0) {\n      d *= 2;\n    }\n\n    if (d > 9) {\n      d -= 9;\n    }\n\n    return sum + d;\n  }, 0) % 10 === 0;\n}\n\nvar ValidCardNumber = Match.Where(function (x) {\n  return (/^[0-9]{13,16}$/.test(x) && luhnValid(x)\n  );\n});\nvar ValidExpireMonth = Match.Where(function (x) {\n  return (/^[0-9]{1,2}$/.test(x)\n  );\n});\nvar ValidExpireYear = Match.Where(function (x) {\n  return (/^[0-9]{4}$/.test(x)\n  );\n});\nvar ValidCVV = Match.Where(function (x) {\n  return (/^[0-9]{3,4}$/.test(x)\n  );\n});\n\nfunction parseCardData(data) {\n  return {\n    number: data.number,\n    name: data.name,\n    cvc: data.cvv2,\n    exp_month: data.expire_month,\n    exp_year: data.expire_year\n  };\n} // Stripe uses a \"Decimal-less\" format so 10.00 becomes 1000\n\n\nfunction formatForStripe(amount) {\n  return Math.round(amount * 100);\n}\n\nfunction unformatFromStripe(amount) {\n  return amount / 100;\n}\n\nfunction stripeCaptureCharge(paymentMethod) {\n  var result = void 0;\n  var captureDetails = {\n    amount: formatForStripe(paymentMethod.amount)\n  };\n\n  try {\n    var captureResult = StripeApi.methods.captureCharge.call({\n      transactionId: paymentMethod.transactionId,\n      captureDetails: captureDetails\n    });\n\n    if (captureResult.status === \"succeeded\") {\n      result = {\n        saved: true,\n        response: captureResult\n      };\n    } else {\n      result = {\n        saved: false,\n        response: captureResult\n      };\n    }\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: error\n    };\n    return {\n      error: error,\n      result: result\n    };\n  }\n\n  return result;\n}\n\nMeteor.methods({\n  \"stripeSubmit\": function (transactionType, cardData, paymentData) {\n    check(transactionType, String);\n    check(cardData, {\n      name: String,\n      number: ValidCardNumber,\n      expire_month: ValidExpireMonth,\n      expire_year: ValidExpireYear,\n      cvv2: ValidCVV,\n      type: String\n    });\n    check(paymentData, {\n      total: String,\n      currency: String\n    });\n    var chargeObj = {\n      amount: \"\",\n      currency: \"\",\n      card: {},\n      capture: true\n    };\n\n    if (transactionType === \"authorize\") {\n      chargeObj.capture = false;\n    }\n\n    chargeObj.card = parseCardData(cardData);\n    chargeObj.amount = formatForStripe(paymentData.total);\n    chargeObj.currency = paymentData.currency;\n    var result = void 0;\n    var chargeResult = void 0;\n\n    try {\n      chargeResult = StripeApi.methods.createCharge.call({\n        chargeObj: chargeObj\n      });\n\n      if (chargeResult && chargeResult.status === \"succeeded\") {\n        result = {\n          saved: true,\n          response: chargeResult\n        };\n      } else {\n        Logger.debug(\"Stripe Call succeeded but charge failed\");\n        result = {\n          saved: false,\n          error: chargeResult.error.message\n        };\n      }\n\n      return result;\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"error\", e.message);\n    }\n  },\n  /**\n   * Capture a Stripe charge\n   * @see https://stripe.com/docs/api#capture_charge\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {Object} results from Stripe normalized\n   */\"stripe/payment/capture\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod); // let result;\n\n    var captureDetails = {\n      amount: formatForStripe(paymentMethod.amount)\n    }; // 100% discounts are not valid when using Stripe\n    // If discount is 100%, capture 100% and then refund 100% of transaction\n\n    if (captureDetails.amount === accounting.unformat(0)) {\n      var voidedAmount = unformatFromStripe(paymentMethod.transactions[0].amount);\n      stripeCaptureCharge(paymentMethod);\n      return Meteor.call(\"stripe/refund/create\", paymentMethod, voidedAmount);\n    }\n\n    return stripeCaptureCharge(paymentMethod);\n  },\n  /**\n   * Issue a refund against a previously captured transaction\n   * @see https://stripe.com/docs/api#refunds\n   * @param  {Object} paymentMethod object\n   * @param  {Number} amount to be refunded\n   * @param  {String} reason refund was issued (currently unused by client)\n   * @return {Object} result\n   */\"stripe/refund/create\": function (paymentMethod, amount) {\n    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"requested_by_customer\";\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n    check(reason, String);\n    var refundDetails = {\n      charge: paymentMethod.transactionId,\n      amount: formatForStripe(amount),\n      reason: reason\n    };\n    var result = void 0;\n\n    try {\n      var refundResult = StripeApi.methods.createRefund.call({\n        refundDetails: refundDetails\n      });\n      Logger.debug(refundResult);\n\n      if (refundResult && refundResult.object === \"refund\") {\n        result = {\n          saved: true,\n          response: refundResult\n        };\n      } else {\n        result = {\n          saved: false,\n          response: refundResult\n        };\n        Logger.warn(\"Stripe call succeeded but refund not issued\");\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = {\n        saved: false,\n        error: \"Cannot issue refund: \" + error.message\n      };\n      Logger.fatal(\"Stripe call failed, refund was not issued\");\n    }\n\n    return result;\n  },\n  /**\n   * List refunds\n   * @param  {Object} paymentMethod object\n   * @return {Object} result\n   */\"stripe/refund/list\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    var result = void 0;\n\n    try {\n      var refunds = StripeApi.methods.listRefunds.call({\n        transactionId: paymentMethod.transactionId\n      });\n      result = [];\n\n      for (var _iterator = refunds.data, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var refund = _ref;\n        result.push({\n          type: refund.object,\n          amount: refund.amount / 100,\n          created: refund.created * 1000,\n          currency: refund.currency,\n          raw: refund\n        });\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = {\n        error: error\n      };\n    }\n\n    return result;\n  }\n});","map":{"version":3,"sources":["/imports/plugins/included/payments-stripe/server/methods/stripe.js"],"names":["accounting","Meteor","check","Match","Reaction","Logger","StripeApi","luhnValid","x","reverse","reduce","sum","c","i","d","parseInt","ValidCardNumber","Where","test","ValidExpireMonth","ValidExpireYear","ValidCVV","parseCardData","data","number","name","cvc","cvv2","exp_month","expire_month","exp_year","expire_year","formatForStripe","amount","Math","round","unformatFromStripe","stripeCaptureCharge","paymentMethod","result","captureDetails","captureResult","methods","captureCharge","call","transactionId","status","saved","response","error","transactionType","cardData","paymentData","String","type","total","currency","chargeObj","card","capture","chargeResult","createCharge","debug","message","e","Error","Schemas","PaymentMethod","unformat","voidedAmount","transactions","reason","Number","refundDetails","charge","refundResult","createRefund","object","warn","fatal","refunds","listRefunds","refund","push","created","raw"],"mappings":"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","file":"/imports/plugins/included/payments-stripe/server/methods/stripe.js.map","sourcesContent":["import accounting from \"accounting-js\";\n/* eslint camelcase: 0 */\n// meteor modules\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\n// reaction modules\nimport { Reaction, Logger } from \"/server/api\";\nimport { StripeApi } from \"./stripeapi\";\n\nfunction luhnValid(x) {\n  return [...x].reverse().reduce((sum, c, i) => {\n    let d = parseInt(c, 10);\n    if (i % 2 !== 0) { d *= 2; }\n    if (d > 9) { d -= 9; }\n    return sum + d;\n  }, 0) % 10 === 0;\n}\n\nconst ValidCardNumber = Match.Where(function (x) {\n  return /^[0-9]{13,16}$/.test(x) && luhnValid(x);\n});\n\nconst ValidExpireMonth = Match.Where(function (x) {\n  return /^[0-9]{1,2}$/.test(x);\n});\n\nconst ValidExpireYear = Match.Where(function (x) {\n  return /^[0-9]{4}$/.test(x);\n});\n\nconst ValidCVV = Match.Where(function (x) {\n  return /^[0-9]{3,4}$/.test(x);\n});\n\nfunction parseCardData(data) {\n  return {\n    number: data.number,\n    name: data.name,\n    cvc: data.cvv2,\n    exp_month: data.expire_month,\n    exp_year: data.expire_year\n  };\n}\n\n// Stripe uses a \"Decimal-less\" format so 10.00 becomes 1000\nfunction formatForStripe(amount) {\n  return Math.round(amount * 100);\n}\nfunction unformatFromStripe(amount) {\n  return (amount / 100);\n}\n\nfunction stripeCaptureCharge(paymentMethod) {\n  let result;\n  const captureDetails = {\n    amount: formatForStripe(paymentMethod.amount)\n  };\n\n  try {\n    const captureResult = StripeApi.methods.captureCharge.call({\n      transactionId: paymentMethod.transactionId,\n      captureDetails: captureDetails\n    });\n    if (captureResult.status === \"succeeded\") {\n      result = {\n        saved: true,\n        response: captureResult\n      };\n    } else {\n      result = {\n        saved: false,\n        response: captureResult\n      };\n    }\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: error\n    };\n    return { error, result };\n  }\n  return result;\n}\n\n\nMeteor.methods({\n  \"stripeSubmit\": function (transactionType, cardData, paymentData) {\n    check(transactionType, String);\n    check(cardData, {\n      name: String,\n      number: ValidCardNumber,\n      expire_month: ValidExpireMonth,\n      expire_year: ValidExpireYear,\n      cvv2: ValidCVV,\n      type: String\n    });\n    check(paymentData, {\n      total: String,\n      currency: String\n    });\n\n    const chargeObj = {\n      amount: \"\",\n      currency: \"\",\n      card: {},\n      capture: true\n    };\n\n    if (transactionType === \"authorize\") {\n      chargeObj.capture = false;\n    }\n    chargeObj.card = parseCardData(cardData);\n    chargeObj.amount = formatForStripe(paymentData.total);\n    chargeObj.currency = paymentData.currency;\n    let result;\n    let chargeResult;\n\n    try {\n      chargeResult = StripeApi.methods.createCharge.call({ chargeObj });\n      if (chargeResult && chargeResult.status === \"succeeded\") {\n        result = {\n          saved: true,\n          response: chargeResult\n        };\n      } else {\n        Logger.debug(\"Stripe Call succeeded but charge failed\");\n        result = {\n          saved: false,\n          error: chargeResult.error.message\n        };\n      }\n      return result;\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"error\", e.message);\n    }\n  },\n\n  /**\n   * Capture a Stripe charge\n   * @see https://stripe.com/docs/api#capture_charge\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {Object} results from Stripe normalized\n   */\n  \"stripe/payment/capture\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    // let result;\n    const captureDetails = {\n      amount: formatForStripe(paymentMethod.amount)\n    };\n\n    // 100% discounts are not valid when using Stripe\n    // If discount is 100%, capture 100% and then refund 100% of transaction\n    if (captureDetails.amount === accounting.unformat(0)) {\n      const voidedAmount = unformatFromStripe(paymentMethod.transactions[0].amount);\n      stripeCaptureCharge(paymentMethod);\n\n      return Meteor.call(\"stripe/refund/create\", paymentMethod, voidedAmount);\n    }\n    return stripeCaptureCharge(paymentMethod);\n  },\n\n  /**\n   * Issue a refund against a previously captured transaction\n   * @see https://stripe.com/docs/api#refunds\n   * @param  {Object} paymentMethod object\n   * @param  {Number} amount to be refunded\n   * @param  {String} reason refund was issued (currently unused by client)\n   * @return {Object} result\n   */\n  \"stripe/refund/create\": function (paymentMethod, amount, reason = \"requested_by_customer\") {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n    check(reason, String);\n\n    const refundDetails = {\n      charge: paymentMethod.transactionId,\n      amount: formatForStripe(amount),\n      reason\n    };\n\n    let result;\n    try {\n      const refundResult = StripeApi.methods.createRefund.call({ refundDetails });\n      Logger.debug(refundResult);\n      if (refundResult && refundResult.object === \"refund\") {\n        result = {\n          saved: true,\n          response: refundResult\n        };\n      } else {\n        result = {\n          saved: false,\n          response: refundResult\n        };\n        Logger.warn(\"Stripe call succeeded but refund not issued\");\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = {\n        saved: false,\n        error: `Cannot issue refund: ${error.message}`\n      };\n      Logger.fatal(\"Stripe call failed, refund was not issued\");\n    }\n    return result;\n  },\n\n  /**\n   * List refunds\n   * @param  {Object} paymentMethod object\n   * @return {Object} result\n   */\n  \"stripe/refund/list\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    let result;\n    try {\n      const refunds = StripeApi.methods.listRefunds.call({ transactionId: paymentMethod.transactionId });\n      result = [];\n      for (const refund of refunds.data) {\n        result.push({\n          type: refund.object,\n          amount: refund.amount / 100,\n          created: refund.created * 1000,\n          currency: refund.currency,\n          raw: refund\n        });\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = { error };\n    }\n    return result;\n  }\n});\n"]},"hash":"be2e0425862cd7a8e981031135f1c74419f66534"}
