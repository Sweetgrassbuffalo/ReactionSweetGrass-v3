{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash/isEmpty","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_isEmpty"}]},{"source":"lodash/includes","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_includes"}]},{"source":"lodash/max","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_max"}]},{"source":"lodash/min","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_min"}]},{"source":"lodash/split","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_split"}]},{"source":"deep-diff","imported":["diff"],"specifiers":[{"kind":"named","imported":"diff","local":"diff"}]},{"source":"/lib/collections","imported":["Products","Revisions","Tags","Media"],"specifiers":[{"kind":"named","imported":"Products","local":"Products"},{"kind":"named","imported":"Revisions","local":"Revisions"},{"kind":"named","imported":"Tags","local":"Tags"},{"kind":"named","imported":"Media","local":"Media"}]},{"source":"/server/api","imported":["Logger"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"}]},{"source":"../lib/api","imported":["RevisionApi"],"specifiers":[{"kind":"named","imported":"RevisionApi","local":"RevisionApi"}]},{"source":"/lib/api","imported":["getSlug"],"specifiers":[{"kind":"named","imported":"getSlug","local":"getSlug"}]}],"exports":{"exported":["ProductRevision"],"specifiers":[{"kind":"local","local":"ProductRevision","exported":"ProductRevision"}]}}},"options":{"filename":"/imports/plugins/core/revisions/server/hooks.js","filenameRelative":"/imports/plugins/core/revisions/server/hooks.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/core/revisions/server/hooks.js"],"names":["diff","Products","Revisions","Tags","Media","Logger","RevisionApi","getSlug","convertMetadata","modifierObject","metadata","prop","hasOwnProperty","indexOf","splitName","ProductRevision","getProductPriceRange","productId","product","findOne","variants","getTopVariants","_id","length","variantPrices","forEach","variant","isVisible","range","getVariantPriceRange","firstPrice","parseFloat","substr","lastPrice","lastIndexOf","push","priceMin","priceMax","priceRange","toString","priceObject","min","max","price","variantId","children","getVariants","visibleChildren","filter","child","topVariant","getProduct","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","map","findRevision","documentId","$nin","revision","documentData","id","find","ancestors","type","isDeleted","$in","getVariantQuantity","options","reduce","sum","option","inventoryQuantity","files","before","insert","userid","media","isRevisionControlEnabled","revisionMetadata","Object","assign","workflow","documentType","parentDocument","changeType","status","update","userId","fieldNames","modifier","convertedModifier","$set","convertedMetadata","existingRevision","updatedMetadata","remove","productRevision","productHasAncestors","Array","isArray","archivedCount","count","debug","Meteor","Error","revisionHasAncestors","modiferContainsIsDeleted","originalSelector","args","revisionSelector","revisionModifier","publish","hasAncestors","operation","call","property","metafields","$addToSet","$push","updateId","newValue","newTitle","title","newHandle","handle","slugDocId","revisionTitle","revisionHandle","hasNewHandle","hasExistingTitle","hasNewTitle","hasHandle","handleMatchesId","$unset","$pull","hashtags","tagId","productCount","relatedTagsCount","relatedTagIds","$inc","newSet","newInc","hasIgnoredFields","ignoredFields","field","after","differences","image","direct","d","fetchPrevious"],"mappings":"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","file":"/imports/plugins/core/revisions/server/hooks.js.map","sourcesContent":["import _ from \"lodash\";\nimport { diff } from \"deep-diff\";\nimport { Products, Revisions, Tags, Media } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\nimport { RevisionApi } from \"../lib/api\";\nimport { getSlug } from \"/lib/api\";\n\nfunction convertMetadata(modifierObject) {\n  const metadata = {};\n  for (const prop in modifierObject) {\n    if (modifierObject.hasOwnProperty(prop)) {\n      if (prop.indexOf(\"metadata\") !== -1) {\n        const splitName = _.split(prop, \".\")[1];\n        metadata[splitName] = modifierObject[prop];\n      }\n    }\n  }\n  return metadata;\n}\n\nexport const ProductRevision = {\n  getProductPriceRange(productId) {\n    const product = Products.findOne(productId);\n    if (!product) {\n      return \"\";\n    }\n    const variants = this.getTopVariants(product._id);\n\n    if (variants.length > 0) {\n      const variantPrices = [];\n      variants.forEach(variant => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n      const priceMin = _.min(variantPrices);\n      const priceMax = _.max(variantPrices);\n      let priceRange = `${priceMin} - ${priceMax}`;\n      // if we don't have a range\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n      const priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    }\n    // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n    return product.price;\n  },\n\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter(child => child.isVisible);\n\n    switch (visibleChildren.length) {\n      case 0:\n        const topVariant = this.getProduct(variantId);\n        // topVariant could be undefined when we removing last top variant\n        return topVariant && topVariant.price;\n      case 1:\n        return visibleChildren[0].price;\n      default:\n        let priceMin = Number.POSITIVE_INFINITY;\n        let priceMax = Number.NEGATIVE_INFINITY;\n\n        visibleChildren.map(child => {\n          if (child.price < priceMin) {\n            priceMin = child.price;\n          }\n          if (child.price > priceMax) {\n            priceMax = child.price;\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n        return `${priceMin} - ${priceMax}`;\n    }\n  },\n\n  findRevision({ documentId }) {\n    return Revisions.findOne({\n      \"documentId\": documentId,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    });\n  },\n\n  getProduct(variantId) {\n    const product = Products.findOne(variantId);\n    const revision = this.findRevision({\n      documentId: variantId\n    });\n\n    return revision && revision.documentData || product;\n  },\n\n  getTopVariants(id) {\n    const variants = [];\n\n    Products.find({\n      ancestors: [id],\n      type: \"variant\",\n      isDeleted: false\n    }).map((product) => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n\n    return variants;\n  },\n\n  getVariants(id, type) {\n    const variants = [];\n\n    Products.find({\n      ancestors: { $in: [id] },\n      type: type || \"variant\",\n      isDeleted: false\n    }).forEach((product) => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n    return variants;\n  },\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n    if (options && options.length) {\n      return options.reduce((sum, option) =>\n      sum + option.inventoryQuantity || 0, 0);\n    }\n    return variant.inventoryQuantity || 0;\n  }\n};\n\nMedia.files.before.insert((userid, media) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  if (media.metadata.productId) {\n    const revisionMetadata = Object.assign({}, media.metadata);\n    revisionMetadata.workflow = \"published\";\n    Revisions.insert({\n      documentId: media._id,\n      documentData: revisionMetadata,\n      documentType: \"image\",\n      parentDocument: media.metadata.productId,\n      changeType: \"insert\",\n      workflow: {\n        status: \"revision/update\"\n      }\n    });\n    media.metadata.workflow = \"unpublished\";\n  } else {\n    media.metadata.workflow = \"published\";\n  }\n  return true;\n});\n\nMedia.files.before.update((userId, media, fieldNames, modifier) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  // if it's not metadata ignore it, as LOTS of othing things change on this record\n  if (!_.includes(fieldNames, \"metadata\")) {\n    return true;\n  }\n\n  if (media.metadata.productId) {\n    const convertedModifier = convertMetadata(modifier.$set);\n    const convertedMetadata = Object.assign({}, media.metadata, convertedModifier);\n    const existingRevision = Revisions.findOne({\n      \"documentId\": media._id,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    });\n    if (existingRevision) {\n      const updatedMetadata = Object.assign({}, existingRevision.documentData, convertedMetadata);\n      // Special case where if we have both added and reordered images before publishing we don't want to overwrite\n      // the workflow status since it would be \"unpublished\"\n      if (existingRevision.documentData.workflow === \"published\" || existingRevision.changeType === \"insert\") {\n        updatedMetadata.workflow = \"published\";\n      }\n      Revisions.update({ _id: existingRevision._id }, {\n        $set: {\n          documentData: updatedMetadata\n        }\n      });\n    } else {\n      Revisions.insert({\n        documentId: media._id,\n        documentData: convertedMetadata,\n        documentType: \"image\",\n        parentDocument: media.metadata.productId,\n        changeType: \"update\",\n        workflow: {\n          status: \"revision/update\"\n        }\n      });\n    }\n\n    return false; // prevent actual update of image. This also stops other hooks from running :/\n  }\n  // for non-product images, just ignore and keep on moving\n  return true;\n});\n\nMedia.files.before.remove((userId, media) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  // if the media is unpublished, then go ahead and just delete it\n  if (media.metadata.workflow && media.metadata.workflow === \"unpublished\") {\n    Revisions.remove({\n      documentId: media._id\n    });\n    return true;\n  }\n  if (media.metadata.productId) {\n    Revisions.insert({\n      documentId: media._id,\n      documentData: media.metadata,\n      documentType: \"image\",\n      parentDocument: media.metadata.productId,\n      changeType: \"remove\",\n      workflow: {\n        status: \"revision/update\"\n      }\n    });\n    return false; // prevent actual deletion of image. This also stops other hooks from running :/\n  }\n  return true;\n});\n\n\nProducts.before.insert((userId, product) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  const productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  });\n\n  // Prevent this product from being created if a parent product / varaint ancestor is deleted.\n  //\n  // This will prevent cases where a parent variant hase been deleted and a user tries to create a\n  // child variant. You cannot create the child variant becuase the parent will no longer exist when\n  // changes have been published; resulting in a broken inheretence and UI\n  const productHasAncestors = Array.isArray(product.ancestors);\n\n  if (productHasAncestors) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": { $in: product.ancestors },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot create product ${product._id} as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"Unable to create product variant\");\n    }\n  }\n\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n  }\n});\n\n\nProducts.before.update(function (userId, product, fieldNames, modifier, options) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  let productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  });\n\n  // Prevent this product revision from beign restored from isDeleted state if a product / varaint\n  // ancestor is also deleted.\n  //\n  // This will prevent cases where a parent variant hase been deleted and a user tries to undeleted a\n  // child variant. You cannot undeleted the child variant, becuase the parent will no longer exist when\n  // changes have been published; resulting in a broken inheretence and UI\n  const revisionHasAncestors = productRevision && productRevision.documentData && Array.isArray(productRevision.documentData.ancestors);\n  const modiferContainsIsDeleted = modifier.$set && modifier.$set.isDeleted === false;\n\n  if (revisionHasAncestors && modiferContainsIsDeleted) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": { $in: productRevision.documentData.ancestors },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot restore product ${product._id} as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"Unable to delete product variant\");\n    }\n  }\n\n  const originalSelector = this.args[0];\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    // Create a new revision\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n\n    // Fetch newly created revision\n    productRevision = Revisions.findOne({\n      documentId: product._id\n    });\n  }\n\n  // Create a new selector for the revision\n  //\n  // This is especially important since we may need to update some fields\n  // like metadata, and the selector is very important to that.\n  const revisionSelector = {\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  };\n\n  // Create a new modifier for the revision\n  const revisionModifier = {\n    $set: {\n      \"workflow.status\": \"revision/update\"\n    }\n  };\n\n  if (options.publish === true || (product.workflow && product.workflow.status === \"product/publish\")) {\n    // Maybe mark the revision as published\n\n    Logger.debug(`Publishing revison for product ${product._id}.`);\n    Revisions.update(revisionSelector, {\n      $set: {\n        \"workflow.status\": \"revision/published\"\n      }\n    });\n\n    return true;\n  }\n\n  const hasAncestors = Array.isArray(product.ancestors) && product.ancestors.length > 0;\n\n  for (const operation in modifier) {\n    if (Object.hasOwnProperty.call(modifier, operation)) {\n      if (!revisionModifier[operation]) {\n        revisionModifier[operation] = {};\n      }\n\n      for (const property in modifier[operation]) {\n        if (modifier[operation].hasOwnProperty(property)) {\n          if (operation === \"$set\" && property === \"metafields.$\") {\n            // Special handling for meta fields with $ operator\n            // We need to update the selector otherwise the operation would completly fail.\n            //\n            // This does NOT apply to metafield.0, metafield.1, metafield.n operations\n            // where 0, 1, n represent an array index.\n            revisionSelector[\"documentData.metafields\"] = originalSelector.metafields;\n            revisionModifier.$set[`documentData.${property}`] = modifier.$set[property];\n          } else if (operation === \"$push\" && property === \"hashtags\") {\n            if (!revisionModifier.$addToSet) {\n              revisionModifier.$addToSet = {};\n            }\n            revisionModifier.$addToSet[`documentData.${property}`] = modifier.$push[property];\n          } else if (operation === \"$set\" && property === \"price\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.price\": modifier.$set.price\n              }\n            });\n\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && property === \"isVisible\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.isVisible\": modifier.$set.isVisible\n              }\n            });\n\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && (property === \"title\" || property === \"handle\") && hasAncestors === false) {\n            // Special handling for product title and handle\n            //\n            // Summary:\n            // When a user updates the product title, if the handle matches the product id,\n            // then update the handle to be a sligified version of the title\n            //\n            // This block ensures that the handle is either a custom slug, slug of the title, or\n            // the _id of the product, but is never blank\n\n            // New data\n            const newValue = modifier.$set[property];\n            const newTitle = modifier.$set.title;\n            const newHandle = modifier.$set.handle;\n\n            // Current revision data\n            const documentId = productRevision.documentId;\n            const slugDocId = getSlug(documentId);\n            const revisionTitle = productRevision.documentData.title;\n            const revisionHandle = productRevision.documentData.handle;\n\n            // Checks\n            const hasNewHandle = _.isEmpty(newHandle) === false;\n            const hasExistingTitle = _.isEmpty(revisionTitle) === false;\n            const hasNewTitle = _.isEmpty(newTitle) === false;\n            const hasHandle = _.isEmpty(revisionHandle) === false;\n            const handleMatchesId = revisionHandle === documentId || revisionHandle === slugDocId || newValue === documentId || newValue === slugDocId;\n\n            // Continue to set the title / handle as origionally requested\n            // Handle will get changed if conditions are met in the below if block\n            revisionModifier.$set[`documentData.${property}`] = newValue;\n\n            if ((handleMatchesId || hasHandle === false) && (hasExistingTitle || hasNewTitle) && hasNewHandle === false) {\n              // Set the handle to be the slug of the product.title\n              // when documentId (product._id) matches the handle, then handle is enpty, and a title exists\n              revisionModifier.$set[\"documentData.handle\"] = getSlug(newTitle || revisionTitle);\n            } else if (hasHandle === false && hasExistingTitle === false && hasNewHandle === false) {\n              // If the handle & title is empty, the handle becomes the product id\n              revisionModifier.$set[\"documentData.handle\"] = documentId;\n            } else if (hasNewHandle === false && property === \"handle\") {\n              // If the handle is empty, the handle becomes the sligified product title, or document id if title does not exist.\n              // const newTitle = modifier.$set[\"title\"];\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle ? getSlug(newTitle || revisionTitle) : documentId;\n            }\n          } else if (operation === \"$unset\" && property === \"handle\" && hasAncestors === false) {\n            // Special handling for product handle when it is going to be unset\n            //\n            // Summary:\n            // When a user updates the handle to a black string e.g. deltes all text in field in UI and saves,\n            // the handle will be adjusted so it will not be blank\n            const newValue = modifier.$unset[property];\n            const revisionTitle = productRevision.documentData.title;\n            const hasExistingTitle = _.isEmpty(revisionTitle) === false;\n\n            // If the new handle is going to be empty, the handle becomes the sligified product title, or document id if title does not exist.\n            if (_.isEmpty(newValue)) {\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle ? getSlug(revisionTitle) : documentId;\n            }\n          } else {\n            // Let everything else through\n            revisionModifier[operation][`documentData.${property}`] = modifier[operation][property];\n          }\n        }\n      }\n    }\n  }\n\n  Revisions.update(revisionSelector, revisionModifier);\n\n  Logger.debug(`Revison updated for product ${product._id}.`);\n\n  if (modifier.$pull && modifier.$pull.hashtags) {\n    const tagId = modifier.$pull.hashtags;\n\n    const productCount = Products.find({\n      hashtags: {\n        $in: [tagId]\n      }\n    }).count();\n\n    const relatedTagsCount = Tags.find({\n      relatedTagIds: {\n        $in: [tagId]\n      }\n    }).count();\n\n    if (productCount === 0 && relatedTagsCount === 0) {\n      // Mark tag as deleted\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: true\n        }\n      });\n    } else {\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: false\n        }\n      });\n    }\n  }\n\n  // If we are using $set or $inc, and the fields are one of the ignoredFields,\n  // allow product to be updated without going through revision control\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    const newSet = {};\n    const newInc = {};\n    let hasIgnoredFields = false;\n    const ignoredFields = [\n      \"isLowQuantity\",\n      \"isSoldOut\",\n      \"inventoryQuantity\"\n    ];\n\n    for (const field of ignoredFields) {\n      if (modifier.$set && (typeof modifier.$set[field] === \"number\" || typeof modifier.$set[field] === \"boolean\")) {\n        newSet[field] = modifier.$set[field];\n        hasIgnoredFields = true;\n      }\n\n      if (modifier.$inc && (typeof modifier.$inc[field] === \"number\" || typeof modifier.$inc[field] === \"boolean\")) {\n        newInc[field] = modifier.$inc[field];\n        hasIgnoredFields = true;\n      }\n    }\n    if (_.isEmpty(newSet) === false) {\n      modifier.$set = newSet;\n    }\n\n    if (_.isEmpty(newInc) === false) {\n      modifier.$inc = newInc;\n    }\n\n    return hasIgnoredFields === true;\n  }\n\n  // prevent the underlying document from being modified as it is in draft mode\n  return false;\n});\n\nProducts.before.remove(function (userId, product) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  let productRevision = Revisions.findOne({\n    documentId: product._id\n  });\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n    productRevision =  Revisions.findOne({\n      documentId: product._id\n    });\n  }\n\n  // Set the revision as deleted \"isDeleted: true\"\n  Revisions.update({\n    documentId: product._id\n  }, {\n    $set: {\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": \"revision/remove\"\n    }\n  });\n\n  Logger.debug(`Revison updated for product ${product._id}.`);\n  Logger.debug(`Product ${product._id} is now marked as deleted.`);\n\n  // If the original product is deleted, and the user is trying to delete it again,\n  // then actually remove it completly.\n  //\n  // This acts like a trash. Where the product is sent to trash before it can actually\n  // be deleted perminately.\n  if (product.isDeleted === true) {\n    Logger.debug(`Allowing write to product ${product._id} for Collection.remove().`);\n\n    return true;\n  }\n\n  Logger.debug(`Preventing write to product ${product._id} for Collection.remove().`);\n\n  return false;\n});\n\nRevisions.after.update(function (userId, revision) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  let differences;\n\n\n  if (!revision.documentType || revision.documentType === \"product\") {\n    // Make diff\n    const product = Products.findOne({\n      _id: revision.documentId\n    });\n    differences = diff(product, revision.documentData);\n  }\n\n  if (revision.documentType && revision.documentType === \"image\") {\n    const image = Media.findOne(revision.documentId);\n    differences = diff(image.metadata, revision.documentData);\n  }\n\n  Revisions.direct.update({\n    _id: revision._id\n  }, {\n    $set: {\n      diff: differences && differences.map((d) => Object.assign({}, d))\n    }\n  });\n}, {\n  fetchPrevious: false\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/core/revisions/server/hooks.js.map","sourceFileName":"/imports/plugins/core/revisions/server/hooks.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"hooks"},"ignored":false,"code":"module.export({\n  ProductRevision: function () {\n    return ProductRevision;\n  }\n});\n\nvar _isEmpty = void 0;\n\nmodule.importSync(\"lodash/isEmpty\", {\n  \"default\": function (v) {\n    _isEmpty = v;\n  }\n}, 0);\n\nvar _includes = void 0;\n\nmodule.importSync(\"lodash/includes\", {\n  \"default\": function (v) {\n    _includes = v;\n  }\n}, 1);\n\nvar _max = void 0;\n\nmodule.importSync(\"lodash/max\", {\n  \"default\": function (v) {\n    _max = v;\n  }\n}, 2);\n\nvar _min = void 0;\n\nmodule.importSync(\"lodash/min\", {\n  \"default\": function (v) {\n    _min = v;\n  }\n}, 3);\n\nvar _split = void 0;\n\nmodule.importSync(\"lodash/split\", {\n  \"default\": function (v) {\n    _split = v;\n  }\n}, 4);\nvar diff = void 0;\nmodule.importSync(\"deep-diff\", {\n  diff: function (v) {\n    diff = v;\n  }\n}, 5);\nvar Products = void 0,\n    Revisions = void 0,\n    Tags = void 0,\n    Media = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Products: function (v) {\n    Products = v;\n  },\n  Revisions: function (v) {\n    Revisions = v;\n  },\n  Tags: function (v) {\n    Tags = v;\n  },\n  Media: function (v) {\n    Media = v;\n  }\n}, 6);\nvar Logger = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  }\n}, 7);\nvar RevisionApi = void 0;\nmodule.importSync(\"../lib/api\", {\n  RevisionApi: function (v) {\n    RevisionApi = v;\n  }\n}, 8);\nvar getSlug = void 0;\nmodule.importSync(\"/lib/api\", {\n  getSlug: function (v) {\n    getSlug = v;\n  }\n}, 9);\n\nfunction convertMetadata(modifierObject) {\n  var metadata = {};\n\n  for (var prop in meteorBabelHelpers.sanitizeForInObject(modifierObject)) {\n    if (modifierObject.hasOwnProperty(prop)) {\n      if (prop.indexOf(\"metadata\") !== -1) {\n        var splitName = _split(prop, \".\")[1];\n\n        metadata[splitName] = modifierObject[prop];\n      }\n    }\n  }\n\n  return metadata;\n}\n\nvar ProductRevision = {\n  getProductPriceRange: function (productId) {\n    var _this = this;\n\n    var product = Products.findOne(productId);\n\n    if (!product) {\n      return \"\";\n    }\n\n    var variants = this.getTopVariants(product._id);\n\n    if (variants.length > 0) {\n      var variantPrices = [];\n      variants.forEach(function (variant) {\n        if (variant.isVisible === true) {\n          var range = _this.getVariantPriceRange(variant._id);\n\n          if (typeof range === \"string\") {\n            var firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            var lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n\n      var priceMin = _min(variantPrices);\n\n      var priceMax = _max(variantPrices);\n\n      var priceRange = priceMin + \" - \" + priceMax; // if we don't have a range\n\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n\n      var priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    } // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n\n\n    return product.price;\n  },\n  getVariantPriceRange: function (variantId) {\n    var children = this.getVariants(variantId);\n    var visibleChildren = children.filter(function (child) {\n      return child.isVisible;\n    });\n\n    switch (visibleChildren.length) {\n      case 0:\n        var topVariant = this.getProduct(variantId); // topVariant could be undefined when we removing last top variant\n\n        return topVariant && topVariant.price;\n\n      case 1:\n        return visibleChildren[0].price;\n\n      default:\n        var priceMin = Number.POSITIVE_INFINITY;\n        var priceMax = Number.NEGATIVE_INFINITY;\n        visibleChildren.map(function (child) {\n          if (child.price < priceMin) {\n            priceMin = child.price;\n          }\n\n          if (child.price > priceMax) {\n            priceMax = child.price;\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n\n        return priceMin + \" - \" + priceMax;\n    }\n  },\n  findRevision: function (_ref) {\n    var documentId = _ref.documentId;\n    return Revisions.findOne({\n      \"documentId\": documentId,\n      \"workflow.status\": {\n        $nin: [\"revision/published\"]\n      }\n    });\n  },\n  getProduct: function (variantId) {\n    var product = Products.findOne(variantId);\n    var revision = this.findRevision({\n      documentId: variantId\n    });\n    return revision && revision.documentData || product;\n  },\n  getTopVariants: function (id) {\n    var _this2 = this;\n\n    var variants = [];\n    Products.find({\n      ancestors: [id],\n      type: \"variant\",\n      isDeleted: false\n    }).map(function (product) {\n      var revision = _this2.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n    return variants;\n  },\n  getVariants: function (id, type) {\n    var _this3 = this;\n\n    var variants = [];\n    Products.find({\n      ancestors: {\n        $in: [id]\n      },\n      type: type || \"variant\",\n      isDeleted: false\n    }).forEach(function (product) {\n      var revision = _this3.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n    return variants;\n  },\n  getVariantQuantity: function (variant) {\n    var options = this.getVariants(variant._id);\n\n    if (options && options.length) {\n      return options.reduce(function (sum, option) {\n        return sum + option.inventoryQuantity || 0;\n      }, 0);\n    }\n\n    return variant.inventoryQuantity || 0;\n  }\n};\nMedia.files.before.insert(function (userid, media) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  if (media.metadata.productId) {\n    var revisionMetadata = Object.assign({}, media.metadata);\n    revisionMetadata.workflow = \"published\";\n    Revisions.insert({\n      documentId: media._id,\n      documentData: revisionMetadata,\n      documentType: \"image\",\n      parentDocument: media.metadata.productId,\n      changeType: \"insert\",\n      workflow: {\n        status: \"revision/update\"\n      }\n    });\n    media.metadata.workflow = \"unpublished\";\n  } else {\n    media.metadata.workflow = \"published\";\n  }\n\n  return true;\n});\nMedia.files.before.update(function (userId, media, fieldNames, modifier) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  } // if it's not metadata ignore it, as LOTS of othing things change on this record\n\n\n  if (!_includes(fieldNames, \"metadata\")) {\n    return true;\n  }\n\n  if (media.metadata.productId) {\n    var convertedModifier = convertMetadata(modifier.$set);\n    var convertedMetadata = Object.assign({}, media.metadata, convertedModifier);\n    var existingRevision = Revisions.findOne({\n      \"documentId\": media._id,\n      \"workflow.status\": {\n        $nin: [\"revision/published\"]\n      }\n    });\n\n    if (existingRevision) {\n      var updatedMetadata = Object.assign({}, existingRevision.documentData, convertedMetadata); // Special case where if we have both added and reordered images before publishing we don't want to overwrite\n      // the workflow status since it would be \"unpublished\"\n\n      if (existingRevision.documentData.workflow === \"published\" || existingRevision.changeType === \"insert\") {\n        updatedMetadata.workflow = \"published\";\n      }\n\n      Revisions.update({\n        _id: existingRevision._id\n      }, {\n        $set: {\n          documentData: updatedMetadata\n        }\n      });\n    } else {\n      Revisions.insert({\n        documentId: media._id,\n        documentData: convertedMetadata,\n        documentType: \"image\",\n        parentDocument: media.metadata.productId,\n        changeType: \"update\",\n        workflow: {\n          status: \"revision/update\"\n        }\n      });\n    }\n\n    return false; // prevent actual update of image. This also stops other hooks from running :/\n  } // for non-product images, just ignore and keep on moving\n\n\n  return true;\n});\nMedia.files.before.remove(function (userId, media) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  } // if the media is unpublished, then go ahead and just delete it\n\n\n  if (media.metadata.workflow && media.metadata.workflow === \"unpublished\") {\n    Revisions.remove({\n      documentId: media._id\n    });\n    return true;\n  }\n\n  if (media.metadata.productId) {\n    Revisions.insert({\n      documentId: media._id,\n      documentData: media.metadata,\n      documentType: \"image\",\n      parentDocument: media.metadata.productId,\n      changeType: \"remove\",\n      workflow: {\n        status: \"revision/update\"\n      }\n    });\n    return false; // prevent actual deletion of image. This also stops other hooks from running :/\n  }\n\n  return true;\n});\nProducts.before.insert(function (userId, product) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  var productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }); // Prevent this product from being created if a parent product / varaint ancestor is deleted.\n  //\n  // This will prevent cases where a parent variant hase been deleted and a user tries to create a\n  // child variant. You cannot create the child variant becuase the parent will no longer exist when\n  // changes have been published; resulting in a broken inheretence and UI\n\n  var productHasAncestors = Array.isArray(product.ancestors);\n\n  if (productHasAncestors) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    var archivedCount = Revisions.find({\n      \"documentId\": {\n        $in: product.ancestors\n      },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\"revision/published\"]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(\"Cannot create product \" + product._id + \" as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.\");\n      throw new Meteor.Error(\"Unable to create product variant\");\n    }\n  }\n\n  if (!productRevision) {\n    Logger.debug(\"No revision found for product \" + product._id + \". Creating new revision\");\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n  }\n});\nProducts.before.update(function (userId, product, fieldNames, modifier, options) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  var productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }); // Prevent this product revision from beign restored from isDeleted state if a product / varaint\n  // ancestor is also deleted.\n  //\n  // This will prevent cases where a parent variant hase been deleted and a user tries to undeleted a\n  // child variant. You cannot undeleted the child variant, becuase the parent will no longer exist when\n  // changes have been published; resulting in a broken inheretence and UI\n\n  var revisionHasAncestors = productRevision && productRevision.documentData && Array.isArray(productRevision.documentData.ancestors);\n  var modiferContainsIsDeleted = modifier.$set && modifier.$set.isDeleted === false;\n\n  if (revisionHasAncestors && modiferContainsIsDeleted) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    var archivedCount = Revisions.find({\n      \"documentId\": {\n        $in: productRevision.documentData.ancestors\n      },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\"revision/published\"]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(\"Cannot restore product \" + product._id + \" as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.\");\n      throw new Meteor.Error(\"Unable to delete product variant\");\n    }\n  }\n\n  var originalSelector = this.args[0];\n\n  if (!productRevision) {\n    Logger.debug(\"No revision found for product \" + product._id + \". Creating new revision\"); // Create a new revision\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    }); // Fetch newly created revision\n\n    productRevision = Revisions.findOne({\n      documentId: product._id\n    });\n  } // Create a new selector for the revision\n  //\n  // This is especially important since we may need to update some fields\n  // like metadata, and the selector is very important to that.\n\n\n  var revisionSelector = {\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\"revision/published\"]\n    }\n  }; // Create a new modifier for the revision\n\n  var revisionModifier = {\n    $set: {\n      \"workflow.status\": \"revision/update\"\n    }\n  };\n\n  if (options.publish === true || product.workflow && product.workflow.status === \"product/publish\") {\n    // Maybe mark the revision as published\n    Logger.debug(\"Publishing revison for product \" + product._id + \".\");\n    Revisions.update(revisionSelector, {\n      $set: {\n        \"workflow.status\": \"revision/published\"\n      }\n    });\n    return true;\n  }\n\n  var hasAncestors = Array.isArray(product.ancestors) && product.ancestors.length > 0;\n\n  for (var operation in meteorBabelHelpers.sanitizeForInObject(modifier)) {\n    if (Object.hasOwnProperty.call(modifier, operation)) {\n      if (!revisionModifier[operation]) {\n        revisionModifier[operation] = {};\n      }\n\n      for (var property in meteorBabelHelpers.sanitizeForInObject(modifier[operation])) {\n        if (modifier[operation].hasOwnProperty(property)) {\n          if (operation === \"$set\" && property === \"metafields.$\") {\n            // Special handling for meta fields with $ operator\n            // We need to update the selector otherwise the operation would completly fail.\n            //\n            // This does NOT apply to metafield.0, metafield.1, metafield.n operations\n            // where 0, 1, n represent an array index.\n            revisionSelector[\"documentData.metafields\"] = originalSelector.metafields;\n            revisionModifier.$set[\"documentData.\" + property] = modifier.$set[property];\n          } else if (operation === \"$push\" && property === \"hashtags\") {\n            if (!revisionModifier.$addToSet) {\n              revisionModifier.$addToSet = {};\n            }\n\n            revisionModifier.$addToSet[\"documentData.\" + property] = modifier.$push[property];\n          } else if (operation === \"$set\" && property === \"price\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.price\": modifier.$set.price\n              }\n            });\n            var updateId = product.ancestors[0] || product._id;\n            var priceRange = ProductRevision.getProductPriceRange(updateId);\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && property === \"isVisible\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.isVisible\": modifier.$set.isVisible\n              }\n            });\n\n            var _updateId = product.ancestors[0] || product._id;\n\n            var _priceRange = ProductRevision.getProductPriceRange(_updateId);\n\n            Meteor.call(\"products/updateProductField\", _updateId, \"price\", _priceRange);\n          } else if (operation === \"$set\" && (property === \"title\" || property === \"handle\") && hasAncestors === false) {\n            // Special handling for product title and handle\n            //\n            // Summary:\n            // When a user updates the product title, if the handle matches the product id,\n            // then update the handle to be a sligified version of the title\n            //\n            // This block ensures that the handle is either a custom slug, slug of the title, or\n            // the _id of the product, but is never blank\n            // New data\n            var newValue = modifier.$set[property];\n            var newTitle = modifier.$set.title;\n            var newHandle = modifier.$set.handle; // Current revision data\n\n            var _documentId = productRevision.documentId;\n            var slugDocId = getSlug(_documentId);\n            var revisionTitle = productRevision.documentData.title;\n            var revisionHandle = productRevision.documentData.handle; // Checks\n\n            var hasNewHandle = _isEmpty(newHandle) === false;\n            var hasExistingTitle = _isEmpty(revisionTitle) === false;\n            var hasNewTitle = _isEmpty(newTitle) === false;\n            var hasHandle = _isEmpty(revisionHandle) === false;\n            var handleMatchesId = revisionHandle === _documentId || revisionHandle === slugDocId || newValue === _documentId || newValue === slugDocId; // Continue to set the title / handle as origionally requested\n            // Handle will get changed if conditions are met in the below if block\n\n            revisionModifier.$set[\"documentData.\" + property] = newValue;\n\n            if ((handleMatchesId || hasHandle === false) && (hasExistingTitle || hasNewTitle) && hasNewHandle === false) {\n              // Set the handle to be the slug of the product.title\n              // when documentId (product._id) matches the handle, then handle is enpty, and a title exists\n              revisionModifier.$set[\"documentData.handle\"] = getSlug(newTitle || revisionTitle);\n            } else if (hasHandle === false && hasExistingTitle === false && hasNewHandle === false) {\n              // If the handle & title is empty, the handle becomes the product id\n              revisionModifier.$set[\"documentData.handle\"] = _documentId;\n            } else if (hasNewHandle === false && property === \"handle\") {\n              // If the handle is empty, the handle becomes the sligified product title, or document id if title does not exist.\n              // const newTitle = modifier.$set[\"title\"];\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle ? getSlug(newTitle || revisionTitle) : _documentId;\n            }\n          } else if (operation === \"$unset\" && property === \"handle\" && hasAncestors === false) {\n            // Special handling for product handle when it is going to be unset\n            //\n            // Summary:\n            // When a user updates the handle to a black string e.g. deltes all text in field in UI and saves,\n            // the handle will be adjusted so it will not be blank\n            var _newValue = modifier.$unset[property];\n            var _revisionTitle = productRevision.documentData.title;\n\n            var _hasExistingTitle = _isEmpty(_revisionTitle) === false; // If the new handle is going to be empty, the handle becomes the sligified product title, or document id if title does not exist.\n\n\n            if (_isEmpty(_newValue)) {\n              revisionModifier.$set[\"documentData.handle\"] = _hasExistingTitle ? getSlug(_revisionTitle) : documentId;\n            }\n          } else {\n            // Let everything else through\n            revisionModifier[operation][\"documentData.\" + property] = modifier[operation][property];\n          }\n        }\n      }\n    }\n  }\n\n  Revisions.update(revisionSelector, revisionModifier);\n  Logger.debug(\"Revison updated for product \" + product._id + \".\");\n\n  if (modifier.$pull && modifier.$pull.hashtags) {\n    var tagId = modifier.$pull.hashtags;\n    var productCount = Products.find({\n      hashtags: {\n        $in: [tagId]\n      }\n    }).count();\n    var relatedTagsCount = Tags.find({\n      relatedTagIds: {\n        $in: [tagId]\n      }\n    }).count();\n\n    if (productCount === 0 && relatedTagsCount === 0) {\n      // Mark tag as deleted\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: true\n        }\n      });\n    } else {\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: false\n        }\n      });\n    }\n  } // If we are using $set or $inc, and the fields are one of the ignoredFields,\n  // allow product to be updated without going through revision control\n\n\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    var newSet = {};\n    var newInc = {};\n    var hasIgnoredFields = false;\n    var ignoredFields = [\"isLowQuantity\", \"isSoldOut\", \"inventoryQuantity\"];\n\n    for (var _iterator = ignoredFields, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var field = _ref2;\n\n      if (modifier.$set && (typeof modifier.$set[field] === \"number\" || typeof modifier.$set[field] === \"boolean\")) {\n        newSet[field] = modifier.$set[field];\n        hasIgnoredFields = true;\n      }\n\n      if (modifier.$inc && (typeof modifier.$inc[field] === \"number\" || typeof modifier.$inc[field] === \"boolean\")) {\n        newInc[field] = modifier.$inc[field];\n        hasIgnoredFields = true;\n      }\n    }\n\n    if (_isEmpty(newSet) === false) {\n      modifier.$set = newSet;\n    }\n\n    if (_isEmpty(newInc) === false) {\n      modifier.$inc = newInc;\n    }\n\n    return hasIgnoredFields === true;\n  } // prevent the underlying document from being modified as it is in draft mode\n\n\n  return false;\n});\nProducts.before.remove(function (userId, product) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  var productRevision = Revisions.findOne({\n    documentId: product._id\n  });\n\n  if (!productRevision) {\n    Logger.debug(\"No revision found for product \" + product._id + \". Creating new revision\");\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n    productRevision = Revisions.findOne({\n      documentId: product._id\n    });\n  } // Set the revision as deleted \"isDeleted: true\"\n\n\n  Revisions.update({\n    documentId: product._id\n  }, {\n    $set: {\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": \"revision/remove\"\n    }\n  });\n  Logger.debug(\"Revison updated for product \" + product._id + \".\");\n  Logger.debug(\"Product \" + product._id + \" is now marked as deleted.\"); // If the original product is deleted, and the user is trying to delete it again,\n  // then actually remove it completly.\n  //\n  // This acts like a trash. Where the product is sent to trash before it can actually\n  // be deleted perminately.\n\n  if (product.isDeleted === true) {\n    Logger.debug(\"Allowing write to product \" + product._id + \" for Collection.remove().\");\n    return true;\n  }\n\n  Logger.debug(\"Preventing write to product \" + product._id + \" for Collection.remove().\");\n  return false;\n});\nRevisions.after.update(function (userId, revision) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  var differences = void 0;\n\n  if (!revision.documentType || revision.documentType === \"product\") {\n    // Make diff\n    var product = Products.findOne({\n      _id: revision.documentId\n    });\n    differences = diff(product, revision.documentData);\n  }\n\n  if (revision.documentType && revision.documentType === \"image\") {\n    var image = Media.findOne(revision.documentId);\n    differences = diff(image.metadata, revision.documentData);\n  }\n\n  Revisions.direct.update({\n    _id: revision._id\n  }, {\n    $set: {\n      diff: differences && differences.map(function (d) {\n        return Object.assign({}, d);\n      })\n    }\n  });\n}, {\n  fetchPrevious: false\n});","map":{"version":3,"sources":["/imports/plugins/core/revisions/server/hooks.js"],"names":["diff","Products","Revisions","Tags","Media","Logger","RevisionApi","getSlug","convertMetadata","modifierObject","metadata","prop","hasOwnProperty","indexOf","splitName","ProductRevision","getProductPriceRange","productId","product","findOne","variants","getTopVariants","_id","length","variantPrices","forEach","variant","isVisible","range","getVariantPriceRange","firstPrice","parseFloat","substr","lastPrice","lastIndexOf","push","priceMin","priceMax","priceRange","toString","priceObject","min","max","price","variantId","children","getVariants","visibleChildren","filter","child","topVariant","getProduct","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","map","findRevision","documentId","$nin","revision","documentData","id","find","ancestors","type","isDeleted","$in","getVariantQuantity","options","reduce","sum","option","inventoryQuantity","files","before","insert","userid","media","isRevisionControlEnabled","revisionMetadata","Object","assign","workflow","documentType","parentDocument","changeType","status","update","userId","fieldNames","modifier","convertedModifier","$set","convertedMetadata","existingRevision","updatedMetadata","remove","productRevision","productHasAncestors","Array","isArray","archivedCount","count","debug","Meteor","Error","revisionHasAncestors","modiferContainsIsDeleted","originalSelector","args","revisionSelector","revisionModifier","publish","hasAncestors","operation","call","property","metafields","$addToSet","$push","updateId","newValue","newTitle","title","newHandle","handle","slugDocId","revisionTitle","revisionHandle","hasNewHandle","hasExistingTitle","hasNewTitle","hasHandle","handleMatchesId","$unset","$pull","hashtags","tagId","productCount","relatedTagsCount","relatedTagIds","$inc","newSet","newInc","hasIgnoredFields","ignoredFields","field","after","differences","image","direct","d","fetchPrevious"],"mappings":"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","file":"/imports/plugins/core/revisions/server/hooks.js.map","sourcesContent":["import _ from \"lodash\";\nimport { diff } from \"deep-diff\";\nimport { Products, Revisions, Tags, Media } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\nimport { RevisionApi } from \"../lib/api\";\nimport { getSlug } from \"/lib/api\";\n\nfunction convertMetadata(modifierObject) {\n  const metadata = {};\n  for (const prop in modifierObject) {\n    if (modifierObject.hasOwnProperty(prop)) {\n      if (prop.indexOf(\"metadata\") !== -1) {\n        const splitName = _.split(prop, \".\")[1];\n        metadata[splitName] = modifierObject[prop];\n      }\n    }\n  }\n  return metadata;\n}\n\nexport const ProductRevision = {\n  getProductPriceRange(productId) {\n    const product = Products.findOne(productId);\n    if (!product) {\n      return \"\";\n    }\n    const variants = this.getTopVariants(product._id);\n\n    if (variants.length > 0) {\n      const variantPrices = [];\n      variants.forEach(variant => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n      const priceMin = _.min(variantPrices);\n      const priceMax = _.max(variantPrices);\n      let priceRange = `${priceMin} - ${priceMax}`;\n      // if we don't have a range\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n      const priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    }\n    // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n    return product.price;\n  },\n\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter(child => child.isVisible);\n\n    switch (visibleChildren.length) {\n      case 0:\n        const topVariant = this.getProduct(variantId);\n        // topVariant could be undefined when we removing last top variant\n        return topVariant && topVariant.price;\n      case 1:\n        return visibleChildren[0].price;\n      default:\n        let priceMin = Number.POSITIVE_INFINITY;\n        let priceMax = Number.NEGATIVE_INFINITY;\n\n        visibleChildren.map(child => {\n          if (child.price < priceMin) {\n            priceMin = child.price;\n          }\n          if (child.price > priceMax) {\n            priceMax = child.price;\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n        return `${priceMin} - ${priceMax}`;\n    }\n  },\n\n  findRevision({ documentId }) {\n    return Revisions.findOne({\n      \"documentId\": documentId,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    });\n  },\n\n  getProduct(variantId) {\n    const product = Products.findOne(variantId);\n    const revision = this.findRevision({\n      documentId: variantId\n    });\n\n    return revision && revision.documentData || product;\n  },\n\n  getTopVariants(id) {\n    const variants = [];\n\n    Products.find({\n      ancestors: [id],\n      type: \"variant\",\n      isDeleted: false\n    }).map((product) => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n\n    return variants;\n  },\n\n  getVariants(id, type) {\n    const variants = [];\n\n    Products.find({\n      ancestors: { $in: [id] },\n      type: type || \"variant\",\n      isDeleted: false\n    }).forEach((product) => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n    return variants;\n  },\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n    if (options && options.length) {\n      return options.reduce((sum, option) =>\n      sum + option.inventoryQuantity || 0, 0);\n    }\n    return variant.inventoryQuantity || 0;\n  }\n};\n\nMedia.files.before.insert((userid, media) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  if (media.metadata.productId) {\n    const revisionMetadata = Object.assign({}, media.metadata);\n    revisionMetadata.workflow = \"published\";\n    Revisions.insert({\n      documentId: media._id,\n      documentData: revisionMetadata,\n      documentType: \"image\",\n      parentDocument: media.metadata.productId,\n      changeType: \"insert\",\n      workflow: {\n        status: \"revision/update\"\n      }\n    });\n    media.metadata.workflow = \"unpublished\";\n  } else {\n    media.metadata.workflow = \"published\";\n  }\n  return true;\n});\n\nMedia.files.before.update((userId, media, fieldNames, modifier) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  // if it's not metadata ignore it, as LOTS of othing things change on this record\n  if (!_.includes(fieldNames, \"metadata\")) {\n    return true;\n  }\n\n  if (media.metadata.productId) {\n    const convertedModifier = convertMetadata(modifier.$set);\n    const convertedMetadata = Object.assign({}, media.metadata, convertedModifier);\n    const existingRevision = Revisions.findOne({\n      \"documentId\": media._id,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    });\n    if (existingRevision) {\n      const updatedMetadata = Object.assign({}, existingRevision.documentData, convertedMetadata);\n      // Special case where if we have both added and reordered images before publishing we don't want to overwrite\n      // the workflow status since it would be \"unpublished\"\n      if (existingRevision.documentData.workflow === \"published\" || existingRevision.changeType === \"insert\") {\n        updatedMetadata.workflow = \"published\";\n      }\n      Revisions.update({ _id: existingRevision._id }, {\n        $set: {\n          documentData: updatedMetadata\n        }\n      });\n    } else {\n      Revisions.insert({\n        documentId: media._id,\n        documentData: convertedMetadata,\n        documentType: \"image\",\n        parentDocument: media.metadata.productId,\n        changeType: \"update\",\n        workflow: {\n          status: \"revision/update\"\n        }\n      });\n    }\n\n    return false; // prevent actual update of image. This also stops other hooks from running :/\n  }\n  // for non-product images, just ignore and keep on moving\n  return true;\n});\n\nMedia.files.before.remove((userId, media) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  // if the media is unpublished, then go ahead and just delete it\n  if (media.metadata.workflow && media.metadata.workflow === \"unpublished\") {\n    Revisions.remove({\n      documentId: media._id\n    });\n    return true;\n  }\n  if (media.metadata.productId) {\n    Revisions.insert({\n      documentId: media._id,\n      documentData: media.metadata,\n      documentType: \"image\",\n      parentDocument: media.metadata.productId,\n      changeType: \"remove\",\n      workflow: {\n        status: \"revision/update\"\n      }\n    });\n    return false; // prevent actual deletion of image. This also stops other hooks from running :/\n  }\n  return true;\n});\n\n\nProducts.before.insert((userId, product) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  const productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  });\n\n  // Prevent this product from being created if a parent product / varaint ancestor is deleted.\n  //\n  // This will prevent cases where a parent variant hase been deleted and a user tries to create a\n  // child variant. You cannot create the child variant becuase the parent will no longer exist when\n  // changes have been published; resulting in a broken inheretence and UI\n  const productHasAncestors = Array.isArray(product.ancestors);\n\n  if (productHasAncestors) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": { $in: product.ancestors },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot create product ${product._id} as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"Unable to create product variant\");\n    }\n  }\n\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n  }\n});\n\n\nProducts.before.update(function (userId, product, fieldNames, modifier, options) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  let productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  });\n\n  // Prevent this product revision from beign restored from isDeleted state if a product / varaint\n  // ancestor is also deleted.\n  //\n  // This will prevent cases where a parent variant hase been deleted and a user tries to undeleted a\n  // child variant. You cannot undeleted the child variant, becuase the parent will no longer exist when\n  // changes have been published; resulting in a broken inheretence and UI\n  const revisionHasAncestors = productRevision && productRevision.documentData && Array.isArray(productRevision.documentData.ancestors);\n  const modiferContainsIsDeleted = modifier.$set && modifier.$set.isDeleted === false;\n\n  if (revisionHasAncestors && modiferContainsIsDeleted) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": { $in: productRevision.documentData.ancestors },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot restore product ${product._id} as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"Unable to delete product variant\");\n    }\n  }\n\n  const originalSelector = this.args[0];\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    // Create a new revision\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n\n    // Fetch newly created revision\n    productRevision = Revisions.findOne({\n      documentId: product._id\n    });\n  }\n\n  // Create a new selector for the revision\n  //\n  // This is especially important since we may need to update some fields\n  // like metadata, and the selector is very important to that.\n  const revisionSelector = {\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  };\n\n  // Create a new modifier for the revision\n  const revisionModifier = {\n    $set: {\n      \"workflow.status\": \"revision/update\"\n    }\n  };\n\n  if (options.publish === true || (product.workflow && product.workflow.status === \"product/publish\")) {\n    // Maybe mark the revision as published\n\n    Logger.debug(`Publishing revison for product ${product._id}.`);\n    Revisions.update(revisionSelector, {\n      $set: {\n        \"workflow.status\": \"revision/published\"\n      }\n    });\n\n    return true;\n  }\n\n  const hasAncestors = Array.isArray(product.ancestors) && product.ancestors.length > 0;\n\n  for (const operation in modifier) {\n    if (Object.hasOwnProperty.call(modifier, operation)) {\n      if (!revisionModifier[operation]) {\n        revisionModifier[operation] = {};\n      }\n\n      for (const property in modifier[operation]) {\n        if (modifier[operation].hasOwnProperty(property)) {\n          if (operation === \"$set\" && property === \"metafields.$\") {\n            // Special handling for meta fields with $ operator\n            // We need to update the selector otherwise the operation would completly fail.\n            //\n            // This does NOT apply to metafield.0, metafield.1, metafield.n operations\n            // where 0, 1, n represent an array index.\n            revisionSelector[\"documentData.metafields\"] = originalSelector.metafields;\n            revisionModifier.$set[`documentData.${property}`] = modifier.$set[property];\n          } else if (operation === \"$push\" && property === \"hashtags\") {\n            if (!revisionModifier.$addToSet) {\n              revisionModifier.$addToSet = {};\n            }\n            revisionModifier.$addToSet[`documentData.${property}`] = modifier.$push[property];\n          } else if (operation === \"$set\" && property === \"price\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.price\": modifier.$set.price\n              }\n            });\n\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && property === \"isVisible\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.isVisible\": modifier.$set.isVisible\n              }\n            });\n\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && (property === \"title\" || property === \"handle\") && hasAncestors === false) {\n            // Special handling for product title and handle\n            //\n            // Summary:\n            // When a user updates the product title, if the handle matches the product id,\n            // then update the handle to be a sligified version of the title\n            //\n            // This block ensures that the handle is either a custom slug, slug of the title, or\n            // the _id of the product, but is never blank\n\n            // New data\n            const newValue = modifier.$set[property];\n            const newTitle = modifier.$set.title;\n            const newHandle = modifier.$set.handle;\n\n            // Current revision data\n            const documentId = productRevision.documentId;\n            const slugDocId = getSlug(documentId);\n            const revisionTitle = productRevision.documentData.title;\n            const revisionHandle = productRevision.documentData.handle;\n\n            // Checks\n            const hasNewHandle = _.isEmpty(newHandle) === false;\n            const hasExistingTitle = _.isEmpty(revisionTitle) === false;\n            const hasNewTitle = _.isEmpty(newTitle) === false;\n            const hasHandle = _.isEmpty(revisionHandle) === false;\n            const handleMatchesId = revisionHandle === documentId || revisionHandle === slugDocId || newValue === documentId || newValue === slugDocId;\n\n            // Continue to set the title / handle as origionally requested\n            // Handle will get changed if conditions are met in the below if block\n            revisionModifier.$set[`documentData.${property}`] = newValue;\n\n            if ((handleMatchesId || hasHandle === false) && (hasExistingTitle || hasNewTitle) && hasNewHandle === false) {\n              // Set the handle to be the slug of the product.title\n              // when documentId (product._id) matches the handle, then handle is enpty, and a title exists\n              revisionModifier.$set[\"documentData.handle\"] = getSlug(newTitle || revisionTitle);\n            } else if (hasHandle === false && hasExistingTitle === false && hasNewHandle === false) {\n              // If the handle & title is empty, the handle becomes the product id\n              revisionModifier.$set[\"documentData.handle\"] = documentId;\n            } else if (hasNewHandle === false && property === \"handle\") {\n              // If the handle is empty, the handle becomes the sligified product title, or document id if title does not exist.\n              // const newTitle = modifier.$set[\"title\"];\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle ? getSlug(newTitle || revisionTitle) : documentId;\n            }\n          } else if (operation === \"$unset\" && property === \"handle\" && hasAncestors === false) {\n            // Special handling for product handle when it is going to be unset\n            //\n            // Summary:\n            // When a user updates the handle to a black string e.g. deltes all text in field in UI and saves,\n            // the handle will be adjusted so it will not be blank\n            const newValue = modifier.$unset[property];\n            const revisionTitle = productRevision.documentData.title;\n            const hasExistingTitle = _.isEmpty(revisionTitle) === false;\n\n            // If the new handle is going to be empty, the handle becomes the sligified product title, or document id if title does not exist.\n            if (_.isEmpty(newValue)) {\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle ? getSlug(revisionTitle) : documentId;\n            }\n          } else {\n            // Let everything else through\n            revisionModifier[operation][`documentData.${property}`] = modifier[operation][property];\n          }\n        }\n      }\n    }\n  }\n\n  Revisions.update(revisionSelector, revisionModifier);\n\n  Logger.debug(`Revison updated for product ${product._id}.`);\n\n  if (modifier.$pull && modifier.$pull.hashtags) {\n    const tagId = modifier.$pull.hashtags;\n\n    const productCount = Products.find({\n      hashtags: {\n        $in: [tagId]\n      }\n    }).count();\n\n    const relatedTagsCount = Tags.find({\n      relatedTagIds: {\n        $in: [tagId]\n      }\n    }).count();\n\n    if (productCount === 0 && relatedTagsCount === 0) {\n      // Mark tag as deleted\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: true\n        }\n      });\n    } else {\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: false\n        }\n      });\n    }\n  }\n\n  // If we are using $set or $inc, and the fields are one of the ignoredFields,\n  // allow product to be updated without going through revision control\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    const newSet = {};\n    const newInc = {};\n    let hasIgnoredFields = false;\n    const ignoredFields = [\n      \"isLowQuantity\",\n      \"isSoldOut\",\n      \"inventoryQuantity\"\n    ];\n\n    for (const field of ignoredFields) {\n      if (modifier.$set && (typeof modifier.$set[field] === \"number\" || typeof modifier.$set[field] === \"boolean\")) {\n        newSet[field] = modifier.$set[field];\n        hasIgnoredFields = true;\n      }\n\n      if (modifier.$inc && (typeof modifier.$inc[field] === \"number\" || typeof modifier.$inc[field] === \"boolean\")) {\n        newInc[field] = modifier.$inc[field];\n        hasIgnoredFields = true;\n      }\n    }\n    if (_.isEmpty(newSet) === false) {\n      modifier.$set = newSet;\n    }\n\n    if (_.isEmpty(newInc) === false) {\n      modifier.$inc = newInc;\n    }\n\n    return hasIgnoredFields === true;\n  }\n\n  // prevent the underlying document from being modified as it is in draft mode\n  return false;\n});\n\nProducts.before.remove(function (userId, product) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  let productRevision = Revisions.findOne({\n    documentId: product._id\n  });\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n    productRevision =  Revisions.findOne({\n      documentId: product._id\n    });\n  }\n\n  // Set the revision as deleted \"isDeleted: true\"\n  Revisions.update({\n    documentId: product._id\n  }, {\n    $set: {\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": \"revision/remove\"\n    }\n  });\n\n  Logger.debug(`Revison updated for product ${product._id}.`);\n  Logger.debug(`Product ${product._id} is now marked as deleted.`);\n\n  // If the original product is deleted, and the user is trying to delete it again,\n  // then actually remove it completly.\n  //\n  // This acts like a trash. Where the product is sent to trash before it can actually\n  // be deleted perminately.\n  if (product.isDeleted === true) {\n    Logger.debug(`Allowing write to product ${product._id} for Collection.remove().`);\n\n    return true;\n  }\n\n  Logger.debug(`Preventing write to product ${product._id} for Collection.remove().`);\n\n  return false;\n});\n\nRevisions.after.update(function (userId, revision) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  let differences;\n\n\n  if (!revision.documentType || revision.documentType === \"product\") {\n    // Make diff\n    const product = Products.findOne({\n      _id: revision.documentId\n    });\n    differences = diff(product, revision.documentData);\n  }\n\n  if (revision.documentType && revision.documentType === \"image\") {\n    const image = Media.findOne(revision.documentId);\n    differences = diff(image.metadata, revision.documentData);\n  }\n\n  Revisions.direct.update({\n    _id: revision._id\n  }, {\n    $set: {\n      diff: differences && differences.map((d) => Object.assign({}, d))\n    }\n  });\n}, {\n  fetchPrevious: false\n});\n"]},"hash":"bec3f3465d4a9bded307e40eff0106193af72525"}
