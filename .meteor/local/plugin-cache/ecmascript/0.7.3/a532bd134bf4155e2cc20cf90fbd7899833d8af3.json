{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/api/hooks.js","filenameRelative":"/server/api/hooks.js","inputSourceMap":{"version":3,"sources":["/server/api/hooks.js"],"names":["Meteor","Hooks","Events","add","name","callback","push","remove","callbackName","_","reject","run","item","constant","callbacks","length","reduce","result","runAsync","isServer","defer","forEach"],"mappings":"AAAA;OAAuB;;;;;AAKvB,AAAM,AAAQ;;;GACd,IAAA,AAAM,QAAN,AAAe,A,AAGf;mBAMA,AAAM,AAAO,AAAM,AAAC,AAAM,AAAa,AACrC,AACA,AAAI,AAAO,AAAM,AAAO,AAAU,AAAa;;;;;;;AAC7C,MAAM,OAAN,AAAa,gBAAb,AAAqB,MAArB,UACD;;iDACD;AAAO,UAAM,OAAN,AAAa,Q,AALtB,AAKE,AAAO,AAAmB,AAAK,AAChC;AAGD;;;GAMA,AAAM,AAAO,AAAS,AAAC,AAAM,AAAiB,AAC5C,AAAM,AAAO,AAAQ,AAAE,AAAO,AAAM,AAAO,AAAO,AAAC,AAAa,AAC9D,AAAO,AAAS,AAAS,AAC1B;;;;;;;AAED,MAAO,OAAP,AAAa,uCALf,AAMC;A,AAGD;;;;GAOA,AAAM,AAAO,AAAM,AAAC,AAAM,AAAM,AAAa,AAC3C,AAAM,AAAY,AAAM,AAAO,AAE/B,AACA,AAAI,AAAO,AAAc,AAAe,AAAC,AAAC,AAAU,AAAQ,AAC1D,AAAO,AAAU,AAAO,AAAC,AAAQ,AAAa,AAC5C,AAAO,AAAS,AAAQ,AACzB,AAAE;;;;;;;;AACJ;+BARH,AASE,AAAO,AACR,O,AAGD;;;;;;;;;AAOA,AAAM,AAAO,AAAW,AAAC,AAAM,AAAM,AAAa,AAChD,AAAM,AAAY,AAAM,AAAO,GAE/B,AAAI,AAAO,AAAY,AAAO,AAAc,AAAe,AAAC,AAAC,AAAU,AAAQ,AAC7E,AACA,AAAO,AAAM,AAAM,AACjB,AACA,AAAU,AAAQ,AAAC,AAAa,AAC9B,AAAS,AAAM;;;;;;;;AAChB,MAFD,kDAGD;AALD,+BAMD;;iFACD;AAZF,AAYE,AAAO,AACR;;AAGD;AAAe,gBAAf;;;;;;;;;OAlFS,OAAT,mB,AAAA,AACA","file":"/server/api/hooks.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\n/**\n * Callback hooks to alter the behavior of common operations or trigger other things.\n * @namespace Hooks.Events\n */\nconst Hooks = {};\nHooks.Events = {};\n\n\n/**\n * Add a callback function to a hook\n * @param {String} name - The name of the hook\n * @param {Function} callback - The callback function\n * @return {Array} array of the currently defined hooks\n */\nHooks.Events.add = (name, callback) => {\n  // if callback array doesn't exist yet, initialize it\n  if (typeof Hooks.Events[name] === \"undefined\") {\n    Hooks.Events[name] = [];\n  }\n  return Hooks.Events[name].push(callback);\n};\n\n\n/**\n * Remove a callback from a hook\n * @param {String} name - The name of the hook\n * @param {String} callbackName - The name of the function to remove\n * @return {Array} array of remaining callbacks\n */\nHooks.Events.remove = (name, callbackName) => {\n  Hooks.Events[name] = _.reject(Hooks.Events[name], (callback) => {\n    return callback.name === callbackName;\n  });\n\n  return Hooks.Events;\n};\n\n\n/**\n * Successively run all of a hook's callbacks on an item\n * @param {String} name - The name of the hook\n * @param {Object} item - The object, modifier, etc. on which to run the callbacks\n * @param {Object} [constant] - An optional constant that will be passed along to each callback\n * @return {Object} Returns the item after it has been through all callbacks for this hook\n */\nHooks.Events.run = (name, item, constant) => {\n  const callbacks = Hooks.Events[name];\n\n  // if the hook exists, and contains callbacks to run\n  if (typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    return callbacks.reduce((result, callback) => {\n      return callback(result, constant);\n    }, item);\n  }\n  return item;\n};\n\n\n/**\n * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n * @param {String} name - The name of the hook\n * @param {Object} item - The object, modifier, etc. on which to run the callbacks\n * @param {Object} [constant] - An optional constant that will be passed along to each callback\n * @return {Object} Returns the item after it has been through all callbacks for this hook\n */\nHooks.Events.runAsync = (name, item, constant) => {\n  const callbacks = Hooks.Events[name];\n\n  if (Meteor.isServer && typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    // use defer to avoid holding up client\n    Meteor.defer(() => {\n      // run all async server callbacks successively on object\n      callbacks.forEach((callback) => {\n        callback(item, constant);\n      });\n    });\n  }\n  return item;\n};\n\n\nexport default Hooks;\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/api/hooks.js.map","sourceFileName":"/server/api/hooks.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"hooks"},"ignored":false,"code":"var Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\n/**\n * Callback hooks to alter the behavior of common operations or trigger other things.\n * @namespace Hooks.Events\n */var Hooks = {};\nHooks.Events = {}; /**\n                    * Add a callback function to a hook\n                    * @param {String} name - The name of the hook\n                    * @param {Function} callback - The callback function\n                    * @return {Array} array of the currently defined hooks\n                    */\n\nHooks.Events.add = function (name, callback) {\n  // if callback array doesn't exist yet, initialize it\n  if (typeof Hooks.Events[name] === \"undefined\") {\n    Hooks.Events[name] = [];\n  }\n\n  return Hooks.Events[name].push(callback);\n}; /**\n    * Remove a callback from a hook\n    * @param {String} name - The name of the hook\n    * @param {String} callbackName - The name of the function to remove\n    * @return {Array} array of remaining callbacks\n    */\n\nHooks.Events.remove = function (name, callbackName) {\n  Hooks.Events[name] = _.reject(Hooks.Events[name], function (callback) {\n    return callback.name === callbackName;\n  });\n  return Hooks.Events;\n}; /**\n    * Successively run all of a hook's callbacks on an item\n    * @param {String} name - The name of the hook\n    * @param {Object} item - The object, modifier, etc. on which to run the callbacks\n    * @param {Object} [constant] - An optional constant that will be passed along to each callback\n    * @return {Object} Returns the item after it has been through all callbacks for this hook\n    */\n\nHooks.Events.run = function (name, item, constant) {\n  var callbacks = Hooks.Events[name]; // if the hook exists, and contains callbacks to run\n\n  if (typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    return callbacks.reduce(function (result, callback) {\n      return callback(result, constant);\n    }, item);\n  }\n\n  return item;\n}; /**\n    * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n    * @param {String} name - The name of the hook\n    * @param {Object} item - The object, modifier, etc. on which to run the callbacks\n    * @param {Object} [constant] - An optional constant that will be passed along to each callback\n    * @return {Object} Returns the item after it has been through all callbacks for this hook\n    */\n\nHooks.Events.runAsync = function (name, item, constant) {\n  var callbacks = Hooks.Events[name];\n\n  if (Meteor.isServer && typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    // use defer to avoid holding up client\n    Meteor.defer(function () {\n      // run all async server callbacks successively on object\n      callbacks.forEach(function (callback) {\n        callback(item, constant);\n      });\n    });\n  }\n\n  return item;\n};\n\nmodule.export(\"default\", exports.default = Hooks);","map":{"version":3,"sources":["/server/api/hooks.js"],"names":["Meteor","Hooks","Events","add","name","callback","push","remove","callbackName","_","reject","run","item","constant","callbacks","length","reduce","result","runAsync","isServer","defer","forEach"],"mappings":"AAAA;OAAuB;;;;;AAKvB,AAAM,AAAQ;;;GACd,IAAA,AAAM,QAAN,AAAe,A,AAGf;mBAMA,AAAM,AAAO,AAAM,AAAC,AAAM,AAAa,AACrC,AACA,AAAI,AAAO,AAAM,AAAO,AAAU,AAAa;;;;;;;AAC7C,MAAM,OAAN,AAAa,gBAAb,AAAqB,MAArB,UACD;;iDACD;AAAO,UAAM,OAAN,AAAa,Q,AALtB,AAKE,AAAO,AAAmB,AAAK,AAChC;AAGD;;;GAMA,AAAM,AAAO,AAAS,AAAC,AAAM,AAAiB,AAC5C,AAAM,AAAO,AAAQ,AAAE,AAAO,AAAM,AAAO,AAAO,AAAC,AAAa,AAC9D,AAAO,AAAS,AAAS,AAC1B;;;;;;;AAED,MAAO,OAAP,AAAa,uCALf,AAMC;A,AAGD;;;;GAOA,AAAM,AAAO,AAAM,AAAC,AAAM,AAAM,AAAa,AAC3C,AAAM,AAAY,AAAM,AAAO,AAE/B,AACA,AAAI,AAAO,AAAc,AAAe,AAAC,AAAC,AAAU,AAAQ,AAC1D,AAAO,AAAU,AAAO,AAAC,AAAQ,AAAa,AAC5C,AAAO,AAAS,AAAQ,AACzB,AAAE;;;;;;;;AACJ;+BARH,AASE,AAAO,AACR,O,AAGD;;;;;;;;;AAOA,AAAM,AAAO,AAAW,AAAC,AAAM,AAAM,AAAa,AAChD,AAAM,AAAY,AAAM,AAAO,GAE/B,AAAI,AAAO,AAAY,AAAO,AAAc,AAAe,AAAC,AAAC,AAAU,AAAQ,AAC7E,AACA,AAAO,AAAM,AAAM,AACjB,AACA,AAAU,AAAQ,AAAC,AAAa,AAC9B,AAAS,AAAM;;;;;;;;AAChB,MAFD,kDAGD;AALD,+BAMD;;iFACD;AAZF,AAYE,AAAO,AACR;;AAGD;AAAe,gBAAf;;;;;;;;;OAlFS,OAAT,mB,AAAA,AACA","file":"/server/api/hooks.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\n/**\n * Callback hooks to alter the behavior of common operations or trigger other things.\n * @namespace Hooks.Events\n */\nconst Hooks = {};\nHooks.Events = {};\n\n\n/**\n * Add a callback function to a hook\n * @param {String} name - The name of the hook\n * @param {Function} callback - The callback function\n * @return {Array} array of the currently defined hooks\n */\nHooks.Events.add = (name, callback) => {\n  // if callback array doesn't exist yet, initialize it\n  if (typeof Hooks.Events[name] === \"undefined\") {\n    Hooks.Events[name] = [];\n  }\n  return Hooks.Events[name].push(callback);\n};\n\n\n/**\n * Remove a callback from a hook\n * @param {String} name - The name of the hook\n * @param {String} callbackName - The name of the function to remove\n * @return {Array} array of remaining callbacks\n */\nHooks.Events.remove = (name, callbackName) => {\n  Hooks.Events[name] = _.reject(Hooks.Events[name], (callback) => {\n    return callback.name === callbackName;\n  });\n\n  return Hooks.Events;\n};\n\n\n/**\n * Successively run all of a hook's callbacks on an item\n * @param {String} name - The name of the hook\n * @param {Object} item - The object, modifier, etc. on which to run the callbacks\n * @param {Object} [constant] - An optional constant that will be passed along to each callback\n * @return {Object} Returns the item after it has been through all callbacks for this hook\n */\nHooks.Events.run = (name, item, constant) => {\n  const callbacks = Hooks.Events[name];\n\n  // if the hook exists, and contains callbacks to run\n  if (typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    return callbacks.reduce((result, callback) => {\n      return callback(result, constant);\n    }, item);\n  }\n  return item;\n};\n\n\n/**\n * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n * @param {String} name - The name of the hook\n * @param {Object} item - The object, modifier, etc. on which to run the callbacks\n * @param {Object} [constant] - An optional constant that will be passed along to each callback\n * @return {Object} Returns the item after it has been through all callbacks for this hook\n */\nHooks.Events.runAsync = (name, item, constant) => {\n  const callbacks = Hooks.Events[name];\n\n  if (Meteor.isServer && typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    // use defer to avoid holding up client\n    Meteor.defer(() => {\n      // run all async server callbacks successively on object\n      callbacks.forEach((callback) => {\n        callback(item, constant);\n      });\n    });\n  }\n  return item;\n};\n\n\nexport default Hooks;\n"]},"hash":"a532bd134bf4155e2cc20cf90fbd7899833d8af3"}
