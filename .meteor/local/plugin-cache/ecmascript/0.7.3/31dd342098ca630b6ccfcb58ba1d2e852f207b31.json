{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/check","imported":["check","Match"],"specifiers":[{"kind":"named","imported":"check","local":"check"},{"kind":"named","imported":"Match","local":"Match"}]},{"source":"/lib/api","imported":["Catalog"],"specifiers":[{"kind":"named","imported":"Catalog","local":"Catalog"}]},{"source":"/lib/collections","imported":["Inventory"],"specifiers":[{"kind":"named","imported":"Inventory","local":"Inventory"}]},{"source":"/lib/collections/schemas","imported":["*"],"specifiers":[{"kind":"namespace","local":"Schemas"}]},{"source":"/server/api","imported":["Logger","Reaction"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":["registerInventory","product"],"specifiers":[{"kind":"local","local":"registerInventory","exported":"registerInventory"},{"kind":"local","local":"product","exported":"product"}]}}},"options":{"filename":"/imports/plugins/included/inventory/server/methods/inventory.js","filenameRelative":"/imports/plugins/included/inventory/server/methods/inventory.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/included/inventory/server/methods/inventory.js"],"names":["Meteor","check","Match","Catalog","Inventory","Schemas","Logger","Reaction","registerInventory","product","OneOf","ProductVariant","Product","type","totalNewInventory","productId","ancestors","_id","variants","getVariants","variant","inventory","find","variantId","shopId","inventoryVariantCount","count","inventoryQuantity","newQty","i","debug","batch","_collection","rawCollection","initializeUnorderedBulkOp","id","_makeNewID","insert","createdAt","Date","updatedAt","workflow","status","execute","wrapAsync","inventoryItem","inserted","nInserted","adjustInventory","results","hasPermission","Error","qty","itemCount","call","removeQty","removeInventory","sort","limit","fetch","methods"],"mappings":"AAAA,OAAS;AAAT,AAAuB;WAAvB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GACA,A,AAAS,AAAO,AAAa,AAC7B,AAAS,AAAe,AACxB,AAAS,AAAiB,AAC1B,AAAO,AAAK,AAAa,AACzB,AAAS,AAAQ,AAAgB,AAEjC,AAMA,AAAO,AAAS,AAAkB,AAAS,AACzC,AAAM,AAAS,AAAM,AAAM,AAAQ,AAAgB,AAAQ,AAC3D,AAAI;;AAAJ;6DACA;MAAA,AAAQ,AAAQ,AACd;;AAAK,kBAAL,AACE;SAAA,AAAM,AAAS,AAAQ,AACvB;YAAO,SAAP,QACA;;AACF;;AACE;YAAA,AAAM,SAAS,QAAf,AAAuB,AACvB;aAPJ,AAOI,AAAO;;;0BAEX;AAAI,kBAAJ,AAAwB,oDACxB;MAAM,WAAY,QAAA,AAAS,YAbc,AAazC,AAAkB,AAAqB,AAAQ,AAAU,AAAK,AAAQ,AACtE,AAAM,AAAW,AAAQ,AAAY,AAErC,YACA;;AAAK,uBAAL,AAAsB;AAAU,AAC9B;;;;;;;;;;;QADF,AAAW;QACH,sBAAY,AAAU;iBAAK,AACpB,AACX;iBAAW,QAFoB,AAEZ,AACnB;cAAQ,QAJoB,AAC9B,AAAkB,AAAe,AAGf,AAElB;AALiC,AAC/B,KADgB,GAMlB;;QAAM,wBAAwB,UAPA,AAO9B,AAA8B,AAAU,AACxC,AACA;AACA;;QAAI,wBAAwB,QAA5B,AAAoC;UAC5B,SAAS,QAAA,AAAQ,qBAAvB,AAA4C,AAC5C;UAAI,IAAI,wBAAR,AAAgC,AAEhC,AAAO,AACJ,AAAY,AAAS,AACnB,AAA2B,AAAQ,AAAI;aAG5C,AAAM,AAAQ,+BAAd,AAAc,AACd,AAAY,AAAgB,+DAC5B,AAAO,AAAK,AAAQ,AAClB,AAAM,AAAK,AAAU;;kBACrB,UAAM,YAAN,AAAa,gBACX;;aADW,AACN,aACL;iBAAW,UAFA,AAGX;;;eAHW,AAIH,AAAQ,AAChB;qBALW,AAKA,AAAI,AACf;qBAAW,AAAI,QANJ,AAMA,AACX;kBAAU,QAAE;yBACV;AAAQ,yBADA,AACM;;AADN;0BApBuC,AAanD,AAAa,AAWb,AACD;;;AAZc,AAGA,AAAQ,AACnB;AAUJ;AACA,OA5BqD,AACrD,CA2BA,AAAM,AAAU,AAAO,AAAU,AAAM,AAAS,AAChD;;;UAAM,UAAgB,OAAtB,yBACA;UAAM,AAAW,gBAAjB,AAA+B;mCAE/B,AAAI,AAAC,AAAU,AAAE;;;AACf;AACA;eAAA,AAAO,AACR;;;mCACD;AAAA,AAAO,AAAO,2BAAd,AAA2B,AAAS,AACpC;AAAA,AAAqB,AACtB;AACF,IAlEwC,AAmEzC;;;;AACA,AAAO;;AACR;MAED;MAAA,AAAS,AAAgB,AAAS,AAChC,kBAAA,AAAI,AACJ;;AAAI,UAF4B,AAEhC,AACA;SACA;AAAQ,YAAQ,SAAhB,QACE;AAAK,aAAL,AACE;AAAA,AAAM,AAAS,AAAQ,AACvB;;AAAA,AAAO,AACP;;aACF,AACE;IAAA,AAAM,AAAS,AAAQ,AACvB;;;OAAO,SAAP,gCAX4B,AAIhC;AASA;IACA,AAAI,AAAC,AAAS,AAAc,AAAkB,AAC5C;AAAA,AAAM,AAAI,AAAO,AAAM,AAAK,AAC7B;;;AAhB+B,AAiBhC,0BAEA;;;wCACA,AAAI,AAAS,AAAW,AACtB,AAAM,AAAU,AACd;;QAAK,AAAQ;AACR,iBAAQ,kBAFf,AAAgB,AAET,AAA6B;yBAGpC,AAAM,AAAY,AAAU,AAAK,AAC/B;AAJA,KAFc;QAMH,YAAQ,UADY,AACpB,AAAkB,AAC7B,AAAW,AAAQ;;AAFrB,AAAkB,mCAIlB;UAAM,YAAY,QAAU,KAA5B,AAAkB;AAElB;AAAI,kBAAc,YAAlB,AAA0B,AAAK,kCAC7B;AAAI,iBAAY,YAAhB,AAAwB,AAAK;AAE3B;YAAU,YAAY,AAAO,YAAP,AAAY,QAFpC,AAEE,AAAsB,AAAkC,AACzD,KAAM,AAAI,AAAY,AAAQ,AAAK,AAClC;;;AACM,uBAAY,QAFgB,AAElC,AAA8B,AAAQ,AACtC;6BACA;AAFA;;wBAEwB,AAAe,AAElB,AAClB,AACD;AAJqC,AACxB,AAAQ,AACrB;AAEM,iBACJ;AALE,AAAkB,AAAU,AAAK,AACrC,WAEC,AACK,AACO,AAAC,AAEd;AAAO,kBAJN,UATH,CAMA,AAAwB,AAQrB,AAEH;;AAAU;;;;;;;;;;;;cAdwB,AAclC,AACA;qDACA,gBAAA,AAAK,AAAM,AAAiB,AAAiB,AAC3C;AAD2C,AAC3C,AAAW,AAAO,AAAK,AAAoB,AAC3C,AACD;AACF;;qFACD,AAAO,AACJ,AAAiB,AAAQ,AAAI,AAAQ,AAAU,AAAM,AAAQ,AAEjE;AACF;AACF;;;AAED,OAAA,AAAO;wBACiB,UAAA,AAAU,SAAS,AACvC;QAAI,CAAC,SAAA,AAAS,cAAd,AAAK,AAAuB,kBAAkB,AAC5C;YAAM,IAAI,OAAJ,AAAW,MAAX,AAAiB,KAAvB,AAAM,AAAsB,AAC7B;;;sBACD;AAAA,AAAkB,AACnB;AANY;AAOb;mBAAoB,YAAU,QAAV,AAAmB,iBAAE;oBACvC;AARJ,AAAe,AAQX,AAAM,AAAS,AAAM,AAAM,AAAQ,AAAS,AAAQ,AACpD,AAAgB,AACjB;AAVY,AACb","file":"/imports/plugins/included/inventory/server/methods/inventory.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Catalog } from \"/lib/api\";\nimport { Inventory } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * inventory/register\n * @summary check a product and update Inventory collection with inventory documents.\n * @param {Object} product - valid Schemas.Product object\n * @return {Number} - returns the total amount of new inventory created\n */\nexport function registerInventory(product) {\n  check(product, Match.OneOf(Schemas.ProductVariant, Schemas.Product));\n  let type;\n  switch (product.type) {\n    case \"variant\":\n      check(product, Schemas.ProductVariant);\n      type = \"variant\";\n      break;\n    default:\n      check(product, Schemas.Product);\n      type = \"simple\";\n  }\n  let totalNewInventory = 0;\n  const productId = type === \"variant\" ? product.ancestors[0] : product._id;\n  const variants = Catalog.getVariants(productId);\n\n  // we'll check each variant to see if it has been fully registered\n  for (const variant of variants) {\n    const inventory = Inventory.find({\n      productId: productId,\n      variantId: variant._id,\n      shopId: product.shopId\n    });\n    // we'll return this as well\n    const inventoryVariantCount = inventory.count();\n    // if the variant exists already we're remove from the inventoryVariants\n    // so that we don't process it as an insert\n    if (inventoryVariantCount < variant.inventoryQuantity) {\n      const newQty = variant.inventoryQuantity || 0;\n      let i = inventoryVariantCount + 1;\n\n      Logger.debug(\n        `inserting ${newQty - inventoryVariantCount\n          } new inventory items for ${variant._id}`\n      );\n\n      const batch = Inventory.\n      _collection.rawCollection().initializeUnorderedBulkOp();\n      while (i <= newQty) {\n        const id = Inventory._makeNewID();\n        batch.insert({\n          _id: id,\n          productId: productId,\n          variantId: variant._id,\n          shopId: product.shopId,\n          createdAt: new Date,\n          updatedAt: new Date,\n          workflow: { // we add this line because `batchInsert` doesn't know\n            status: \"new\" // about SimpleSchema, so `defaultValue` will not\n          }\n        });\n        i++;\n      }\n\n      // took from: http://guide.meteor.com/collections.html#bulk-data-changes\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n      const inventoryItem = execute();\n      const inserted = inventoryItem.nInserted;\n\n      if (!inserted) { // or maybe `inventory.length === 0`?\n        // throw new Meteor.Error(\"Inventory Anomaly Detected. Abort! Abort!\");\n        return totalNewInventory;\n      }\n      Logger.debug(`registered ${inserted}`);\n      totalNewInventory += inserted;\n    }\n  }\n  // returns the total amount of new inventory created\n  return totalNewInventory;\n}\n\nfunction adjustInventory(product) {\n  let type;\n  let results;\n  // adds or updates inventory collection with this product\n  switch (product.type) {\n    case \"variant\":\n      check(product, Schemas.ProductVariant);\n      type = \"variant\";\n      break;\n    default:\n      check(product, Schemas.Product);\n      type = \"simple\";\n  }\n  // user needs createProduct permission to adjust inventory\n  if (!Reaction.hasPermission(\"createProduct\")) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  }\n  // this.unblock();\n\n  // Quantity and variants of this product's variant inventory\n  if (type === \"variant\") {\n    const variant = {\n      _id: product._id,\n      qty: product.inventoryQuantity || 0\n    };\n\n    const inventory = Inventory.find({\n      productId: product.ancestors[0],\n      variantId: product._id\n    });\n    const itemCount = inventory.count();\n\n    if (itemCount !== variant.qty) {\n      if (itemCount < variant.qty) {\n        // we need to register some new variants to inventory\n        results = itemCount + Meteor.call(\"inventory/register\", product);\n      } else if (itemCount > variant.qty) {\n        // determine how many records to delete\n        const removeQty = itemCount - variant.qty;\n        // we're only going to delete records that are new\n        const removeInventory = Inventory.find({\n          \"variantId\": variant._id,\n          \"workflow.status\": \"new\"\n        }, {\n          sort: {\n            updatedAt: -1\n          },\n          limit: removeQty\n        }).fetch();\n\n        results = itemCount;\n        // delete latest inventory \"status:new\" records\n        for (const inventoryItem of removeInventory) {\n          results -= Meteor.call(\"inventory/remove\", inventoryItem);\n          // we could add handling for the case when aren't enough \"new\" items\n        }\n      }\n      Logger.debug(\n        `adjust variant ${variant._id} from ${itemCount} to ${results}`\n      );\n    }\n  }\n}\n\nMeteor.methods({\n  \"inventory/register\": function (product) {\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    registerInventory(product);\n  },\n  \"inventory/adjust\": function (product) { // TODO: this should be variant\n    check(product, Match.OneOf(Schemas.Product, Schemas.ProductVariant));\n    adjustInventory(product);\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/included/inventory/server/methods/inventory.js.map","sourceFileName":"/imports/plugins/included/inventory/server/methods/inventory.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"inventory"},"ignored":false,"code":"module.export({\n  registerInventory: function () {\n    return registerInventory;\n  }\n});\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar check = void 0,\n    Match = void 0;\nmodule.importSync(\"meteor/check\", {\n  check: function (v) {\n    check = v;\n  },\n  Match: function (v) {\n    Match = v;\n  }\n}, 1);\nvar Catalog = void 0;\nmodule.importSync(\"/lib/api\", {\n  Catalog: function (v) {\n    Catalog = v;\n  }\n}, 2);\nvar Inventory = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Inventory: function (v) {\n    Inventory = v;\n  }\n}, 3);\nvar Schemas = Object.create(null);\nmodule.importSync(\"/lib/collections/schemas\", {\n  \"*\": function (v, n) {\n    Schemas[n] = v;\n  }\n}, 4);\nvar Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 5);\n\nfunction registerInventory(product) {\n  check(product, Match.OneOf(Schemas.ProductVariant, Schemas.Product));\n  var type = void 0;\n\n  switch (product.type) {\n    case \"variant\":\n      check(product, Schemas.ProductVariant);\n      type = \"variant\";\n      break;\n\n    default:\n      check(product, Schemas.Product);\n      type = \"simple\";\n  }\n\n  var totalNewInventory = 0;\n  var productId = type === \"variant\" ? product.ancestors[0] : product._id;\n  var variants = Catalog.getVariants(productId); // we'll check each variant to see if it has been fully registered\n\n  for (var _iterator = variants, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var variant = _ref;\n    var inventory = Inventory.find({\n      productId: productId,\n      variantId: variant._id,\n      shopId: product.shopId\n    }); // we'll return this as well\n\n    var inventoryVariantCount = inventory.count(); // if the variant exists already we're remove from the inventoryVariants\n    // so that we don't process it as an insert\n\n    if (inventoryVariantCount < variant.inventoryQuantity) {\n      var newQty = variant.inventoryQuantity || 0;\n      var i = inventoryVariantCount + 1;\n      Logger.debug(\"inserting \" + (newQty - inventoryVariantCount) + \" new inventory items for \" + variant._id);\n\n      var batch = Inventory._collection.rawCollection().initializeUnorderedBulkOp();\n\n      while (i <= newQty) {\n        var id = Inventory._makeNewID();\n\n        batch.insert({\n          _id: id,\n          productId: productId,\n          variantId: variant._id,\n          shopId: product.shopId,\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          workflow: {\n            // we add this line because `batchInsert` doesn't know\n            status: \"new\" // about SimpleSchema, so `defaultValue` will not\n\n          }\n        });\n        i++;\n      } // took from: http://guide.meteor.com/collections.html#bulk-data-changes\n\n\n      var execute = Meteor.wrapAsync(batch.execute, batch);\n      var inventoryItem = execute();\n      var inserted = inventoryItem.nInserted;\n\n      if (!inserted) {\n        // or maybe `inventory.length === 0`?\n        // throw new Meteor.Error(\"Inventory Anomaly Detected. Abort! Abort!\");\n        return totalNewInventory;\n      }\n\n      Logger.debug(\"registered \" + inserted);\n      totalNewInventory += inserted;\n    }\n  } // returns the total amount of new inventory created\n\n\n  return totalNewInventory;\n}\n\nfunction adjustInventory(product) {\n  var type = void 0;\n  var results = void 0; // adds or updates inventory collection with this product\n\n  switch (product.type) {\n    case \"variant\":\n      check(product, Schemas.ProductVariant);\n      type = \"variant\";\n      break;\n\n    default:\n      check(product, Schemas.Product);\n      type = \"simple\";\n  } // user needs createProduct permission to adjust inventory\n\n\n  if (!Reaction.hasPermission(\"createProduct\")) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  } // this.unblock();\n  // Quantity and variants of this product's variant inventory\n\n\n  if (type === \"variant\") {\n    var variant = {\n      _id: product._id,\n      qty: product.inventoryQuantity || 0\n    };\n    var inventory = Inventory.find({\n      productId: product.ancestors[0],\n      variantId: product._id\n    });\n    var itemCount = inventory.count();\n\n    if (itemCount !== variant.qty) {\n      if (itemCount < variant.qty) {\n        // we need to register some new variants to inventory\n        results = itemCount + Meteor.call(\"inventory/register\", product);\n      } else if (itemCount > variant.qty) {\n        // determine how many records to delete\n        var removeQty = itemCount - variant.qty; // we're only going to delete records that are new\n\n        var removeInventory = Inventory.find({\n          \"variantId\": variant._id,\n          \"workflow.status\": \"new\"\n        }, {\n          sort: {\n            updatedAt: -1\n          },\n          limit: removeQty\n        }).fetch();\n        results = itemCount; // delete latest inventory \"status:new\" records\n\n        for (var _iterator2 = removeInventory, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n          var _ref2;\n\n          if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref2 = _iterator2[_i2++];\n          } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref2 = _i2.value;\n          }\n\n          var inventoryItem = _ref2;\n          results -= Meteor.call(\"inventory/remove\", inventoryItem); // we could add handling for the case when aren't enough \"new\" items\n        }\n      }\n\n      Logger.debug(\"adjust variant \" + variant._id + \" from \" + itemCount + \" to \" + results);\n    }\n  }\n}\n\nMeteor.methods({\n  \"inventory/register\": function (product) {\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    registerInventory(product);\n  },\n  \"inventory/adjust\": function (product) {\n    // TODO: this should be variant\n    check(product, Match.OneOf(Schemas.Product, Schemas.ProductVariant));\n    adjustInventory(product);\n  }\n});","map":{"version":3,"sources":["/imports/plugins/included/inventory/server/methods/inventory.js"],"names":["Meteor","check","Match","Catalog","Inventory","Schemas","Logger","Reaction","registerInventory","product","OneOf","ProductVariant","Product","type","totalNewInventory","productId","ancestors","_id","variants","getVariants","variant","inventory","find","variantId","shopId","inventoryVariantCount","count","inventoryQuantity","newQty","i","debug","batch","_collection","rawCollection","initializeUnorderedBulkOp","id","_makeNewID","insert","createdAt","Date","updatedAt","workflow","status","execute","wrapAsync","inventoryItem","inserted","nInserted","adjustInventory","results","hasPermission","Error","qty","itemCount","call","removeQty","removeInventory","sort","limit","fetch","methods"],"mappings":"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","file":"/imports/plugins/included/inventory/server/methods/inventory.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Catalog } from \"/lib/api\";\nimport { Inventory } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * inventory/register\n * @summary check a product and update Inventory collection with inventory documents.\n * @param {Object} product - valid Schemas.Product object\n * @return {Number} - returns the total amount of new inventory created\n */\nexport function registerInventory(product) {\n  check(product, Match.OneOf(Schemas.ProductVariant, Schemas.Product));\n  let type;\n  switch (product.type) {\n    case \"variant\":\n      check(product, Schemas.ProductVariant);\n      type = \"variant\";\n      break;\n    default:\n      check(product, Schemas.Product);\n      type = \"simple\";\n  }\n  let totalNewInventory = 0;\n  const productId = type === \"variant\" ? product.ancestors[0] : product._id;\n  const variants = Catalog.getVariants(productId);\n\n  // we'll check each variant to see if it has been fully registered\n  for (const variant of variants) {\n    const inventory = Inventory.find({\n      productId: productId,\n      variantId: variant._id,\n      shopId: product.shopId\n    });\n    // we'll return this as well\n    const inventoryVariantCount = inventory.count();\n    // if the variant exists already we're remove from the inventoryVariants\n    // so that we don't process it as an insert\n    if (inventoryVariantCount < variant.inventoryQuantity) {\n      const newQty = variant.inventoryQuantity || 0;\n      let i = inventoryVariantCount + 1;\n\n      Logger.debug(\n        `inserting ${newQty - inventoryVariantCount\n          } new inventory items for ${variant._id}`\n      );\n\n      const batch = Inventory.\n      _collection.rawCollection().initializeUnorderedBulkOp();\n      while (i <= newQty) {\n        const id = Inventory._makeNewID();\n        batch.insert({\n          _id: id,\n          productId: productId,\n          variantId: variant._id,\n          shopId: product.shopId,\n          createdAt: new Date,\n          updatedAt: new Date,\n          workflow: { // we add this line because `batchInsert` doesn't know\n            status: \"new\" // about SimpleSchema, so `defaultValue` will not\n          }\n        });\n        i++;\n      }\n\n      // took from: http://guide.meteor.com/collections.html#bulk-data-changes\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n      const inventoryItem = execute();\n      const inserted = inventoryItem.nInserted;\n\n      if (!inserted) { // or maybe `inventory.length === 0`?\n        // throw new Meteor.Error(\"Inventory Anomaly Detected. Abort! Abort!\");\n        return totalNewInventory;\n      }\n      Logger.debug(`registered ${inserted}`);\n      totalNewInventory += inserted;\n    }\n  }\n  // returns the total amount of new inventory created\n  return totalNewInventory;\n}\n\nfunction adjustInventory(product) {\n  let type;\n  let results;\n  // adds or updates inventory collection with this product\n  switch (product.type) {\n    case \"variant\":\n      check(product, Schemas.ProductVariant);\n      type = \"variant\";\n      break;\n    default:\n      check(product, Schemas.Product);\n      type = \"simple\";\n  }\n  // user needs createProduct permission to adjust inventory\n  if (!Reaction.hasPermission(\"createProduct\")) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  }\n  // this.unblock();\n\n  // Quantity and variants of this product's variant inventory\n  if (type === \"variant\") {\n    const variant = {\n      _id: product._id,\n      qty: product.inventoryQuantity || 0\n    };\n\n    const inventory = Inventory.find({\n      productId: product.ancestors[0],\n      variantId: product._id\n    });\n    const itemCount = inventory.count();\n\n    if (itemCount !== variant.qty) {\n      if (itemCount < variant.qty) {\n        // we need to register some new variants to inventory\n        results = itemCount + Meteor.call(\"inventory/register\", product);\n      } else if (itemCount > variant.qty) {\n        // determine how many records to delete\n        const removeQty = itemCount - variant.qty;\n        // we're only going to delete records that are new\n        const removeInventory = Inventory.find({\n          \"variantId\": variant._id,\n          \"workflow.status\": \"new\"\n        }, {\n          sort: {\n            updatedAt: -1\n          },\n          limit: removeQty\n        }).fetch();\n\n        results = itemCount;\n        // delete latest inventory \"status:new\" records\n        for (const inventoryItem of removeInventory) {\n          results -= Meteor.call(\"inventory/remove\", inventoryItem);\n          // we could add handling for the case when aren't enough \"new\" items\n        }\n      }\n      Logger.debug(\n        `adjust variant ${variant._id} from ${itemCount} to ${results}`\n      );\n    }\n  }\n}\n\nMeteor.methods({\n  \"inventory/register\": function (product) {\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    registerInventory(product);\n  },\n  \"inventory/adjust\": function (product) { // TODO: this should be variant\n    check(product, Match.OneOf(Schemas.Product, Schemas.ProductVariant));\n    adjustInventory(product);\n  }\n});\n"]},"hash":"31dd342098ca630b6ccfcb58ba1d2e852f207b31"}
