{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"lodash/find","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_find"}]},{"source":"lodash/upperCase","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_upperCase"}]},{"source":"lodash/trim","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_trim"}]},{"source":"lodash/get","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_get"}]},{"source":"lodash/includes","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_includes"}]},{"source":"lodash/filter","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_filter"}]},{"source":"moment","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"moment"}]},{"source":"path","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"path"}]},{"source":"meteor/accounts-base","imported":["Accounts"],"specifiers":[{"kind":"named","imported":"Accounts","local":"MeteorAccounts"}]},{"source":"/lib/collections","imported":["Accounts","Cart","Media","Shops","Packages"],"specifiers":[{"kind":"named","imported":"Accounts","local":"Accounts"},{"kind":"named","imported":"Cart","local":"Cart"},{"kind":"named","imported":"Media","local":"Media"},{"kind":"named","imported":"Shops","local":"Shops"},{"kind":"named","imported":"Packages","local":"Packages"}]},{"source":"/lib/collections/schemas","imported":["*"],"specifiers":[{"kind":"namespace","local":"Schemas"}]},{"source":"/server/api","imported":["Logger","Reaction"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/methods/accounts/accounts.js","filenameRelative":"/server/methods/accounts/accounts.js","inputSourceMap":{"version":3,"sources":["/server/methods/accounts/accounts.js"],"names":["moment","path","Accounts","MeteorAccounts","Cart","Media","Shops","Packages","Schemas","Logger","Reaction","getValidator","shopId","getShopId","geoCoders","find","fetch","length","geoCoder","coder","name","registryName","registry","provides","packageKey","split","settings","methodName","addressValidation","addressValidationMethod","compareAddress","address","validationAddress","errors","address1","push","address2","city","postal","region","country","validateAddress","check","Object","validated","validationErrors","validatedAddress","formErrors","Address","clean","validator","validationResult","Meteor","call","validationResults","fieldErrors","methods","user","users","findOne","userId","services","password","accountUserId","Match","Optional","String","hasAdminAccess","Error","unblock","_id","Random","id","isShippingDefault","isBillingDefault","cart","update","$set","upsert","$addToSet","type","OneOf","undefined","account","oldAddress","profile","addressBook","addr","assign","addressId","$pull","email","shop","msg","error","hasPermission","currentUser","currentUserName","username","createUser","newUser","token","when","Date","emailLogo","Array","isArray","brandAssets","brandAsset","asset","mediaId","join","absoluteUrl","url","dataForEmail","contactEmail","emails","homepage","copyrightDate","format","legalName","company","physicalAddress","shopName","socialLinks","display","facebook","icon","link","googlePlus","twitter","invitedUserName","urls","enrollAccount","tpl","subject","SSR","compileTemplate","Email","getTemplate","getSubject","send","to","from","render","html","userEmail","shopEmail","debug","permissions","group","Roles","addUsersToRoles","removeUsersFromRoles","setUserRoles"],"mappings":"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","file":"/server/methods/accounts/accounts.js.map","sourcesContent":["import _ from \"lodash\";\nimport moment from \"moment\";\nimport path from \"path\";\nimport { Accounts as MeteorAccounts } from \"meteor/accounts-base\";\nimport { Accounts, Cart, Media, Shops, Packages } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n\n/**\n * @summary Returns the name of the geocoder method to use\n * @returns {string} Name of the Geocoder method to use\n */\nfunction getValidator() {\n  const shopId = Reaction.getShopId();\n  const geoCoders = Packages.find({\n    \"registry.provides\": \"addressValidation\",\n    \"settings.addressValidation.enabled\": true,\n    \"shopId\": shopId,\n    \"enabled\": true\n  }).fetch();\n\n  if (!geoCoders.length) {\n    return \"\";\n  }\n  let geoCoder;\n  // Just one?, use that one\n  if (geoCoders.length === 1) {\n    geoCoder = geoCoders[0];\n  }\n  // If there are two, we default to the one that is not the Reaction one\n  if (geoCoders.length === 2) {\n    geoCoder = _.filter(geoCoders, function (coder) {\n      return !_.includes(coder.name, \"reaction\");\n    })[0];\n  }\n\n  // check if addressValidation is enabled but the package is disabled, don't do address validation\n  let registryName;\n  for (const registry of geoCoder.registry) {\n    if (registry.provides === \"addressValidation\") {\n      registryName = registry.name;\n    }\n  }\n  const packageKey = registryName.split(\"/\")[2];  // \"taxes/addressValidation/{packageKey}\"\n  if (!_.get(geoCoder.settings[packageKey], \"enabled\")) {\n    return \"\";\n  }\n\n  const methodName = geoCoder.settings.addressValidation.addressValidationMethod;\n  return methodName;\n}\n\n/**\n * @summary Compare individual fields of address and accumulate errors\n * @param {Object} address - the address provided by the customer\n * @param {Object} validationAddress - address provided by validator\n * @returns {Array} Array of errors (or empty)\n */\nfunction compareAddress(address, validationAddress) {\n  const errors = [];\n  // first check, if a field is missing (and was present in original address), that means it didn't validate\n  // TODO rewrite with just a loop over field names but KISS for now\n  if (address.address1 && !validationAddress.address1) {\n    errors.push({ address1: \"Address line one did not validate\" });\n  }\n\n  if (address.address2 && validationAddress.address2 && _.trim(_.upperCase(address.address2)) !== _.trim(_.upperCase(validationAddress.address2))) {\n    errors.push({ address2: \"Address line 2 did not validate\" });\n  }\n\n  if (!validationAddress.city) {\n    errors.push({ city: \"City did not validate\" });\n  }\n  if (address.postal && !validationAddress.postal) {\n    errors.push({ postal: \"Postal did not validate\" });\n  }\n\n  if (address.region && !validationAddress.region) {\n    errors.push({ region: \"Region did not validate\" });\n  }\n\n  if (address.country && !validationAddress.country) {\n    errors.push({ country: \"Country did not validate\" });\n  }\n  // second check if both fields exist, but they don't match (which almost always happen for certain fields on first time)\n  if (validationAddress.address1 && address.address1 && _.trim(_.upperCase(address.address1)) !== _.trim(_.upperCase(validationAddress.address1))) {\n    errors.push({ address1: \"Address line 1 did not match\" });\n  }\n\n  if (validationAddress.address2 && address.address2 && (_.upperCase(address.address2) !== _.upperCase(validationAddress.address2))) {\n    errors.push({ address2: \"Address line 2\" });\n  }\n\n  if (validationAddress.city && address.city && _.trim(_.upperCase(address.city)) !== _.trim(_.upperCase(validationAddress.city))) {\n    errors.push({ city: \"City did not match\" });\n  }\n\n  if (validationAddress.postal && address.postal && _.trim(_.upperCase(address.postal)) !== _.trim(_.upperCase(validationAddress.postal))) {\n    errors.push({ postal: \"Postal Code did not match\" });\n  }\n\n  if (validationAddress.region && address.region && _.trim(_.upperCase(address.region)) !== _.trim(_.upperCase(validationAddress.region))) {\n    errors.push({ region: \"Region did not match\" });\n  }\n\n  if (validationAddress.country && address.country && _.upperCase(address.country) !== _.upperCase(validationAddress.country)) {\n    errors.push({ country: \"Country did not match\" });\n  }\n  return errors;\n}\n\n/**\n * @summary Validates an address, and if fails returns details of issues\n * @param {Object} address - The address object to validate\n * @returns {{validated: boolean, address: *}} - The results of the validation\n */\nfunction validateAddress(address) {\n  check(address, Object);\n  let validated = true;\n  let validationErrors;\n  let validatedAddress = address;\n  let formErrors;\n  Schemas.Address.clean(address);\n  const validator = getValidator();\n  if (validator) {\n    const validationResult = Meteor.call(validator, address);\n    validatedAddress = validationResult.validatedAddress;\n    formErrors = validationResult.errors;\n    if (validatedAddress) {\n      validationErrors = compareAddress(address, validatedAddress);\n      if (validationErrors.length || formErrors.length) {\n        validated = false;\n      }\n    } else {\n      // No address, fail validation\n      validated = false;\n    }\n  }\n  const validationResults = { validated, fieldErrors: validationErrors, formErrors, validatedAddress };\n  return validationResults;\n}\n\n/**\n * Reaction Account Methods\n */\nMeteor.methods({\n  \"accounts/validateAddress\": validateAddress,\n  /*\n   * check if current user has password\n   */\n  \"accounts/currentUserHasPassword\": function () {\n    const user = Meteor.users.findOne(Meteor.userId());\n    if (user.services.password) {\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * accounts/addressBookAdd\n   * @description add new addresses to an account\n   * @param {Object} address - address\n   * @param {String} [accountUserId] - `account.userId` used by admin to edit\n   * users\n   * @return {Object} with keys `numberAffected` and `insertedId` if doc was\n   * inserted\n   */\n  \"accounts/addressBookAdd\": function (address, accountUserId) {\n    check(address, Schemas.Address);\n    check(accountUserId, Match.Optional(String));\n    // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n    if (typeof accountUserId === \"string\") { // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n    this.unblock();\n\n    const userId = accountUserId || Meteor.userId();\n    // required default id\n    if (!address._id) {\n      address._id = Random.id();\n    }\n    // if address got shippment or billing default, we need to update cart\n    // addresses accordingly\n    if (address.isShippingDefault || address.isBillingDefault) {\n      const cart = Cart.findOne({ userId: userId });\n      // if cart exists\n      // First amend the cart,\n      if (typeof cart === \"object\") {\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n        }\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n        }\n      }\n      // then change the address that has been affected\n      if (address.isShippingDefault) {\n        Accounts.update({\n          \"userId\": userId,\n          \"profile.addressBook.isShippingDefault\": true\n        }, {\n          $set: {\n            \"profile.addressBook.$.isShippingDefault\": false\n          }\n        });\n      }\n      if (address.isBillingDefault) {\n        Accounts.update({\n          \"userId\": userId,\n          \"profile.addressBook.isBillingDefault\": true\n        }, {\n          $set: {\n            \"profile.addressBook.$.isBillingDefault\": false\n          }\n        });\n      }\n    }\n\n    return Accounts.upsert({\n      userId: userId\n    }, {\n      $set: {\n        userId: userId\n      },\n      $addToSet: {\n        \"profile.addressBook\": address\n      }\n    });\n  },\n\n  /**\n   * accounts/addressBookUpdate\n   * @description update existing address in user's profile\n   * @param {Object} address - address\n   * @param {String|null} [accountUserId] - `account.userId` used by admin to\n   * edit users\n   * @param {shipping|billing} [type] - name of selected address type\n   * @return {Number} The number of affected documents\n   */\n  \"accounts/addressBookUpdate\": function (address, accountUserId, type) {\n    check(address, Schemas.Address);\n    check(accountUserId, Match.OneOf(String, null, undefined));\n    check(type, Match.Optional(String));\n    // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n    if (typeof accountUserId === \"string\") { // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n    this.unblock();\n\n    const userId = accountUserId || Meteor.userId();\n    // we need to compare old state of isShippingDefault, isBillingDefault with\n    // new state and if it was enabled/disabled reflect this changes in cart\n    const account = Accounts.findOne({\n      userId: userId\n    });\n    const oldAddress = account.profile.addressBook.find(function (addr) {\n      return addr._id === address._id;\n    });\n\n    // happens when the user clicked the address in grid. We need to set type\n    // to `true`\n    if (typeof type === \"string\") {\n      Object.assign(address, { [type]: true });\n    }\n\n    // We want the cart addresses to be updated when current default address\n    // (shipping or Billing) are different than the previous one, but also\n    // when the current default address(ship or bill) gets edited(so Current and Previous default are the same).\n    // This check can be simplified to :\n    if  (address.isShippingDefault || address.isBillingDefault ||\n         oldAddress.isShippingDefault || address.isBillingDefault) {\n      const cart = Cart.findOne({ userId: userId });\n      // Cart should exist to this moment, so we doesn't need to to verify its\n      // existence.\n      if (oldAddress.isShippingDefault !== address.isShippingDefault) {\n        // if isShippingDefault was changed and now it is `true`\n        if (address.isShippingDefault) {\n          // we need to add this address to cart\n          Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n          // then, if another address was `ShippingDefault`, we need to unset it\n          Accounts.update({\n            \"userId\": userId,\n            \"profile.addressBook.isShippingDefault\": true\n          }, {\n            $set: {\n              \"profile.addressBook.$.isShippingDefault\": false\n            }\n          });\n        } else {\n          // if new `isShippingDefault` state is false, then we need to remove\n          // this address from `cart.shipping`\n          Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"shipping\");\n        }\n      } else if (address.isShippingDefault && oldAddress.isShippingDefault) {\n        // If current Shipping Address was edited but not changed update it to cart too\n        Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n      }\n\n      // the same logic used for billing\n      if (oldAddress.isBillingDefault !== address.isBillingDefault) {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n          Accounts.update({\n            \"userId\": userId,\n            \"profile.addressBook.isBillingDefault\": true\n          }, {\n            $set: {\n              \"profile.addressBook.$.isBillingDefault\": false\n            }\n          });\n        } else {\n          Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"billing\");\n        }\n      } else if (address.isBillingDefault && oldAddress.isBillingDefault) {\n        // If current Billing Address was edited but not changed update it to cart too\n        Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n      }\n    }\n\n    return Accounts.update({\n      \"userId\": userId,\n      \"profile.addressBook._id\": address._id\n    }, {\n      $set: {\n        \"profile.addressBook.$\": address\n      }\n    });\n  },\n\n  /**\n   * accounts/addressBookRemove\n   * @description remove existing address in user's profile\n   * @param {String} addressId - address `_id`\n   * @param {String} [accountUserId] - `account.userId` used by admin to edit\n   * users\n   * @return {Number|Object} The number of removed documents or error object\n   */\n  \"accounts/addressBookRemove\": function (addressId, accountUserId) {\n    check(addressId, String);\n    check(accountUserId, Match.Optional(String));\n    // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n    if (typeof accountUserId === \"string\") { // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n    this.unblock();\n\n    const userId = accountUserId || Meteor.userId();\n    // remove this address in cart, if used, before completely removing\n    Meteor.call(\"cart/unsetAddresses\", addressId, userId);\n\n    return Accounts.update({\n      \"userId\": userId,\n      \"profile.addressBook._id\": addressId\n    }, {\n      $pull: {\n        \"profile.addressBook\": {\n          _id: addressId\n        }\n      }\n    });\n  },\n\n  /**\n   * accounts/inviteShopMember\n   * invite new admin users\n   * (not consumers) to secure access in the dashboard\n   * to permissions as specified in packages/roles\n   * @param {String} shopId - shop to invite user\n   * @param {String} email - email of invitee\n   * @param {String} name - name to address email\n   * @returns {Boolean} returns true\n   */\n  \"accounts/inviteShopMember\": function (shopId, email, name) {\n    check(shopId, String);\n    check(email, String);\n    check(name, String);\n\n    this.unblock();\n\n    const shop = Shops.findOne(shopId);\n\n    if (!shop) {\n      const msg = `accounts/inviteShopMember - Shop ${shopId} not found`;\n      Logger.error(msg);\n      throw new Meteor.Error(\"shop-not-found\", msg);\n    }\n\n    if (!Reaction.hasPermission(\"reaction-accounts\", this.userId, shopId)) {\n      Logger.error(`User ${this.userId} does not have reaction-accounts permissions`);\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n\n    const currentUser = Meteor.users.findOne(this.userId);\n\n    let currentUserName;\n\n    if (currentUser) {\n      if (currentUser.profile) {\n        currentUserName = currentUser.profile.name || currentUser.username;\n      } else {\n        currentUserName = currentUser.username;\n      }\n    } else {\n      currentUserName = \"Admin\";\n    }\n\n    const user = Meteor.users.findOne({\n      \"emails.address\": email\n    });\n\n    if (!user) {\n      const userId = MeteorAccounts.createUser({\n        email: email,\n        username: name\n      });\n\n      const newUser = Meteor.users.findOne(userId);\n\n      if (!newUser) {\n        throw new Error(\"Can't find user\");\n      }\n\n      const token = Random.id();\n\n      Meteor.users.update(userId, {\n        $set: {\n          \"services.password.reset\": { token, email, when: new Date() }\n        }\n      });\n\n      // Get shop logo, if available. If not, use default logo from file-system\n      let emailLogo;\n      if (Array.isArray(shop.brandAssets)) {\n        const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n        const mediaId = Media.findOne(brandAsset.mediaId);\n        emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n      } else {\n        emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n      }\n\n      const dataForEmail = {\n        // Shop Data\n        shop: shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo: emailLogo,\n        copyrightDate: moment().format(\"YYYY\"),\n        legalName: shop.addressBook[0].company,\n        physicalAddress: {\n          address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n          city: shop.addressBook[0].city,\n          region: shop.addressBook[0].region,\n          postal: shop.addressBook[0].postal\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Account Data\n        user: Meteor.user(),\n        currentUserName,\n        invitedUserName: name,\n        url: MeteorAccounts.urls.enrollAccount(token)\n      };\n\n      // Compile Email with SSR\n      const tpl = \"accounts/inviteShopMember\";\n      const subject = \"accounts/inviteShopMember/subject\";\n      SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n      SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n      Reaction.Email.send({\n        to: email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n    } else {\n      Reaction.Email.send({\n        to: email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n    }\n    return true;\n  },\n\n  /**\n   * accounts/sendWelcomeEmail\n   * send an email to consumers on sign up\n   * @param {String} shopId - shopId of new User\n   * @param {String} userId - new userId to welcome\n   * @returns {Boolean} returns boolean\n   */\n  \"accounts/sendWelcomeEmail\": function (shopId, userId) {\n    check(shopId, String);\n    check(userId, String);\n\n    this.unblock();\n\n    const user = Accounts.findOne(userId);\n    const shop = Shops.findOne(shopId);\n\n    // Get shop logo, if available. If not, use default logo from file-system\n    let emailLogo;\n    if (Array.isArray(shop.brandAssets)) {\n      const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n      const mediaId = Media.findOne(brandAsset.mediaId);\n      emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n    } else {\n      emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n    }\n\n    const dataForEmail = {\n      // Shop Data\n      shop: shop,\n      contactEmail: shop.emails[0].address,\n      homepage: Meteor.absoluteUrl(),\n      emailLogo: emailLogo,\n      copyrightDate: moment().format(\"YYYY\"),\n      legalName: shop.addressBook[0].company,\n      physicalAddress: {\n        address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n        city: shop.addressBook[0].city,\n        region: shop.addressBook[0].region,\n        postal: shop.addressBook[0].postal\n      },\n      shopName: shop.name,\n      socialLinks: {\n        display: true,\n        facebook: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n          link: \"https://www.facebook.com\"\n        },\n        googlePlus: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n          link: \"https://plus.google.com\"\n        },\n        twitter: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n          link: \"https://www.twitter.com\"\n        }\n      },\n      // Account Data\n      user: Meteor.user()\n    };\n\n    // anonymous users arent welcome here\n    if (!user.emails || !user.emails.length > 0) {\n      return true;\n    }\n\n    const userEmail = user.emails[0].address;\n\n    let shopEmail;\n    // provide some defaults for missing shop email.\n    if (!shop.emails) {\n      shopEmail = `${shop.name}@localhost`;\n      Logger.debug(`Shop email address not configured. Using ${shopEmail}`);\n    } else {\n      shopEmail = shop.emails[0].address;\n    }\n\n    const tpl = \"accounts/sendWelcomeEmail\";\n    const subject = \"accounts/sendWelcomeEmail/subject\";\n    SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n    SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n    Reaction.Email.send({\n      to: userEmail,\n      from: `${shop.name} <${shopEmail}>`,\n      subject: SSR.render(subject, dataForEmail),\n      html: SSR.render(tpl, dataForEmail)\n    });\n\n    return true;\n  },\n\n  /**\n   * accounts/addUserPermissions\n   * @param {String} userId - userId\n   * @param {Array|String} permissions -\n   *               Name of role/permission.  If array, users\n   *               returned will have at least one of the roles\n   *               specified but need not have _all_ roles.\n   * @param {String} [group] Optional name of group to restrict roles to.\n   *                         User\"s Roles.GLOBAL_GROUP will also be checked.\n   * @returns {Boolean} success/failure\n   */\n  \"accounts/addUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n    check(userId, Match.OneOf(String, Array));\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String));\n    this.unblock();\n    try {\n      return Roles.addUsersToRoles(userId, permissions, group);\n    } catch (error) {\n      return Logger.error(error);\n    }\n  },\n\n  /*\n   * accounts/removeUserPermissions\n   */\n  \"accounts/removeUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n    check(userId, String);\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String, null));\n    this.unblock();\n\n    try {\n      return Roles.removeUsersFromRoles(userId, permissions, group);\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n  },\n\n  /**\n   * accounts/setUserPermissions\n   * @param {String} userId - userId\n   * @param {String|Array} permissions - string/array of permissions\n   * @param {String} group - group\n   * @returns {Boolean} returns Roles.setUserRoles result\n   */\n  \"accounts/setUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n    check(userId, String);\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String));\n    this.unblock();\n    try {\n      return Roles.setUserRoles(userId, permissions, group);\n    } catch (error) {\n      Logger.error(error);\n      return error;\n    }\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/methods/accounts/accounts.js.map","sourceFileName":"/server/methods/accounts/accounts.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"accounts"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _find = void 0;\n\nmodule.importSync(\"lodash/find\", {\n  \"default\": function (v) {\n    _find = v;\n  }\n}, 0);\n\nvar _upperCase = void 0;\n\nmodule.importSync(\"lodash/upperCase\", {\n  \"default\": function (v) {\n    _upperCase = v;\n  }\n}, 1);\n\nvar _trim = void 0;\n\nmodule.importSync(\"lodash/trim\", {\n  \"default\": function (v) {\n    _trim = v;\n  }\n}, 2);\n\nvar _get = void 0;\n\nmodule.importSync(\"lodash/get\", {\n  \"default\": function (v) {\n    _get = v;\n  }\n}, 3);\n\nvar _includes = void 0;\n\nmodule.importSync(\"lodash/includes\", {\n  \"default\": function (v) {\n    _includes = v;\n  }\n}, 4);\n\nvar _filter = void 0;\n\nmodule.importSync(\"lodash/filter\", {\n  \"default\": function (v) {\n    _filter = v;\n  }\n}, 5);\nvar moment = void 0;\nmodule.importSync(\"moment\", {\n  \"default\": function (v) {\n    moment = v;\n  }\n}, 6);\nvar path = void 0;\nmodule.importSync(\"path\", {\n  \"default\": function (v) {\n    path = v;\n  }\n}, 7);\nvar MeteorAccounts = void 0;\nmodule.importSync(\"meteor/accounts-base\", {\n  Accounts: function (v) {\n    MeteorAccounts = v;\n  }\n}, 8);\nvar Accounts = void 0,\n    Cart = void 0,\n    Media = void 0,\n    Shops = void 0,\n    Packages = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Accounts: function (v) {\n    Accounts = v;\n  },\n  Cart: function (v) {\n    Cart = v;\n  },\n  Media: function (v) {\n    Media = v;\n  },\n  Shops: function (v) {\n    Shops = v;\n  },\n  Packages: function (v) {\n    Packages = v;\n  }\n}, 9);\nvar Schemas = Object.create(null);\nmodule.importSync(\"/lib/collections/schemas\", {\n  \"*\": function (v, n) {\n    Schemas[n] = v;\n  }\n}, 10);\nvar Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 11);\n\n/**\n * @summary Returns the name of the geocoder method to use\n * @returns {string} Name of the Geocoder method to use\n */function getValidator() {\n  var shopId = Reaction.getShopId();\n  var geoCoders = Packages.find({\n    \"registry.provides\": \"addressValidation\",\n    \"settings.addressValidation.enabled\": true,\n    \"shopId\": shopId,\n    \"enabled\": true\n  }).fetch();\n\n  if (!geoCoders.length) {\n    return \"\";\n  }\n\n  var geoCoder = void 0; // Just one?, use that one\n\n  if (geoCoders.length === 1) {\n    geoCoder = geoCoders[0];\n  } // If there are two, we default to the one that is not the Reaction one\n\n\n  if (geoCoders.length === 2) {\n    geoCoder = _filter(geoCoders, function (coder) {\n      return !_includes(coder.name, \"reaction\");\n    })[0];\n  } // check if addressValidation is enabled but the package is disabled, don't do address validation\n\n\n  var registryName = void 0;\n\n  for (var _iterator = geoCoder.registry, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var registry = _ref;\n\n    if (registry.provides === \"addressValidation\") {\n      registryName = registry.name;\n    }\n  }\n\n  var packageKey = registryName.split(\"/\")[2]; // \"taxes/addressValidation/{packageKey}\"\n\n  if (!_get(geoCoder.settings[packageKey], \"enabled\")) {\n    return \"\";\n  }\n\n  var methodName = geoCoder.settings.addressValidation.addressValidationMethod;\n  return methodName;\n} /**\n   * @summary Compare individual fields of address and accumulate errors\n   * @param {Object} address - the address provided by the customer\n   * @param {Object} validationAddress - address provided by validator\n   * @returns {Array} Array of errors (or empty)\n   */\n\nfunction compareAddress(address, validationAddress) {\n  var errors = []; // first check, if a field is missing (and was present in original address), that means it didn't validate\n  // TODO rewrite with just a loop over field names but KISS for now\n\n  if (address.address1 && !validationAddress.address1) {\n    errors.push({\n      address1: \"Address line one did not validate\"\n    });\n  }\n\n  if (address.address2 && validationAddress.address2 && _trim(_upperCase(address.address2)) !== _trim(_upperCase(validationAddress.address2))) {\n    errors.push({\n      address2: \"Address line 2 did not validate\"\n    });\n  }\n\n  if (!validationAddress.city) {\n    errors.push({\n      city: \"City did not validate\"\n    });\n  }\n\n  if (address.postal && !validationAddress.postal) {\n    errors.push({\n      postal: \"Postal did not validate\"\n    });\n  }\n\n  if (address.region && !validationAddress.region) {\n    errors.push({\n      region: \"Region did not validate\"\n    });\n  }\n\n  if (address.country && !validationAddress.country) {\n    errors.push({\n      country: \"Country did not validate\"\n    });\n  } // second check if both fields exist, but they don't match (which almost always happen for certain fields on first time)\n\n\n  if (validationAddress.address1 && address.address1 && _trim(_upperCase(address.address1)) !== _trim(_upperCase(validationAddress.address1))) {\n    errors.push({\n      address1: \"Address line 1 did not match\"\n    });\n  }\n\n  if (validationAddress.address2 && address.address2 && _upperCase(address.address2) !== _upperCase(validationAddress.address2)) {\n    errors.push({\n      address2: \"Address line 2\"\n    });\n  }\n\n  if (validationAddress.city && address.city && _trim(_upperCase(address.city)) !== _trim(_upperCase(validationAddress.city))) {\n    errors.push({\n      city: \"City did not match\"\n    });\n  }\n\n  if (validationAddress.postal && address.postal && _trim(_upperCase(address.postal)) !== _trim(_upperCase(validationAddress.postal))) {\n    errors.push({\n      postal: \"Postal Code did not match\"\n    });\n  }\n\n  if (validationAddress.region && address.region && _trim(_upperCase(address.region)) !== _trim(_upperCase(validationAddress.region))) {\n    errors.push({\n      region: \"Region did not match\"\n    });\n  }\n\n  if (validationAddress.country && address.country && _upperCase(address.country) !== _upperCase(validationAddress.country)) {\n    errors.push({\n      country: \"Country did not match\"\n    });\n  }\n\n  return errors;\n} /**\n   * @summary Validates an address, and if fails returns details of issues\n   * @param {Object} address - The address object to validate\n   * @returns {{validated: boolean, address: *}} - The results of the validation\n   */\n\nfunction validateAddress(address) {\n  check(address, Object);\n  var validated = true;\n  var validationErrors = void 0;\n  var validatedAddress = address;\n  var formErrors = void 0;\n  Schemas.Address.clean(address);\n  var validator = getValidator();\n\n  if (validator) {\n    var validationResult = Meteor.call(validator, address);\n    validatedAddress = validationResult.validatedAddress;\n    formErrors = validationResult.errors;\n\n    if (validatedAddress) {\n      validationErrors = compareAddress(address, validatedAddress);\n\n      if (validationErrors.length || formErrors.length) {\n        validated = false;\n      }\n    } else {\n      // No address, fail validation\n      validated = false;\n    }\n  }\n\n  var validationResults = {\n    validated: validated,\n    fieldErrors: validationErrors,\n    formErrors: formErrors,\n    validatedAddress: validatedAddress\n  };\n  return validationResults;\n} /**\n   * Reaction Account Methods\n   */\n\nMeteor.methods({\n  \"accounts/validateAddress\": validateAddress,\n  /*\n   * check if current user has password\n   */\"accounts/currentUserHasPassword\": function () {\n    var user = Meteor.users.findOne(Meteor.userId());\n\n    if (user.services.password) {\n      return true;\n    }\n\n    return false;\n  },\n  /**\n   * accounts/addressBookAdd\n   * @description add new addresses to an account\n   * @param {Object} address - address\n   * @param {String} [accountUserId] - `account.userId` used by admin to edit\n   * users\n   * @return {Object} with keys `numberAffected` and `insertedId` if doc was\n   * inserted\n   */\"accounts/addressBookAdd\": function (address, accountUserId) {\n    check(address, Schemas.Address);\n    check(accountUserId, Match.Optional(String)); // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n\n    if (typeof accountUserId === \"string\") {\n      // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n\n    this.unblock();\n    var userId = accountUserId || Meteor.userId(); // required default id\n\n    if (!address._id) {\n      address._id = Random.id();\n    } // if address got shippment or billing default, we need to update cart\n    // addresses accordingly\n\n\n    if (address.isShippingDefault || address.isBillingDefault) {\n      var cart = Cart.findOne({\n        userId: userId\n      }); // if cart exists\n      // First amend the cart,\n\n      if ((typeof cart === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(cart)) === \"object\") {\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n        }\n\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n        }\n      } // then change the address that has been affected\n\n\n      if (address.isShippingDefault) {\n        Accounts.update({\n          \"userId\": userId,\n          \"profile.addressBook.isShippingDefault\": true\n        }, {\n          $set: {\n            \"profile.addressBook.$.isShippingDefault\": false\n          }\n        });\n      }\n\n      if (address.isBillingDefault) {\n        Accounts.update({\n          \"userId\": userId,\n          \"profile.addressBook.isBillingDefault\": true\n        }, {\n          $set: {\n            \"profile.addressBook.$.isBillingDefault\": false\n          }\n        });\n      }\n    }\n\n    return Accounts.upsert({\n      userId: userId\n    }, {\n      $set: {\n        userId: userId\n      },\n      $addToSet: {\n        \"profile.addressBook\": address\n      }\n    });\n  },\n  /**\n   * accounts/addressBookUpdate\n   * @description update existing address in user's profile\n   * @param {Object} address - address\n   * @param {String|null} [accountUserId] - `account.userId` used by admin to\n   * edit users\n   * @param {shipping|billing} [type] - name of selected address type\n   * @return {Number} The number of affected documents\n   */\"accounts/addressBookUpdate\": function (address, accountUserId, type) {\n    check(address, Schemas.Address);\n    check(accountUserId, Match.OneOf(String, null, undefined));\n    check(type, Match.Optional(String)); // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n\n    if (typeof accountUserId === \"string\") {\n      // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n\n    this.unblock();\n    var userId = accountUserId || Meteor.userId(); // we need to compare old state of isShippingDefault, isBillingDefault with\n    // new state and if it was enabled/disabled reflect this changes in cart\n\n    var account = Accounts.findOne({\n      userId: userId\n    });\n    var oldAddress = account.profile.addressBook.find(function (addr) {\n      return addr._id === address._id;\n    }); // happens when the user clicked the address in grid. We need to set type\n    // to `true`\n\n    if (typeof type === \"string\") {\n      var _Object$assign;\n\n      Object.assign(address, (_Object$assign = {}, _Object$assign[type] = true, _Object$assign));\n    } // We want the cart addresses to be updated when current default address\n    // (shipping or Billing) are different than the previous one, but also\n    // when the current default address(ship or bill) gets edited(so Current and Previous default are the same).\n    // This check can be simplified to :\n\n\n    if (address.isShippingDefault || address.isBillingDefault || oldAddress.isShippingDefault || address.isBillingDefault) {\n      var cart = Cart.findOne({\n        userId: userId\n      }); // Cart should exist to this moment, so we doesn't need to to verify its\n      // existence.\n\n      if (oldAddress.isShippingDefault !== address.isShippingDefault) {\n        // if isShippingDefault was changed and now it is `true`\n        if (address.isShippingDefault) {\n          // we need to add this address to cart\n          Meteor.call(\"cart/setShipmentAddress\", cart._id, address); // then, if another address was `ShippingDefault`, we need to unset it\n\n          Accounts.update({\n            \"userId\": userId,\n            \"profile.addressBook.isShippingDefault\": true\n          }, {\n            $set: {\n              \"profile.addressBook.$.isShippingDefault\": false\n            }\n          });\n        } else {\n          // if new `isShippingDefault` state is false, then we need to remove\n          // this address from `cart.shipping`\n          Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"shipping\");\n        }\n      } else if (address.isShippingDefault && oldAddress.isShippingDefault) {\n        // If current Shipping Address was edited but not changed update it to cart too\n        Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n      } // the same logic used for billing\n\n\n      if (oldAddress.isBillingDefault !== address.isBillingDefault) {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n          Accounts.update({\n            \"userId\": userId,\n            \"profile.addressBook.isBillingDefault\": true\n          }, {\n            $set: {\n              \"profile.addressBook.$.isBillingDefault\": false\n            }\n          });\n        } else {\n          Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"billing\");\n        }\n      } else if (address.isBillingDefault && oldAddress.isBillingDefault) {\n        // If current Billing Address was edited but not changed update it to cart too\n        Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n      }\n    }\n\n    return Accounts.update({\n      \"userId\": userId,\n      \"profile.addressBook._id\": address._id\n    }, {\n      $set: {\n        \"profile.addressBook.$\": address\n      }\n    });\n  },\n  /**\n   * accounts/addressBookRemove\n   * @description remove existing address in user's profile\n   * @param {String} addressId - address `_id`\n   * @param {String} [accountUserId] - `account.userId` used by admin to edit\n   * users\n   * @return {Number|Object} The number of removed documents or error object\n   */\"accounts/addressBookRemove\": function (addressId, accountUserId) {\n    check(addressId, String);\n    check(accountUserId, Match.Optional(String)); // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n\n    if (typeof accountUserId === \"string\") {\n      // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n\n    this.unblock();\n    var userId = accountUserId || Meteor.userId(); // remove this address in cart, if used, before completely removing\n\n    Meteor.call(\"cart/unsetAddresses\", addressId, userId);\n    return Accounts.update({\n      \"userId\": userId,\n      \"profile.addressBook._id\": addressId\n    }, {\n      $pull: {\n        \"profile.addressBook\": {\n          _id: addressId\n        }\n      }\n    });\n  },\n  /**\n   * accounts/inviteShopMember\n   * invite new admin users\n   * (not consumers) to secure access in the dashboard\n   * to permissions as specified in packages/roles\n   * @param {String} shopId - shop to invite user\n   * @param {String} email - email of invitee\n   * @param {String} name - name to address email\n   * @returns {Boolean} returns true\n   */\"accounts/inviteShopMember\": function (shopId, email, name) {\n    check(shopId, String);\n    check(email, String);\n    check(name, String);\n    this.unblock();\n    var shop = Shops.findOne(shopId);\n\n    if (!shop) {\n      var msg = \"accounts/inviteShopMember - Shop \" + shopId + \" not found\";\n      Logger.error(msg);\n      throw new Meteor.Error(\"shop-not-found\", msg);\n    }\n\n    if (!Reaction.hasPermission(\"reaction-accounts\", this.userId, shopId)) {\n      Logger.error(\"User \" + this.userId + \" does not have reaction-accounts permissions\");\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n\n    var currentUser = Meteor.users.findOne(this.userId);\n    var currentUserName = void 0;\n\n    if (currentUser) {\n      if (currentUser.profile) {\n        currentUserName = currentUser.profile.name || currentUser.username;\n      } else {\n        currentUserName = currentUser.username;\n      }\n    } else {\n      currentUserName = \"Admin\";\n    }\n\n    var user = Meteor.users.findOne({\n      \"emails.address\": email\n    });\n\n    if (!user) {\n      var userId = MeteorAccounts.createUser({\n        email: email,\n        username: name\n      });\n      var newUser = Meteor.users.findOne(userId);\n\n      if (!newUser) {\n        throw new Error(\"Can't find user\");\n      }\n\n      var token = Random.id();\n      Meteor.users.update(userId, {\n        $set: {\n          \"services.password.reset\": {\n            token: token,\n            email: email,\n            when: new Date()\n          }\n        }\n      }); // Get shop logo, if available. If not, use default logo from file-system\n\n      var emailLogo = void 0;\n\n      if (Array.isArray(shop.brandAssets)) {\n        var brandAsset = _find(shop.brandAssets, function (asset) {\n          return asset.type === \"navbarBrandImage\";\n        });\n\n        var mediaId = Media.findOne(brandAsset.mediaId);\n        emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n      } else {\n        emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n      }\n\n      var _dataForEmail = {\n        // Shop Data\n        shop: shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo: emailLogo,\n        copyrightDate: moment().format(\"YYYY\"),\n        legalName: shop.addressBook[0].company,\n        physicalAddress: {\n          address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n          city: shop.addressBook[0].city,\n          region: shop.addressBook[0].region,\n          postal: shop.addressBook[0].postal\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Account Data\n        user: Meteor.user(),\n        currentUserName: currentUserName,\n        invitedUserName: name,\n        url: MeteorAccounts.urls.enrollAccount(token)\n      }; // Compile Email with SSR\n\n      var _tpl = \"accounts/inviteShopMember\";\n      var _subject = \"accounts/inviteShopMember/subject\";\n      SSR.compileTemplate(_tpl, Reaction.Email.getTemplate(_tpl));\n      SSR.compileTemplate(_subject, Reaction.Email.getSubject(_tpl));\n      Reaction.Email.send({\n        to: email,\n        from: shop.name + \" <\" + shop.emails[0].address + \">\",\n        subject: SSR.render(_subject, _dataForEmail),\n        html: SSR.render(_tpl, _dataForEmail)\n      });\n    } else {\n      Reaction.Email.send({\n        to: email,\n        from: shop.name + \" <\" + shop.emails[0].address + \">\",\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n    }\n\n    return true;\n  },\n  /**\n   * accounts/sendWelcomeEmail\n   * send an email to consumers on sign up\n   * @param {String} shopId - shopId of new User\n   * @param {String} userId - new userId to welcome\n   * @returns {Boolean} returns boolean\n   */\"accounts/sendWelcomeEmail\": function (shopId, userId) {\n    check(shopId, String);\n    check(userId, String);\n    this.unblock();\n    var user = Accounts.findOne(userId);\n    var shop = Shops.findOne(shopId); // Get shop logo, if available. If not, use default logo from file-system\n\n    var emailLogo = void 0;\n\n    if (Array.isArray(shop.brandAssets)) {\n      var brandAsset = _find(shop.brandAssets, function (asset) {\n        return asset.type === \"navbarBrandImage\";\n      });\n\n      var mediaId = Media.findOne(brandAsset.mediaId);\n      emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n    } else {\n      emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n    }\n\n    var dataForEmail = {\n      // Shop Data\n      shop: shop,\n      contactEmail: shop.emails[0].address,\n      homepage: Meteor.absoluteUrl(),\n      emailLogo: emailLogo,\n      copyrightDate: moment().format(\"YYYY\"),\n      legalName: shop.addressBook[0].company,\n      physicalAddress: {\n        address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n        city: shop.addressBook[0].city,\n        region: shop.addressBook[0].region,\n        postal: shop.addressBook[0].postal\n      },\n      shopName: shop.name,\n      socialLinks: {\n        display: true,\n        facebook: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n          link: \"https://www.facebook.com\"\n        },\n        googlePlus: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n          link: \"https://plus.google.com\"\n        },\n        twitter: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n          link: \"https://www.twitter.com\"\n        }\n      },\n      // Account Data\n      user: Meteor.user()\n    }; // anonymous users arent welcome here\n\n    if (!user.emails || !user.emails.length > 0) {\n      return true;\n    }\n\n    var userEmail = user.emails[0].address;\n    var shopEmail = void 0; // provide some defaults for missing shop email.\n\n    if (!shop.emails) {\n      shopEmail = shop.name + \"@localhost\";\n      Logger.debug(\"Shop email address not configured. Using \" + shopEmail);\n    } else {\n      shopEmail = shop.emails[0].address;\n    }\n\n    var tpl = \"accounts/sendWelcomeEmail\";\n    var subject = \"accounts/sendWelcomeEmail/subject\";\n    SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n    SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n    Reaction.Email.send({\n      to: userEmail,\n      from: shop.name + \" <\" + shopEmail + \">\",\n      subject: SSR.render(subject, dataForEmail),\n      html: SSR.render(tpl, dataForEmail)\n    });\n    return true;\n  },\n  /**\n   * accounts/addUserPermissions\n   * @param {String} userId - userId\n   * @param {Array|String} permissions -\n   *               Name of role/permission.  If array, users\n   *               returned will have at least one of the roles\n   *               specified but need not have _all_ roles.\n   * @param {String} [group] Optional name of group to restrict roles to.\n   *                         User\"s Roles.GLOBAL_GROUP will also be checked.\n   * @returns {Boolean} success/failure\n   */\"accounts/addUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n\n    check(userId, Match.OneOf(String, Array));\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String));\n    this.unblock();\n\n    try {\n      return Roles.addUsersToRoles(userId, permissions, group);\n    } catch (error) {\n      return Logger.error(error);\n    }\n  },\n  /*\n   * accounts/removeUserPermissions\n   */\"accounts/removeUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n\n    check(userId, String);\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String, null));\n    this.unblock();\n\n    try {\n      return Roles.removeUsersFromRoles(userId, permissions, group);\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n  },\n  /**\n   * accounts/setUserPermissions\n   * @param {String} userId - userId\n   * @param {String|Array} permissions - string/array of permissions\n   * @param {String} group - group\n   * @returns {Boolean} returns Roles.setUserRoles result\n   */\"accounts/setUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n\n    check(userId, String);\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String));\n    this.unblock();\n\n    try {\n      return Roles.setUserRoles(userId, permissions, group);\n    } catch (error) {\n      Logger.error(error);\n      return error;\n    }\n  }\n});","map":{"version":3,"sources":["/server/methods/accounts/accounts.js"],"names":["moment","path","Accounts","MeteorAccounts","Cart","Media","Shops","Packages","Schemas","Logger","Reaction","getValidator","shopId","getShopId","geoCoders","find","fetch","length","geoCoder","coder","name","registryName","registry","provides","packageKey","split","settings","methodName","addressValidation","addressValidationMethod","compareAddress","address","validationAddress","errors","address1","push","address2","city","postal","region","country","validateAddress","check","Object","validated","validationErrors","validatedAddress","formErrors","Address","clean","validator","validationResult","Meteor","call","validationResults","fieldErrors","methods","user","users","findOne","userId","services","password","accountUserId","Match","Optional","String","hasAdminAccess","Error","unblock","_id","Random","id","isShippingDefault","isBillingDefault","cart","update","$set","upsert","$addToSet","type","OneOf","undefined","account","oldAddress","profile","addressBook","addr","assign","addressId","$pull","email","shop","msg","error","hasPermission","currentUser","currentUserName","username","createUser","newUser","token","when","Date","emailLogo","Array","isArray","brandAssets","brandAsset","asset","mediaId","join","absoluteUrl","url","dataForEmail","contactEmail","emails","homepage","copyrightDate","format","legalName","company","physicalAddress","shopName","socialLinks","display","facebook","icon","link","googlePlus","twitter","invitedUserName","urls","enrollAccount","tpl","subject","SSR","compileTemplate","Email","getTemplate","getSubject","send","to","from","render","html","userEmail","shopEmail","debug","permissions","group","Roles","addUsersToRoles","removeUsersFromRoles","setUserRoles"],"mappings":"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","file":"/server/methods/accounts/accounts.js.map","sourcesContent":["import _ from \"lodash\";\nimport moment from \"moment\";\nimport path from \"path\";\nimport { Accounts as MeteorAccounts } from \"meteor/accounts-base\";\nimport { Accounts, Cart, Media, Shops, Packages } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n\n/**\n * @summary Returns the name of the geocoder method to use\n * @returns {string} Name of the Geocoder method to use\n */\nfunction getValidator() {\n  const shopId = Reaction.getShopId();\n  const geoCoders = Packages.find({\n    \"registry.provides\": \"addressValidation\",\n    \"settings.addressValidation.enabled\": true,\n    \"shopId\": shopId,\n    \"enabled\": true\n  }).fetch();\n\n  if (!geoCoders.length) {\n    return \"\";\n  }\n  let geoCoder;\n  // Just one?, use that one\n  if (geoCoders.length === 1) {\n    geoCoder = geoCoders[0];\n  }\n  // If there are two, we default to the one that is not the Reaction one\n  if (geoCoders.length === 2) {\n    geoCoder = _.filter(geoCoders, function (coder) {\n      return !_.includes(coder.name, \"reaction\");\n    })[0];\n  }\n\n  // check if addressValidation is enabled but the package is disabled, don't do address validation\n  let registryName;\n  for (const registry of geoCoder.registry) {\n    if (registry.provides === \"addressValidation\") {\n      registryName = registry.name;\n    }\n  }\n  const packageKey = registryName.split(\"/\")[2];  // \"taxes/addressValidation/{packageKey}\"\n  if (!_.get(geoCoder.settings[packageKey], \"enabled\")) {\n    return \"\";\n  }\n\n  const methodName = geoCoder.settings.addressValidation.addressValidationMethod;\n  return methodName;\n}\n\n/**\n * @summary Compare individual fields of address and accumulate errors\n * @param {Object} address - the address provided by the customer\n * @param {Object} validationAddress - address provided by validator\n * @returns {Array} Array of errors (or empty)\n */\nfunction compareAddress(address, validationAddress) {\n  const errors = [];\n  // first check, if a field is missing (and was present in original address), that means it didn't validate\n  // TODO rewrite with just a loop over field names but KISS for now\n  if (address.address1 && !validationAddress.address1) {\n    errors.push({ address1: \"Address line one did not validate\" });\n  }\n\n  if (address.address2 && validationAddress.address2 && _.trim(_.upperCase(address.address2)) !== _.trim(_.upperCase(validationAddress.address2))) {\n    errors.push({ address2: \"Address line 2 did not validate\" });\n  }\n\n  if (!validationAddress.city) {\n    errors.push({ city: \"City did not validate\" });\n  }\n  if (address.postal && !validationAddress.postal) {\n    errors.push({ postal: \"Postal did not validate\" });\n  }\n\n  if (address.region && !validationAddress.region) {\n    errors.push({ region: \"Region did not validate\" });\n  }\n\n  if (address.country && !validationAddress.country) {\n    errors.push({ country: \"Country did not validate\" });\n  }\n  // second check if both fields exist, but they don't match (which almost always happen for certain fields on first time)\n  if (validationAddress.address1 && address.address1 && _.trim(_.upperCase(address.address1)) !== _.trim(_.upperCase(validationAddress.address1))) {\n    errors.push({ address1: \"Address line 1 did not match\" });\n  }\n\n  if (validationAddress.address2 && address.address2 && (_.upperCase(address.address2) !== _.upperCase(validationAddress.address2))) {\n    errors.push({ address2: \"Address line 2\" });\n  }\n\n  if (validationAddress.city && address.city && _.trim(_.upperCase(address.city)) !== _.trim(_.upperCase(validationAddress.city))) {\n    errors.push({ city: \"City did not match\" });\n  }\n\n  if (validationAddress.postal && address.postal && _.trim(_.upperCase(address.postal)) !== _.trim(_.upperCase(validationAddress.postal))) {\n    errors.push({ postal: \"Postal Code did not match\" });\n  }\n\n  if (validationAddress.region && address.region && _.trim(_.upperCase(address.region)) !== _.trim(_.upperCase(validationAddress.region))) {\n    errors.push({ region: \"Region did not match\" });\n  }\n\n  if (validationAddress.country && address.country && _.upperCase(address.country) !== _.upperCase(validationAddress.country)) {\n    errors.push({ country: \"Country did not match\" });\n  }\n  return errors;\n}\n\n/**\n * @summary Validates an address, and if fails returns details of issues\n * @param {Object} address - The address object to validate\n * @returns {{validated: boolean, address: *}} - The results of the validation\n */\nfunction validateAddress(address) {\n  check(address, Object);\n  let validated = true;\n  let validationErrors;\n  let validatedAddress = address;\n  let formErrors;\n  Schemas.Address.clean(address);\n  const validator = getValidator();\n  if (validator) {\n    const validationResult = Meteor.call(validator, address);\n    validatedAddress = validationResult.validatedAddress;\n    formErrors = validationResult.errors;\n    if (validatedAddress) {\n      validationErrors = compareAddress(address, validatedAddress);\n      if (validationErrors.length || formErrors.length) {\n        validated = false;\n      }\n    } else {\n      // No address, fail validation\n      validated = false;\n    }\n  }\n  const validationResults = { validated, fieldErrors: validationErrors, formErrors, validatedAddress };\n  return validationResults;\n}\n\n/**\n * Reaction Account Methods\n */\nMeteor.methods({\n  \"accounts/validateAddress\": validateAddress,\n  /*\n   * check if current user has password\n   */\n  \"accounts/currentUserHasPassword\": function () {\n    const user = Meteor.users.findOne(Meteor.userId());\n    if (user.services.password) {\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * accounts/addressBookAdd\n   * @description add new addresses to an account\n   * @param {Object} address - address\n   * @param {String} [accountUserId] - `account.userId` used by admin to edit\n   * users\n   * @return {Object} with keys `numberAffected` and `insertedId` if doc was\n   * inserted\n   */\n  \"accounts/addressBookAdd\": function (address, accountUserId) {\n    check(address, Schemas.Address);\n    check(accountUserId, Match.Optional(String));\n    // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n    if (typeof accountUserId === \"string\") { // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n    this.unblock();\n\n    const userId = accountUserId || Meteor.userId();\n    // required default id\n    if (!address._id) {\n      address._id = Random.id();\n    }\n    // if address got shippment or billing default, we need to update cart\n    // addresses accordingly\n    if (address.isShippingDefault || address.isBillingDefault) {\n      const cart = Cart.findOne({ userId: userId });\n      // if cart exists\n      // First amend the cart,\n      if (typeof cart === \"object\") {\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n        }\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n        }\n      }\n      // then change the address that has been affected\n      if (address.isShippingDefault) {\n        Accounts.update({\n          \"userId\": userId,\n          \"profile.addressBook.isShippingDefault\": true\n        }, {\n          $set: {\n            \"profile.addressBook.$.isShippingDefault\": false\n          }\n        });\n      }\n      if (address.isBillingDefault) {\n        Accounts.update({\n          \"userId\": userId,\n          \"profile.addressBook.isBillingDefault\": true\n        }, {\n          $set: {\n            \"profile.addressBook.$.isBillingDefault\": false\n          }\n        });\n      }\n    }\n\n    return Accounts.upsert({\n      userId: userId\n    }, {\n      $set: {\n        userId: userId\n      },\n      $addToSet: {\n        \"profile.addressBook\": address\n      }\n    });\n  },\n\n  /**\n   * accounts/addressBookUpdate\n   * @description update existing address in user's profile\n   * @param {Object} address - address\n   * @param {String|null} [accountUserId] - `account.userId` used by admin to\n   * edit users\n   * @param {shipping|billing} [type] - name of selected address type\n   * @return {Number} The number of affected documents\n   */\n  \"accounts/addressBookUpdate\": function (address, accountUserId, type) {\n    check(address, Schemas.Address);\n    check(accountUserId, Match.OneOf(String, null, undefined));\n    check(type, Match.Optional(String));\n    // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n    if (typeof accountUserId === \"string\") { // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n    this.unblock();\n\n    const userId = accountUserId || Meteor.userId();\n    // we need to compare old state of isShippingDefault, isBillingDefault with\n    // new state and if it was enabled/disabled reflect this changes in cart\n    const account = Accounts.findOne({\n      userId: userId\n    });\n    const oldAddress = account.profile.addressBook.find(function (addr) {\n      return addr._id === address._id;\n    });\n\n    // happens when the user clicked the address in grid. We need to set type\n    // to `true`\n    if (typeof type === \"string\") {\n      Object.assign(address, { [type]: true });\n    }\n\n    // We want the cart addresses to be updated when current default address\n    // (shipping or Billing) are different than the previous one, but also\n    // when the current default address(ship or bill) gets edited(so Current and Previous default are the same).\n    // This check can be simplified to :\n    if  (address.isShippingDefault || address.isBillingDefault ||\n         oldAddress.isShippingDefault || address.isBillingDefault) {\n      const cart = Cart.findOne({ userId: userId });\n      // Cart should exist to this moment, so we doesn't need to to verify its\n      // existence.\n      if (oldAddress.isShippingDefault !== address.isShippingDefault) {\n        // if isShippingDefault was changed and now it is `true`\n        if (address.isShippingDefault) {\n          // we need to add this address to cart\n          Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n          // then, if another address was `ShippingDefault`, we need to unset it\n          Accounts.update({\n            \"userId\": userId,\n            \"profile.addressBook.isShippingDefault\": true\n          }, {\n            $set: {\n              \"profile.addressBook.$.isShippingDefault\": false\n            }\n          });\n        } else {\n          // if new `isShippingDefault` state is false, then we need to remove\n          // this address from `cart.shipping`\n          Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"shipping\");\n        }\n      } else if (address.isShippingDefault && oldAddress.isShippingDefault) {\n        // If current Shipping Address was edited but not changed update it to cart too\n        Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n      }\n\n      // the same logic used for billing\n      if (oldAddress.isBillingDefault !== address.isBillingDefault) {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n          Accounts.update({\n            \"userId\": userId,\n            \"profile.addressBook.isBillingDefault\": true\n          }, {\n            $set: {\n              \"profile.addressBook.$.isBillingDefault\": false\n            }\n          });\n        } else {\n          Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"billing\");\n        }\n      } else if (address.isBillingDefault && oldAddress.isBillingDefault) {\n        // If current Billing Address was edited but not changed update it to cart too\n        Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n      }\n    }\n\n    return Accounts.update({\n      \"userId\": userId,\n      \"profile.addressBook._id\": address._id\n    }, {\n      $set: {\n        \"profile.addressBook.$\": address\n      }\n    });\n  },\n\n  /**\n   * accounts/addressBookRemove\n   * @description remove existing address in user's profile\n   * @param {String} addressId - address `_id`\n   * @param {String} [accountUserId] - `account.userId` used by admin to edit\n   * users\n   * @return {Number|Object} The number of removed documents or error object\n   */\n  \"accounts/addressBookRemove\": function (addressId, accountUserId) {\n    check(addressId, String);\n    check(accountUserId, Match.Optional(String));\n    // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n    if (typeof accountUserId === \"string\") { // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n    this.unblock();\n\n    const userId = accountUserId || Meteor.userId();\n    // remove this address in cart, if used, before completely removing\n    Meteor.call(\"cart/unsetAddresses\", addressId, userId);\n\n    return Accounts.update({\n      \"userId\": userId,\n      \"profile.addressBook._id\": addressId\n    }, {\n      $pull: {\n        \"profile.addressBook\": {\n          _id: addressId\n        }\n      }\n    });\n  },\n\n  /**\n   * accounts/inviteShopMember\n   * invite new admin users\n   * (not consumers) to secure access in the dashboard\n   * to permissions as specified in packages/roles\n   * @param {String} shopId - shop to invite user\n   * @param {String} email - email of invitee\n   * @param {String} name - name to address email\n   * @returns {Boolean} returns true\n   */\n  \"accounts/inviteShopMember\": function (shopId, email, name) {\n    check(shopId, String);\n    check(email, String);\n    check(name, String);\n\n    this.unblock();\n\n    const shop = Shops.findOne(shopId);\n\n    if (!shop) {\n      const msg = `accounts/inviteShopMember - Shop ${shopId} not found`;\n      Logger.error(msg);\n      throw new Meteor.Error(\"shop-not-found\", msg);\n    }\n\n    if (!Reaction.hasPermission(\"reaction-accounts\", this.userId, shopId)) {\n      Logger.error(`User ${this.userId} does not have reaction-accounts permissions`);\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n\n    const currentUser = Meteor.users.findOne(this.userId);\n\n    let currentUserName;\n\n    if (currentUser) {\n      if (currentUser.profile) {\n        currentUserName = currentUser.profile.name || currentUser.username;\n      } else {\n        currentUserName = currentUser.username;\n      }\n    } else {\n      currentUserName = \"Admin\";\n    }\n\n    const user = Meteor.users.findOne({\n      \"emails.address\": email\n    });\n\n    if (!user) {\n      const userId = MeteorAccounts.createUser({\n        email: email,\n        username: name\n      });\n\n      const newUser = Meteor.users.findOne(userId);\n\n      if (!newUser) {\n        throw new Error(\"Can't find user\");\n      }\n\n      const token = Random.id();\n\n      Meteor.users.update(userId, {\n        $set: {\n          \"services.password.reset\": { token, email, when: new Date() }\n        }\n      });\n\n      // Get shop logo, if available. If not, use default logo from file-system\n      let emailLogo;\n      if (Array.isArray(shop.brandAssets)) {\n        const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n        const mediaId = Media.findOne(brandAsset.mediaId);\n        emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n      } else {\n        emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n      }\n\n      const dataForEmail = {\n        // Shop Data\n        shop: shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo: emailLogo,\n        copyrightDate: moment().format(\"YYYY\"),\n        legalName: shop.addressBook[0].company,\n        physicalAddress: {\n          address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n          city: shop.addressBook[0].city,\n          region: shop.addressBook[0].region,\n          postal: shop.addressBook[0].postal\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Account Data\n        user: Meteor.user(),\n        currentUserName,\n        invitedUserName: name,\n        url: MeteorAccounts.urls.enrollAccount(token)\n      };\n\n      // Compile Email with SSR\n      const tpl = \"accounts/inviteShopMember\";\n      const subject = \"accounts/inviteShopMember/subject\";\n      SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n      SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n      Reaction.Email.send({\n        to: email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n    } else {\n      Reaction.Email.send({\n        to: email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n    }\n    return true;\n  },\n\n  /**\n   * accounts/sendWelcomeEmail\n   * send an email to consumers on sign up\n   * @param {String} shopId - shopId of new User\n   * @param {String} userId - new userId to welcome\n   * @returns {Boolean} returns boolean\n   */\n  \"accounts/sendWelcomeEmail\": function (shopId, userId) {\n    check(shopId, String);\n    check(userId, String);\n\n    this.unblock();\n\n    const user = Accounts.findOne(userId);\n    const shop = Shops.findOne(shopId);\n\n    // Get shop logo, if available. If not, use default logo from file-system\n    let emailLogo;\n    if (Array.isArray(shop.brandAssets)) {\n      const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n      const mediaId = Media.findOne(brandAsset.mediaId);\n      emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n    } else {\n      emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n    }\n\n    const dataForEmail = {\n      // Shop Data\n      shop: shop,\n      contactEmail: shop.emails[0].address,\n      homepage: Meteor.absoluteUrl(),\n      emailLogo: emailLogo,\n      copyrightDate: moment().format(\"YYYY\"),\n      legalName: shop.addressBook[0].company,\n      physicalAddress: {\n        address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n        city: shop.addressBook[0].city,\n        region: shop.addressBook[0].region,\n        postal: shop.addressBook[0].postal\n      },\n      shopName: shop.name,\n      socialLinks: {\n        display: true,\n        facebook: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n          link: \"https://www.facebook.com\"\n        },\n        googlePlus: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n          link: \"https://plus.google.com\"\n        },\n        twitter: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n          link: \"https://www.twitter.com\"\n        }\n      },\n      // Account Data\n      user: Meteor.user()\n    };\n\n    // anonymous users arent welcome here\n    if (!user.emails || !user.emails.length > 0) {\n      return true;\n    }\n\n    const userEmail = user.emails[0].address;\n\n    let shopEmail;\n    // provide some defaults for missing shop email.\n    if (!shop.emails) {\n      shopEmail = `${shop.name}@localhost`;\n      Logger.debug(`Shop email address not configured. Using ${shopEmail}`);\n    } else {\n      shopEmail = shop.emails[0].address;\n    }\n\n    const tpl = \"accounts/sendWelcomeEmail\";\n    const subject = \"accounts/sendWelcomeEmail/subject\";\n    SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n    SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n    Reaction.Email.send({\n      to: userEmail,\n      from: `${shop.name} <${shopEmail}>`,\n      subject: SSR.render(subject, dataForEmail),\n      html: SSR.render(tpl, dataForEmail)\n    });\n\n    return true;\n  },\n\n  /**\n   * accounts/addUserPermissions\n   * @param {String} userId - userId\n   * @param {Array|String} permissions -\n   *               Name of role/permission.  If array, users\n   *               returned will have at least one of the roles\n   *               specified but need not have _all_ roles.\n   * @param {String} [group] Optional name of group to restrict roles to.\n   *                         User\"s Roles.GLOBAL_GROUP will also be checked.\n   * @returns {Boolean} success/failure\n   */\n  \"accounts/addUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n    check(userId, Match.OneOf(String, Array));\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String));\n    this.unblock();\n    try {\n      return Roles.addUsersToRoles(userId, permissions, group);\n    } catch (error) {\n      return Logger.error(error);\n    }\n  },\n\n  /*\n   * accounts/removeUserPermissions\n   */\n  \"accounts/removeUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n    check(userId, String);\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String, null));\n    this.unblock();\n\n    try {\n      return Roles.removeUsersFromRoles(userId, permissions, group);\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n  },\n\n  /**\n   * accounts/setUserPermissions\n   * @param {String} userId - userId\n   * @param {String|Array} permissions - string/array of permissions\n   * @param {String} group - group\n   * @returns {Boolean} returns Roles.setUserRoles result\n   */\n  \"accounts/setUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n    check(userId, String);\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String));\n    this.unblock();\n    try {\n      return Roles.setUserRoles(userId, permissions, group);\n    } catch (error) {\n      Logger.error(error);\n      return error;\n    }\n  }\n});\n"]},"hash":"f66eacadb43d67c0940141e5495b02e29196d3c0"}
