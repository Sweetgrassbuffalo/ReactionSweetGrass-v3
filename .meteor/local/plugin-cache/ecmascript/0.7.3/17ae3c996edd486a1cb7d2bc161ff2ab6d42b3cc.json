{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"/lib/collections","imported":["Packages"],"specifiers":[{"kind":"named","imported":"Packages","local":"Packages"}]},{"source":"/server/api","imported":["Logger","Reaction"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]},{"source":"meteor/http","imported":["HTTP"],"specifiers":[{"kind":"named","imported":"HTTP","local":"HTTP"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]}],"exports":{"exported":["GeoCoder"],"specifiers":[{"kind":"local","local":"GeoCoder","exported":"GeoCoder"}]}}},"options":{"filename":"/server/api/geocoder.js","filenameRelative":"/server/api/geocoder.js","inputSourceMap":{"version":3,"sources":["/server/api/geocoder.js"],"names":["Packages","Logger","Reaction","HTTP","Meteor","wrapAsync","_wrapAsync","GeoCoder","options","extra","self","shopSettings","findOne","shopId","getShopId","name","fields","settings","google","clientId","apiKey","_","extend","geocoderProvider","httpAdapter","gc","address","callback","g","require","geocode","prototype","geoCoderGeocode","geoCallback","geoAddress","bindEnvironment","error","rv","lat","lng","reverse","lon","geoCoderReverse","_error","latitude","longitude","country","city","state","stateCode","zipcode","streetName","streetNumber","countryCode","gi","lookupAddress","process","env","NODE_TLS_REJECT_UNAUTHORIZED","call","geoip","data","warn"],"mappings":"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","file":"/server/api/geocoder.js.map","sourcesContent":["import { Packages } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\nimport { HTTP } from \"meteor/http\";\nimport { Meteor } from \"meteor/meteor\";\n\n/**\n * meteor-geocoder\n * modifed for reaction core.\n *\n * https://github.com/aldeed/meteor-geocoder\n * The MIT License (MIT)\n * Copyright (c) 2014 Eric Dobbertin\n */\n\n// backwards compatibility\nif (typeof Meteor.wrapAsync === \"undefined\") {\n  Meteor.wrapAsync = Meteor._wrapAsync;\n}\n/* eslint func-style: 1 */\n//\n// init geocoder\nexport const GeoCoder = (options) => {\n  let extra;\n  const self = this;\n  // fetch shop settings for api auth credentials\n  const shopSettings = Packages.findOne({\n    shopId: Reaction.getShopId(),\n    name: \"core\"\n  }, {\n    fields: {\n      settings: 1\n    }\n  });\n\n  if (shopSettings) {\n    if (shopSettings.settings.google) {\n      extra = {\n        clientId: shopSettings.settings.google.clientId,\n        apiKey: shopSettings.settings.google.apiKey\n      };\n    }\n  }\n\n  self.options = _.extend({\n    geocoderProvider: \"google\",\n    httpAdapter: \"https\",\n    extra: extra\n  }, options || {});\n};\n\nfunction gc(address, options, callback) {\n  const g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter,\n    options.extra);\n  g.geocode(address, callback);\n}\n\nGeoCoder.prototype.geocode = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n      if (error) throw error;\n    });\n    gc(geoAddress, this.options, geoCallback);\n  } else {\n    geoAddress = Meteor.wrapAsync(gc)(geoAddress, this.options);\n    return geoAddress[0];\n  }\n};\n\nfunction rv(lat, lng, options, callback) {\n  const g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter,\n    options.extra);\n  g.reverse({\n    lat: lat,\n    lon: lng\n  }, callback);\n}\n\nGeoCoder.prototype.reverse = function geoCoderReverse(lat, lng, callback) {\n  let geoCallback = callback;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n      if (error) throw error;\n    });\n    rv(lat, lng, this.options, geoCallback);\n  } else {\n    try {\n      address = Meteor.wrapAsync(rv)(lat, lng, this.options);\n      return address[0];\n    } catch (_error) {\n      return {\n        latitude: null,\n        longitude: null,\n        country: \"United States\",\n        city: null,\n        state: null,\n        stateCode: null,\n        zipcode: null,\n        streetName: null,\n        streetNumber: null,\n        countryCode: \"US\"\n      };\n    }\n  }\n};\n\nfunction gi(address, callback) {\n  let lookupAddress = address;\n  // short term solution to an haproxy ssl cert installation issue\n  process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0;\n  // if we're local, let's let freegeoip guess.\n  if (lookupAddress === \"127.0.0.1\" || lookupAddress === null) {\n    lookupAddress = \"\";\n  }\n  // calls a private reaction hosted version of freegeoip\n  HTTP.call(\"GET\", `https://geo.getreaction.io/json/${lookupAddress}`, callback);\n}\n\nGeoCoder.prototype.geoip = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n      if (error) throw error;\n    });\n    gi(geoAddress, this.options, geoCallback);\n  } else {\n    try {\n      geoAddress = Meteor.wrapAsync(gi)(geoAddress);\n      return geoAddress.data;\n    } catch (error) {\n      Logger.warn(\"shop/getLocale geoip lookup failure\", error);\n      return {};\n    }\n  }\n};\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/api/geocoder.js.map","sourceFileName":"/server/api/geocoder.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"geocoder"},"ignored":false,"code":"var _this = this;\n\nmodule.export({\n  GeoCoder: function () {\n    return GeoCoder;\n  }\n});\nvar Packages = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Packages: function (v) {\n    Packages = v;\n  }\n}, 0);\nvar Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 1);\nvar HTTP = void 0;\nmodule.importSync(\"meteor/http\", {\n  HTTP: function (v) {\n    HTTP = v;\n  }\n}, 2);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 3);\n\n/**\n * meteor-geocoder\n * modifed for reaction core.\n *\n * https://github.com/aldeed/meteor-geocoder\n * The MIT License (MIT)\n * Copyright (c) 2014 Eric Dobbertin\n */ // backwards compatibility\nif (typeof Meteor.wrapAsync === \"undefined\") {\n  Meteor.wrapAsync = Meteor._wrapAsync;\n} /* eslint func-style: 1 */ //\n// init geocoder\n\n\nvar GeoCoder = function (options) {\n  var extra = void 0;\n  var self = _this; // fetch shop settings for api auth credentials\n\n  var shopSettings = Packages.findOne({\n    shopId: Reaction.getShopId(),\n    name: \"core\"\n  }, {\n    fields: {\n      settings: 1\n    }\n  });\n\n  if (shopSettings) {\n    if (shopSettings.settings.google) {\n      extra = {\n        clientId: shopSettings.settings.google.clientId,\n        apiKey: shopSettings.settings.google.apiKey\n      };\n    }\n  }\n\n  self.options = _.extend({\n    geocoderProvider: \"google\",\n    httpAdapter: \"https\",\n    extra: extra\n  }, options || {});\n};\n\nfunction gc(address, options, callback) {\n  var g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter, options.extra);\n\n  g.geocode(address, callback);\n}\n\nGeoCoder.prototype.geocode = function () {\n  function geoCoderGeocode(address, callback) {\n    var geoCallback = callback;\n    var geoAddress = address;\n\n    if (geoCallback) {\n      geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n        if (error) throw error;\n      });\n      gc(geoAddress, this.options, geoCallback);\n    } else {\n      geoAddress = Meteor.wrapAsync(gc)(geoAddress, this.options);\n      return geoAddress[0];\n    }\n  }\n\n  return geoCoderGeocode;\n}();\n\nfunction rv(lat, lng, options, callback) {\n  var g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter, options.extra);\n\n  g.reverse({\n    lat: lat,\n    lon: lng\n  }, callback);\n}\n\nGeoCoder.prototype.reverse = function () {\n  function geoCoderReverse(lat, lng, callback) {\n    var geoCallback = callback;\n\n    if (geoCallback) {\n      geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n        if (error) throw error;\n      });\n      rv(lat, lng, this.options, geoCallback);\n    } else {\n      try {\n        address = Meteor.wrapAsync(rv)(lat, lng, this.options);\n        return address[0];\n      } catch (_error) {\n        return {\n          latitude: null,\n          longitude: null,\n          country: \"United States\",\n          city: null,\n          state: null,\n          stateCode: null,\n          zipcode: null,\n          streetName: null,\n          streetNumber: null,\n          countryCode: \"US\"\n        };\n      }\n    }\n  }\n\n  return geoCoderReverse;\n}();\n\nfunction gi(address, callback) {\n  var lookupAddress = address; // short term solution to an haproxy ssl cert installation issue\n\n  process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0; // if we're local, let's let freegeoip guess.\n\n  if (lookupAddress === \"127.0.0.1\" || lookupAddress === null) {\n    lookupAddress = \"\";\n  } // calls a private reaction hosted version of freegeoip\n\n\n  HTTP.call(\"GET\", \"https://geo.getreaction.io/json/\" + lookupAddress, callback);\n}\n\nGeoCoder.prototype.geoip = function () {\n  function geoCoderGeocode(address, callback) {\n    var geoCallback = callback;\n    var geoAddress = address;\n\n    if (geoCallback) {\n      geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n        if (error) throw error;\n      });\n      gi(geoAddress, this.options, geoCallback);\n    } else {\n      try {\n        geoAddress = Meteor.wrapAsync(gi)(geoAddress);\n        return geoAddress.data;\n      } catch (error) {\n        Logger.warn(\"shop/getLocale geoip lookup failure\", error);\n        return {};\n      }\n    }\n  }\n\n  return geoCoderGeocode;\n}();","map":{"version":3,"sources":["/server/api/geocoder.js"],"names":["Packages","Logger","Reaction","HTTP","Meteor","wrapAsync","_wrapAsync","GeoCoder","options","extra","self","shopSettings","findOne","shopId","getShopId","name","fields","settings","google","clientId","apiKey","_","extend","geocoderProvider","httpAdapter","gc","address","callback","g","require","geocode","prototype","geoCoderGeocode","geoCallback","geoAddress","bindEnvironment","error","rv","lat","lng","reverse","lon","geoCoderReverse","_error","latitude","longitude","country","city","state","stateCode","zipcode","streetName","streetNumber","countryCode","gi","lookupAddress","process","env","NODE_TLS_REJECT_UNAUTHORIZED","call","geoip","data","warn"],"mappings":"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","file":"/server/api/geocoder.js.map","sourcesContent":["import { Packages } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\nimport { HTTP } from \"meteor/http\";\nimport { Meteor } from \"meteor/meteor\";\n\n/**\n * meteor-geocoder\n * modifed for reaction core.\n *\n * https://github.com/aldeed/meteor-geocoder\n * The MIT License (MIT)\n * Copyright (c) 2014 Eric Dobbertin\n */\n\n// backwards compatibility\nif (typeof Meteor.wrapAsync === \"undefined\") {\n  Meteor.wrapAsync = Meteor._wrapAsync;\n}\n/* eslint func-style: 1 */\n//\n// init geocoder\nexport const GeoCoder = (options) => {\n  let extra;\n  const self = this;\n  // fetch shop settings for api auth credentials\n  const shopSettings = Packages.findOne({\n    shopId: Reaction.getShopId(),\n    name: \"core\"\n  }, {\n    fields: {\n      settings: 1\n    }\n  });\n\n  if (shopSettings) {\n    if (shopSettings.settings.google) {\n      extra = {\n        clientId: shopSettings.settings.google.clientId,\n        apiKey: shopSettings.settings.google.apiKey\n      };\n    }\n  }\n\n  self.options = _.extend({\n    geocoderProvider: \"google\",\n    httpAdapter: \"https\",\n    extra: extra\n  }, options || {});\n};\n\nfunction gc(address, options, callback) {\n  const g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter,\n    options.extra);\n  g.geocode(address, callback);\n}\n\nGeoCoder.prototype.geocode = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n      if (error) throw error;\n    });\n    gc(geoAddress, this.options, geoCallback);\n  } else {\n    geoAddress = Meteor.wrapAsync(gc)(geoAddress, this.options);\n    return geoAddress[0];\n  }\n};\n\nfunction rv(lat, lng, options, callback) {\n  const g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter,\n    options.extra);\n  g.reverse({\n    lat: lat,\n    lon: lng\n  }, callback);\n}\n\nGeoCoder.prototype.reverse = function geoCoderReverse(lat, lng, callback) {\n  let geoCallback = callback;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n      if (error) throw error;\n    });\n    rv(lat, lng, this.options, geoCallback);\n  } else {\n    try {\n      address = Meteor.wrapAsync(rv)(lat, lng, this.options);\n      return address[0];\n    } catch (_error) {\n      return {\n        latitude: null,\n        longitude: null,\n        country: \"United States\",\n        city: null,\n        state: null,\n        stateCode: null,\n        zipcode: null,\n        streetName: null,\n        streetNumber: null,\n        countryCode: \"US\"\n      };\n    }\n  }\n};\n\nfunction gi(address, callback) {\n  let lookupAddress = address;\n  // short term solution to an haproxy ssl cert installation issue\n  process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0;\n  // if we're local, let's let freegeoip guess.\n  if (lookupAddress === \"127.0.0.1\" || lookupAddress === null) {\n    lookupAddress = \"\";\n  }\n  // calls a private reaction hosted version of freegeoip\n  HTTP.call(\"GET\", `https://geo.getreaction.io/json/${lookupAddress}`, callback);\n}\n\nGeoCoder.prototype.geoip = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n      if (error) throw error;\n    });\n    gi(geoAddress, this.options, geoCallback);\n  } else {\n    try {\n      geoAddress = Meteor.wrapAsync(gi)(geoAddress);\n      return geoAddress.data;\n    } catch (error) {\n      Logger.warn(\"shop/getLocale geoip lookup failure\", error);\n      return {};\n    }\n  }\n};\n"]},"hash":"17ae3c996edd486a1cb7d2bc161ff2ab6d42b3cc"}
