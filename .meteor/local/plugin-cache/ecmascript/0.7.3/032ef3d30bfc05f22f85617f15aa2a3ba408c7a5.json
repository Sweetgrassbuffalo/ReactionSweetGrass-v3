{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"/lib/collections","imported":["Products","Revisions"],"specifiers":[{"kind":"named","imported":"Products","local":"Products"},{"kind":"named","imported":"Revisions","local":"Revisions"}]},{"source":"/server/api","imported":["Reaction","Logger"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"},{"kind":"named","imported":"Logger","local":"Logger"}]},{"source":"/imports/plugins/core/revisions/lib/api/revisions","imported":["RevisionApi"],"specifiers":[{"kind":"named","imported":"RevisionApi","local":"RevisionApi"}]},{"source":"./product","imported":["findProductMedia"],"specifiers":[{"kind":"named","imported":"findProductMedia","local":"findProductMedia"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/publications/collections/products.js","filenameRelative":"/server/publications/collections/products.js","inputSourceMap":{"version":3,"sources":["/server/publications/collections/products.js"],"names":["Products","Revisions","Reaction","Logger","RevisionApi","findProductMedia","filters","SimpleSchema","type","String","optional","Boolean","Object","Meteor","publish","productScrollLimit","productFilters","sort","check","Number","Match","OneOf","undefined","e","debug","ready","shop","getCurrentShop","selector","Roles","userIsInRole","userId","_id","_","extend","isDeleted","$in","ancestors","$exists","shopId","shops","thisShopId","shopAdmin","tags","hashtags","query","cond","$regex","$options","$or","title","pageTitle","description","details","metafields","$elemMatch","key","value","visibility","isVisible","$gte","parseFloat","$lte","pmin","pmax","$lt","$gt","weight","wmin","wmax","productIds","find","limit","map","product","newSelector","omit","isRevisionControlEnabled","productCursor","handle","observeChanges","added","id","fields","revisions","documentId","parentDocument","$nin","fetch","__revisions","changed","removed","handle2","observe","revision","documentType","findOne","docuentType","onStop","stop","mediaProductIds","p","mediaCursor"],"mappings":"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","file":"/server/publications/collections/products.js.map","sourcesContent":["import { Products, Revisions } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { RevisionApi } from \"/imports/plugins/core/revisions/lib/api/revisions\";\nimport { findProductMedia } from \"./product\";\n\n//\n// define search filters as a schema so we can validate\n// params supplied to the products publication\n//\nconst filters = new SimpleSchema({\n  \"shops\": {\n    type: [String],\n    optional: true\n  },\n  \"tags\": {\n    type: [String],\n    optional: true\n  },\n  \"query\": {\n    type: String,\n    optional: true\n  },\n  \"visibility\": {\n    type: Boolean,\n    optional: true\n  },\n  \"details\": {\n    type: Object,\n    optional: true\n  },\n  \"details.key\": {\n    type: String,\n    optional: true\n  },\n  \"details.value\": {\n    type: String,\n    optional: true\n  },\n  \"price\": {\n    type: Object,\n    optional: true\n  },\n  \"price.min\": {\n    type: String,\n    optional: true\n  },\n  \"price.max\": {\n    type: String,\n    optional: true\n  },\n  \"weight\": {\n    type: Object,\n    optional: true\n  },\n  \"weight.min\": {\n    type: String,\n    optional: true\n  },\n  \"weight.max\": {\n    type: String,\n    optional: true\n  }\n});\n\n/**\n * products publication\n * @param {Number} productScrollLimit - optional, defaults to 24\n * @param {Array} shops - array of shopId to retrieve product from.\n * @return {Object} return product cursor\n */\nMeteor.publish(\"Products\", function (productScrollLimit = 24, productFilters, sort = {}) {\n  check(productScrollLimit, Number);\n  check(productFilters, Match.OneOf(undefined, Object));\n  check(sort, Match.OneOf(undefined, Object));\n\n  // if there are filter/params that don't match the schema\n  // validate, catch except but return no results\n  try {\n    check(productFilters, Match.OneOf(undefined, filters));\n  } catch (e) {\n    Logger.debug(e, \"Invalid Product Filters\");\n    return this.ready();\n  }\n  // ensure that we've got a shop instance\n  const shop = Reaction.getCurrentShop();\n  if (typeof shop !== \"object\") {\n    return this.ready();\n  }\n\n  if (shop) {\n    const selector = {};\n    if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"], shop._id)) {\n      _.extend(selector, {\n        isDeleted: { $in: [null, false] },\n        ancestors: { $exists: true },\n        shopId: shop._id\n      });\n    } else { // Changing the selector for non admin users only. To get top-level products.\n      _.extend(selector, {\n        isDeleted: { $in: [null, false] },\n        ancestors: [],\n        shopId: shop._id\n      });\n    }\n\n    if (productFilters) {\n      // handle multiple shops\n      if (productFilters.shops) {\n        _.extend(selector, {\n          shopId: {\n            $in: productFilters.shops\n          }\n        });\n\n        // check if this user is a shopAdmin\n        for (const thisShopId of productFilters.shops) {\n          if (Roles.userIsInRole(this.userId, [\"admin\", \"createProduct\"], thisShopId)) {\n            shopAdmin = true;\n          }\n        }\n      }\n\n      // filter by tags\n      if (productFilters.tags) {\n        _.extend(selector, {\n          hashtags: {\n            $in: productFilters.tags\n          }\n        });\n      }\n\n      // filter by query\n      if (productFilters.query) {\n        const cond = {\n          $regex: productFilters.query,\n          $options: \"i\"\n        };\n        _.extend(selector, {\n          $or: [{\n            title: cond\n          }, {\n            pageTitle: cond\n          }, {\n            description: cond\n          }]\n        });\n      }\n\n      // filter by details\n      if (productFilters.details) {\n        _.extend(selector, {\n          metafields: {\n            $elemMatch: {\n              key: {\n                $regex: productFilters.details.key,\n                $options: \"i\"\n              },\n              value: {\n                $regex: productFilters.details.value,\n                $options: \"i\"\n              }\n            }\n          }\n        });\n      }\n\n      // filter by visibility\n      if (productFilters.visibility !== undefined) {\n        _.extend(selector, {\n          isVisible: productFilters.visibility\n        });\n      }\n\n      // filter by gte minimum price\n      if (productFilters[\"price.min\"] && !productFilters[\"price.max\"]) {\n        _.extend(selector, {\n          \"price.min\": {\n            $gte: parseFloat(productFilters[\"price.min\"])\n          }\n        });\n      }\n\n      // filter by lte maximum price\n      if (productFilters[\"price.max\"] && !productFilters[\"price.min\"]) {\n        _.extend(selector, {\n          \"price.max\": {\n            $lte: parseFloat(productFilters[\"price.max\"])\n          }\n        });\n      }\n\n      // filter with a price range\n      if (productFilters[\"price.min\"] && productFilters[\"price.max\"]) {\n        const pmin = parseFloat(productFilters[\"price.min\"]);\n        const pmax = parseFloat(productFilters[\"price.max\"]);\n        // where product A has min 12.99 variant and a 19.99 variant\n        // price.min=12.99&price.max=19.98\n        // should return product A\n        _.extend(selector, {\n          \"price.min\": {\n            $lt: pmax\n          },\n          \"price.max\": {\n            $gt: pmin\n          }\n        });\n      }\n\n      // filter by gte minimum weight\n      if (productFilters[\"weight.min\"] && !productFilters[\"weight.max\"]) {\n        _.extend(selector, {\n          weight: {\n            $gte: parseFloat(productFilters[\"weight.min\"])\n          }\n        });\n      }\n\n      // filter by lte maximum weight\n      if (productFilters[\"weight.max\"] && !productFilters[\"weight.min\"]) {\n        _.extend(selector, {\n          weight: {\n            $lte: parseFloat(productFilters[\"weight.max\"])\n          }\n        });\n      }\n\n      // filter with a weight range\n      if (productFilters[\"weight.min\"] && productFilters[\"weight.max\"]) {\n        const wmin = parseFloat(productFilters[\"weight.min\"]);\n        const wmax = parseFloat(productFilters[\"weight.max\"]);\n        _.extend(selector, {\n          weight: {\n            $lt: wmax,\n            $gt: wmin\n          }\n        });\n      }\n    } // end if productFilters\n\n    // Authorized content curators fo the shop get special publication of the product\n    // with all relevant revisions all is one package\n\n    if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"], shop._id)) {\n      selector.isVisible = {\n        $in: [true, false, undefined]\n      };\n\n      // Get _ids of top-level products\n      const productIds = Products.find(selector, {\n        sort: sort,\n        limit: productScrollLimit\n      }).map(product => product._id);\n\n      let newSelector = selector;\n\n      // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n      if (productFilters && productFilters.tags) {\n        newSelector = _.omit(selector, [\"hashtags\"]);\n\n        // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n        _.extend(newSelector, {\n          $or: [\n            {\n              ancestors: {\n                $in: productIds\n              }\n            }, {\n              hashtags: {\n                $in: productFilters.tags\n              }\n            }\n          ]\n        });\n      }\n\n      if (RevisionApi.isRevisionControlEnabled()) {\n        const productCursor = Products.find(newSelector);\n        const handle = productCursor.observeChanges({\n          added: (id, fields) => {\n            const revisions = Revisions.find({\n              \"$or\": [\n                { documentId: id },\n                { parentDocument: id }\n              ],\n              \"workflow.status\": {\n                $nin: [\n                  \"revision/published\"\n                ]\n              }\n            }).fetch();\n            fields.__revisions = revisions;\n\n            this.added(\"Products\", id, fields);\n          },\n          changed: (id, fields) => {\n            const revisions = Revisions.find({\n              \"$or\": [\n                { documentId: id },\n                { parentDocument: id }\n              ],\n              \"workflow.status\": {\n                $nin: [\n                  \"revision/published\"\n                ]\n              }\n            }).fetch();\n\n            fields.__revisions = revisions;\n            this.changed(\"Products\", id, fields);\n          },\n          removed: (id) => {\n            this.removed(\"Products\", id);\n          }\n        });\n\n        const handle2 = Revisions.find({\n          \"workflow.status\": {\n            $nin: [\n              \"revision/published\"\n            ]\n          }\n        }).observe({\n          added: (revision) => {\n            let product;\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.documentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n\n            if (product) {\n              this.added(\"Products\", product._id, product);\n              this.added(\"Revisions\", revision._id, revision);\n            }\n          },\n          changed: (revision) => {\n            let product;\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.documentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n            if (product) {\n              product.__revisions = [revision];\n              this.changed(\"Products\", product._id, product);\n              this.changed(\"Revisions\", revision._id, revision);\n            }\n          },\n          removed: (revision) => {\n            let product;\n\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.docuentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n            if (product) {\n              product.__revisions = [];\n              this.changed(\"Products\", product._id, product);\n              this.removed(\"Revisions\", revision._id, revision);\n            }\n          }\n        });\n\n\n        this.onStop(() => {\n          handle.stop();\n          handle2.stop();\n        });\n\n        const mediaProductIds = productCursor.fetch().map((p) => p._id);\n        const mediaCursor = findProductMedia(this, mediaProductIds);\n\n        return [\n          mediaCursor\n        ];\n      }\n      // Revision control is disabled, but is admin\n      const productCursor = Products.find(newSelector, {\n        sort: sort,\n        limit: productScrollLimit\n      });\n      const mediaProductIds = productCursor.fetch().map((p) => p._id);\n      const mediaCursor = findProductMedia(this, mediaProductIds);\n\n      return [\n        productCursor,\n        mediaCursor\n      ];\n    }\n\n    // Everyone else gets the standard, visible products\n    selector.isVisible = true;\n\n    // Get _ids of top-level products\n    const productIds = Products.find(selector, {\n      sort: sort,\n      limit: productScrollLimit\n    }).map(product => product._id);\n\n    let newSelector = selector;\n\n    // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n    if (productFilters && productFilters.tags) {\n      newSelector = _.omit(selector, [\"hashtags\"]);\n\n      // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n      _.extend(newSelector, {\n        $or: [\n          {\n            ancestors: {\n              $in: productIds\n            }\n          }, {\n            hashtags: {\n              $in: productFilters.tags\n            }\n          }\n        ]\n      });\n    }\n    // Returning Complete product tree for top level products to avoid sold out warning.\n    const productCursor = Products.find({\n      $or: [\n        { _id: { $in: productIds } },\n        { ancestors: { $in: productIds } }\n      ]\n    });\n\n    const mediaProductIds = productCursor.fetch().map((p) => p._id);\n    const mediaCursor = findProductMedia(this, mediaProductIds);\n\n    return [\n      productCursor,\n      mediaCursor\n    ];\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/publications/collections/products.js.map","sourceFileName":"/server/publications/collections/products.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"products"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar Products = void 0,\n    Revisions = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Products: function (v) {\n    Products = v;\n  },\n  Revisions: function (v) {\n    Revisions = v;\n  }\n}, 0);\nvar Reaction = void 0,\n    Logger = void 0;\nmodule.importSync(\"/server/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  },\n  Logger: function (v) {\n    Logger = v;\n  }\n}, 1);\nvar RevisionApi = void 0;\nmodule.importSync(\"/imports/plugins/core/revisions/lib/api/revisions\", {\n  RevisionApi: function (v) {\n    RevisionApi = v;\n  }\n}, 2);\nvar findProductMedia = void 0;\nmodule.importSync(\"./product\", {\n  findProductMedia: function (v) {\n    findProductMedia = v;\n  }\n}, 3);\n//\n// define search filters as a schema so we can validate\n// params supplied to the products publication\n//\nvar filters = new SimpleSchema({\n  \"shops\": {\n    type: [String],\n    optional: true\n  },\n  \"tags\": {\n    type: [String],\n    optional: true\n  },\n  \"query\": {\n    type: String,\n    optional: true\n  },\n  \"visibility\": {\n    type: Boolean,\n    optional: true\n  },\n  \"details\": {\n    type: Object,\n    optional: true\n  },\n  \"details.key\": {\n    type: String,\n    optional: true\n  },\n  \"details.value\": {\n    type: String,\n    optional: true\n  },\n  \"price\": {\n    type: Object,\n    optional: true\n  },\n  \"price.min\": {\n    type: String,\n    optional: true\n  },\n  \"price.max\": {\n    type: String,\n    optional: true\n  },\n  \"weight\": {\n    type: Object,\n    optional: true\n  },\n  \"weight.min\": {\n    type: String,\n    optional: true\n  },\n  \"weight.max\": {\n    type: String,\n    optional: true\n  }\n}); /**\n     * products publication\n     * @param {Number} productScrollLimit - optional, defaults to 24\n     * @param {Array} shops - array of shopId to retrieve product from.\n     * @return {Object} return product cursor\n     */\nMeteor.publish(\"Products\", function () {\n  var productScrollLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 24;\n\n  var _this = this;\n\n  var productFilters = arguments[1];\n  var sort = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  check(productScrollLimit, Number);\n  check(productFilters, Match.OneOf(undefined, Object));\n  check(sort, Match.OneOf(undefined, Object)); // if there are filter/params that don't match the schema\n  // validate, catch except but return no results\n\n  try {\n    check(productFilters, Match.OneOf(undefined, filters));\n  } catch (e) {\n    Logger.debug(e, \"Invalid Product Filters\");\n    return this.ready();\n  } // ensure that we've got a shop instance\n\n\n  var shop = Reaction.getCurrentShop();\n\n  if ((typeof shop === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(shop)) !== \"object\") {\n    return this.ready();\n  }\n\n  if (shop) {\n    var selector = {};\n\n    if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"], shop._id)) {\n      _.extend(selector, {\n        isDeleted: {\n          $in: [null, false]\n        },\n        ancestors: {\n          $exists: true\n        },\n        shopId: shop._id\n      });\n    } else {\n      // Changing the selector for non admin users only. To get top-level products.\n      _.extend(selector, {\n        isDeleted: {\n          $in: [null, false]\n        },\n        ancestors: [],\n        shopId: shop._id\n      });\n    }\n\n    if (productFilters) {\n      // handle multiple shops\n      if (productFilters.shops) {\n        _.extend(selector, {\n          shopId: {\n            $in: productFilters.shops\n          }\n        }); // check if this user is a shopAdmin\n\n\n        for (var _iterator = productFilters.shops, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var thisShopId = _ref;\n\n          if (Roles.userIsInRole(this.userId, [\"admin\", \"createProduct\"], thisShopId)) {\n            shopAdmin = true;\n          }\n        }\n      } // filter by tags\n\n\n      if (productFilters.tags) {\n        _.extend(selector, {\n          hashtags: {\n            $in: productFilters.tags\n          }\n        });\n      } // filter by query\n\n\n      if (productFilters.query) {\n        var cond = {\n          $regex: productFilters.query,\n          $options: \"i\"\n        };\n\n        _.extend(selector, {\n          $or: [{\n            title: cond\n          }, {\n            pageTitle: cond\n          }, {\n            description: cond\n          }]\n        });\n      } // filter by details\n\n\n      if (productFilters.details) {\n        _.extend(selector, {\n          metafields: {\n            $elemMatch: {\n              key: {\n                $regex: productFilters.details.key,\n                $options: \"i\"\n              },\n              value: {\n                $regex: productFilters.details.value,\n                $options: \"i\"\n              }\n            }\n          }\n        });\n      } // filter by visibility\n\n\n      if (productFilters.visibility !== undefined) {\n        _.extend(selector, {\n          isVisible: productFilters.visibility\n        });\n      } // filter by gte minimum price\n\n\n      if (productFilters[\"price.min\"] && !productFilters[\"price.max\"]) {\n        _.extend(selector, {\n          \"price.min\": {\n            $gte: parseFloat(productFilters[\"price.min\"])\n          }\n        });\n      } // filter by lte maximum price\n\n\n      if (productFilters[\"price.max\"] && !productFilters[\"price.min\"]) {\n        _.extend(selector, {\n          \"price.max\": {\n            $lte: parseFloat(productFilters[\"price.max\"])\n          }\n        });\n      } // filter with a price range\n\n\n      if (productFilters[\"price.min\"] && productFilters[\"price.max\"]) {\n        var pmin = parseFloat(productFilters[\"price.min\"]);\n        var pmax = parseFloat(productFilters[\"price.max\"]); // where product A has min 12.99 variant and a 19.99 variant\n        // price.min=12.99&price.max=19.98\n        // should return product A\n\n        _.extend(selector, {\n          \"price.min\": {\n            $lt: pmax\n          },\n          \"price.max\": {\n            $gt: pmin\n          }\n        });\n      } // filter by gte minimum weight\n\n\n      if (productFilters[\"weight.min\"] && !productFilters[\"weight.max\"]) {\n        _.extend(selector, {\n          weight: {\n            $gte: parseFloat(productFilters[\"weight.min\"])\n          }\n        });\n      } // filter by lte maximum weight\n\n\n      if (productFilters[\"weight.max\"] && !productFilters[\"weight.min\"]) {\n        _.extend(selector, {\n          weight: {\n            $lte: parseFloat(productFilters[\"weight.max\"])\n          }\n        });\n      } // filter with a weight range\n\n\n      if (productFilters[\"weight.min\"] && productFilters[\"weight.max\"]) {\n        var wmin = parseFloat(productFilters[\"weight.min\"]);\n        var wmax = parseFloat(productFilters[\"weight.max\"]);\n\n        _.extend(selector, {\n          weight: {\n            $lt: wmax,\n            $gt: wmin\n          }\n        });\n      }\n    } // end if productFilters\n    // Authorized content curators fo the shop get special publication of the product\n    // with all relevant revisions all is one package\n\n\n    if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"], shop._id)) {\n      selector.isVisible = {\n        $in: [true, false, undefined]\n      }; // Get _ids of top-level products\n\n      var _productIds = Products.find(selector, {\n        sort: sort,\n        limit: productScrollLimit\n      }).map(function (product) {\n        return product._id;\n      });\n\n      var _newSelector = selector; // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n\n      if (productFilters && productFilters.tags) {\n        _newSelector = _.omit(selector, [\"hashtags\"]); // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n\n        _.extend(_newSelector, {\n          $or: [{\n            ancestors: {\n              $in: _productIds\n            }\n          }, {\n            hashtags: {\n              $in: productFilters.tags\n            }\n          }]\n        });\n      }\n\n      if (RevisionApi.isRevisionControlEnabled()) {\n        var _productCursor2 = Products.find(_newSelector);\n\n        var handle = _productCursor2.observeChanges({\n          added: function (id, fields) {\n            var revisions = Revisions.find({\n              \"$or\": [{\n                documentId: id\n              }, {\n                parentDocument: id\n              }],\n              \"workflow.status\": {\n                $nin: [\"revision/published\"]\n              }\n            }).fetch();\n            fields.__revisions = revisions;\n\n            _this.added(\"Products\", id, fields);\n          },\n          changed: function (id, fields) {\n            var revisions = Revisions.find({\n              \"$or\": [{\n                documentId: id\n              }, {\n                parentDocument: id\n              }],\n              \"workflow.status\": {\n                $nin: [\"revision/published\"]\n              }\n            }).fetch();\n            fields.__revisions = revisions;\n\n            _this.changed(\"Products\", id, fields);\n          },\n          removed: function (id) {\n            _this.removed(\"Products\", id);\n          }\n        });\n\n        var handle2 = Revisions.find({\n          \"workflow.status\": {\n            $nin: [\"revision/published\"]\n          }\n        }).observe({\n          added: function (revision) {\n            var product = void 0;\n\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.documentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n\n            if (product) {\n              _this.added(\"Products\", product._id, product);\n\n              _this.added(\"Revisions\", revision._id, revision);\n            }\n          },\n          changed: function (revision) {\n            var product = void 0;\n\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.documentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n\n            if (product) {\n              product.__revisions = [revision];\n\n              _this.changed(\"Products\", product._id, product);\n\n              _this.changed(\"Revisions\", revision._id, revision);\n            }\n          },\n          removed: function (revision) {\n            var product = void 0;\n\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.docuentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n\n            if (product) {\n              product.__revisions = [];\n\n              _this.changed(\"Products\", product._id, product);\n\n              _this.removed(\"Revisions\", revision._id, revision);\n            }\n          }\n        });\n        this.onStop(function () {\n          handle.stop();\n          handle2.stop();\n        });\n\n        var _mediaProductIds2 = _productCursor2.fetch().map(function (p) {\n          return p._id;\n        });\n\n        var _mediaCursor2 = findProductMedia(this, _mediaProductIds2);\n\n        return [_mediaCursor2];\n      } // Revision control is disabled, but is admin\n\n\n      var _productCursor = Products.find(_newSelector, {\n        sort: sort,\n        limit: productScrollLimit\n      });\n\n      var _mediaProductIds = _productCursor.fetch().map(function (p) {\n        return p._id;\n      });\n\n      var _mediaCursor = findProductMedia(this, _mediaProductIds);\n\n      return [_productCursor, _mediaCursor];\n    } // Everyone else gets the standard, visible products\n\n\n    selector.isVisible = true; // Get _ids of top-level products\n\n    var productIds = Products.find(selector, {\n      sort: sort,\n      limit: productScrollLimit\n    }).map(function (product) {\n      return product._id;\n    });\n    var newSelector = selector; // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n\n    if (productFilters && productFilters.tags) {\n      newSelector = _.omit(selector, [\"hashtags\"]); // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n\n      _.extend(newSelector, {\n        $or: [{\n          ancestors: {\n            $in: productIds\n          }\n        }, {\n          hashtags: {\n            $in: productFilters.tags\n          }\n        }]\n      });\n    } // Returning Complete product tree for top level products to avoid sold out warning.\n\n\n    var productCursor = Products.find({\n      $or: [{\n        _id: {\n          $in: productIds\n        }\n      }, {\n        ancestors: {\n          $in: productIds\n        }\n      }]\n    });\n    var mediaProductIds = productCursor.fetch().map(function (p) {\n      return p._id;\n    });\n    var mediaCursor = findProductMedia(this, mediaProductIds);\n    return [productCursor, mediaCursor];\n  }\n});","map":{"version":3,"sources":["/server/publications/collections/products.js"],"names":["Products","Revisions","Reaction","Logger","RevisionApi","findProductMedia","filters","SimpleSchema","type","String","optional","Boolean","Object","Meteor","publish","productScrollLimit","productFilters","sort","check","Number","Match","OneOf","undefined","e","debug","ready","shop","getCurrentShop","selector","Roles","userIsInRole","userId","_id","_","extend","isDeleted","$in","ancestors","$exists","shopId","shops","thisShopId","shopAdmin","tags","hashtags","query","cond","$regex","$options","$or","title","pageTitle","description","details","metafields","$elemMatch","key","value","visibility","isVisible","$gte","parseFloat","$lte","pmin","pmax","$lt","$gt","weight","wmin","wmax","productIds","find","limit","map","product","newSelector","omit","isRevisionControlEnabled","productCursor","handle","observeChanges","added","id","fields","revisions","documentId","parentDocument","$nin","fetch","__revisions","changed","removed","handle2","observe","revision","documentType","findOne","docuentType","onStop","stop","mediaProductIds","p","mediaCursor"],"mappings":"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","file":"/server/publications/collections/products.js.map","sourcesContent":["import { Products, Revisions } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { RevisionApi } from \"/imports/plugins/core/revisions/lib/api/revisions\";\nimport { findProductMedia } from \"./product\";\n\n//\n// define search filters as a schema so we can validate\n// params supplied to the products publication\n//\nconst filters = new SimpleSchema({\n  \"shops\": {\n    type: [String],\n    optional: true\n  },\n  \"tags\": {\n    type: [String],\n    optional: true\n  },\n  \"query\": {\n    type: String,\n    optional: true\n  },\n  \"visibility\": {\n    type: Boolean,\n    optional: true\n  },\n  \"details\": {\n    type: Object,\n    optional: true\n  },\n  \"details.key\": {\n    type: String,\n    optional: true\n  },\n  \"details.value\": {\n    type: String,\n    optional: true\n  },\n  \"price\": {\n    type: Object,\n    optional: true\n  },\n  \"price.min\": {\n    type: String,\n    optional: true\n  },\n  \"price.max\": {\n    type: String,\n    optional: true\n  },\n  \"weight\": {\n    type: Object,\n    optional: true\n  },\n  \"weight.min\": {\n    type: String,\n    optional: true\n  },\n  \"weight.max\": {\n    type: String,\n    optional: true\n  }\n});\n\n/**\n * products publication\n * @param {Number} productScrollLimit - optional, defaults to 24\n * @param {Array} shops - array of shopId to retrieve product from.\n * @return {Object} return product cursor\n */\nMeteor.publish(\"Products\", function (productScrollLimit = 24, productFilters, sort = {}) {\n  check(productScrollLimit, Number);\n  check(productFilters, Match.OneOf(undefined, Object));\n  check(sort, Match.OneOf(undefined, Object));\n\n  // if there are filter/params that don't match the schema\n  // validate, catch except but return no results\n  try {\n    check(productFilters, Match.OneOf(undefined, filters));\n  } catch (e) {\n    Logger.debug(e, \"Invalid Product Filters\");\n    return this.ready();\n  }\n  // ensure that we've got a shop instance\n  const shop = Reaction.getCurrentShop();\n  if (typeof shop !== \"object\") {\n    return this.ready();\n  }\n\n  if (shop) {\n    const selector = {};\n    if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"], shop._id)) {\n      _.extend(selector, {\n        isDeleted: { $in: [null, false] },\n        ancestors: { $exists: true },\n        shopId: shop._id\n      });\n    } else { // Changing the selector for non admin users only. To get top-level products.\n      _.extend(selector, {\n        isDeleted: { $in: [null, false] },\n        ancestors: [],\n        shopId: shop._id\n      });\n    }\n\n    if (productFilters) {\n      // handle multiple shops\n      if (productFilters.shops) {\n        _.extend(selector, {\n          shopId: {\n            $in: productFilters.shops\n          }\n        });\n\n        // check if this user is a shopAdmin\n        for (const thisShopId of productFilters.shops) {\n          if (Roles.userIsInRole(this.userId, [\"admin\", \"createProduct\"], thisShopId)) {\n            shopAdmin = true;\n          }\n        }\n      }\n\n      // filter by tags\n      if (productFilters.tags) {\n        _.extend(selector, {\n          hashtags: {\n            $in: productFilters.tags\n          }\n        });\n      }\n\n      // filter by query\n      if (productFilters.query) {\n        const cond = {\n          $regex: productFilters.query,\n          $options: \"i\"\n        };\n        _.extend(selector, {\n          $or: [{\n            title: cond\n          }, {\n            pageTitle: cond\n          }, {\n            description: cond\n          }]\n        });\n      }\n\n      // filter by details\n      if (productFilters.details) {\n        _.extend(selector, {\n          metafields: {\n            $elemMatch: {\n              key: {\n                $regex: productFilters.details.key,\n                $options: \"i\"\n              },\n              value: {\n                $regex: productFilters.details.value,\n                $options: \"i\"\n              }\n            }\n          }\n        });\n      }\n\n      // filter by visibility\n      if (productFilters.visibility !== undefined) {\n        _.extend(selector, {\n          isVisible: productFilters.visibility\n        });\n      }\n\n      // filter by gte minimum price\n      if (productFilters[\"price.min\"] && !productFilters[\"price.max\"]) {\n        _.extend(selector, {\n          \"price.min\": {\n            $gte: parseFloat(productFilters[\"price.min\"])\n          }\n        });\n      }\n\n      // filter by lte maximum price\n      if (productFilters[\"price.max\"] && !productFilters[\"price.min\"]) {\n        _.extend(selector, {\n          \"price.max\": {\n            $lte: parseFloat(productFilters[\"price.max\"])\n          }\n        });\n      }\n\n      // filter with a price range\n      if (productFilters[\"price.min\"] && productFilters[\"price.max\"]) {\n        const pmin = parseFloat(productFilters[\"price.min\"]);\n        const pmax = parseFloat(productFilters[\"price.max\"]);\n        // where product A has min 12.99 variant and a 19.99 variant\n        // price.min=12.99&price.max=19.98\n        // should return product A\n        _.extend(selector, {\n          \"price.min\": {\n            $lt: pmax\n          },\n          \"price.max\": {\n            $gt: pmin\n          }\n        });\n      }\n\n      // filter by gte minimum weight\n      if (productFilters[\"weight.min\"] && !productFilters[\"weight.max\"]) {\n        _.extend(selector, {\n          weight: {\n            $gte: parseFloat(productFilters[\"weight.min\"])\n          }\n        });\n      }\n\n      // filter by lte maximum weight\n      if (productFilters[\"weight.max\"] && !productFilters[\"weight.min\"]) {\n        _.extend(selector, {\n          weight: {\n            $lte: parseFloat(productFilters[\"weight.max\"])\n          }\n        });\n      }\n\n      // filter with a weight range\n      if (productFilters[\"weight.min\"] && productFilters[\"weight.max\"]) {\n        const wmin = parseFloat(productFilters[\"weight.min\"]);\n        const wmax = parseFloat(productFilters[\"weight.max\"]);\n        _.extend(selector, {\n          weight: {\n            $lt: wmax,\n            $gt: wmin\n          }\n        });\n      }\n    } // end if productFilters\n\n    // Authorized content curators fo the shop get special publication of the product\n    // with all relevant revisions all is one package\n\n    if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"], shop._id)) {\n      selector.isVisible = {\n        $in: [true, false, undefined]\n      };\n\n      // Get _ids of top-level products\n      const productIds = Products.find(selector, {\n        sort: sort,\n        limit: productScrollLimit\n      }).map(product => product._id);\n\n      let newSelector = selector;\n\n      // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n      if (productFilters && productFilters.tags) {\n        newSelector = _.omit(selector, [\"hashtags\"]);\n\n        // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n        _.extend(newSelector, {\n          $or: [\n            {\n              ancestors: {\n                $in: productIds\n              }\n            }, {\n              hashtags: {\n                $in: productFilters.tags\n              }\n            }\n          ]\n        });\n      }\n\n      if (RevisionApi.isRevisionControlEnabled()) {\n        const productCursor = Products.find(newSelector);\n        const handle = productCursor.observeChanges({\n          added: (id, fields) => {\n            const revisions = Revisions.find({\n              \"$or\": [\n                { documentId: id },\n                { parentDocument: id }\n              ],\n              \"workflow.status\": {\n                $nin: [\n                  \"revision/published\"\n                ]\n              }\n            }).fetch();\n            fields.__revisions = revisions;\n\n            this.added(\"Products\", id, fields);\n          },\n          changed: (id, fields) => {\n            const revisions = Revisions.find({\n              \"$or\": [\n                { documentId: id },\n                { parentDocument: id }\n              ],\n              \"workflow.status\": {\n                $nin: [\n                  \"revision/published\"\n                ]\n              }\n            }).fetch();\n\n            fields.__revisions = revisions;\n            this.changed(\"Products\", id, fields);\n          },\n          removed: (id) => {\n            this.removed(\"Products\", id);\n          }\n        });\n\n        const handle2 = Revisions.find({\n          \"workflow.status\": {\n            $nin: [\n              \"revision/published\"\n            ]\n          }\n        }).observe({\n          added: (revision) => {\n            let product;\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.documentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n\n            if (product) {\n              this.added(\"Products\", product._id, product);\n              this.added(\"Revisions\", revision._id, revision);\n            }\n          },\n          changed: (revision) => {\n            let product;\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.documentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n            if (product) {\n              product.__revisions = [revision];\n              this.changed(\"Products\", product._id, product);\n              this.changed(\"Revisions\", revision._id, revision);\n            }\n          },\n          removed: (revision) => {\n            let product;\n\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.docuentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n            if (product) {\n              product.__revisions = [];\n              this.changed(\"Products\", product._id, product);\n              this.removed(\"Revisions\", revision._id, revision);\n            }\n          }\n        });\n\n\n        this.onStop(() => {\n          handle.stop();\n          handle2.stop();\n        });\n\n        const mediaProductIds = productCursor.fetch().map((p) => p._id);\n        const mediaCursor = findProductMedia(this, mediaProductIds);\n\n        return [\n          mediaCursor\n        ];\n      }\n      // Revision control is disabled, but is admin\n      const productCursor = Products.find(newSelector, {\n        sort: sort,\n        limit: productScrollLimit\n      });\n      const mediaProductIds = productCursor.fetch().map((p) => p._id);\n      const mediaCursor = findProductMedia(this, mediaProductIds);\n\n      return [\n        productCursor,\n        mediaCursor\n      ];\n    }\n\n    // Everyone else gets the standard, visible products\n    selector.isVisible = true;\n\n    // Get _ids of top-level products\n    const productIds = Products.find(selector, {\n      sort: sort,\n      limit: productScrollLimit\n    }).map(product => product._id);\n\n    let newSelector = selector;\n\n    // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n    if (productFilters && productFilters.tags) {\n      newSelector = _.omit(selector, [\"hashtags\"]);\n\n      // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n      _.extend(newSelector, {\n        $or: [\n          {\n            ancestors: {\n              $in: productIds\n            }\n          }, {\n            hashtags: {\n              $in: productFilters.tags\n            }\n          }\n        ]\n      });\n    }\n    // Returning Complete product tree for top level products to avoid sold out warning.\n    const productCursor = Products.find({\n      $or: [\n        { _id: { $in: productIds } },\n        { ancestors: { $in: productIds } }\n      ]\n    });\n\n    const mediaProductIds = productCursor.fetch().map((p) => p._id);\n    const mediaCursor = findProductMedia(this, mediaProductIds);\n\n    return [\n      productCursor,\n      mediaCursor\n    ];\n  }\n});\n"]},"hash":"032ef3d30bfc05f22f85617f15aa2a3ba408c7a5"}
