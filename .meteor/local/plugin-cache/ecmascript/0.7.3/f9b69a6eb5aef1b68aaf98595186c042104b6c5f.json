{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"lodash/uniq","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_uniq"}]},{"source":"lodash/includes","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_includes"}]},{"source":"lodash/each","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_each"}]},{"source":"lodash/filter","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_filter"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"/lib/collections","imported":["Cart","Orders","Packages","Shops"],"specifiers":[{"kind":"named","imported":"Cart","local":"Cart"},{"kind":"named","imported":"Orders","local":"Orders"},{"kind":"named","imported":"Packages","local":"Packages"},{"kind":"named","imported":"Shops","local":"Shops"}]},{"source":"/server/api","imported":["Logger","Reaction"],"specifiers":[{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/plugins/core/checkout/server/methods/workflow.js","filenameRelative":"/imports/plugins/core/checkout/server/methods/workflow.js","inputSourceMap":{"version":3,"sources":["/imports/plugins/core/checkout/server/methods/workflow.js"],"names":["Meteor","Cart","Orders","Packages","Shops","Logger","Reaction","methods","workflow","newWorkflowStatus","cartId","check","String","Match","Optional","unblock","currentCart","defaultPackageWorkflows","nextWorkflowStep","template","findOne","userId","currentWorkflowStatus","status","packages","find","getShopId","forEach","reactionPackage","layout","layouts","audience","defaultRoles","sort","priority","hasPermission","Roles","userIsInRole","push","statusExistsInWorkflow","maxSteps","length","nextWorkflowStepIndex","templateProcessedinWorkflow","gotoNextWorkflowStep","currentStatusIndex","debug","_id","result","update","$set","$addToSet","cart","resetToIndex","indexOf","resetedWorkflow","slice","order","Object","workflowStatus","$pull","itemIds","Array","items","map","item","workflows"],"mappings":"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","file":"/imports/plugins/core/checkout/server/methods/workflow.js.map","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Cart, Orders, Packages, Shops } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/* eslint no-shadow: 0 */\n\nMeteor.methods({\n  /**\n   * workflow/pushCartWorkflow\n   * @summary updates cart workflow status\n   * @description status in the workflow is stored as the current active\n   * workflow step.\n   *\n   * first sets, second call moves status to next workflow\n   * additional calls do nothing\n   * user permissions to template are verified\n   * @param {String} workflow - name of workflow\n   * @param {String} newWorkflowStatus - name of the next workflow stage\n   * @param {String} [cartId] - cart._id\n   * @return {Array|Boolean|Number} return\n   */\n  \"workflow/pushCartWorkflow\": function (workflow, newWorkflowStatus, cartId) {\n    check(workflow, String);\n    check(newWorkflowStatus, String);\n    check(cartId, Match.Optional(String));\n    this.unblock();\n\n    let currentCart;\n    const defaultPackageWorkflows = [];\n    let nextWorkflowStep = {\n      template: \"\"\n    };\n\n    // This method could be called indirectly from publication method in a time\n    // when `this.userId` will be null, that's why we have a third argument in\n    // this method - `cartId`. So, we can't completely rely on `Meteor.userId()`\n    // here.\n    if (typeof cartId === \"string\") {\n      currentCart = Cart.findOne(cartId);\n    } else {\n      currentCart = Cart.findOne({\n        userId: this.userId\n      });\n    }\n    // exit if a cart doesn't exist.\n    if (!currentCart) return [];\n    // TODO doc this\n    const currentWorkflowStatus = currentCart.workflow.status;\n    const packages = Packages.find({\n      \"shopId\": Reaction.getShopId(),\n      \"layout.workflow\": workflow\n    });\n\n    // loop through packages and set the defaultPackageWorkflows\n    packages.forEach(function (reactionPackage) {\n      // todo fix this hack for not filtering nicely\n      if (!reactionPackage.layout.layout) {\n        const layouts = _.filter(reactionPackage.layout, {\n          workflow: workflow\n        });\n        // for every layout, process the associated workflows\n        _.each(layouts, function (layout) {\n          // audience is the layout permissions\n          if (typeof layout.audience !== \"object\") {\n            const defaultRoles = Shops.findOne(\n              Reaction.getShopId(), {\n                sort: {\n                  priority: 1\n                }\n              }).defaultRoles;\n            layout.audience = defaultRoles;\n          }\n          // check permissions so you don't have to on template. For a case, when\n          // this method calls indirectly from publication method, we do this\n          // check which is looks not pretty secure\n          let hasPermission;\n          if (typeof Meteor.userId() !== \"string\") {\n            hasPermission = Roles.userIsInRole(currentCart.userId, layout.audience, Reaction.getShopId());\n          } else {\n            hasPermission = Roles.userIsInRole(Meteor.userId(), layout.audience, Reaction.getShopId());\n          }\n\n          if (hasPermission  && !layout.layout) {\n            defaultPackageWorkflows.push(layout);\n          }\n        });\n      }\n    });\n\n    // statusExistsInWorkflow boolean\n    const statusExistsInWorkflow = _.includes(currentCart.workflow.workflow, newWorkflowStatus);\n    const maxSteps = defaultPackageWorkflows.length;\n    let nextWorkflowStepIndex;\n    let templateProcessedinWorkflow = false;\n    let gotoNextWorkflowStep = false;\n\n    // if we haven't populated workflows lets exit\n    if (!defaultPackageWorkflows.length > 0) {\n      return [];\n    }\n\n    // loop through all shop configured layouts, and their default workflows\n    // to determine what the next workflow step should be\n    // the cart workflow status while processing is neither true nor false (set to template)\n    _.each(defaultPackageWorkflows, function (workflow, currentStatusIndex) {\n      if (workflow.template === currentWorkflowStatus) {\n        // don't go past the end of the workflow\n        if (currentStatusIndex < maxSteps - 1) {\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          nextWorkflowStepIndex = currentStatusIndex + 1;\n        } else {\n          nextWorkflowStepIndex = currentStatusIndex;\n        }\n\n        Logger.debug(\"nextWorkflowStepIndex\", nextWorkflowStepIndex);\n        // set the nextWorkflowStep as the next workflow object from registry\n        nextWorkflowStep = defaultPackageWorkflows[nextWorkflowStepIndex];\n\n        Logger.debug(\"setting nextWorkflowStep\", nextWorkflowStep.template);\n      }\n    });\n\n    // check to see if the next step has already been processed.\n    // templateProcessedinWorkflow boolean\n    gotoNextWorkflowStep = nextWorkflowStep.template;\n    templateProcessedinWorkflow = _.includes(currentCart.workflow.workflow,\n      nextWorkflowStep.template);\n\n    // debug info\n    Logger.debug(\"currentWorkflowStatus: \", currentWorkflowStatus);\n    Logger.debug(\"workflow/pushCartWorkflow workflow: \", workflow);\n    Logger.debug(\"newWorkflowStatus: \", newWorkflowStatus);\n    Logger.debug(\"current cartId: \", currentCart._id);\n    Logger.debug(\"currentWorkflow: \", currentCart.workflow.workflow);\n    Logger.debug(\"nextWorkflowStep: \", nextWorkflowStep.template || defaultPackageWorkflows[0].template);\n    Logger.debug(\"statusExistsInWorkflow: \", statusExistsInWorkflow);\n    Logger.debug(\"templateProcessedinWorkflow: \", templateProcessedinWorkflow);\n    Logger.debug(\"gotoNextWorkflowStep: \", gotoNextWorkflowStep);\n\n    // Condition One\n    // if you're going to join the workflow you need a status that is a template name.\n    // this status/template is how we know\n    // where you are in the flow and configures `gotoNextWorkflowStep`\n\n    if (!gotoNextWorkflowStep && currentWorkflowStatus !== newWorkflowStatus) {\n      Logger.debug(\n        `######## Condition One #########: initialise the ${currentCart._id} ${workflow}: ${defaultPackageWorkflows[0].template}`\n      );\n      const result = Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": defaultPackageWorkflows[0].template\n        }\n      });\n      Logger.debug(result);\n      return result;\n    }\n\n    // Condition Two\n    // your're now accepted into the workflow,\n    // but to begin the workflow you need to have a next step\n    // and you should have already be in the current workflow template\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === false &&\n      templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Two #########: set status to: \",\n        nextWorkflowStep.template);\n\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    }\n\n    // Condition Three\n    // If you got here by skipping around willy nilly\n    // we're going to do our best to ignore you.\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true &&\n      templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Three #########: complete workflow \" +\n        currentWorkflowStatus + \" updates and move to: \",\n        nextWorkflowStep.template);\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    }\n\n    // Condition Four\n    // you got here through hard work, and processed the previous template\n    // nice job. now start over with the next step.\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true &&\n      templateProcessedinWorkflow === true) {\n      Logger.debug(\n        \"######## Condition Four #########: previously ran, doing nothing. : \",\n        newWorkflowStatus);\n      return true;\n    }\n  },\n\n  /**\n   * workflow/revertCartWorkflow\n   * @description if something was changed on the previous `cartWorkflow` steps\n   * we need to revert to this step to renew the order\n   * @param {String} newWorkflowStatus - name of `cartWorkflow` step, which\n   * we need to revert\n   * @todo need tests\n   * @return {Number|Boolean} cart update results\n   */\n  \"workflow/revertCartWorkflow\": function (newWorkflowStatus) {\n    check(newWorkflowStatus, String);\n    this.unblock();\n\n    const cart = Cart.findOne({\n      userId: this.userId\n    });\n\n    if (!cart || typeof cart.workflow !== \"object\") return false;\n    if (typeof cart.workflow.workflow !== \"object\") return false;\n\n    const { workflow } = cart.workflow;\n    // get index of `newWorkflowStatus`\n    const resetToIndex = workflow.indexOf(newWorkflowStatus);\n    // exit if no such step in workflow\n    if (!~resetToIndex) return false;\n    // remove all steps that further `newWorkflowStatus` and itself\n    const resetedWorkflow = workflow.slice(0, resetToIndex);\n\n    return Cart.update(cart._id, {\n      $set: {\n        \"workflow.status\": newWorkflowStatus,\n        \"workflow.workflow\": resetedWorkflow\n      }\n    });\n  },\n\n  /**\n   * workflow/pushOrderWorkflow\n   * Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   *\n   * Step 1 meteor call to push a new workflow\n   * Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", this);\n   * NOTE: \"coreOrderWorkflow\", \"processing\" will be combined into \"coreOrderWorkflow/processing\"\n   * and set as the status\n   *\n   * Step 2 (this method) of the \"workflow/pushOrderWorkflow\" flow; Try to update the current status\n   *\n   * @summary Update the order workflow\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pushOrderWorkflow\": function (workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Object); // TODO: Validatate as Schemas.Order\n    this.unblock();\n\n    const workflowStatus = `${workflow}/${status}`;\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        // Combine (workflow) \"coreOrderWorkflow\", (status) \"processing\" into \"coreOrderWorkflow/processing\".\n        // This comoniation will be used to call the method \"workflow/coreOrderWorkflow/processing\", if it exists.\n        \"workflow.status\": `${workflow}/${status}`\n      },\n      $addToSet: {\n        \"workflow.workflow\": workflowStatus\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * workflow/pullOrderWorkflow\n   * Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   * @summary Pull a previous order status\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pullOrderWorkflow\": function (workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Object);\n    this.unblock();\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        \"workflow.status\": status\n      },\n      $pull: {\n        \"workflow.workflow\": order.workflow.status\n      }\n    });\n\n    return result;\n  },\n\n  \"workflow/pushItemWorkflow\": function (status, order, itemIds) {\n    check(status, String);\n    check(order, Object);\n    check(itemIds, Array);\n\n    const items = order.items.map((item) => {\n      // Add the current status to completed workflows\n      if (item.workflow.status !== \"new\") {\n        const workflows = item.workflow.workflow || [];\n\n        workflows.push(status);\n        item.workflow.workflow = _.uniq(workflows);\n      }\n\n      // Set the new item status\n      item.workflow.status = status;\n      return item;\n    });\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        items: items\n      }\n    });\n\n    return result;\n  }\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/plugins/core/checkout/server/methods/workflow.js.map","sourceFileName":"/imports/plugins/core/checkout/server/methods/workflow.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"workflow"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _uniq = void 0;\n\nmodule.importSync(\"lodash/uniq\", {\n  \"default\": function (v) {\n    _uniq = v;\n  }\n}, 0);\n\nvar _includes = void 0;\n\nmodule.importSync(\"lodash/includes\", {\n  \"default\": function (v) {\n    _includes = v;\n  }\n}, 1);\n\nvar _each = void 0;\n\nmodule.importSync(\"lodash/each\", {\n  \"default\": function (v) {\n    _each = v;\n  }\n}, 2);\n\nvar _filter = void 0;\n\nmodule.importSync(\"lodash/filter\", {\n  \"default\": function (v) {\n    _filter = v;\n  }\n}, 3);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 4);\nvar Cart = void 0,\n    Orders = void 0,\n    Packages = void 0,\n    Shops = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Cart: function (v) {\n    Cart = v;\n  },\n  Orders: function (v) {\n    Orders = v;\n  },\n  Packages: function (v) {\n    Packages = v;\n  },\n  Shops: function (v) {\n    Shops = v;\n  }\n}, 5);\nvar Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 6);\n/* eslint no-shadow: 0 */Meteor.methods({\n  /**\n   * workflow/pushCartWorkflow\n   * @summary updates cart workflow status\n   * @description status in the workflow is stored as the current active\n   * workflow step.\n   *\n   * first sets, second call moves status to next workflow\n   * additional calls do nothing\n   * user permissions to template are verified\n   * @param {String} workflow - name of workflow\n   * @param {String} newWorkflowStatus - name of the next workflow stage\n   * @param {String} [cartId] - cart._id\n   * @return {Array|Boolean|Number} return\n   */\"workflow/pushCartWorkflow\": function (workflow, newWorkflowStatus, cartId) {\n    check(workflow, String);\n    check(newWorkflowStatus, String);\n    check(cartId, Match.Optional(String));\n    this.unblock();\n    var currentCart = void 0;\n    var defaultPackageWorkflows = [];\n    var nextWorkflowStep = {\n      template: \"\"\n    }; // This method could be called indirectly from publication method in a time\n    // when `this.userId` will be null, that's why we have a third argument in\n    // this method - `cartId`. So, we can't completely rely on `Meteor.userId()`\n    // here.\n\n    if (typeof cartId === \"string\") {\n      currentCart = Cart.findOne(cartId);\n    } else {\n      currentCart = Cart.findOne({\n        userId: this.userId\n      });\n    } // exit if a cart doesn't exist.\n\n\n    if (!currentCart) return []; // TODO doc this\n\n    var currentWorkflowStatus = currentCart.workflow.status;\n    var packages = Packages.find({\n      \"shopId\": Reaction.getShopId(),\n      \"layout.workflow\": workflow\n    }); // loop through packages and set the defaultPackageWorkflows\n\n    packages.forEach(function (reactionPackage) {\n      // todo fix this hack for not filtering nicely\n      if (!reactionPackage.layout.layout) {\n        var layouts = _filter(reactionPackage.layout, {\n          workflow: workflow\n        }); // for every layout, process the associated workflows\n\n\n        _each(layouts, function (layout) {\n          // audience is the layout permissions\n          if ((0, _typeof3.default)(layout.audience) !== \"object\") {\n            var defaultRoles = Shops.findOne(Reaction.getShopId(), {\n              sort: {\n                priority: 1\n              }\n            }).defaultRoles;\n            layout.audience = defaultRoles;\n          } // check permissions so you don't have to on template. For a case, when\n          // this method calls indirectly from publication method, we do this\n          // check which is looks not pretty secure\n\n\n          var hasPermission = void 0;\n\n          if (typeof Meteor.userId() !== \"string\") {\n            hasPermission = Roles.userIsInRole(currentCart.userId, layout.audience, Reaction.getShopId());\n          } else {\n            hasPermission = Roles.userIsInRole(Meteor.userId(), layout.audience, Reaction.getShopId());\n          }\n\n          if (hasPermission && !layout.layout) {\n            defaultPackageWorkflows.push(layout);\n          }\n        });\n      }\n    }); // statusExistsInWorkflow boolean\n\n    var statusExistsInWorkflow = _includes(currentCart.workflow.workflow, newWorkflowStatus);\n\n    var maxSteps = defaultPackageWorkflows.length;\n    var nextWorkflowStepIndex = void 0;\n    var templateProcessedinWorkflow = false;\n    var gotoNextWorkflowStep = false; // if we haven't populated workflows lets exit\n\n    if (!defaultPackageWorkflows.length > 0) {\n      return [];\n    } // loop through all shop configured layouts, and their default workflows\n    // to determine what the next workflow step should be\n    // the cart workflow status while processing is neither true nor false (set to template)\n\n\n    _each(defaultPackageWorkflows, function (workflow, currentStatusIndex) {\n      if (workflow.template === currentWorkflowStatus) {\n        // don't go past the end of the workflow\n        if (currentStatusIndex < maxSteps - 1) {\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          nextWorkflowStepIndex = currentStatusIndex + 1;\n        } else {\n          nextWorkflowStepIndex = currentStatusIndex;\n        }\n\n        Logger.debug(\"nextWorkflowStepIndex\", nextWorkflowStepIndex); // set the nextWorkflowStep as the next workflow object from registry\n\n        nextWorkflowStep = defaultPackageWorkflows[nextWorkflowStepIndex];\n        Logger.debug(\"setting nextWorkflowStep\", nextWorkflowStep.template);\n      }\n    }); // check to see if the next step has already been processed.\n    // templateProcessedinWorkflow boolean\n\n\n    gotoNextWorkflowStep = nextWorkflowStep.template;\n    templateProcessedinWorkflow = _includes(currentCart.workflow.workflow, nextWorkflowStep.template); // debug info\n\n    Logger.debug(\"currentWorkflowStatus: \", currentWorkflowStatus);\n    Logger.debug(\"workflow/pushCartWorkflow workflow: \", workflow);\n    Logger.debug(\"newWorkflowStatus: \", newWorkflowStatus);\n    Logger.debug(\"current cartId: \", currentCart._id);\n    Logger.debug(\"currentWorkflow: \", currentCart.workflow.workflow);\n    Logger.debug(\"nextWorkflowStep: \", nextWorkflowStep.template || defaultPackageWorkflows[0].template);\n    Logger.debug(\"statusExistsInWorkflow: \", statusExistsInWorkflow);\n    Logger.debug(\"templateProcessedinWorkflow: \", templateProcessedinWorkflow);\n    Logger.debug(\"gotoNextWorkflowStep: \", gotoNextWorkflowStep); // Condition One\n    // if you're going to join the workflow you need a status that is a template name.\n    // this status/template is how we know\n    // where you are in the flow and configures `gotoNextWorkflowStep`\n\n    if (!gotoNextWorkflowStep && currentWorkflowStatus !== newWorkflowStatus) {\n      Logger.debug(\"######## Condition One #########: initialise the \" + currentCart._id + \" \" + workflow + \": \" + defaultPackageWorkflows[0].template);\n      var result = Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": defaultPackageWorkflows[0].template\n        }\n      });\n      Logger.debug(result);\n      return result;\n    } // Condition Two\n    // your're now accepted into the workflow,\n    // but to begin the workflow you need to have a next step\n    // and you should have already be in the current workflow template\n\n\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === false && templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Two #########: set status to: \", nextWorkflowStep.template);\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    } // Condition Three\n    // If you got here by skipping around willy nilly\n    // we're going to do our best to ignore you.\n\n\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true && templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Three #########: complete workflow \" + currentWorkflowStatus + \" updates and move to: \", nextWorkflowStep.template);\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    } // Condition Four\n    // you got here through hard work, and processed the previous template\n    // nice job. now start over with the next step.\n\n\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true && templateProcessedinWorkflow === true) {\n      Logger.debug(\"######## Condition Four #########: previously ran, doing nothing. : \", newWorkflowStatus);\n      return true;\n    }\n  },\n  /**\n   * workflow/revertCartWorkflow\n   * @description if something was changed on the previous `cartWorkflow` steps\n   * we need to revert to this step to renew the order\n   * @param {String} newWorkflowStatus - name of `cartWorkflow` step, which\n   * we need to revert\n   * @todo need tests\n   * @return {Number|Boolean} cart update results\n   */\"workflow/revertCartWorkflow\": function (newWorkflowStatus) {\n    check(newWorkflowStatus, String);\n    this.unblock();\n    var cart = Cart.findOne({\n      userId: this.userId\n    });\n    if (!cart || (0, _typeof3.default)(cart.workflow) !== \"object\") return false;\n    if ((0, _typeof3.default)(cart.workflow.workflow) !== \"object\") return false;\n    var workflow = cart.workflow.workflow; // get index of `newWorkflowStatus`\n\n    var resetToIndex = workflow.indexOf(newWorkflowStatus); // exit if no such step in workflow\n\n    if (!~resetToIndex) return false; // remove all steps that further `newWorkflowStatus` and itself\n\n    var resetedWorkflow = workflow.slice(0, resetToIndex);\n    return Cart.update(cart._id, {\n      $set: {\n        \"workflow.status\": newWorkflowStatus,\n        \"workflow.workflow\": resetedWorkflow\n      }\n    });\n  },\n  /**\n   * workflow/pushOrderWorkflow\n   * Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   *\n   * Step 1 meteor call to push a new workflow\n   * Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", this);\n   * NOTE: \"coreOrderWorkflow\", \"processing\" will be combined into \"coreOrderWorkflow/processing\"\n   * and set as the status\n   *\n   * Step 2 (this method) of the \"workflow/pushOrderWorkflow\" flow; Try to update the current status\n   *\n   * @summary Update the order workflow\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\"workflow/pushOrderWorkflow\": function (workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Object); // TODO: Validatate as Schemas.Order\n\n    this.unblock();\n    var workflowStatus = workflow + \"/\" + status;\n    var result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        // Combine (workflow) \"coreOrderWorkflow\", (status) \"processing\" into \"coreOrderWorkflow/processing\".\n        // This comoniation will be used to call the method \"workflow/coreOrderWorkflow/processing\", if it exists.\n        \"workflow.status\": workflow + \"/\" + status\n      },\n      $addToSet: {\n        \"workflow.workflow\": workflowStatus\n      }\n    });\n    return result;\n  },\n  /**\n   * workflow/pullOrderWorkflow\n   * Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   * @summary Pull a previous order status\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\"workflow/pullOrderWorkflow\": function (workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Object);\n    this.unblock();\n    var result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        \"workflow.status\": status\n      },\n      $pull: {\n        \"workflow.workflow\": order.workflow.status\n      }\n    });\n    return result;\n  },\n  \"workflow/pushItemWorkflow\": function (status, order, itemIds) {\n    check(status, String);\n    check(order, Object);\n    check(itemIds, Array);\n    var items = order.items.map(function (item) {\n      // Add the current status to completed workflows\n      if (item.workflow.status !== \"new\") {\n        var workflows = item.workflow.workflow || [];\n        workflows.push(status);\n        item.workflow.workflow = _uniq(workflows);\n      } // Set the new item status\n\n\n      item.workflow.status = status;\n      return item;\n    });\n    var result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        items: items\n      }\n    });\n    return result;\n  }\n});","map":{"version":3,"sources":["/imports/plugins/core/checkout/server/methods/workflow.js"],"names":["Meteor","Cart","Orders","Packages","Shops","Logger","Reaction","methods","workflow","newWorkflowStatus","cartId","check","String","Match","Optional","unblock","currentCart","defaultPackageWorkflows","nextWorkflowStep","template","findOne","userId","currentWorkflowStatus","status","packages","find","getShopId","forEach","reactionPackage","layout","layouts","audience","defaultRoles","sort","priority","hasPermission","Roles","userIsInRole","push","statusExistsInWorkflow","maxSteps","length","nextWorkflowStepIndex","templateProcessedinWorkflow","gotoNextWorkflowStep","currentStatusIndex","debug","_id","result","update","$set","$addToSet","cart","resetToIndex","indexOf","resetedWorkflow","slice","order","Object","workflowStatus","$pull","itemIds","Array","items","map","item","workflows"],"mappings":"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","file":"/imports/plugins/core/checkout/server/methods/workflow.js.map","sourcesContent":["import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Cart, Orders, Packages, Shops } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/* eslint no-shadow: 0 */\n\nMeteor.methods({\n  /**\n   * workflow/pushCartWorkflow\n   * @summary updates cart workflow status\n   * @description status in the workflow is stored as the current active\n   * workflow step.\n   *\n   * first sets, second call moves status to next workflow\n   * additional calls do nothing\n   * user permissions to template are verified\n   * @param {String} workflow - name of workflow\n   * @param {String} newWorkflowStatus - name of the next workflow stage\n   * @param {String} [cartId] - cart._id\n   * @return {Array|Boolean|Number} return\n   */\n  \"workflow/pushCartWorkflow\": function (workflow, newWorkflowStatus, cartId) {\n    check(workflow, String);\n    check(newWorkflowStatus, String);\n    check(cartId, Match.Optional(String));\n    this.unblock();\n\n    let currentCart;\n    const defaultPackageWorkflows = [];\n    let nextWorkflowStep = {\n      template: \"\"\n    };\n\n    // This method could be called indirectly from publication method in a time\n    // when `this.userId` will be null, that's why we have a third argument in\n    // this method - `cartId`. So, we can't completely rely on `Meteor.userId()`\n    // here.\n    if (typeof cartId === \"string\") {\n      currentCart = Cart.findOne(cartId);\n    } else {\n      currentCart = Cart.findOne({\n        userId: this.userId\n      });\n    }\n    // exit if a cart doesn't exist.\n    if (!currentCart) return [];\n    // TODO doc this\n    const currentWorkflowStatus = currentCart.workflow.status;\n    const packages = Packages.find({\n      \"shopId\": Reaction.getShopId(),\n      \"layout.workflow\": workflow\n    });\n\n    // loop through packages and set the defaultPackageWorkflows\n    packages.forEach(function (reactionPackage) {\n      // todo fix this hack for not filtering nicely\n      if (!reactionPackage.layout.layout) {\n        const layouts = _.filter(reactionPackage.layout, {\n          workflow: workflow\n        });\n        // for every layout, process the associated workflows\n        _.each(layouts, function (layout) {\n          // audience is the layout permissions\n          if (typeof layout.audience !== \"object\") {\n            const defaultRoles = Shops.findOne(\n              Reaction.getShopId(), {\n                sort: {\n                  priority: 1\n                }\n              }).defaultRoles;\n            layout.audience = defaultRoles;\n          }\n          // check permissions so you don't have to on template. For a case, when\n          // this method calls indirectly from publication method, we do this\n          // check which is looks not pretty secure\n          let hasPermission;\n          if (typeof Meteor.userId() !== \"string\") {\n            hasPermission = Roles.userIsInRole(currentCart.userId, layout.audience, Reaction.getShopId());\n          } else {\n            hasPermission = Roles.userIsInRole(Meteor.userId(), layout.audience, Reaction.getShopId());\n          }\n\n          if (hasPermission  && !layout.layout) {\n            defaultPackageWorkflows.push(layout);\n          }\n        });\n      }\n    });\n\n    // statusExistsInWorkflow boolean\n    const statusExistsInWorkflow = _.includes(currentCart.workflow.workflow, newWorkflowStatus);\n    const maxSteps = defaultPackageWorkflows.length;\n    let nextWorkflowStepIndex;\n    let templateProcessedinWorkflow = false;\n    let gotoNextWorkflowStep = false;\n\n    // if we haven't populated workflows lets exit\n    if (!defaultPackageWorkflows.length > 0) {\n      return [];\n    }\n\n    // loop through all shop configured layouts, and their default workflows\n    // to determine what the next workflow step should be\n    // the cart workflow status while processing is neither true nor false (set to template)\n    _.each(defaultPackageWorkflows, function (workflow, currentStatusIndex) {\n      if (workflow.template === currentWorkflowStatus) {\n        // don't go past the end of the workflow\n        if (currentStatusIndex < maxSteps - 1) {\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          nextWorkflowStepIndex = currentStatusIndex + 1;\n        } else {\n          nextWorkflowStepIndex = currentStatusIndex;\n        }\n\n        Logger.debug(\"nextWorkflowStepIndex\", nextWorkflowStepIndex);\n        // set the nextWorkflowStep as the next workflow object from registry\n        nextWorkflowStep = defaultPackageWorkflows[nextWorkflowStepIndex];\n\n        Logger.debug(\"setting nextWorkflowStep\", nextWorkflowStep.template);\n      }\n    });\n\n    // check to see if the next step has already been processed.\n    // templateProcessedinWorkflow boolean\n    gotoNextWorkflowStep = nextWorkflowStep.template;\n    templateProcessedinWorkflow = _.includes(currentCart.workflow.workflow,\n      nextWorkflowStep.template);\n\n    // debug info\n    Logger.debug(\"currentWorkflowStatus: \", currentWorkflowStatus);\n    Logger.debug(\"workflow/pushCartWorkflow workflow: \", workflow);\n    Logger.debug(\"newWorkflowStatus: \", newWorkflowStatus);\n    Logger.debug(\"current cartId: \", currentCart._id);\n    Logger.debug(\"currentWorkflow: \", currentCart.workflow.workflow);\n    Logger.debug(\"nextWorkflowStep: \", nextWorkflowStep.template || defaultPackageWorkflows[0].template);\n    Logger.debug(\"statusExistsInWorkflow: \", statusExistsInWorkflow);\n    Logger.debug(\"templateProcessedinWorkflow: \", templateProcessedinWorkflow);\n    Logger.debug(\"gotoNextWorkflowStep: \", gotoNextWorkflowStep);\n\n    // Condition One\n    // if you're going to join the workflow you need a status that is a template name.\n    // this status/template is how we know\n    // where you are in the flow and configures `gotoNextWorkflowStep`\n\n    if (!gotoNextWorkflowStep && currentWorkflowStatus !== newWorkflowStatus) {\n      Logger.debug(\n        `######## Condition One #########: initialise the ${currentCart._id} ${workflow}: ${defaultPackageWorkflows[0].template}`\n      );\n      const result = Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": defaultPackageWorkflows[0].template\n        }\n      });\n      Logger.debug(result);\n      return result;\n    }\n\n    // Condition Two\n    // your're now accepted into the workflow,\n    // but to begin the workflow you need to have a next step\n    // and you should have already be in the current workflow template\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === false &&\n      templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Two #########: set status to: \",\n        nextWorkflowStep.template);\n\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    }\n\n    // Condition Three\n    // If you got here by skipping around willy nilly\n    // we're going to do our best to ignore you.\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true &&\n      templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Three #########: complete workflow \" +\n        currentWorkflowStatus + \" updates and move to: \",\n        nextWorkflowStep.template);\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    }\n\n    // Condition Four\n    // you got here through hard work, and processed the previous template\n    // nice job. now start over with the next step.\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true &&\n      templateProcessedinWorkflow === true) {\n      Logger.debug(\n        \"######## Condition Four #########: previously ran, doing nothing. : \",\n        newWorkflowStatus);\n      return true;\n    }\n  },\n\n  /**\n   * workflow/revertCartWorkflow\n   * @description if something was changed on the previous `cartWorkflow` steps\n   * we need to revert to this step to renew the order\n   * @param {String} newWorkflowStatus - name of `cartWorkflow` step, which\n   * we need to revert\n   * @todo need tests\n   * @return {Number|Boolean} cart update results\n   */\n  \"workflow/revertCartWorkflow\": function (newWorkflowStatus) {\n    check(newWorkflowStatus, String);\n    this.unblock();\n\n    const cart = Cart.findOne({\n      userId: this.userId\n    });\n\n    if (!cart || typeof cart.workflow !== \"object\") return false;\n    if (typeof cart.workflow.workflow !== \"object\") return false;\n\n    const { workflow } = cart.workflow;\n    // get index of `newWorkflowStatus`\n    const resetToIndex = workflow.indexOf(newWorkflowStatus);\n    // exit if no such step in workflow\n    if (!~resetToIndex) return false;\n    // remove all steps that further `newWorkflowStatus` and itself\n    const resetedWorkflow = workflow.slice(0, resetToIndex);\n\n    return Cart.update(cart._id, {\n      $set: {\n        \"workflow.status\": newWorkflowStatus,\n        \"workflow.workflow\": resetedWorkflow\n      }\n    });\n  },\n\n  /**\n   * workflow/pushOrderWorkflow\n   * Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   *\n   * Step 1 meteor call to push a new workflow\n   * Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", this);\n   * NOTE: \"coreOrderWorkflow\", \"processing\" will be combined into \"coreOrderWorkflow/processing\"\n   * and set as the status\n   *\n   * Step 2 (this method) of the \"workflow/pushOrderWorkflow\" flow; Try to update the current status\n   *\n   * @summary Update the order workflow\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pushOrderWorkflow\": function (workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Object); // TODO: Validatate as Schemas.Order\n    this.unblock();\n\n    const workflowStatus = `${workflow}/${status}`;\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        // Combine (workflow) \"coreOrderWorkflow\", (status) \"processing\" into \"coreOrderWorkflow/processing\".\n        // This comoniation will be used to call the method \"workflow/coreOrderWorkflow/processing\", if it exists.\n        \"workflow.status\": `${workflow}/${status}`\n      },\n      $addToSet: {\n        \"workflow.workflow\": workflowStatus\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * workflow/pullOrderWorkflow\n   * Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   * @summary Pull a previous order status\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pullOrderWorkflow\": function (workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Object);\n    this.unblock();\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        \"workflow.status\": status\n      },\n      $pull: {\n        \"workflow.workflow\": order.workflow.status\n      }\n    });\n\n    return result;\n  },\n\n  \"workflow/pushItemWorkflow\": function (status, order, itemIds) {\n    check(status, String);\n    check(order, Object);\n    check(itemIds, Array);\n\n    const items = order.items.map((item) => {\n      // Add the current status to completed workflows\n      if (item.workflow.status !== \"new\") {\n        const workflows = item.workflow.workflow || [];\n\n        workflows.push(status);\n        item.workflow.workflow = _.uniq(workflows);\n      }\n\n      // Set the new item status\n      item.workflow.status = status;\n      return item;\n    });\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        items: items\n      }\n    });\n\n    return result;\n  }\n});\n"]},"hash":"f9b69a6eb5aef1b68aaf98595186c042104b6c5f"}
