{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"nodemailer","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"nodemailer"}]},{"source":"/lib/collections","imported":["Emails","Jobs"],"specifiers":[{"kind":"named","imported":"Emails","local":"Emails"},{"kind":"named","imported":"Jobs","local":"Jobs"}]},{"source":"/server/api","imported":["Reaction","Logger"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"},{"kind":"named","imported":"Logger","local":"Logger"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/jobs/email.js","filenameRelative":"/server/jobs/email.js","inputSourceMap":{"version":3,"sources":["/server/jobs/email.js"],"names":["nodemailer","Emails","Jobs","Reaction","Logger","sendEmail","processJobs","pollInterval","workTimeout","payload","jobs","callback","forEach","job","from","to","subject","html","data","msg","error","fail","fatal","jobId","_doc","_id","update","$set","status","upsert","Email","getMailUrl","config","getMailConfig","debug","transport","createTransport","sendMail","Meteor","bindEnvironment","toString","done","find","type","observe","added","trigger"],"mappings":"AAAA;AAAA,OAAuB,WAAvB;;;;;;;;;;;;;;;;;;;;;;;;GACA,AAAS,AAAQ,AAAY,AAC7B,AAAS,AAAU,AAAc,AAEjC,AAAe,AAAY,AACzB;OALK;AAWL,AAAM,AAAY,AAAK,AAAY,AAAa,AAC9C,AAAc,AAAI,AAAK,AAAM;;;;;;AAChB,kBAAI,IAAJ,AAAS,KAFwB;AAElB;;AAC5B;aAHgB,AAA8B,AAGrC;AADT,KAEC,UAAA,AAAC,MAAD,AAAO,UAAa,AACrB;SAAA,AAAK,QAAS,UAAD,AAAS;AACpB,AAAM,0BAAA,AAAE,AAAM;;;;;;UAAR,mCAAY;YAAZ,MAAqB;iCAArB;AAA8B,AAAI;;SAAxC;AAEA,AAAI,AAAC,AAAQ,AAAC,AAAM,AAAC,AAAW,AAAC,AAAM,AACrC;;UAAM,QAAM,SAAZ,AACA,AAAO,AAAO,AAAS,AAAI,AAC3B;aAAO,AAAI;AAAJ,AAAS,AAAK;;;AAArB,AACD;;AAED;AAAA,AAAM,AAAQ,AAAI,AAAK,AAEvB;AAAO,kBAAP,AAAc,AAAE;AALP,AAAc,AAAS;AAAP;AAMjB,gBAAA,AACJ,AACA,AACA;AAJqB,AACvB;;WAAM,6BAIJ;AAJI;;;;oBADR,AAAyB,AAQtB,AACD,AAAQ;AARF,AAKI;AAAR;;qBAMJ;AAAI,AAAC,mBAAS,KAAd,AAAK,AAAe,AAAc,AAChC;AAAA,AAAO,AAAO,AAAE;;AAAhB,AAAyB,kCACvB;aAAM,cAAA,AACJ,AAAQ;iDAFZ,AAAyB,AAKzB;AAAM,gBAAM;;;AAAZ;;iDACA;YAAO,OAAP,AAAa,AACb;AAAO,iBAAA,AAAI;AAAX,AAAO;AAAS;;sBAGlB,AAAM,AAAS,AAAS,AAAM,AAC9B,AAAO,AAAM,AAAQ,AAErB;;AALC;AAKK,uBAAY,OAAlB,AAAkB,AAAW,AAAgB,AAE7C;AAAU,qBAAV,AAAmB,WAAE;AAAF,AAAQ;;AAAR;;;AAAA;oBAAnB,AAAmB,AAA6B,AAAO,AAAgB,AAAC,AAAU,AAChF,AAAI,AAAO,AACT;AAFoC;AAAT;eAE3B,AAAO,AAAO,sCAAE;mBAAF;AAAd,AAAyB,AACvB,AAAM,AACJ;aADI,AACI;AAFZ,AAAyB,AAKzB;WAAA,AAAO,AAAM,AAAO,AACpB;AAAA,AAAO,AAAI,AAAK,AAAM,AACvB,MACD;AAAA,AAAO,AAAO,AAAE;;;AAAhB,UAAyB,AACvB;YAAM,AACJ;AAFU;uBAAW;AAAzB,gBAKA;AAAA,AAAO,AAAO,AAA6B,AAAG,AAC9C,AAAO,AAAI,AACZ;AANS,AACI;AA/DO,AAOzB,AAAkB,AAKhB,AAuCE,AAAgD,AAmBhD,AAAO,AACR,AAED,AAAO,AACR,AAED,AACA,AACA,AAAK,AAAK,AACR,AAAM,AACN,AAAQ,AACP,AAAQ,AACT,AAAQ,AACN,AAAU,AACX,AAEJ","file":"/server/jobs/email.js.map","sourcesContent":["import nodemailer from \"nodemailer\";\nimport { Emails, Jobs } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\n\nexport default function () {\n  /**\n   * Send Email job\n   *\n   * Example usage:\n   * new Job(Jobs, \"sendEmail\", { from, to, subject, html }).save();\n   */\n  const sendEmail = Jobs.processJobs(\"sendEmail\", {\n    pollInterval: 5 * 60 * 1000, // poll every 5 mins as a backup - see the realtime observer below\n    workTimeout: 2 * 60 * 1000, // fail if it takes longer than 2mins\n    payload: 20\n  }, (jobs, callback) => {\n    jobs.forEach((job) => {\n      const { from, to, subject, html } = job.data;\n\n      if (!from || !to || !subject || !html) {\n        const msg = \"Email job requires an options object with to/from/subject/html.\";\n        Logger.error(`[Job]: ${msg}`);\n        return job.fail(msg, { fatal: true });\n      }\n\n      const jobId = job._doc._id;\n\n      Emails.update({ jobId }, {\n        $set: {\n          from,\n          to,\n          subject,\n          html,\n          status: \"processing\"\n        }\n      }, {\n        upsert: true\n      });\n\n      if (!Reaction.Email.getMailUrl()) {\n        Emails.update({ jobId }, {\n          $set: {\n            status: \"failed\"\n          }\n        });\n        const msg = \"Mail not configured\";\n        Logger.error(msg);\n        return job.fail(msg);\n      }\n\n      const config = Reaction.Email.getMailConfig();\n      Logger.debug(config, \"Sending email with config\");\n\n      const transport = nodemailer.createTransport(config);\n\n      transport.sendMail({ from, to, subject, html }, Meteor.bindEnvironment((error) => {\n        if (error) {\n          Emails.update({ jobId }, {\n            $set: {\n              status: \"failed\"\n            }\n          });\n          Logger.error(error, \"Email job failed\");\n          return job.fail(error.toString());\n        }\n        Emails.update({ jobId }, {\n          $set: {\n            status: \"completed\"\n          }\n        });\n        Logger.debug(`Successfully sent email to ${to}`);\n        return job.done();\n      }));\n\n      return true;\n    });\n\n    return callback();\n  });\n\n  // Job Collection Observer\n  // This processes an email sending job as soon as it's submitted\n  Jobs.find({\n    type: \"sendEmail\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      sendEmail.trigger();\n    }\n  });\n}\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/jobs/email.js.map","sourceFileName":"/server/jobs/email.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"email"},"ignored":false,"code":"var nodemailer = void 0;\nmodule.importSync(\"nodemailer\", {\n  \"default\": function (v) {\n    nodemailer = v;\n  }\n}, 0);\nvar Emails = void 0,\n    Jobs = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Emails: function (v) {\n    Emails = v;\n  },\n  Jobs: function (v) {\n    Jobs = v;\n  }\n}, 1);\nvar Reaction = void 0,\n    Logger = void 0;\nmodule.importSync(\"/server/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  },\n  Logger: function (v) {\n    Logger = v;\n  }\n}, 2);\nmodule.export(\"default\", exports.default = function () {\n  /**\n   * Send Email job\n   *\n   * Example usage:\n   * new Job(Jobs, \"sendEmail\", { from, to, subject, html }).save();\n   */var sendEmail = Jobs.processJobs(\"sendEmail\", {\n    pollInterval: 5 * 60 * 1000,\n    // poll every 5 mins as a backup - see the realtime observer below\n    workTimeout: 2 * 60 * 1000,\n    // fail if it takes longer than 2mins\n    payload: 20\n  }, function (jobs, callback) {\n    jobs.forEach(function (job) {\n      var _job$data = job.data,\n          from = _job$data.from,\n          to = _job$data.to,\n          subject = _job$data.subject,\n          html = _job$data.html;\n\n      if (!from || !to || !subject || !html) {\n        var msg = \"Email job requires an options object with to/from/subject/html.\";\n        Logger.error(\"[Job]: \" + msg);\n        return job.fail(msg, {\n          fatal: true\n        });\n      }\n\n      var jobId = job._doc._id;\n      Emails.update({\n        jobId: jobId\n      }, {\n        $set: {\n          from: from,\n          to: to,\n          subject: subject,\n          html: html,\n          status: \"processing\"\n        }\n      }, {\n        upsert: true\n      });\n\n      if (!Reaction.Email.getMailUrl()) {\n        Emails.update({\n          jobId: jobId\n        }, {\n          $set: {\n            status: \"failed\"\n          }\n        });\n        var _msg = \"Mail not configured\";\n        Logger.error(_msg);\n        return job.fail(_msg);\n      }\n\n      var config = Reaction.Email.getMailConfig();\n      Logger.debug(config, \"Sending email with config\");\n      var transport = nodemailer.createTransport(config);\n      transport.sendMail({\n        from: from,\n        to: to,\n        subject: subject,\n        html: html\n      }, Meteor.bindEnvironment(function (error) {\n        if (error) {\n          Emails.update({\n            jobId: jobId\n          }, {\n            $set: {\n              status: \"failed\"\n            }\n          });\n          Logger.error(error, \"Email job failed\");\n          return job.fail(error.toString());\n        }\n\n        Emails.update({\n          jobId: jobId\n        }, {\n          $set: {\n            status: \"completed\"\n          }\n        });\n        Logger.debug(\"Successfully sent email to \" + to);\n        return job.done();\n      }));\n      return true;\n    });\n    return callback();\n  }); // Job Collection Observer\n  // This processes an email sending job as soon as it's submitted\n\n  Jobs.find({\n    type: \"sendEmail\",\n    status: \"ready\"\n  }).observe({\n    added: function () {\n      sendEmail.trigger();\n    }\n  });\n});","map":{"version":3,"sources":["/server/jobs/email.js"],"names":["nodemailer","Emails","Jobs","Reaction","Logger","sendEmail","processJobs","pollInterval","workTimeout","payload","jobs","callback","forEach","job","from","to","subject","html","data","msg","error","fail","fatal","jobId","_doc","_id","update","$set","status","upsert","Email","getMailUrl","config","getMailConfig","debug","transport","createTransport","sendMail","Meteor","bindEnvironment","toString","done","find","type","observe","added","trigger"],"mappings":"AAAA;AAAA,OAAuB,WAAvB;;;;;;;;;;;;;;;;;;;;;;;;GACA,AAAS,AAAQ,AAAY,AAC7B,AAAS,AAAU,AAAc,AAEjC,AAAe,AAAY,AACzB;OALK;AAWL,AAAM,AAAY,AAAK,AAAY,AAAa,AAC9C,AAAc,AAAI,AAAK,AAAM;;;;;;AAChB,kBAAI,IAAJ,AAAS,KAFwB;AAElB;;AAC5B;aAHgB,AAA8B,AAGrC;AADT,KAEC,UAAA,AAAC,MAAD,AAAO,UAAa,AACrB;SAAA,AAAK,QAAS,UAAD,AAAS;AACpB,AAAM,0BAAA,AAAE,AAAM;;;;;;UAAR,mCAAY;YAAZ,MAAqB;iCAArB;AAA8B,AAAI;;SAAxC;AAEA,AAAI,AAAC,AAAQ,AAAC,AAAM,AAAC,AAAW,AAAC,AAAM,AACrC;;UAAM,QAAM,SAAZ,AACA,AAAO,AAAO,AAAS,AAAI,AAC3B;aAAO,AAAI;AAAJ,AAAS,AAAK;;;AAArB,AACD;;AAED;AAAA,AAAM,AAAQ,AAAI,AAAK,AAEvB;AAAO,kBAAP,AAAc,AAAE;AALP,AAAc,AAAS;AAAP;AAMjB,gBAAA,AACJ,AACA,AACA;AAJqB,AACvB;;WAAM,6BAIJ;AAJI;;;;oBADR,AAAyB,AAQtB,AACD,AAAQ;AARF,AAKI;AAAR;;qBAMJ;AAAI,AAAC,mBAAS,KAAd,AAAK,AAAe,AAAc,AAChC;AAAA,AAAO,AAAO,AAAE;;AAAhB,AAAyB,kCACvB;aAAM,cAAA,AACJ,AAAQ;iDAFZ,AAAyB,AAKzB;AAAM,gBAAM;;;AAAZ;;iDACA;YAAO,OAAP,AAAa,AACb;AAAO,iBAAA,AAAI;AAAX,AAAO;AAAS;;sBAGlB,AAAM,AAAS,AAAS,AAAM,AAC9B,AAAO,AAAM,AAAQ,AAErB;;AALC;AAKK,uBAAY,OAAlB,AAAkB,AAAW,AAAgB,AAE7C;AAAU,qBAAV,AAAmB,WAAE;AAAF,AAAQ;;AAAR;;;AAAA;oBAAnB,AAAmB,AAA6B,AAAO,AAAgB,AAAC,AAAU,AAChF,AAAI,AAAO,AACT;AAFoC;AAAT;eAE3B,AAAO,AAAO,sCAAE;mBAAF;AAAd,AAAyB,AACvB,AAAM,AACJ;aADI,AACI;AAFZ,AAAyB,AAKzB;WAAA,AAAO,AAAM,AAAO,AACpB;AAAA,AAAO,AAAI,AAAK,AAAM,AACvB,MACD;AAAA,AAAO,AAAO,AAAE;;;AAAhB,UAAyB,AACvB;YAAM,AACJ;AAFU;uBAAW;AAAzB,gBAKA;AAAA,AAAO,AAAO,AAA6B,AAAG,AAC9C,AAAO,AAAI,AACZ;AANS,AACI;AA/DO,AAOzB,AAAkB,AAKhB,AAuCE,AAAgD,AAmBhD,AAAO,AACR,AAED,AAAO,AACR,AAED,AACA,AACA,AAAK,AAAK,AACR,AAAM,AACN,AAAQ,AACP,AAAQ,AACT,AAAQ,AACN,AAAU,AACX,AAEJ","file":"/server/jobs/email.js.map","sourcesContent":["import nodemailer from \"nodemailer\";\nimport { Emails, Jobs } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\n\nexport default function () {\n  /**\n   * Send Email job\n   *\n   * Example usage:\n   * new Job(Jobs, \"sendEmail\", { from, to, subject, html }).save();\n   */\n  const sendEmail = Jobs.processJobs(\"sendEmail\", {\n    pollInterval: 5 * 60 * 1000, // poll every 5 mins as a backup - see the realtime observer below\n    workTimeout: 2 * 60 * 1000, // fail if it takes longer than 2mins\n    payload: 20\n  }, (jobs, callback) => {\n    jobs.forEach((job) => {\n      const { from, to, subject, html } = job.data;\n\n      if (!from || !to || !subject || !html) {\n        const msg = \"Email job requires an options object with to/from/subject/html.\";\n        Logger.error(`[Job]: ${msg}`);\n        return job.fail(msg, { fatal: true });\n      }\n\n      const jobId = job._doc._id;\n\n      Emails.update({ jobId }, {\n        $set: {\n          from,\n          to,\n          subject,\n          html,\n          status: \"processing\"\n        }\n      }, {\n        upsert: true\n      });\n\n      if (!Reaction.Email.getMailUrl()) {\n        Emails.update({ jobId }, {\n          $set: {\n            status: \"failed\"\n          }\n        });\n        const msg = \"Mail not configured\";\n        Logger.error(msg);\n        return job.fail(msg);\n      }\n\n      const config = Reaction.Email.getMailConfig();\n      Logger.debug(config, \"Sending email with config\");\n\n      const transport = nodemailer.createTransport(config);\n\n      transport.sendMail({ from, to, subject, html }, Meteor.bindEnvironment((error) => {\n        if (error) {\n          Emails.update({ jobId }, {\n            $set: {\n              status: \"failed\"\n            }\n          });\n          Logger.error(error, \"Email job failed\");\n          return job.fail(error.toString());\n        }\n        Emails.update({ jobId }, {\n          $set: {\n            status: \"completed\"\n          }\n        });\n        Logger.debug(`Successfully sent email to ${to}`);\n        return job.done();\n      }));\n\n      return true;\n    });\n\n    return callback();\n  });\n\n  // Job Collection Observer\n  // This processes an email sending job as soon as it's submitted\n  Jobs.find({\n    type: \"sendEmail\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      sendEmail.trigger();\n    }\n  });\n}\n"]},"hash":"67f8f84e41826c93248e42e652030de7572df503"}
