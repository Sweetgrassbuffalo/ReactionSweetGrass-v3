{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"lodash/uniqWith","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_uniqWith"}]},{"source":"lodash/merge","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_merge"}]},{"source":"url","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"url"}]},{"source":"/package.json","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"packageJson"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/ejson","imported":["EJSON"],"specifiers":[{"kind":"named","imported":"EJSON","local":"EJSON"}]},{"source":"/lib/collections","imported":["Jobs","Packages","Shops"],"specifiers":[{"kind":"named","imported":"Jobs","local":"Jobs"},{"kind":"named","imported":"Packages","local":"Packages"},{"kind":"named","imported":"Shops","local":"Shops"}]},{"source":"/server/api","imported":["Hooks","Logger"],"specifiers":[{"kind":"named","imported":"Hooks","local":"Hooks"},{"kind":"named","imported":"Logger","local":"Logger"}]},{"source":"/server/jobs","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"ProcessJobs"}]},{"source":"./setDomain","imported":["getRegistryDomain"],"specifiers":[{"kind":"named","imported":"getRegistryDomain","local":"getRegistryDomain"}]},{"source":"./templates","imported":["registerTemplate"],"specifiers":[{"kind":"named","imported":"registerTemplate","local":"registerTemplate"}]},{"source":"./accounts","imported":["sendVerificationEmail"],"specifiers":[{"kind":"named","imported":"sendVerificationEmail","local":"sendVerificationEmail"}]},{"source":"./email/config","imported":["getMailUrl"],"specifiers":[{"kind":"named","imported":"getMailUrl","local":"getMailUrl"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/api/core/core.js","filenameRelative":"/server/api/core/core.js","inputSourceMap":{"version":3,"sources":["/server/api/core/core.js"],"names":["url","packageJson","Meteor","EJSON","Jobs","Packages","Shops","Hooks","Logger","ProcessJobs","getRegistryDomain","registerTemplate","sendVerificationEmail","getMailUrl","init","getShopId","warn","_sleepForMs","Events","run","startJobServer","info","process","env","VERBOSE_JOBS","setLogStream","stdout","loadPackages","Import","flush","isAppTest","createDefaultAdminUser","setAppVersion","debug","registerPackage","packageInfo","registeredPackage","name","hasPermission","checkPermissions","userId","checkGroup","permissions","undefined","group","Roles","GLOBAL_GROUP","push","_","uniq","userIsInRole","sellerShopPermissions","getGroupsForUser","key","shop","hasOwnerAccess","hasAdminAccess","hasDashboardAccess","getSellerShopId","configureMailUrl","getCurrentShopCursor","domain","getDomain","cursor","find","domains","limit","count","getCurrentShop","currentShopCursor","fetch","fields","_id","parse","absoluteUrl","hostname","getShopName","getShopPrefix","getSlug","toLowerCase","getShopEmail","emails","address","getShopSettings","settings","findOne","shopId","getShopCurrency","currency","getShopLanguage","language","getPackageSettings","packageName","getAppVersion","appVersion","defaultAdminRoles","options","configureEnv","accountId","getUsersInRole","REACTION_EMAIL","REACTION_USER","REACTION_AUTH","email","Random","id","username","password","secret","reaction","update","$addToSet","verified","ROOT_URL","users","Accounts","createUser","NODE_ENV","$set","setUserRoles","packages","pkg","assignOwnerRoles","registry","user","registryFixtureData","REACTION_REGISTRY","Assets","getText","error","validatedJson","Array","isArray","layouts","each","config","pkgName","forEach","settingsFromPackage","icon","enabled","autoEnable","layout","settingsFromFixture","packageSetting","settingsFromDB","ps","combinedSettings","package","uniqLayouts","isEqual","has","remove","version","multi"],"mappings":"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","file":"/server/api/core/core.js.map","sourcesContent":["import url from \"url\";\nimport packageJson from \"/package.json\";\nimport { merge, uniqWith } from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { EJSON } from \"meteor/ejson\";\nimport { Jobs, Packages, Shops } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\nimport ProcessJobs from \"/server/jobs\";\nimport { getRegistryDomain } from \"./setDomain\";\nimport { registerTemplate } from \"./templates\";\nimport { sendVerificationEmail } from \"./accounts\";\nimport { getMailUrl } from \"./email/config\";\n\n\nexport default {\n\n  init() {\n    // make sure the default shop has been created before going further\n    while (!this.getShopId()) {\n      Logger.warn(\"No shopId, waiting one second...\");\n      Meteor._sleepForMs(1000);\n    }\n\n    // run onCoreInit hooks\n    Hooks.Events.run(\"onCoreInit\");\n\n    // start job server\n    Jobs.startJobServer(() => {\n      Logger.info(\"JobServer started\");\n      ProcessJobs();\n      Hooks.Events.run(\"onJobServerStart\");\n    });\n    if (process.env.VERBOSE_JOBS) {\n      Jobs.setLogStream(process.stdout);\n    }\n\n    this.loadPackages();\n    // process imports from packages and any hooked imports\n    this.Import.flush();\n    // timing is important, packages are rqd for initial permissions configuration.\n    if (!Meteor.isAppTest) {\n      this.createDefaultAdminUser();\n    }\n    this.setAppVersion();\n    // hook after init finished\n    Hooks.Events.run(\"afterCoreInit\");\n\n    Logger.debug(\"Reaction.init() has run\");\n\n    return true;\n  },\n\n  Packages: {},\n\n  registerPackage(packageInfo) {\n    const registeredPackage = this.Packages[packageInfo.name] = packageInfo;\n    return registeredPackage;\n  },\n\n  /**\n   * registerTemplate\n   * registers Templates into the Tempaltes Collection\n   * @return {function} Registers template\n   */\n  registerTemplate: registerTemplate,\n\n  /**\n   * hasPermission - server\n   * server permissions checks\n   * hasPermission exists on both the server and the client.\n   * @param {String | Array} checkPermissions -String or Array of permissions if empty, defaults to \"admin, owner\"\n   * @param {String} userId - userId, defaults to Meteor.userId()\n   * @param {String} checkGroup group - default to shopId\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasPermission(checkPermissions, userId = Meteor.userId(), checkGroup = this.getShopId()) {\n    // check(checkPermissions, Match.OneOf(String, Array)); check(userId, String); check(checkGroup,\n    // Match.Optional(String));\n\n    let permissions;\n    // default group to the shop or global if shop isn't defined for some reason.\n    if (checkGroup !== undefined && typeof checkGroup === \"string\") {\n      group = checkGroup;\n    } else {\n      group = this.getShopId() || Roles.GLOBAL_GROUP;\n    }\n\n    // permissions can be either a string or an array we'll force it into an array and use that\n    if (checkPermissions === undefined) {\n      permissions = [\"owner\"];\n    } else if (typeof checkPermissions === \"string\") {\n      permissions = [checkPermissions];\n    } else {\n      permissions = checkPermissions;\n    }\n\n    // if the user has admin, owner permissions we'll always check if those roles are enough\n    permissions.push(\"owner\");\n    permissions = _.uniq(permissions);\n\n    // return if user has permissions in the group\n    if (Roles.userIsInRole(userId, permissions, group)) {\n      return true;\n    }\n\n    // global roles check\n    const sellerShopPermissions = Roles.getGroupsForUser(userId, \"admin\");\n\n    // we're looking for seller permissions.\n    if (sellerShopPermissions) {\n      // loop through shops roles and check permissions\n      for (const key in sellerShopPermissions) {\n        if (key) {\n          const shop = sellerShopPermissions[key];\n          if (Roles.userIsInRole(userId, permissions, shop)) {\n            return true;\n          }\n        }\n      }\n    }\n    // no specific permissions found returning false\n    return false;\n  },\n\n  hasOwnerAccess() {\n    return this.hasPermission([\"owner\"]);\n  },\n\n  hasAdminAccess() {\n    return this.hasPermission([\"owner\", \"admin\"]);\n  },\n\n  hasDashboardAccess() {\n    return this.hasPermission([\"owner\", \"admin\", \"dashboard\"]);\n  },\n\n  getSellerShopId() {\n    return Roles.getGroupsForUser(this.userId, \"admin\");\n  },\n\n  configureMailUrl() {\n    // maintained for legacy support\n    Logger.warn(\"Reaction.configureMailUrl() is deprecated. Please use Reaction.Email.getMailUrl() instead\");\n    return getMailUrl();\n  },\n\n  getCurrentShopCursor() {\n    const domain = this.getDomain();\n    const cursor = Shops.find({\n      domains: domain\n    }, { limit: 1 });\n    if (!cursor.count()) {\n      Logger.debug(domain, \"Add a domain entry to shops for \");\n    }\n    return cursor;\n  },\n\n  getCurrentShop() {\n    const currentShopCursor = this.getCurrentShopCursor();\n    // also, we could check in such a way: `currentShopCursor instanceof Object` but not instanceof something.Cursor\n    if (typeof currentShopCursor === \"object\") {\n      return currentShopCursor.fetch()[0];\n    }\n    return null;\n  },\n\n  getShopId() {\n    const domain = this.getDomain();\n    const shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        _id: 1\n      }\n    }).fetch()[0];\n    return shop && shop._id;\n  },\n\n  getDomain() {\n    return url.parse(Meteor.absoluteUrl()).hostname;\n  },\n\n  getShopName() {\n    const domain = this.getDomain();\n    const shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        name: 1\n      }\n    }).fetch()[0];\n    return shop && shop.name;\n  },\n\n  getShopPrefix() {\n    return \"/\" + this.getSlug(this.getShopName().toLowerCase());\n  },\n\n  getShopEmail() {\n    const shop = Shops.find({\n      _id: this.getShopId()\n    }, {\n      limit: 1,\n      fields: {\n        emails: 1\n      }\n    }).fetch()[0];\n    return shop && shop.emails && shop.emails[0].address;\n  },\n\n  getShopSettings(name = \"core\") {\n    const settings = Packages.findOne({ name: name, shopId: this.getShopId() }) || {};\n    return settings.settings || {};\n  },\n\n  getShopCurrency() {\n    const shop = Shops.findOne({\n      _id: this.getShopId()\n    });\n\n    return shop && shop.currency || \"USD\";\n  },\n\n  getShopLanguage() {\n    const { language } = Shops.findOne({\n      _id: this.getShopId()\n    }, {\n      fields: {\n        language: 1\n      } }\n    );\n    return language;\n  },\n\n  getPackageSettings(name) {\n    return Packages.findOne({ packageName: name, shopId: this.getShopId() }) || null;\n  },\n\n  getAppVersion() {\n    return Shops.findOne().appVersion;\n  },\n\n  /**\n   * createDefaultAdminUser\n   * @summary Method that creates default admin user\n   * Settings load precendence:\n   *  1. settings in meteor.settings\n   *  2. environment variables\n   * @returns {String} return userId\n   */\n  createDefaultAdminUser() {\n    const domain = getRegistryDomain();\n    const env = process.env;\n    const defaultAdminRoles = [\"owner\", \"admin\", \"guest\", \"account/profile\"];\n    let options = {};\n    let configureEnv = false;\n    let accountId;\n\n    const shopId = this.getShopId();\n\n    // if an admin user has already been created, we'll exit\n    if (Roles.getUsersInRole(\"owner\", shopId).count() !== 0) {\n      Logger.debug(\"Not creating default admin user, already exists\");\n      return \"\"; // this default admin has already been created for this shop.\n    }\n\n    // run hooks on options object before creating user (the options object must be returned from all callbacks)\n    options = Hooks.Events.run(\"beforeCreateDefaultAdminUser\", options);\n\n    //\n    // process Meteor settings and env variables for initial user config if ENV variables are set, these always override\n    // \"settings.json\" this is to allow for testing environments. where we don't want to use users configured in a settings\n    // file.\n    //\n    if (env.REACTION_EMAIL && env.REACTION_USER && env.REACTION_AUTH) {\n      configureEnv = true;\n    }\n\n    // defaults use either env or generated\n    options.email = env.REACTION_EMAIL || Random.id(8).toLowerCase() + \"@\" + domain;\n    options.username = env.REACTION_USER || \"Admin\"; // username\n    options.password = env.REACTION_AUTH || Random.secret(8);\n\n    // but we can override with provided `meteor --settings`\n    if (Meteor.settings && !configureEnv) {\n      if (Meteor.settings.reaction) {\n        options.username = Meteor.settings.reaction.REACTION_USER || \"Admin\";\n        options.password = Meteor.settings.reaction.REACTION_AUTH || Random.secret(8);\n        options.email = Meteor.settings.reaction.REACTION_EMAIL || Random.id(8).toLowerCase() + \"@\" + domain;\n        Logger.info(\"Using meteor --settings to create admin user\");\n      }\n    }\n\n    // set the default shop email to the default admin email\n    Shops.update(shopId, {\n      $addToSet: {\n        emails: {\n          address: options.email,\n          verified: true\n        },\n        domains: Meteor.settings.ROOT_URL\n      }\n    });\n\n    //\n    // create the new admin user\n    //\n\n    // we're checking again to see if this user was created but not specifically for this shop.\n    if (Meteor.users.find({ \"emails.address\": options.email }).count() === 0) {\n      accountId = Accounts.createUser(options);\n    } else {\n      // this should only occur when existing admin creates a new shop\n      accountId = Meteor.users.findOne({ \"emails.address\": options.email })._id;\n    }\n\n    //\n    // send verification email\n    //\n\n    // we dont need to validate admin user in development\n    if (process.env.NODE_ENV === \"development\") {\n      Meteor.users.update({\n        \"_id\": accountId,\n        \"emails.address\": options.email\n      }, {\n        $set: {\n          \"emails.$.verified\": true\n        }\n      });\n    } else {\n      // send verification email to admin\n      sendVerificationEmail(accountId);\n    }\n\n    //\n    // Set Default Roles\n    //\n\n    // we don't use accounts/addUserPermissions here because we may not yet have permissions\n    Roles.setUserRoles(accountId, _.uniq(defaultAdminRoles), shopId);\n    // // the reaction owner has permissions to all sites by default\n    Roles.setUserRoles(accountId, _.uniq(defaultAdminRoles), Roles.GLOBAL_GROUP);\n    // initialize package permissions we don't need to do any further permission configuration it is taken care of in the\n    // assignOwnerRoles\n    const packages = Packages.find().fetch();\n    for (const pkg of packages) {\n      this.assignOwnerRoles(shopId, pkg.name, pkg.registry);\n    }\n\n    //\n    //  notify user that admin was created account email should print on console\n    //\n\n    Logger.warn(`\\n *********************************\n        \\n  IMPORTANT! DEFAULT ADMIN INFO\n        \\n  EMAIL/LOGIN: ${options.email}\n        \\n  PASSWORD: ${options.password}\n        \\n ********************************* \\n\\n`);\n\n    // run hooks on new user object\n    const user = Meteor.users.findOne(accountId);\n    Hooks.Events.run(\"afterCreateDefaultAdminUser\", user);\n    return accountId;\n  },\n\n  /**\n   *  loadPackages\n   *  insert Reaction packages into registry\n   *  we check to see if the number of packages have changed against current data\n   *  if there is a change, we'll either insert or upsert package registry\n   *  into the Packages collection\n   *  import is processed on hook in init()\n   *  @return {String} returns insert result\n   */\n  loadPackages() {\n    const packages = Packages.find().fetch();\n\n    let registryFixtureData;\n\n    if (process.env.REACTION_REGISTRY) {\n      // check the environment for the registry fixture data first\n      registryFixtureData = process.env.REACTION_REGISTRY;\n      Logger.info(\"Loaded REACTION_REGISTRY environment variable for registry fixture import\");\n    } else {\n      // or attempt to load reaction.json fixture data\n      try {\n        registryFixtureData = Assets.getText(\"settings/reaction.json\");\n        Logger.info(\"Loaded \\\"/private/settings/reaction.json\\\" for registry fixture import\");\n      } catch (error) {\n        Logger.warn(\"Skipped loading settings from reaction.json.\");\n        Logger.debug(error, \"loadSettings reaction.json not loaded.\");\n      }\n    }\n\n    if (!!registryFixtureData) {\n      const validatedJson = EJSON.parse(registryFixtureData);\n\n      if (!Array.isArray(validatedJson[0])) {\n        Logger.warn(\"Registry fixture data is not an array. Failed to load.\");\n      } else {\n        registryFixtureData = validatedJson;\n      }\n    }\n\n    const layouts = [];\n    // for each shop, we're loading packages in a unique registry\n    _.each(this.Packages, (config, pkgName) => {\n      return Shops.find().forEach((shop) => {\n        const shopId = shop._id;\n        if (!shopId) return [];\n\n        // existing registry will be upserted with changes, perhaps we should add:\n        this.assignOwnerRoles(shopId, pkgName, config.registry);\n\n        // Settings from the package registry.js\n        const settingsFromPackage = {\n          name: pkgName,\n          icon: config.icon,\n          enabled: !!config.autoEnable,\n          settings: config.settings,\n          registry: config.registry,\n          layout: config.layout\n        };\n\n        // Setting from a fixture file, most likely reaction.json\n        let settingsFromFixture;\n        if (registryFixtureData) {\n          settingsFromFixture = _.find(registryFixtureData[0], (packageSetting) => {\n            return config.name === packageSetting.name;\n          });\n        }\n\n        // Setting already imported into the packages collection\n        const settingsFromDB = _.find(packages, (ps) => {\n          return (config.name === ps.name && shopId === ps.shopId);\n        });\n\n        const combinedSettings = merge({}, settingsFromPackage, settingsFromFixture || {}, settingsFromDB || {});\n\n        // populate array of layouts that don't already exist in Shops\n        if (combinedSettings.layout) {\n          // filter out layout Templates\n          for (const pkg of combinedSettings.layout) {\n            if (pkg.layout) {\n              layouts.push(pkg);\n            }\n          }\n        }\n        // Import package data\n        this.Import.package(combinedSettings, shopId);\n        return Logger.debug(`Initializing ${shop.name} ${pkgName}`);\n      }); // end shops\n    });\n\n    // helper for removing layout duplicates\n    const uniqLayouts = uniqWith(layouts, _.isEqual);\n    // import layouts into Shops\n    Shops.find().forEach((shop) => {\n      this.Import.layout(uniqLayouts, shop._id);\n    });\n\n    //\n    // package cleanup\n    //\n    Shops.find().forEach((shop) => {\n      return Packages.find().forEach((pkg) => {\n        // delete registry entries for packages that have been removed\n        if (!_.has(this.Packages, pkg.name)) {\n          Logger.debug(`Removing ${pkg.name}`);\n          return Packages.remove({ shopId: shop._id, name: pkg.name });\n        }\n        return false;\n      });\n    });\n  },\n  setAppVersion() {\n    const version = packageJson.version;\n    Logger.info(`Reaction Version: ${version}`);\n    Shops.update({}, { $set: { appVersion: version } }, { multi: true });\n  }\n};\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/api/core/core.js.map","sourceFileName":"/server/api/core/core.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"core"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _uniqWith = void 0;\n\nmodule.importSync(\"lodash/uniqWith\", {\n  \"default\": function (v) {\n    _uniqWith = v;\n  }\n}, 0);\n\nvar _merge = void 0;\n\nmodule.importSync(\"lodash/merge\", {\n  \"default\": function (v) {\n    _merge = v;\n  }\n}, 1);\nvar url = void 0;\nmodule.importSync(\"url\", {\n  \"default\": function (v) {\n    url = v;\n  }\n}, 2);\nvar packageJson = void 0;\nmodule.importSync(\"/package.json\", {\n  \"default\": function (v) {\n    packageJson = v;\n  }\n}, 3);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 4);\nvar EJSON = void 0;\nmodule.importSync(\"meteor/ejson\", {\n  EJSON: function (v) {\n    EJSON = v;\n  }\n}, 5);\nvar Jobs = void 0,\n    Packages = void 0,\n    Shops = void 0;\nmodule.importSync(\"/lib/collections\", {\n  Jobs: function (v) {\n    Jobs = v;\n  },\n  Packages: function (v) {\n    Packages = v;\n  },\n  Shops: function (v) {\n    Shops = v;\n  }\n}, 6);\nvar Hooks = void 0,\n    Logger = void 0;\nmodule.importSync(\"/server/api\", {\n  Hooks: function (v) {\n    Hooks = v;\n  },\n  Logger: function (v) {\n    Logger = v;\n  }\n}, 7);\nvar ProcessJobs = void 0;\nmodule.importSync(\"/server/jobs\", {\n  \"default\": function (v) {\n    ProcessJobs = v;\n  }\n}, 8);\nvar getRegistryDomain = void 0;\nmodule.importSync(\"./setDomain\", {\n  getRegistryDomain: function (v) {\n    getRegistryDomain = v;\n  }\n}, 9);\nvar registerTemplate = void 0;\nmodule.importSync(\"./templates\", {\n  registerTemplate: function (v) {\n    registerTemplate = v;\n  }\n}, 10);\nvar sendVerificationEmail = void 0;\nmodule.importSync(\"./accounts\", {\n  sendVerificationEmail: function (v) {\n    sendVerificationEmail = v;\n  }\n}, 11);\nvar getMailUrl = void 0;\nmodule.importSync(\"./email/config\", {\n  getMailUrl: function (v) {\n    getMailUrl = v;\n  }\n}, 12);\nmodule.export(\"default\", exports.default = {\n  init: function () {\n    // make sure the default shop has been created before going further\n    while (!this.getShopId()) {\n      Logger.warn(\"No shopId, waiting one second...\");\n\n      Meteor._sleepForMs(1000);\n    } // run onCoreInit hooks\n\n\n    Hooks.Events.run(\"onCoreInit\"); // start job server\n\n    Jobs.startJobServer(function () {\n      Logger.info(\"JobServer started\");\n      ProcessJobs();\n      Hooks.Events.run(\"onJobServerStart\");\n    });\n\n    if (process.env.VERBOSE_JOBS) {\n      Jobs.setLogStream(process.stdout);\n    }\n\n    this.loadPackages(); // process imports from packages and any hooked imports\n\n    this.Import.flush(); // timing is important, packages are rqd for initial permissions configuration.\n\n    if (!Meteor.isAppTest) {\n      this.createDefaultAdminUser();\n    }\n\n    this.setAppVersion(); // hook after init finished\n\n    Hooks.Events.run(\"afterCoreInit\");\n    Logger.debug(\"Reaction.init() has run\");\n    return true;\n  },\n  Packages: {},\n  registerPackage: function (packageInfo) {\n    var registeredPackage = this.Packages[packageInfo.name] = packageInfo;\n    return registeredPackage;\n  },\n  /**\n   * registerTemplate\n   * registers Templates into the Tempaltes Collection\n   * @return {function} Registers template\n   */registerTemplate: registerTemplate,\n  /**\n   * hasPermission - server\n   * server permissions checks\n   * hasPermission exists on both the server and the client.\n   * @param {String | Array} checkPermissions -String or Array of permissions if empty, defaults to \"admin, owner\"\n   * @param {String} userId - userId, defaults to Meteor.userId()\n   * @param {String} checkGroup group - default to shopId\n   * @return {Boolean} Boolean - true if has permission\n   */hasPermission: function (checkPermissions) {\n    var userId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Meteor.userId();\n    var checkGroup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getShopId();\n    // check(checkPermissions, Match.OneOf(String, Array)); check(userId, String); check(checkGroup,\n    // Match.Optional(String));\n    var permissions = void 0; // default group to the shop or global if shop isn't defined for some reason.\n\n    if (checkGroup !== undefined && typeof checkGroup === \"string\") {\n      group = checkGroup;\n    } else {\n      group = this.getShopId() || Roles.GLOBAL_GROUP;\n    } // permissions can be either a string or an array we'll force it into an array and use that\n\n\n    if (checkPermissions === undefined) {\n      permissions = [\"owner\"];\n    } else if (typeof checkPermissions === \"string\") {\n      permissions = [checkPermissions];\n    } else {\n      permissions = checkPermissions;\n    } // if the user has admin, owner permissions we'll always check if those roles are enough\n\n\n    permissions.push(\"owner\");\n    permissions = _.uniq(permissions); // return if user has permissions in the group\n\n    if (Roles.userIsInRole(userId, permissions, group)) {\n      return true;\n    } // global roles check\n\n\n    var sellerShopPermissions = Roles.getGroupsForUser(userId, \"admin\"); // we're looking for seller permissions.\n\n    if (sellerShopPermissions) {\n      // loop through shops roles and check permissions\n      for (var key in meteorBabelHelpers.sanitizeForInObject(sellerShopPermissions)) {\n        if (key) {\n          var shop = sellerShopPermissions[key];\n\n          if (Roles.userIsInRole(userId, permissions, shop)) {\n            return true;\n          }\n        }\n      }\n    } // no specific permissions found returning false\n\n\n    return false;\n  },\n  hasOwnerAccess: function () {\n    return this.hasPermission([\"owner\"]);\n  },\n  hasAdminAccess: function () {\n    return this.hasPermission([\"owner\", \"admin\"]);\n  },\n  hasDashboardAccess: function () {\n    return this.hasPermission([\"owner\", \"admin\", \"dashboard\"]);\n  },\n  getSellerShopId: function () {\n    return Roles.getGroupsForUser(this.userId, \"admin\");\n  },\n  configureMailUrl: function () {\n    // maintained for legacy support\n    Logger.warn(\"Reaction.configureMailUrl() is deprecated. Please use Reaction.Email.getMailUrl() instead\");\n    return getMailUrl();\n  },\n  getCurrentShopCursor: function () {\n    var domain = this.getDomain();\n    var cursor = Shops.find({\n      domains: domain\n    }, {\n      limit: 1\n    });\n\n    if (!cursor.count()) {\n      Logger.debug(domain, \"Add a domain entry to shops for \");\n    }\n\n    return cursor;\n  },\n  getCurrentShop: function () {\n    var currentShopCursor = this.getCurrentShopCursor(); // also, we could check in such a way: `currentShopCursor instanceof Object` but not instanceof something.Cursor\n\n    if ((typeof currentShopCursor === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(currentShopCursor)) === \"object\") {\n      return currentShopCursor.fetch()[0];\n    }\n\n    return null;\n  },\n  getShopId: function () {\n    var domain = this.getDomain();\n    var shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        _id: 1\n      }\n    }).fetch()[0];\n    return shop && shop._id;\n  },\n  getDomain: function () {\n    return url.parse(Meteor.absoluteUrl()).hostname;\n  },\n  getShopName: function () {\n    var domain = this.getDomain();\n    var shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        name: 1\n      }\n    }).fetch()[0];\n    return shop && shop.name;\n  },\n  getShopPrefix: function () {\n    return \"/\" + this.getSlug(this.getShopName().toLowerCase());\n  },\n  getShopEmail: function () {\n    var shop = Shops.find({\n      _id: this.getShopId()\n    }, {\n      limit: 1,\n      fields: {\n        emails: 1\n      }\n    }).fetch()[0];\n    return shop && shop.emails && shop.emails[0].address;\n  },\n  getShopSettings: function () {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"core\";\n    var settings = Packages.findOne({\n      name: name,\n      shopId: this.getShopId()\n    }) || {};\n    return settings.settings || {};\n  },\n  getShopCurrency: function () {\n    var shop = Shops.findOne({\n      _id: this.getShopId()\n    });\n    return shop && shop.currency || \"USD\";\n  },\n  getShopLanguage: function () {\n    var _Shops$findOne = Shops.findOne({\n      _id: this.getShopId()\n    }, {\n      fields: {\n        language: 1\n      }\n    }),\n        language = _Shops$findOne.language;\n\n    return language;\n  },\n  getPackageSettings: function (name) {\n    return Packages.findOne({\n      packageName: name,\n      shopId: this.getShopId()\n    }) || null;\n  },\n  getAppVersion: function () {\n    return Shops.findOne().appVersion;\n  },\n  /**\n   * createDefaultAdminUser\n   * @summary Method that creates default admin user\n   * Settings load precendence:\n   *  1. settings in meteor.settings\n   *  2. environment variables\n   * @returns {String} return userId\n   */createDefaultAdminUser: function () {\n    var domain = getRegistryDomain();\n    var env = process.env;\n    var defaultAdminRoles = [\"owner\", \"admin\", \"guest\", \"account/profile\"];\n    var options = {};\n    var configureEnv = false;\n    var accountId = void 0;\n    var shopId = this.getShopId(); // if an admin user has already been created, we'll exit\n\n    if (Roles.getUsersInRole(\"owner\", shopId).count() !== 0) {\n      Logger.debug(\"Not creating default admin user, already exists\");\n      return \"\"; // this default admin has already been created for this shop.\n    } // run hooks on options object before creating user (the options object must be returned from all callbacks)\n\n\n    options = Hooks.Events.run(\"beforeCreateDefaultAdminUser\", options); //\n    // process Meteor settings and env variables for initial user config if ENV variables are set, these always override\n    // \"settings.json\" this is to allow for testing environments. where we don't want to use users configured in a settings\n    // file.\n    //\n\n    if (env.REACTION_EMAIL && env.REACTION_USER && env.REACTION_AUTH) {\n      configureEnv = true;\n    } // defaults use either env or generated\n\n\n    options.email = env.REACTION_EMAIL || Random.id(8).toLowerCase() + \"@\" + domain;\n    options.username = env.REACTION_USER || \"Admin\"; // username\n\n    options.password = env.REACTION_AUTH || Random.secret(8); // but we can override with provided `meteor --settings`\n\n    if (Meteor.settings && !configureEnv) {\n      if (Meteor.settings.reaction) {\n        options.username = Meteor.settings.reaction.REACTION_USER || \"Admin\";\n        options.password = Meteor.settings.reaction.REACTION_AUTH || Random.secret(8);\n        options.email = Meteor.settings.reaction.REACTION_EMAIL || Random.id(8).toLowerCase() + \"@\" + domain;\n        Logger.info(\"Using meteor --settings to create admin user\");\n      }\n    } // set the default shop email to the default admin email\n\n\n    Shops.update(shopId, {\n      $addToSet: {\n        emails: {\n          address: options.email,\n          verified: true\n        },\n        domains: Meteor.settings.ROOT_URL\n      }\n    }); //\n    // create the new admin user\n    //\n    // we're checking again to see if this user was created but not specifically for this shop.\n\n    if (Meteor.users.find({\n      \"emails.address\": options.email\n    }).count() === 0) {\n      accountId = Accounts.createUser(options);\n    } else {\n      // this should only occur when existing admin creates a new shop\n      accountId = Meteor.users.findOne({\n        \"emails.address\": options.email\n      })._id;\n    } //\n    // send verification email\n    //\n    // we dont need to validate admin user in development\n\n\n    if (process.env.NODE_ENV === \"development\") {\n      Meteor.users.update({\n        \"_id\": accountId,\n        \"emails.address\": options.email\n      }, {\n        $set: {\n          \"emails.$.verified\": true\n        }\n      });\n    } else {\n      // send verification email to admin\n      sendVerificationEmail(accountId);\n    } //\n    // Set Default Roles\n    //\n    // we don't use accounts/addUserPermissions here because we may not yet have permissions\n\n\n    Roles.setUserRoles(accountId, _.uniq(defaultAdminRoles), shopId); // // the reaction owner has permissions to all sites by default\n\n    Roles.setUserRoles(accountId, _.uniq(defaultAdminRoles), Roles.GLOBAL_GROUP); // initialize package permissions we don't need to do any further permission configuration it is taken care of in the\n    // assignOwnerRoles\n\n    var packages = Packages.find().fetch();\n\n    for (var _iterator = packages, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var pkg = _ref;\n      this.assignOwnerRoles(shopId, pkg.name, pkg.registry);\n    } //\n    //  notify user that admin was created account email should print on console\n    //\n\n\n    Logger.warn(\"\\n *********************************\\n        \\n  IMPORTANT! DEFAULT ADMIN INFO\\n        \\n  EMAIL/LOGIN: \" + options.email + \"\\n        \\n  PASSWORD: \" + options.password + \"\\n        \\n ********************************* \\n\\n\"); // run hooks on new user object\n\n    var user = Meteor.users.findOne(accountId);\n    Hooks.Events.run(\"afterCreateDefaultAdminUser\", user);\n    return accountId;\n  },\n  /**\n   *  loadPackages\n   *  insert Reaction packages into registry\n   *  we check to see if the number of packages have changed against current data\n   *  if there is a change, we'll either insert or upsert package registry\n   *  into the Packages collection\n   *  import is processed on hook in init()\n   *  @return {String} returns insert result\n   */loadPackages: function () {\n    var _this = this;\n\n    var packages = Packages.find().fetch();\n    var registryFixtureData = void 0;\n\n    if (process.env.REACTION_REGISTRY) {\n      // check the environment for the registry fixture data first\n      registryFixtureData = process.env.REACTION_REGISTRY;\n      Logger.info(\"Loaded REACTION_REGISTRY environment variable for registry fixture import\");\n    } else {\n      // or attempt to load reaction.json fixture data\n      try {\n        registryFixtureData = Assets.getText(\"settings/reaction.json\");\n        Logger.info(\"Loaded \\\"/private/settings/reaction.json\\\" for registry fixture import\");\n      } catch (error) {\n        Logger.warn(\"Skipped loading settings from reaction.json.\");\n        Logger.debug(error, \"loadSettings reaction.json not loaded.\");\n      }\n    }\n\n    if (!!registryFixtureData) {\n      var validatedJson = EJSON.parse(registryFixtureData);\n\n      if (!Array.isArray(validatedJson[0])) {\n        Logger.warn(\"Registry fixture data is not an array. Failed to load.\");\n      } else {\n        registryFixtureData = validatedJson;\n      }\n    }\n\n    var layouts = []; // for each shop, we're loading packages in a unique registry\n\n    _.each(this.Packages, function (config, pkgName) {\n      return Shops.find().forEach(function (shop) {\n        var shopId = shop._id;\n        if (!shopId) return []; // existing registry will be upserted with changes, perhaps we should add:\n\n        _this.assignOwnerRoles(shopId, pkgName, config.registry); // Settings from the package registry.js\n\n\n        var settingsFromPackage = {\n          name: pkgName,\n          icon: config.icon,\n          enabled: !!config.autoEnable,\n          settings: config.settings,\n          registry: config.registry,\n          layout: config.layout\n        }; // Setting from a fixture file, most likely reaction.json\n\n        var settingsFromFixture = void 0;\n\n        if (registryFixtureData) {\n          settingsFromFixture = _.find(registryFixtureData[0], function (packageSetting) {\n            return config.name === packageSetting.name;\n          });\n        } // Setting already imported into the packages collection\n\n\n        var settingsFromDB = _.find(packages, function (ps) {\n          return config.name === ps.name && shopId === ps.shopId;\n        });\n\n        var combinedSettings = _merge({}, settingsFromPackage, settingsFromFixture || {}, settingsFromDB || {}); // populate array of layouts that don't already exist in Shops\n\n\n        if (combinedSettings.layout) {\n          // filter out layout Templates\n          for (var _iterator2 = combinedSettings.layout, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n            var _ref2;\n\n            if (_isArray2) {\n              if (_i2 >= _iterator2.length) break;\n              _ref2 = _iterator2[_i2++];\n            } else {\n              _i2 = _iterator2.next();\n              if (_i2.done) break;\n              _ref2 = _i2.value;\n            }\n\n            var pkg = _ref2;\n\n            if (pkg.layout) {\n              layouts.push(pkg);\n            }\n          }\n        } // Import package data\n\n\n        _this.Import.package(combinedSettings, shopId);\n\n        return Logger.debug(\"Initializing \" + shop.name + \" \" + pkgName);\n      }); // end shops\n    }); // helper for removing layout duplicates\n\n\n    var uniqLayouts = _uniqWith(layouts, _.isEqual); // import layouts into Shops\n\n\n    Shops.find().forEach(function (shop) {\n      _this.Import.layout(uniqLayouts, shop._id);\n    }); //\n    // package cleanup\n    //\n\n    Shops.find().forEach(function (shop) {\n      return Packages.find().forEach(function (pkg) {\n        // delete registry entries for packages that have been removed\n        if (!_.has(_this.Packages, pkg.name)) {\n          Logger.debug(\"Removing \" + pkg.name);\n          return Packages.remove({\n            shopId: shop._id,\n            name: pkg.name\n          });\n        }\n\n        return false;\n      });\n    });\n  },\n  setAppVersion: function () {\n    var version = packageJson.version;\n    Logger.info(\"Reaction Version: \" + version);\n    Shops.update({}, {\n      $set: {\n        appVersion: version\n      }\n    }, {\n      multi: true\n    });\n  }\n});","map":{"version":3,"sources":["/server/api/core/core.js"],"names":["url","packageJson","Meteor","EJSON","Jobs","Packages","Shops","Hooks","Logger","ProcessJobs","getRegistryDomain","registerTemplate","sendVerificationEmail","getMailUrl","init","getShopId","warn","_sleepForMs","Events","run","startJobServer","info","process","env","VERBOSE_JOBS","setLogStream","stdout","loadPackages","Import","flush","isAppTest","createDefaultAdminUser","setAppVersion","debug","registerPackage","packageInfo","registeredPackage","name","hasPermission","checkPermissions","userId","checkGroup","permissions","undefined","group","Roles","GLOBAL_GROUP","push","_","uniq","userIsInRole","sellerShopPermissions","getGroupsForUser","key","shop","hasOwnerAccess","hasAdminAccess","hasDashboardAccess","getSellerShopId","configureMailUrl","getCurrentShopCursor","domain","getDomain","cursor","find","domains","limit","count","getCurrentShop","currentShopCursor","fetch","fields","_id","parse","absoluteUrl","hostname","getShopName","getShopPrefix","getSlug","toLowerCase","getShopEmail","emails","address","getShopSettings","settings","findOne","shopId","getShopCurrency","currency","getShopLanguage","language","getPackageSettings","packageName","getAppVersion","appVersion","defaultAdminRoles","options","configureEnv","accountId","getUsersInRole","REACTION_EMAIL","REACTION_USER","REACTION_AUTH","email","Random","id","username","password","secret","reaction","update","$addToSet","verified","ROOT_URL","users","Accounts","createUser","NODE_ENV","$set","setUserRoles","packages","pkg","assignOwnerRoles","registry","user","registryFixtureData","REACTION_REGISTRY","Assets","getText","error","validatedJson","Array","isArray","layouts","each","config","pkgName","forEach","settingsFromPackage","icon","enabled","autoEnable","layout","settingsFromFixture","packageSetting","settingsFromDB","ps","combinedSettings","package","uniqLayouts","isEqual","has","remove","version","multi"],"mappings":"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","file":"/server/api/core/core.js.map","sourcesContent":["import url from \"url\";\nimport packageJson from \"/package.json\";\nimport { merge, uniqWith } from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { EJSON } from \"meteor/ejson\";\nimport { Jobs, Packages, Shops } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\nimport ProcessJobs from \"/server/jobs\";\nimport { getRegistryDomain } from \"./setDomain\";\nimport { registerTemplate } from \"./templates\";\nimport { sendVerificationEmail } from \"./accounts\";\nimport { getMailUrl } from \"./email/config\";\n\n\nexport default {\n\n  init() {\n    // make sure the default shop has been created before going further\n    while (!this.getShopId()) {\n      Logger.warn(\"No shopId, waiting one second...\");\n      Meteor._sleepForMs(1000);\n    }\n\n    // run onCoreInit hooks\n    Hooks.Events.run(\"onCoreInit\");\n\n    // start job server\n    Jobs.startJobServer(() => {\n      Logger.info(\"JobServer started\");\n      ProcessJobs();\n      Hooks.Events.run(\"onJobServerStart\");\n    });\n    if (process.env.VERBOSE_JOBS) {\n      Jobs.setLogStream(process.stdout);\n    }\n\n    this.loadPackages();\n    // process imports from packages and any hooked imports\n    this.Import.flush();\n    // timing is important, packages are rqd for initial permissions configuration.\n    if (!Meteor.isAppTest) {\n      this.createDefaultAdminUser();\n    }\n    this.setAppVersion();\n    // hook after init finished\n    Hooks.Events.run(\"afterCoreInit\");\n\n    Logger.debug(\"Reaction.init() has run\");\n\n    return true;\n  },\n\n  Packages: {},\n\n  registerPackage(packageInfo) {\n    const registeredPackage = this.Packages[packageInfo.name] = packageInfo;\n    return registeredPackage;\n  },\n\n  /**\n   * registerTemplate\n   * registers Templates into the Tempaltes Collection\n   * @return {function} Registers template\n   */\n  registerTemplate: registerTemplate,\n\n  /**\n   * hasPermission - server\n   * server permissions checks\n   * hasPermission exists on both the server and the client.\n   * @param {String | Array} checkPermissions -String or Array of permissions if empty, defaults to \"admin, owner\"\n   * @param {String} userId - userId, defaults to Meteor.userId()\n   * @param {String} checkGroup group - default to shopId\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasPermission(checkPermissions, userId = Meteor.userId(), checkGroup = this.getShopId()) {\n    // check(checkPermissions, Match.OneOf(String, Array)); check(userId, String); check(checkGroup,\n    // Match.Optional(String));\n\n    let permissions;\n    // default group to the shop or global if shop isn't defined for some reason.\n    if (checkGroup !== undefined && typeof checkGroup === \"string\") {\n      group = checkGroup;\n    } else {\n      group = this.getShopId() || Roles.GLOBAL_GROUP;\n    }\n\n    // permissions can be either a string or an array we'll force it into an array and use that\n    if (checkPermissions === undefined) {\n      permissions = [\"owner\"];\n    } else if (typeof checkPermissions === \"string\") {\n      permissions = [checkPermissions];\n    } else {\n      permissions = checkPermissions;\n    }\n\n    // if the user has admin, owner permissions we'll always check if those roles are enough\n    permissions.push(\"owner\");\n    permissions = _.uniq(permissions);\n\n    // return if user has permissions in the group\n    if (Roles.userIsInRole(userId, permissions, group)) {\n      return true;\n    }\n\n    // global roles check\n    const sellerShopPermissions = Roles.getGroupsForUser(userId, \"admin\");\n\n    // we're looking for seller permissions.\n    if (sellerShopPermissions) {\n      // loop through shops roles and check permissions\n      for (const key in sellerShopPermissions) {\n        if (key) {\n          const shop = sellerShopPermissions[key];\n          if (Roles.userIsInRole(userId, permissions, shop)) {\n            return true;\n          }\n        }\n      }\n    }\n    // no specific permissions found returning false\n    return false;\n  },\n\n  hasOwnerAccess() {\n    return this.hasPermission([\"owner\"]);\n  },\n\n  hasAdminAccess() {\n    return this.hasPermission([\"owner\", \"admin\"]);\n  },\n\n  hasDashboardAccess() {\n    return this.hasPermission([\"owner\", \"admin\", \"dashboard\"]);\n  },\n\n  getSellerShopId() {\n    return Roles.getGroupsForUser(this.userId, \"admin\");\n  },\n\n  configureMailUrl() {\n    // maintained for legacy support\n    Logger.warn(\"Reaction.configureMailUrl() is deprecated. Please use Reaction.Email.getMailUrl() instead\");\n    return getMailUrl();\n  },\n\n  getCurrentShopCursor() {\n    const domain = this.getDomain();\n    const cursor = Shops.find({\n      domains: domain\n    }, { limit: 1 });\n    if (!cursor.count()) {\n      Logger.debug(domain, \"Add a domain entry to shops for \");\n    }\n    return cursor;\n  },\n\n  getCurrentShop() {\n    const currentShopCursor = this.getCurrentShopCursor();\n    // also, we could check in such a way: `currentShopCursor instanceof Object` but not instanceof something.Cursor\n    if (typeof currentShopCursor === \"object\") {\n      return currentShopCursor.fetch()[0];\n    }\n    return null;\n  },\n\n  getShopId() {\n    const domain = this.getDomain();\n    const shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        _id: 1\n      }\n    }).fetch()[0];\n    return shop && shop._id;\n  },\n\n  getDomain() {\n    return url.parse(Meteor.absoluteUrl()).hostname;\n  },\n\n  getShopName() {\n    const domain = this.getDomain();\n    const shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        name: 1\n      }\n    }).fetch()[0];\n    return shop && shop.name;\n  },\n\n  getShopPrefix() {\n    return \"/\" + this.getSlug(this.getShopName().toLowerCase());\n  },\n\n  getShopEmail() {\n    const shop = Shops.find({\n      _id: this.getShopId()\n    }, {\n      limit: 1,\n      fields: {\n        emails: 1\n      }\n    }).fetch()[0];\n    return shop && shop.emails && shop.emails[0].address;\n  },\n\n  getShopSettings(name = \"core\") {\n    const settings = Packages.findOne({ name: name, shopId: this.getShopId() }) || {};\n    return settings.settings || {};\n  },\n\n  getShopCurrency() {\n    const shop = Shops.findOne({\n      _id: this.getShopId()\n    });\n\n    return shop && shop.currency || \"USD\";\n  },\n\n  getShopLanguage() {\n    const { language } = Shops.findOne({\n      _id: this.getShopId()\n    }, {\n      fields: {\n        language: 1\n      } }\n    );\n    return language;\n  },\n\n  getPackageSettings(name) {\n    return Packages.findOne({ packageName: name, shopId: this.getShopId() }) || null;\n  },\n\n  getAppVersion() {\n    return Shops.findOne().appVersion;\n  },\n\n  /**\n   * createDefaultAdminUser\n   * @summary Method that creates default admin user\n   * Settings load precendence:\n   *  1. settings in meteor.settings\n   *  2. environment variables\n   * @returns {String} return userId\n   */\n  createDefaultAdminUser() {\n    const domain = getRegistryDomain();\n    const env = process.env;\n    const defaultAdminRoles = [\"owner\", \"admin\", \"guest\", \"account/profile\"];\n    let options = {};\n    let configureEnv = false;\n    let accountId;\n\n    const shopId = this.getShopId();\n\n    // if an admin user has already been created, we'll exit\n    if (Roles.getUsersInRole(\"owner\", shopId).count() !== 0) {\n      Logger.debug(\"Not creating default admin user, already exists\");\n      return \"\"; // this default admin has already been created for this shop.\n    }\n\n    // run hooks on options object before creating user (the options object must be returned from all callbacks)\n    options = Hooks.Events.run(\"beforeCreateDefaultAdminUser\", options);\n\n    //\n    // process Meteor settings and env variables for initial user config if ENV variables are set, these always override\n    // \"settings.json\" this is to allow for testing environments. where we don't want to use users configured in a settings\n    // file.\n    //\n    if (env.REACTION_EMAIL && env.REACTION_USER && env.REACTION_AUTH) {\n      configureEnv = true;\n    }\n\n    // defaults use either env or generated\n    options.email = env.REACTION_EMAIL || Random.id(8).toLowerCase() + \"@\" + domain;\n    options.username = env.REACTION_USER || \"Admin\"; // username\n    options.password = env.REACTION_AUTH || Random.secret(8);\n\n    // but we can override with provided `meteor --settings`\n    if (Meteor.settings && !configureEnv) {\n      if (Meteor.settings.reaction) {\n        options.username = Meteor.settings.reaction.REACTION_USER || \"Admin\";\n        options.password = Meteor.settings.reaction.REACTION_AUTH || Random.secret(8);\n        options.email = Meteor.settings.reaction.REACTION_EMAIL || Random.id(8).toLowerCase() + \"@\" + domain;\n        Logger.info(\"Using meteor --settings to create admin user\");\n      }\n    }\n\n    // set the default shop email to the default admin email\n    Shops.update(shopId, {\n      $addToSet: {\n        emails: {\n          address: options.email,\n          verified: true\n        },\n        domains: Meteor.settings.ROOT_URL\n      }\n    });\n\n    //\n    // create the new admin user\n    //\n\n    // we're checking again to see if this user was created but not specifically for this shop.\n    if (Meteor.users.find({ \"emails.address\": options.email }).count() === 0) {\n      accountId = Accounts.createUser(options);\n    } else {\n      // this should only occur when existing admin creates a new shop\n      accountId = Meteor.users.findOne({ \"emails.address\": options.email })._id;\n    }\n\n    //\n    // send verification email\n    //\n\n    // we dont need to validate admin user in development\n    if (process.env.NODE_ENV === \"development\") {\n      Meteor.users.update({\n        \"_id\": accountId,\n        \"emails.address\": options.email\n      }, {\n        $set: {\n          \"emails.$.verified\": true\n        }\n      });\n    } else {\n      // send verification email to admin\n      sendVerificationEmail(accountId);\n    }\n\n    //\n    // Set Default Roles\n    //\n\n    // we don't use accounts/addUserPermissions here because we may not yet have permissions\n    Roles.setUserRoles(accountId, _.uniq(defaultAdminRoles), shopId);\n    // // the reaction owner has permissions to all sites by default\n    Roles.setUserRoles(accountId, _.uniq(defaultAdminRoles), Roles.GLOBAL_GROUP);\n    // initialize package permissions we don't need to do any further permission configuration it is taken care of in the\n    // assignOwnerRoles\n    const packages = Packages.find().fetch();\n    for (const pkg of packages) {\n      this.assignOwnerRoles(shopId, pkg.name, pkg.registry);\n    }\n\n    //\n    //  notify user that admin was created account email should print on console\n    //\n\n    Logger.warn(`\\n *********************************\n        \\n  IMPORTANT! DEFAULT ADMIN INFO\n        \\n  EMAIL/LOGIN: ${options.email}\n        \\n  PASSWORD: ${options.password}\n        \\n ********************************* \\n\\n`);\n\n    // run hooks on new user object\n    const user = Meteor.users.findOne(accountId);\n    Hooks.Events.run(\"afterCreateDefaultAdminUser\", user);\n    return accountId;\n  },\n\n  /**\n   *  loadPackages\n   *  insert Reaction packages into registry\n   *  we check to see if the number of packages have changed against current data\n   *  if there is a change, we'll either insert or upsert package registry\n   *  into the Packages collection\n   *  import is processed on hook in init()\n   *  @return {String} returns insert result\n   */\n  loadPackages() {\n    const packages = Packages.find().fetch();\n\n    let registryFixtureData;\n\n    if (process.env.REACTION_REGISTRY) {\n      // check the environment for the registry fixture data first\n      registryFixtureData = process.env.REACTION_REGISTRY;\n      Logger.info(\"Loaded REACTION_REGISTRY environment variable for registry fixture import\");\n    } else {\n      // or attempt to load reaction.json fixture data\n      try {\n        registryFixtureData = Assets.getText(\"settings/reaction.json\");\n        Logger.info(\"Loaded \\\"/private/settings/reaction.json\\\" for registry fixture import\");\n      } catch (error) {\n        Logger.warn(\"Skipped loading settings from reaction.json.\");\n        Logger.debug(error, \"loadSettings reaction.json not loaded.\");\n      }\n    }\n\n    if (!!registryFixtureData) {\n      const validatedJson = EJSON.parse(registryFixtureData);\n\n      if (!Array.isArray(validatedJson[0])) {\n        Logger.warn(\"Registry fixture data is not an array. Failed to load.\");\n      } else {\n        registryFixtureData = validatedJson;\n      }\n    }\n\n    const layouts = [];\n    // for each shop, we're loading packages in a unique registry\n    _.each(this.Packages, (config, pkgName) => {\n      return Shops.find().forEach((shop) => {\n        const shopId = shop._id;\n        if (!shopId) return [];\n\n        // existing registry will be upserted with changes, perhaps we should add:\n        this.assignOwnerRoles(shopId, pkgName, config.registry);\n\n        // Settings from the package registry.js\n        const settingsFromPackage = {\n          name: pkgName,\n          icon: config.icon,\n          enabled: !!config.autoEnable,\n          settings: config.settings,\n          registry: config.registry,\n          layout: config.layout\n        };\n\n        // Setting from a fixture file, most likely reaction.json\n        let settingsFromFixture;\n        if (registryFixtureData) {\n          settingsFromFixture = _.find(registryFixtureData[0], (packageSetting) => {\n            return config.name === packageSetting.name;\n          });\n        }\n\n        // Setting already imported into the packages collection\n        const settingsFromDB = _.find(packages, (ps) => {\n          return (config.name === ps.name && shopId === ps.shopId);\n        });\n\n        const combinedSettings = merge({}, settingsFromPackage, settingsFromFixture || {}, settingsFromDB || {});\n\n        // populate array of layouts that don't already exist in Shops\n        if (combinedSettings.layout) {\n          // filter out layout Templates\n          for (const pkg of combinedSettings.layout) {\n            if (pkg.layout) {\n              layouts.push(pkg);\n            }\n          }\n        }\n        // Import package data\n        this.Import.package(combinedSettings, shopId);\n        return Logger.debug(`Initializing ${shop.name} ${pkgName}`);\n      }); // end shops\n    });\n\n    // helper for removing layout duplicates\n    const uniqLayouts = uniqWith(layouts, _.isEqual);\n    // import layouts into Shops\n    Shops.find().forEach((shop) => {\n      this.Import.layout(uniqLayouts, shop._id);\n    });\n\n    //\n    // package cleanup\n    //\n    Shops.find().forEach((shop) => {\n      return Packages.find().forEach((pkg) => {\n        // delete registry entries for packages that have been removed\n        if (!_.has(this.Packages, pkg.name)) {\n          Logger.debug(`Removing ${pkg.name}`);\n          return Packages.remove({ shopId: shop._id, name: pkg.name });\n        }\n        return false;\n      });\n    });\n  },\n  setAppVersion() {\n    const version = packageJson.version;\n    Logger.info(`Reaction Version: ${version}`);\n    Shops.update({}, { $set: { appVersion: version } }, { multi: true });\n  }\n};\n"]},"hash":"1efa39cac168b0e260ee6ada69a38d816f0310a6"}
