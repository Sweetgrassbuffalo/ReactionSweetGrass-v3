{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"/lib/collections","imported":["*"],"specifiers":[{"kind":"namespace","local":"Collections"}]},{"source":"/server/api","imported":["Hooks","Logger","Reaction"],"specifiers":[{"kind":"named","imported":"Hooks","local":"Hooks"},{"kind":"named","imported":"Logger","local":"Logger"},{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/startup/accounts.js","filenameRelative":"/server/startup/accounts.js","inputSourceMap":{"version":3,"sources":["/server/startup/accounts.js"],"names":["Meteor","Collections","Hooks","Logger","Reaction","Accounts","validateLoginAttempt","attempt","allowed","type","methodName","user","loginEmail","methodArguments","email","adminEmail","process","env","REACTION_EMAIL","userEmail","_","filter","emails","address","length","verified","Error","registerLoginHandler","options","anonymous","stampedToken","_generateStampedLoginToken","userId","insertUserDoc","services","token","loginHandler","onCreateUser","shop","getCurrentShop","shopId","_id","defaultVisitorRole","defaultRoles","roles","additionals","profile","Object","assign","users","find","count","currentUser","lang","currency","service","provides","push","name","username","picture","profile_image_url_https","dprofile_image_url_https","profile_picture","account","insert","call","userDoc","Events","run","onLogin","opts","update","$pullAll","getShopId","multi","debug","cart","Cart","findOne","currentSessionId","sessionId"],"mappings":";;;;;;AAAA;OAAuB;;;;;;;;;;;;;;;;;;;;;;;;GACvB,AAAO,AAAK,AAAiB,AAC7B,AAAS,AAAO,AAAQ,AAAgB,AAExC,AAAe,AAAY,AACzB;OALO,OAAT,mBAAA;AAYE,AAAS,AAAqB,AAAU,AAAS,AAC/C,AAAI,AAAC,AAAQ,AAAS,AACpB,AAAO,AACR;;;;;;;aAGD;AAAA,AAAI,AAAQ,AAAS,AAAc,AAAQ,AAAe,AAAS,AACjE,AAAO,AAAQ,AAChB;;;uEAED;AAAI,AAAC,aAAQ,QAAb,AAAmB,AACjB;AAAA,AAAO,AAAQ,AAChB;;uBAED;AAAM,qBAAN,AAAmB,AAAQ,AAAgB,AAAG,AAAK,AACnD;AAAA,AAAM,AAAa,AAAQ,AAAI,AAE/B;;AAAI,QAAc,qBAAe,gBAAjC,AAA6C,QAC3C;iCACA,AAAM,AAAY,AAAE,AAAO,AAAQ,AAAK,AAAQ,AAAU,AAAO,AAC/D;;QAAO,AAAM,cAAN,AAAkB,eAAzB;AAHyC,AAE3C,AAAkB,AAIlB;;iCACA;AAAA,AAAI,AAAC,AAAU,AAAU,AAAC,AAAU,AAAG,AAAU,AAC/C,AAAM,AAAI,AAAO,AAAM,AAAO,AAC/B,SALA,CAMF;;;;sCAED;AA7BF,AA6BE,AAAO,AAAQ,AAChB;AAtCwB,AAwCzB;;;AAKA,GArCiD,AAK/C,GAgCF,AAAS,AAAqB,AAAU,AAAS,AAC/C,AAAI,AAAC,AAAQ,AAAW,AACtB,AAAO,AACR,AACD;;;;;AAAM,WAAe,qBAAS,mBAA9B,AAAqB;4BACrB;AAAM,aAAS,AAAS,AAAc,AACpC;AAAU,AACR;;QAAW,wBADH;;AAD0B;AAI7B;mBAET,AAAM,AAAe,AACnB;AAPF,AAAe,AAAuB,AAIhB;AAGd,aADa,aAAA,AAEnB,AAAQ;AAJR;AAEF;AAIO,YA5DgB,AA6CzB,AAeE,AACD;AAED;AAHE;;MAeF,AAAS,AAAa,AAAC,AAAS,AAAS,AACvC,AAAM,AAAO,AAAS,AACtB,AAAM,AAAS,AAAK,AACpB,AAAM,AAAsB,AAAC,AAAa,AAAS,AAAW,AAAO,AAAS,AAAiB,AAC/F,AAAM,AAAgB,AAAC,AAAS,AAAmB,AAAW,AAAO,AAAS,AAAiB,AAC/F;;;;;;;;;;;;AAAM,WAAN,AAAc;QACR,OAAc,SAClB;QAAS,SAAO,KADE,AACT,AAAc,AAAI,AAAW,AAAQ;AADhD,gGAGA;AAAI,AAAC,QAAL,AAAU,AAAQ,gBAAA,AAAK,SATgB,AASrB,AAAc,AAChC,+DACA;;;AACA,AAAI,AAAM,oDACR,AACA;AAFF;oCAGE,GATF,CAUE;AAAA,AAAI,AAAE,AAAO,AAAM,AAAO,AAAY,AAAI,AAAE;;;AAC1C,AAAI,AAAC,AAAK,AAAS,AAAK,AAAU,AAClC;AAAA,AAAM,AAAc,AAAO,AAAK;AAChC;YAAI,aAAe,OAAY,YAA/B,IAAwC;AACtC;aAAI,KAAY,cAAZ,AAAoB,UAAxB,AAAgC,AAAC,AAAK,AAAQ,AAAM,AAClD;YAAA,AAAK,AAAQ,cAAb,AAAoB,YAApB,AAAoB,AAAY,AAAQ,AACzC;;;8DACD;AAAI,yBAAY,OAAZ,AAAoB,YAAY,AAAC,QAArC,AAAqC,AAAK,AAAQ,AAAU,AAC1D;AAAA,AAAK,AAAQ,AAAW,AAAY,AAAQ,AAC7C;;sEACF;wDAdK,AAeP,AAED;;;AACA,AAAI,AAAC,AAAK,AAAU,AAClB,OAdA,CAcA,AAAM,AAAU,AAAK,AAAsB,AAC5C;;;AAFD,WAEO,eACL;cAAA,AAAM,UAAU,KAAA,AAAK,AAAgB,sBADhC,AACL,AACA;aACA;AAAK,cAAM,UAAX,KAAA,AAAsB,AAAK,gBAAU,AACnC,cAAA,AAAI,AAAK,AAAS,AAAS,AAAO,AAChC;;aAAM,IAAQ;mBACF,SADE,gBAEZ;gBAAS;wBAFX,AAAc,AAGF;8CAEZ;AAAA,AAAK,wBAAL,AAAY,AAAK,AAClB;AANe,AAEH,AAAK,AAAS,AAAS,AAChC;6BAIJ;AAAA,AAAI,AAAK,AAAS,AAAS,AAAM,AAC/B;;cAAK,KAAL,SAAgB,AAAK,SAAL,AAAc,MAA9B,AAAgB,AAAuB,AACvC;iBAAY,WAAZ,AAAoB,KAApB,AAA2B,SAAK,SAXC,AAWjC,AAA2B,AAAc,AAAS,AACnD;AACD,8DACA;WAXI;AAYJ;;;cAAI,KAAA,AAAK,SAAL,AAAc,SAAlB,AAA2B,SAAS,AAClC;wBAAA,AAAY,QAAZ,AAAoB,UAAU,KAAA,AAAK,SAAL,AAAc,SAA5C,AAAqD,AACtD;AAFD,qBAEW,KAAA,AAAK,SAAL,AAAc,SAAlB,AAA2B,yBAAyB,AACzD;wBAAA,AAAY,QAAZ,AAAoB,UAAU,KAAA,AAAK,SAD9B,AACL,AAA8B,AAAc,AAC1C,AACH,SAAM,AAAI,AAAK,AAAS,AAAS,AAAiB,AACjD;WAJK,UAIO,KAAZ,AAAoB,SAApB,AAA8B,SAAA,AAAK,AAAS,iBAA5C,AAA8B,AAAuB,AACtD;iEACF;AA9CK,AA+CP,AACD;;QACA;;;UAAM,UAAU,OAAA,AAAO,OAAP,AAAc,IAAd,AAAkB,MAAlC,AAAgB,AAAwB,AACxC;cAAA,AAAQ,SAAS,KAAjB,AAAsB,AACtB;kBAAA,AAAY,SAAZ,AAAqB,OAnDb,AAmDR,AAA4B,AAE5B,AACA,AACA;AACA;AAAA,AAAI,AAAE,AAAO,AAAM,AAAO,AAAY,AAAI,AACxC;;YAAO,OAAP,AAAY,yBAAZ,IAzDM,AAyDN,AAAyC,AAAQ,AAAK,AACvD;AAED;AACA,QA7DQ,AA6DR,AAAK,AAAQ,AAEb,AACA;;;mBACA,OAAA,AAAM,AAAU,AAAM,AAAO,AAAI,AAAgB,AAAM,AACvD;AAAA,AAAO,AACR;;2DA1JsB,AA2EzB,AAgFC;AAED;;MAMA,AAAS,AAAQ,AAAC,AAAS,AACzB,AACA,AACA,AAAU,AAAM,AAAO,AAAI,AAAW,AAEtC,AACA;;;;;;mCACA;;AACA;AAAI,cAAQ,MAAR,AAAiB,WAAjB,AAAgC,WAApC,AAAoC,AAAQ,AAAS,AAAU,AAC7D,AAAM,AAAS,AACb,OADa,AACH;AADZ,AAIA;AAAA,AAAO,AAAS,AAAW,AAAS,AAAe,AAAC,AAEpD;;QAAO,QAAP,AAAa,SAAb,AAAoB;UACb;AADP,AAEG,AAAQ,kBATkD,AAO7D,AAEW,AACT,AAAO,AAET;AALA,AAAoB,AACb,AAAQ,AAAK;0DARyC,AAa7D,AAAO,AAAM,AACX,AAAQ,AAAK,AAEf,AACA;;0BACA;SAAI;eAGJ,AAAM,AAAO,AAAY,AAAK,AAAQ,AACpC;AAtB2D,AAkB7D,AAAI,AAAQ,AAAe,AAAc,AAAO,AAEhD,SAZE,CAaoC,AAC5B,AAAQ,AAAK;;AAtBsC,AAqB7D,AAAa,AAIb,uEAzB6D,AA0B7D,AAAI,AAAO,AAAS,AAAU,AAAO,AACrC,AACA,MACA;;;sDA7B6D,AA8B7D,AAAM,AAAmB,AAAQ,AAC/B,AAAQ,AAAgB,AAAW,AACnC,AAAQ,AAAgB,AAAG,AAE7B,MACA;;UAAO,wBAAA,AAA8B;6BA3CzC,AA6CC,AACF;AAHK,AAAO,AAAmC,AAAK,AAChD,OADQ,AAAO,AAAK","file":"/server/startup/accounts.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport * as Collections from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\nexport default function () {\n  /**\n   * Make sure initial admin user has verified their\n   * email before allowing them to login.\n   *\n   * http://docs.meteor.com/#/full/accounts_validateloginattempt\n   */\n\n  Accounts.validateLoginAttempt(function (attempt) {\n    if (!attempt.allowed) {\n      return false;\n    }\n\n    // confirm this is the accounts-password login method\n    if (attempt.type !== \"password\" || attempt.methodName !== \"login\") {\n      return attempt.allowed;\n    }\n\n    if (!attempt.user) {\n      return attempt.allowed;\n    }\n\n    const loginEmail = attempt.methodArguments[0].user.email;\n    const adminEmail = process.env.REACTION_EMAIL;\n\n    if (loginEmail && loginEmail === adminEmail) {\n      // filter out the matching login email from any existing emails\n      const userEmail = _.filter(attempt.user.emails, function (email) {\n        return email.address === loginEmail;\n      });\n\n      // check if the email is verified\n      if (!userEmail.length || !userEmail[0].verified) {\n        throw new Meteor.Error(\"403\", \"Oops! Please validate your email first.\");\n      }\n    }\n\n    return attempt.allowed;\n  });\n\n  /**\n   * Reaction Accounts handlers\n   * creates a login type \"anonymous\"\n   * default for all unauthenticated visitors\n   */\n  Accounts.registerLoginHandler(function (options) {\n    if (!options.anonymous) {\n      return {};\n    }\n    const stampedToken = Accounts._generateStampedLoginToken();\n    const userId = Accounts.insertUserDoc({\n      services: {\n        anonymous: true\n      },\n      token: stampedToken.token\n    });\n    const loginHandler = {\n      type: \"anonymous\",\n      userId: userId\n    };\n    return loginHandler;\n  });\n\n  /**\n   * Accounts.onCreateUser event\n   * adding either a guest or anonymous role to the user on create\n   * adds Accounts record for reaction user profiles\n   * we clone the user into accounts, as the user collection is\n   * only to be used for authentication.\n   * - defaultVisitorRole\n   * - defaultRoles\n   * can be overriden from Shops\n   *\n   * @see: http://docs.meteor.com/#/full/accounts_oncreateuser\n   */\n  Accounts.onCreateUser((options, user) => {\n    const shop = Reaction.getCurrentShop();\n    const shopId = shop._id;\n    const defaultVisitorRole =  [\"anonymous\", \"guest\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"];\n    const defaultRoles =  [\"guest\", \"account/profile\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"];\n    const roles = {};\n    const additionals = {\n      profile: Object.assign({}, options && options.profile)\n    };\n    if (!user.emails) user.emails = [];\n    // init default user roles\n    // we won't create users unless we have a shop.\n    if (shop) {\n      // retain language when user has defined a language\n      // perhaps should be treated as additionals\n      // or in onLogin below, or in the anonymous method options\n      if (!(Meteor.users.find().count() === 0)) { // dont set on inital admin\n        if (!user.profile) user.profile = {};\n        const currentUser = Meteor.user(user);\n        if (currentUser && currentUser.profile) {\n          if (currentUser.profile.lang && !user.profile.lang) {\n            user.profile.lang = currentUser.profile.lang;\n          }\n          if (currentUser.profile.currency && !user.profile.currency) {\n            user.profile.currency = currentUser.profile.currency;\n          }\n        }\n      }\n\n      // if we don't have user.services we're an anonymous user\n      if (!user.services) {\n        roles[shopId] = shop.defaultVisitorRole || defaultVisitorRole;\n      } else {\n        roles[shopId] = shop.defaultRoles || defaultRoles;\n        // also add services with email defined to user.emails[]\n        for (const service in user.services) {\n          if (user.services[service].email) {\n            const email = {\n              provides: \"default\",\n              address: user.services[service].email,\n              verified: true\n            };\n            user.emails.push(email);\n          }\n          if (user.services[service].name) {\n            user.username = user.services[service].name;\n            additionals.profile.name = user.services[service].name;\n          }\n          // TODO: For now we have here instagram, twitter and google avatar cases\n          // need to make complete list\n          if (user.services[service].picture) {\n            additionals.profile.picture = user.services[service].picture;\n          } else if (user.services[service].profile_image_url_https) {\n            additionals.profile.picture = user.services[service].\n              dprofile_image_url_https;\n          } else if (user.services[service].profile_picture) {\n            additionals.profile.picture = user.services[service].profile_picture;\n          }\n        }\n      }\n      // clone before adding roles\n      const account = Object.assign({}, user, additionals);\n      account.userId = user._id;\n      Collections.Accounts.insert(account);\n\n      // send a welcome email to new users,\n      // but skip the first default admin user\n      // (default admins already get a verification email)\n      if (!(Meteor.users.find().count() === 0)) {\n        Meteor.call(\"accounts/sendWelcomeEmail\", shopId, user._id);\n      }\n\n      // assign default user roles\n      user.roles = roles;\n\n      // run onCreateUser hooks\n      // (the user object must be returned by all callbacks)\n      const userDoc = Hooks.Events.run(\"onCreateUser\", user, options);\n      return userDoc;\n    }\n  });\n\n  /**\n   * Accounts.onLogin event\n   * let's remove \"anonymous\" role, if the login type isn't \"anonymous\"\n   * @param {Object} options - user account creation options\n   * @fires \"cart/mergeCart\" Method\n   */\n  Accounts.onLogin((opts) => {\n    // run onLogin hooks\n    // (the options object must be returned by all callbacks)\n    options = Hooks.Events.run(\"onLogin\", opts);\n\n    // remove anonymous role\n    // all users are guest, but anonymous user don't have profile access\n    // or ability to order history, etc. so ensure its removed upon login.\n    if (options.type !== \"anonymous\" && options.type !== \"resume\") {\n      const update = {\n        $pullAll: {}\n      };\n\n      update.$pullAll[\"roles.\" + Reaction.getShopId()] = [\"anonymous\"];\n\n      Meteor.users.update({\n        _id: options.user._id\n      }, update, {\n        multi: true\n      });\n      // debug info\n      Logger.debug(\"removed anonymous role from user: \" +\n        options.user._id);\n\n      // do not call `cart/mergeCart` on methodName === `createUser`, because\n      // in this case `cart/mergeCart` calls from cart publication\n      if (options.methodName === \"createUser\") return true;\n\n      // onLogin, we want to merge session cart into user cart.\n      const cart = Collections.Cart.findOne({\n        userId: options.user._id\n      });\n\n      // for a rare use cases\n      if (typeof cart !== \"object\") return false;\n      // in current version currentSessionId will be available for anonymous\n      // users only, because it is unknown for me how to pass sessionId when user\n      // logged in\n      const currentSessionId = options.methodArguments &&\n        options.methodArguments.length === 1 &&\n        options.methodArguments[0].sessionId;\n\n      // changing of workflow status from now happens within `cart/mergeCart`\n      return Meteor.call(\"cart/mergeCart\", cart._id, currentSessionId);\n    }\n  });\n}\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/startup/accounts.js.map","sourceFileName":"/server/startup/accounts.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"accounts"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar Collections = Object.create(null);\nmodule.importSync(\"/lib/collections\", {\n  \"*\": function (v, n) {\n    Collections[n] = v;\n  }\n}, 1);\nvar Hooks = void 0,\n    Logger = void 0,\n    Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Hooks: function (v) {\n    Hooks = v;\n  },\n  Logger: function (v) {\n    Logger = v;\n  },\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 2);\nmodule.export(\"default\", exports.default = function () {\n  /**\n   * Make sure initial admin user has verified their\n   * email before allowing them to login.\n   *\n   * http://docs.meteor.com/#/full/accounts_validateloginattempt\n   */Accounts.validateLoginAttempt(function (attempt) {\n    if (!attempt.allowed) {\n      return false;\n    } // confirm this is the accounts-password login method\n\n\n    if (attempt.type !== \"password\" || attempt.methodName !== \"login\") {\n      return attempt.allowed;\n    }\n\n    if (!attempt.user) {\n      return attempt.allowed;\n    }\n\n    var loginEmail = attempt.methodArguments[0].user.email;\n    var adminEmail = process.env.REACTION_EMAIL;\n\n    if (loginEmail && loginEmail === adminEmail) {\n      // filter out the matching login email from any existing emails\n      var userEmail = _.filter(attempt.user.emails, function (email) {\n        return email.address === loginEmail;\n      }); // check if the email is verified\n\n\n      if (!userEmail.length || !userEmail[0].verified) {\n        throw new Meteor.Error(\"403\", \"Oops! Please validate your email first.\");\n      }\n    }\n\n    return attempt.allowed;\n  }); /**\n       * Reaction Accounts handlers\n       * creates a login type \"anonymous\"\n       * default for all unauthenticated visitors\n       */\n  Accounts.registerLoginHandler(function (options) {\n    if (!options.anonymous) {\n      return {};\n    }\n\n    var stampedToken = Accounts._generateStampedLoginToken();\n\n    var userId = Accounts.insertUserDoc({\n      services: {\n        anonymous: true\n      },\n      token: stampedToken.token\n    });\n    var loginHandler = {\n      type: \"anonymous\",\n      userId: userId\n    };\n    return loginHandler;\n  }); /**\n       * Accounts.onCreateUser event\n       * adding either a guest or anonymous role to the user on create\n       * adds Accounts record for reaction user profiles\n       * we clone the user into accounts, as the user collection is\n       * only to be used for authentication.\n       * - defaultVisitorRole\n       * - defaultRoles\n       * can be overriden from Shops\n       *\n       * @see: http://docs.meteor.com/#/full/accounts_oncreateuser\n       */\n  Accounts.onCreateUser(function (options, user) {\n    var shop = Reaction.getCurrentShop();\n    var shopId = shop._id;\n    var defaultVisitorRole = [\"anonymous\", \"guest\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"];\n    var defaultRoles = [\"guest\", \"account/profile\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"];\n    var roles = {};\n    var additionals = {\n      profile: Object.assign({}, options && options.profile)\n    };\n    if (!user.emails) user.emails = []; // init default user roles\n    // we won't create users unless we have a shop.\n\n    if (shop) {\n      // retain language when user has defined a language\n      // perhaps should be treated as additionals\n      // or in onLogin below, or in the anonymous method options\n      if (!(Meteor.users.find().count() === 0)) {\n        // dont set on inital admin\n        if (!user.profile) user.profile = {};\n        var currentUser = Meteor.user(user);\n\n        if (currentUser && currentUser.profile) {\n          if (currentUser.profile.lang && !user.profile.lang) {\n            user.profile.lang = currentUser.profile.lang;\n          }\n\n          if (currentUser.profile.currency && !user.profile.currency) {\n            user.profile.currency = currentUser.profile.currency;\n          }\n        }\n      } // if we don't have user.services we're an anonymous user\n\n\n      if (!user.services) {\n        roles[shopId] = shop.defaultVisitorRole || defaultVisitorRole;\n      } else {\n        roles[shopId] = shop.defaultRoles || defaultRoles; // also add services with email defined to user.emails[]\n\n        for (var service in meteorBabelHelpers.sanitizeForInObject(user.services)) {\n          if (user.services[service].email) {\n            var email = {\n              provides: \"default\",\n              address: user.services[service].email,\n              verified: true\n            };\n            user.emails.push(email);\n          }\n\n          if (user.services[service].name) {\n            user.username = user.services[service].name;\n            additionals.profile.name = user.services[service].name;\n          } // TODO: For now we have here instagram, twitter and google avatar cases\n          // need to make complete list\n\n\n          if (user.services[service].picture) {\n            additionals.profile.picture = user.services[service].picture;\n          } else if (user.services[service].profile_image_url_https) {\n            additionals.profile.picture = user.services[service].dprofile_image_url_https;\n          } else if (user.services[service].profile_picture) {\n            additionals.profile.picture = user.services[service].profile_picture;\n          }\n        }\n      } // clone before adding roles\n\n\n      var account = Object.assign({}, user, additionals);\n      account.userId = user._id;\n      Collections.Accounts.insert(account); // send a welcome email to new users,\n      // but skip the first default admin user\n      // (default admins already get a verification email)\n\n      if (!(Meteor.users.find().count() === 0)) {\n        Meteor.call(\"accounts/sendWelcomeEmail\", shopId, user._id);\n      } // assign default user roles\n\n\n      user.roles = roles; // run onCreateUser hooks\n      // (the user object must be returned by all callbacks)\n\n      var userDoc = Hooks.Events.run(\"onCreateUser\", user, options);\n      return userDoc;\n    }\n  }); /**\n       * Accounts.onLogin event\n       * let's remove \"anonymous\" role, if the login type isn't \"anonymous\"\n       * @param {Object} options - user account creation options\n       * @fires \"cart/mergeCart\" Method\n       */\n  Accounts.onLogin(function (opts) {\n    // run onLogin hooks\n    // (the options object must be returned by all callbacks)\n    options = Hooks.Events.run(\"onLogin\", opts); // remove anonymous role\n    // all users are guest, but anonymous user don't have profile access\n    // or ability to order history, etc. so ensure its removed upon login.\n\n    if (options.type !== \"anonymous\" && options.type !== \"resume\") {\n      var update = {\n        $pullAll: {}\n      };\n      update.$pullAll[\"roles.\" + Reaction.getShopId()] = [\"anonymous\"];\n      Meteor.users.update({\n        _id: options.user._id\n      }, update, {\n        multi: true\n      }); // debug info\n\n      Logger.debug(\"removed anonymous role from user: \" + options.user._id); // do not call `cart/mergeCart` on methodName === `createUser`, because\n      // in this case `cart/mergeCart` calls from cart publication\n\n      if (options.methodName === \"createUser\") return true; // onLogin, we want to merge session cart into user cart.\n\n      var cart = Collections.Cart.findOne({\n        userId: options.user._id\n      }); // for a rare use cases\n\n      if ((typeof cart === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(cart)) !== \"object\") return false; // in current version currentSessionId will be available for anonymous\n      // users only, because it is unknown for me how to pass sessionId when user\n      // logged in\n\n      var currentSessionId = options.methodArguments && options.methodArguments.length === 1 && options.methodArguments[0].sessionId; // changing of workflow status from now happens within `cart/mergeCart`\n\n      return Meteor.call(\"cart/mergeCart\", cart._id, currentSessionId);\n    }\n  });\n});","map":{"version":3,"sources":["/server/startup/accounts.js"],"names":["Meteor","Collections","Hooks","Logger","Reaction","Accounts","validateLoginAttempt","attempt","allowed","type","methodName","user","loginEmail","methodArguments","email","adminEmail","process","env","REACTION_EMAIL","userEmail","_","filter","emails","address","length","verified","Error","registerLoginHandler","options","anonymous","stampedToken","_generateStampedLoginToken","userId","insertUserDoc","services","token","loginHandler","onCreateUser","shop","getCurrentShop","shopId","_id","defaultVisitorRole","defaultRoles","roles","additionals","profile","Object","assign","users","find","count","currentUser","lang","currency","service","provides","push","name","username","picture","profile_image_url_https","dprofile_image_url_https","profile_picture","account","insert","call","userDoc","Events","run","onLogin","opts","update","$pullAll","getShopId","multi","debug","cart","Cart","findOne","currentSessionId","sessionId"],"mappings":"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","file":"/server/startup/accounts.js.map","sourcesContent":["import { Meteor } from \"meteor/meteor\";\nimport * as Collections from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\nexport default function () {\n  /**\n   * Make sure initial admin user has verified their\n   * email before allowing them to login.\n   *\n   * http://docs.meteor.com/#/full/accounts_validateloginattempt\n   */\n\n  Accounts.validateLoginAttempt(function (attempt) {\n    if (!attempt.allowed) {\n      return false;\n    }\n\n    // confirm this is the accounts-password login method\n    if (attempt.type !== \"password\" || attempt.methodName !== \"login\") {\n      return attempt.allowed;\n    }\n\n    if (!attempt.user) {\n      return attempt.allowed;\n    }\n\n    const loginEmail = attempt.methodArguments[0].user.email;\n    const adminEmail = process.env.REACTION_EMAIL;\n\n    if (loginEmail && loginEmail === adminEmail) {\n      // filter out the matching login email from any existing emails\n      const userEmail = _.filter(attempt.user.emails, function (email) {\n        return email.address === loginEmail;\n      });\n\n      // check if the email is verified\n      if (!userEmail.length || !userEmail[0].verified) {\n        throw new Meteor.Error(\"403\", \"Oops! Please validate your email first.\");\n      }\n    }\n\n    return attempt.allowed;\n  });\n\n  /**\n   * Reaction Accounts handlers\n   * creates a login type \"anonymous\"\n   * default for all unauthenticated visitors\n   */\n  Accounts.registerLoginHandler(function (options) {\n    if (!options.anonymous) {\n      return {};\n    }\n    const stampedToken = Accounts._generateStampedLoginToken();\n    const userId = Accounts.insertUserDoc({\n      services: {\n        anonymous: true\n      },\n      token: stampedToken.token\n    });\n    const loginHandler = {\n      type: \"anonymous\",\n      userId: userId\n    };\n    return loginHandler;\n  });\n\n  /**\n   * Accounts.onCreateUser event\n   * adding either a guest or anonymous role to the user on create\n   * adds Accounts record for reaction user profiles\n   * we clone the user into accounts, as the user collection is\n   * only to be used for authentication.\n   * - defaultVisitorRole\n   * - defaultRoles\n   * can be overriden from Shops\n   *\n   * @see: http://docs.meteor.com/#/full/accounts_oncreateuser\n   */\n  Accounts.onCreateUser((options, user) => {\n    const shop = Reaction.getCurrentShop();\n    const shopId = shop._id;\n    const defaultVisitorRole =  [\"anonymous\", \"guest\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"];\n    const defaultRoles =  [\"guest\", \"account/profile\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"];\n    const roles = {};\n    const additionals = {\n      profile: Object.assign({}, options && options.profile)\n    };\n    if (!user.emails) user.emails = [];\n    // init default user roles\n    // we won't create users unless we have a shop.\n    if (shop) {\n      // retain language when user has defined a language\n      // perhaps should be treated as additionals\n      // or in onLogin below, or in the anonymous method options\n      if (!(Meteor.users.find().count() === 0)) { // dont set on inital admin\n        if (!user.profile) user.profile = {};\n        const currentUser = Meteor.user(user);\n        if (currentUser && currentUser.profile) {\n          if (currentUser.profile.lang && !user.profile.lang) {\n            user.profile.lang = currentUser.profile.lang;\n          }\n          if (currentUser.profile.currency && !user.profile.currency) {\n            user.profile.currency = currentUser.profile.currency;\n          }\n        }\n      }\n\n      // if we don't have user.services we're an anonymous user\n      if (!user.services) {\n        roles[shopId] = shop.defaultVisitorRole || defaultVisitorRole;\n      } else {\n        roles[shopId] = shop.defaultRoles || defaultRoles;\n        // also add services with email defined to user.emails[]\n        for (const service in user.services) {\n          if (user.services[service].email) {\n            const email = {\n              provides: \"default\",\n              address: user.services[service].email,\n              verified: true\n            };\n            user.emails.push(email);\n          }\n          if (user.services[service].name) {\n            user.username = user.services[service].name;\n            additionals.profile.name = user.services[service].name;\n          }\n          // TODO: For now we have here instagram, twitter and google avatar cases\n          // need to make complete list\n          if (user.services[service].picture) {\n            additionals.profile.picture = user.services[service].picture;\n          } else if (user.services[service].profile_image_url_https) {\n            additionals.profile.picture = user.services[service].\n              dprofile_image_url_https;\n          } else if (user.services[service].profile_picture) {\n            additionals.profile.picture = user.services[service].profile_picture;\n          }\n        }\n      }\n      // clone before adding roles\n      const account = Object.assign({}, user, additionals);\n      account.userId = user._id;\n      Collections.Accounts.insert(account);\n\n      // send a welcome email to new users,\n      // but skip the first default admin user\n      // (default admins already get a verification email)\n      if (!(Meteor.users.find().count() === 0)) {\n        Meteor.call(\"accounts/sendWelcomeEmail\", shopId, user._id);\n      }\n\n      // assign default user roles\n      user.roles = roles;\n\n      // run onCreateUser hooks\n      // (the user object must be returned by all callbacks)\n      const userDoc = Hooks.Events.run(\"onCreateUser\", user, options);\n      return userDoc;\n    }\n  });\n\n  /**\n   * Accounts.onLogin event\n   * let's remove \"anonymous\" role, if the login type isn't \"anonymous\"\n   * @param {Object} options - user account creation options\n   * @fires \"cart/mergeCart\" Method\n   */\n  Accounts.onLogin((opts) => {\n    // run onLogin hooks\n    // (the options object must be returned by all callbacks)\n    options = Hooks.Events.run(\"onLogin\", opts);\n\n    // remove anonymous role\n    // all users are guest, but anonymous user don't have profile access\n    // or ability to order history, etc. so ensure its removed upon login.\n    if (options.type !== \"anonymous\" && options.type !== \"resume\") {\n      const update = {\n        $pullAll: {}\n      };\n\n      update.$pullAll[\"roles.\" + Reaction.getShopId()] = [\"anonymous\"];\n\n      Meteor.users.update({\n        _id: options.user._id\n      }, update, {\n        multi: true\n      });\n      // debug info\n      Logger.debug(\"removed anonymous role from user: \" +\n        options.user._id);\n\n      // do not call `cart/mergeCart` on methodName === `createUser`, because\n      // in this case `cart/mergeCart` calls from cart publication\n      if (options.methodName === \"createUser\") return true;\n\n      // onLogin, we want to merge session cart into user cart.\n      const cart = Collections.Cart.findOne({\n        userId: options.user._id\n      });\n\n      // for a rare use cases\n      if (typeof cart !== \"object\") return false;\n      // in current version currentSessionId will be available for anonymous\n      // users only, because it is unknown for me how to pass sessionId when user\n      // logged in\n      const currentSessionId = options.methodArguments &&\n        options.methodArguments.length === 1 &&\n        options.methodArguments[0].sessionId;\n\n      // changing of workflow status from now happens within `cart/mergeCart`\n      return Meteor.call(\"cart/mergeCart\", cart._id, currentSessionId);\n    }\n  });\n}\n"]},"hash":"a90377147b37c7861797dfcefe4ef10e46d06a57"}
