{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"accounting-js","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"accounting"}]}],"exports":{"exported":["orderTransform"],"specifiers":[{"kind":"local","local":"orderTransform","exported":"orderTransform"}]}}},"options":{"filename":"/lib/collections/transform/order.js","filenameRelative":"/lib/collections/transform/order.js","inputSourceMap":{"version":3,"sources":["/lib/collections/transform/order.js"],"names":["accounting","getSummary","items","prop","prop2","Array","isArray","reduce","sum","item","length","e","orderTransform","orderCount","orderShipping","rate","shipping","handling","toFixed","orderSubTotal","subTotal","orderTaxes","tax","parseFloat","taxTotal","orderDiscounts","discount","orderTotal","taxes","discountTotal","Math","max","total","itemCount","count","quantity"],"mappings":"AAAA,OAAO;AAAP,AAAuB;WAAvB,AAGA,A;;;;;;;;GACA,AAEA;;;;AAQA,AAAS,AAAW,AAAO,AAAM,AAAO,AACtC,AAAI,AACF,AAAI,AAAM,AAAQ,AAAQ;;;;;;;GACxB,SAAO,AAAM,WAAN,AAAa,OAAA,AAAC,AAAK,MAAN,OAAe,AACjC;MAAA,AAAI,AAAO,AACT;8BACA;mBAAa,iBAAK,KAAL,AAAK,AAAK,AAAO;AAHC,AAMjC;;wEACA,MAAO,KAAO,MAAK,IAAL,MAPT,AAOL,AAAO,AAAO,AAAgB,AAAI,AAAK,AAAK,AACxC,AAAK,AAAK,AAAI,AAAK,AACxB;AATD,AAAO,AASJ,AACJ,SAPK,AAAa,AAAiB,AAAM,AAAW,AAAI,AAAK,AAAM,AAC1D,AAAK,AAAM,AAAI,AAAM,AAC1B,CAPP,AAaC,AAAC;;;AAAA,AAAO,AAAG,oDACV,yBACA;OAVa,EAWb;AACA;WAAA,AAAO,GACR;;AACD;AACD,A,AADC,AAAO,AAGT;;;;;EAUA,AAAO,AAAM,AAAiB,AAC5B,AAAa,AACX,AAAO,AAAW,AAAK,AAAO,AAAC,AAChC;;;;;;;;;;;;0BACe,AACd;mCACA;AAAA,AAAM,AAAO,AAAW,AAAK,AAAU,AAAC,AAAkB,AAC1D;AAAM,6BAAN,AAAiB,AAAW,AAAK,AAAU,AAAC,AAAkB,AAC9D;AAAA,AAAM,AAAW,AAAW,AAAQ,AACpC;QAAO,OAAW,WAAX,AAAmB,KAA1B,AAAO,AAA6B,6BATV,AAU3B;;sCACD;WAAgB,6BACd;AAAA,AAAM,AAAW,AAAW,AAAK,AAAO,AAAC,AAAa,AAAC,AAAY,AACnE;AAAO,6BAbmB,AAa1B,AAAO,AAAW,AAAQ,AAAU,AACrC;;wCACD;AAAa,AACX;0BACA;AACA;AACA;AACA;AAAA,AAAM,AAAM,AAAK,AAAO,AACxB;QAAM,WAAW,OAAjB,AAAiB,AAAW,AAAK,AACjC;QAAM,WAAW,WAAjB,AAA4B,KAC5B;QAAO,WAAA,AAAW,AAAQ,WAvBA,AAuB1B,AAAO,AAA6B,AACrC;;AACD;8BAAiB,AACf;QAAM,WAAW,KAAA,AAAK,YAAtB,AAAkC,AAClC;WAAO,WAAA,AAAW,QAAX,AAAmB,UAA1B,AAAO,AAA6B,AACrC;AA5B2B;0BA6B5B;QAAa,2BACX;QAAM,WAAW,WAAW,KAA5B,AAAiB,AAAW,AAAK,AACjC;QAAM,QAAW,WAAW,KAA5B,AAAiB,AAAW,AAAK,AACjC;QAAM,AAAQ,WAAW,WAAK,KAA9B,AAAc,AAAW,AACzB;QAAM,AAAW,qBAAW,IAAK,cAAjC,AAAiB,AAAW,AAC5B;QAAM,QAAgB,AAAK,gBAAL,AAAS,AAAG,WAAlC,AAAsB,AAAuB,AAC7C;AAAM,WAAQ,mBAAgB,OAA9B,AAAc,AAA2B,AACzC;AAAA,AAAO,AAAW,AAAQ,AAAO,AAClC;AArC2B;gBAsC5B;;cAAY,qBACV;AAAI,AAAQ;;;;;;;;;;;;YAAZ;sBACA;AAAA,AAAI,AAAM,AAAQ,AAAK,AAAQ,AAC7B;AAAA,AAAK,AAAM,AAAQ,AAAK,AAAO,AAC7B;;WAAA,AAAS,AAAK,AACf;AA3CA,AAAuB,AA4CzB,AACD,AAAO,AACR;AA1CD","file":"/lib/collections/transform/order.js.map","sourcesContent":["import accounting from \"accounting-js\";\n\n\n// TODO: This is a duplicate of the cart transform with just the names changed.\n// This should be factored to be just one file for both\n\n/**\n * getSummary\n * @summary iterates over order items with computations\n * @param {Array} items - order.items array\n * @param {Array} prop - path to item property represented by array\n * @param {Array} [prop2] - path to another item property represented by array\n * @return {Number} - computations result\n */\nfunction getSummary(items, prop, prop2) {\n  try {\n    if (Array.isArray(items)) {\n      return items.reduce((sum, item) => {\n        if (prop2) {\n          // S + a * b, where b could be b1 or b2\n          return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] :\n              item[prop2[0]][prop2[1]]);\n        }\n        // S + b, where b could be b1 or b2\n        return sum + (prop.length === 1 ? item[prop[0]] :\n            item[prop[0]][prop[1]]);\n      }, 0);\n    }\n  } catch (e) {\n    // If data not prepared we should send a number to avoid exception with\n    // `toFixed`. This could happens if user stuck on `completed` checkout stage\n    // by some reason.\n    return 0;\n  }\n  return 0;\n}\n\n/**\n * Reaction transform collections\n *\n * transform methods used to return order calculated values\n * orderCount, orderSubTotal, orderShipping, orderTaxes, orderTotal\n * are calculated by a transformation on the collection\n * and are available to use in template as order.xxx\n * in template: {{order.orderCount}}\n * in code: order.findOne().orderTotal()\n */\nexport const orderTransform = {\n  orderCount() {\n    return getSummary(this.items, [\"quantity\"]);\n  },\n  orderShipping() {\n    // loop through the order.shipping, sum shipments.\n    const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"]);\n    const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"]);\n    const shipping = handling + rate || 0;\n    return accounting.toFixed(shipping, 2);\n  },\n  orderSubTotal() {\n    const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"]);\n    return accounting.toFixed(subTotal, 2);\n  },\n  orderTaxes() {\n    // taxes are calculated in a order.after.update hooks\n    // the tax value stored with the order is the effective tax rate\n    // calculated by line items\n    // in the imports/core/taxes plugin\n    const tax = this.tax || 0;\n    const subTotal = parseFloat(this.orderSubTotal());\n    const taxTotal = subTotal * tax;\n    return accounting.toFixed(taxTotal, 2);\n  },\n  orderDiscounts() {\n    const discount = this.discount || 0;\n    return accounting.toFixed(discount, 2);\n  },\n  orderTotal() {\n    const subTotal = parseFloat(this.orderSubTotal());\n    const shipping = parseFloat(this.orderShipping());\n    const taxes = parseFloat(this.orderTaxes());\n    const discount = parseFloat(this.orderDiscounts());\n    const discountTotal = Math.max(0, subTotal - discount);\n    const total = discountTotal + shipping + taxes;\n    return accounting.toFixed(total, 2);\n  },\n  itemCount() {\n    let count = 0;\n    if (Array.isArray(this.items)) {\n      for (const item of this.items) {\n        count += item.quantity;\n      }\n    }\n    return count;\n  }\n};\n\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/lib/collections/transform/order.js.map","sourceFileName":"/lib/collections/transform/order.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"order"},"ignored":false,"code":"module.export({\n  orderTransform: function () {\n    return orderTransform;\n  }\n});\nvar accounting = void 0;\nmodule.importSync(\"accounting-js\", {\n  \"default\": function (v) {\n    accounting = v;\n  }\n}, 0);\n\n// TODO: This is a duplicate of the cart transform with just the names changed.\n// This should be factored to be just one file for both\n/**\n * getSummary\n * @summary iterates over order items with computations\n * @param {Array} items - order.items array\n * @param {Array} prop - path to item property represented by array\n * @param {Array} [prop2] - path to another item property represented by array\n * @return {Number} - computations result\n */function getSummary(items, prop, prop2) {\n  try {\n    if (Array.isArray(items)) {\n      return items.reduce(function (sum, item) {\n        if (prop2) {\n          // S + a * b, where b could be b1 or b2\n          return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] : item[prop2[0]][prop2[1]]);\n        } // S + b, where b could be b1 or b2\n\n\n        return sum + (prop.length === 1 ? item[prop[0]] : item[prop[0]][prop[1]]);\n      }, 0);\n    }\n  } catch (e) {\n    // If data not prepared we should send a number to avoid exception with\n    // `toFixed`. This could happens if user stuck on `completed` checkout stage\n    // by some reason.\n    return 0;\n  }\n\n  return 0;\n} /**\n   * Reaction transform collections\n   *\n   * transform methods used to return order calculated values\n   * orderCount, orderSubTotal, orderShipping, orderTaxes, orderTotal\n   * are calculated by a transformation on the collection\n   * and are available to use in template as order.xxx\n   * in template: {{order.orderCount}}\n   * in code: order.findOne().orderTotal()\n   */\n\nvar orderTransform = {\n  orderCount: function () {\n    return getSummary(this.items, [\"quantity\"]);\n  },\n  orderShipping: function () {\n    // loop through the order.shipping, sum shipments.\n    var rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"]);\n    var handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"]);\n    var shipping = handling + rate || 0;\n    return accounting.toFixed(shipping, 2);\n  },\n  orderSubTotal: function () {\n    var subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"]);\n    return accounting.toFixed(subTotal, 2);\n  },\n  orderTaxes: function () {\n    // taxes are calculated in a order.after.update hooks\n    // the tax value stored with the order is the effective tax rate\n    // calculated by line items\n    // in the imports/core/taxes plugin\n    var tax = this.tax || 0;\n    var subTotal = parseFloat(this.orderSubTotal());\n    var taxTotal = subTotal * tax;\n    return accounting.toFixed(taxTotal, 2);\n  },\n  orderDiscounts: function () {\n    var discount = this.discount || 0;\n    return accounting.toFixed(discount, 2);\n  },\n  orderTotal: function () {\n    var subTotal = parseFloat(this.orderSubTotal());\n    var shipping = parseFloat(this.orderShipping());\n    var taxes = parseFloat(this.orderTaxes());\n    var discount = parseFloat(this.orderDiscounts());\n    var discountTotal = Math.max(0, subTotal - discount);\n    var total = discountTotal + shipping + taxes;\n    return accounting.toFixed(total, 2);\n  },\n  itemCount: function () {\n    var count = 0;\n\n    if (Array.isArray(this.items)) {\n      for (var _iterator = this.items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var item = _ref;\n        count += item.quantity;\n      }\n    }\n\n    return count;\n  }\n};","map":{"version":3,"sources":["/lib/collections/transform/order.js"],"names":["accounting","getSummary","items","prop","prop2","Array","isArray","reduce","sum","item","length","e","orderTransform","orderCount","orderShipping","rate","shipping","handling","toFixed","orderSubTotal","subTotal","orderTaxes","tax","parseFloat","taxTotal","orderDiscounts","discount","orderTotal","taxes","discountTotal","Math","max","total","itemCount","count","quantity"],"mappings":"AAAA,OAAO;AAAP,AAAuB;WAAvB,AAGA,A;;;;;;;;GACA,AAEA;;;;AAQA,AAAS,AAAW,AAAO,AAAM,AAAO,AACtC,AAAI,AACF,AAAI,AAAM,AAAQ,AAAQ;;;;;;;GACxB,SAAO,AAAM,WAAN,AAAa,OAAA,AAAC,AAAK,MAAN,OAAe,AACjC;MAAA,AAAI,AAAO,AACT;8BACA;mBAAa,iBAAK,KAAL,AAAK,AAAK,AAAO;AAHC,AAMjC;;wEACA,MAAO,KAAO,MAAK,IAAL,MAPT,AAOL,AAAO,AAAO,AAAgB,AAAI,AAAK,AAAK,AACxC,AAAK,AAAK,AAAI,AAAK,AACxB;AATD,AAAO,AASJ,AACJ,SAPK,AAAa,AAAiB,AAAM,AAAW,AAAI,AAAK,AAAM,AAC1D,AAAK,AAAM,AAAI,AAAM,AAC1B,CAPP,AAaC,AAAC;;;AAAA,AAAO,AAAG,oDACV,yBACA;OAVa,EAWb;AACA;WAAA,AAAO,GACR;;AACD;AACD,A,AADC,AAAO,AAGT;;;;;EAUA,AAAO,AAAM,AAAiB,AAC5B,AAAa,AACX,AAAO,AAAW,AAAK,AAAO,AAAC,AAChC;;;;;;;;;;;;0BACe,AACd;mCACA;AAAA,AAAM,AAAO,AAAW,AAAK,AAAU,AAAC,AAAkB,AAC1D;AAAM,6BAAN,AAAiB,AAAW,AAAK,AAAU,AAAC,AAAkB,AAC9D;AAAA,AAAM,AAAW,AAAW,AAAQ,AACpC;QAAO,OAAW,WAAX,AAAmB,KAA1B,AAAO,AAA6B,6BATV,AAU3B;;sCACD;WAAgB,6BACd;AAAA,AAAM,AAAW,AAAW,AAAK,AAAO,AAAC,AAAa,AAAC,AAAY,AACnE;AAAO,6BAbmB,AAa1B,AAAO,AAAW,AAAQ,AAAU,AACrC;;wCACD;AAAa,AACX;0BACA;AACA;AACA;AACA;AAAA,AAAM,AAAM,AAAK,AAAO,AACxB;QAAM,WAAW,OAAjB,AAAiB,AAAW,AAAK,AACjC;QAAM,WAAW,WAAjB,AAA4B,KAC5B;QAAO,WAAA,AAAW,AAAQ,WAvBA,AAuB1B,AAAO,AAA6B,AACrC;;AACD;8BAAiB,AACf;QAAM,WAAW,KAAA,AAAK,YAAtB,AAAkC,AAClC;WAAO,WAAA,AAAW,QAAX,AAAmB,UAA1B,AAAO,AAA6B,AACrC;AA5B2B;0BA6B5B;QAAa,2BACX;QAAM,WAAW,WAAW,KAA5B,AAAiB,AAAW,AAAK,AACjC;QAAM,QAAW,WAAW,KAA5B,AAAiB,AAAW,AAAK,AACjC;QAAM,AAAQ,WAAW,WAAK,KAA9B,AAAc,AAAW,AACzB;QAAM,AAAW,qBAAW,IAAK,cAAjC,AAAiB,AAAW,AAC5B;QAAM,QAAgB,AAAK,gBAAL,AAAS,AAAG,WAAlC,AAAsB,AAAuB,AAC7C;AAAM,WAAQ,mBAAgB,OAA9B,AAAc,AAA2B,AACzC;AAAA,AAAO,AAAW,AAAQ,AAAO,AAClC;AArC2B;gBAsC5B;;cAAY,qBACV;AAAI,AAAQ;;;;;;;;;;;;YAAZ;sBACA;AAAA,AAAI,AAAM,AAAQ,AAAK,AAAQ,AAC7B;AAAA,AAAK,AAAM,AAAQ,AAAK,AAAO,AAC7B;;WAAA,AAAS,AAAK,AACf;AA3CA,AAAuB,AA4CzB,AACD,AAAO,AACR;AA1CD","file":"/lib/collections/transform/order.js.map","sourcesContent":["import accounting from \"accounting-js\";\n\n\n// TODO: This is a duplicate of the cart transform with just the names changed.\n// This should be factored to be just one file for both\n\n/**\n * getSummary\n * @summary iterates over order items with computations\n * @param {Array} items - order.items array\n * @param {Array} prop - path to item property represented by array\n * @param {Array} [prop2] - path to another item property represented by array\n * @return {Number} - computations result\n */\nfunction getSummary(items, prop, prop2) {\n  try {\n    if (Array.isArray(items)) {\n      return items.reduce((sum, item) => {\n        if (prop2) {\n          // S + a * b, where b could be b1 or b2\n          return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] :\n              item[prop2[0]][prop2[1]]);\n        }\n        // S + b, where b could be b1 or b2\n        return sum + (prop.length === 1 ? item[prop[0]] :\n            item[prop[0]][prop[1]]);\n      }, 0);\n    }\n  } catch (e) {\n    // If data not prepared we should send a number to avoid exception with\n    // `toFixed`. This could happens if user stuck on `completed` checkout stage\n    // by some reason.\n    return 0;\n  }\n  return 0;\n}\n\n/**\n * Reaction transform collections\n *\n * transform methods used to return order calculated values\n * orderCount, orderSubTotal, orderShipping, orderTaxes, orderTotal\n * are calculated by a transformation on the collection\n * and are available to use in template as order.xxx\n * in template: {{order.orderCount}}\n * in code: order.findOne().orderTotal()\n */\nexport const orderTransform = {\n  orderCount() {\n    return getSummary(this.items, [\"quantity\"]);\n  },\n  orderShipping() {\n    // loop through the order.shipping, sum shipments.\n    const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"]);\n    const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"]);\n    const shipping = handling + rate || 0;\n    return accounting.toFixed(shipping, 2);\n  },\n  orderSubTotal() {\n    const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"]);\n    return accounting.toFixed(subTotal, 2);\n  },\n  orderTaxes() {\n    // taxes are calculated in a order.after.update hooks\n    // the tax value stored with the order is the effective tax rate\n    // calculated by line items\n    // in the imports/core/taxes plugin\n    const tax = this.tax || 0;\n    const subTotal = parseFloat(this.orderSubTotal());\n    const taxTotal = subTotal * tax;\n    return accounting.toFixed(taxTotal, 2);\n  },\n  orderDiscounts() {\n    const discount = this.discount || 0;\n    return accounting.toFixed(discount, 2);\n  },\n  orderTotal() {\n    const subTotal = parseFloat(this.orderSubTotal());\n    const shipping = parseFloat(this.orderShipping());\n    const taxes = parseFloat(this.orderTaxes());\n    const discount = parseFloat(this.orderDiscounts());\n    const discountTotal = Math.max(0, subTotal - discount);\n    const total = discountTotal + shipping + taxes;\n    return accounting.toFixed(total, 2);\n  },\n  itemCount() {\n    let count = 0;\n    if (Array.isArray(this.items)) {\n      for (const item of this.items) {\n        count += item.quantity;\n      }\n    }\n    return count;\n  }\n};\n\n"]},"hash":"4b13e0b88f712c543fd1a78497a97bde95c8d959"}
