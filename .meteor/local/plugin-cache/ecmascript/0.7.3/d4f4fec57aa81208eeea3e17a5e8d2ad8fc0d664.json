{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"lodash/map","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"_map"}]},{"source":"/lib/collections","imported":["*"],"specifiers":[{"kind":"namespace","local":"Collections"}]},{"source":"/server/api","imported":["Reaction"],"specifiers":[{"kind":"named","imported":"Reaction","local":"Reaction"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/server/publications/collections/accounts.js","filenameRelative":"/server/publications/collections/accounts.js","inputSourceMap":{"version":3,"sources":["/server/publications/collections/accounts.js"],"names":["Collections","Reaction","Meteor","publish","userId","check","Match","OneOf","String","ready","shopId","getShopId","nonAnonUsers","users","find","$nin","fields","_id","fetch","Roles","userIsInRole","GLOBAL_GROUP","Accounts","$in","profileUserId","permissions"],"mappings":"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","file":"/server/publications/collections/accounts.js.map","sourcesContent":["import _ from \"lodash\";\nimport * as Collections from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * accounts\n */\n\nMeteor.publish(\"Accounts\", function (userId) {\n  check(userId, Match.OneOf(String, null));\n  // we could additionally make checks of useId defined, but this could lead to\n  // situation when user will may not have time to get an account\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  const nonAnonUsers = _.map(Meteor.users.find({\n    [`roles.${shopId}`]: {\n      $nin: [ \"anonymous\" ]\n    }\n  }, {\n    fields: { _id: 1 }\n  }).fetch(), \"_id\");\n\n  // global admin can get all accounts\n  if (Roles.userIsInRole(this.userId, [\"owner\"], Roles.GLOBAL_GROUP)) {\n    return Collections.Accounts.find({\n      _id: { $in: nonAnonUsers }\n    });\n  // shop admin gets accounts for just this shop\n  } else if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    return Collections.Accounts.find({\n      _id: { $in: nonAnonUsers },\n      shopId: shopId\n    });\n  }\n  // regular users should get just their account\n  return Collections.Accounts.find({\n    userId: this.userId\n  });\n});\n\n/**\n * Single account\n * @params {String} userId -  id of user to find\n */\nMeteor.publish(\"UserAccount\", function (userId) {\n  check(userId, Match.OneOf(String, null));\n\n  const shopId = Reaction.getShopId();\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    return Collections.Accounts.find({\n      userId: userId\n    });\n  }\n  return this.ready();\n});\n\n/**\n * userProfile\n * @deprecated since version 0.10.2\n * get any user name,social profile image\n * should be limited, secure information\n * users with permissions  [\"dashboard/orders\", \"owner\", \"admin\", \"dashboard/\n * customers\"] may view the profileUserId\"s profile data.\n *\n * @params {String} profileUserId -  view this users profile when permitted\n */\nMeteor.publish(\"UserProfile\", function (profileUserId) {\n  check(profileUserId, Match.OneOf(String, null));\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  const permissions = [\"dashboard/orders\", \"owner\", \"admin\",\n    \"dashboard/customers\"];\n  // no need to normal user so see his password hash\n  const fields = {\n    \"emails\": 1,\n    \"profile.lang\": 1,\n    \"profile.firstName\": 1,\n    \"profile.lastName\": 1,\n    \"profile.familyName\": 1,\n    \"profile.secondName\": 1,\n    \"profile.name\": 1,\n    \"services.twitter.profile_image_url_https\": 1,\n    \"services.facebook.id\": 1,\n    \"services.google.picture\": 1,\n    \"services.github.username\": 1,\n    \"services.instagram.profile_picture\": 1\n  };\n  // TODO: this part currently not working as expected.\n  // we could have three situation here:\n  // 1 - registered user log in.\n  // 2 - admin log in\n  // 3 - admin want to get user data\n  // I'm not sure about the 3rd case, but we do not cover 2nd case here, because\n  // we can see a situation when anonymous user still represented by\n  // `profileUserId`, but admin user already could be found by `this.userId`\n  // In that case what we should do here?\n  if (profileUserId !== this.userId && Roles.userIsInRole(this.userId,\n    permissions, shopId ||\n    Roles.userIsInRole(this.userId, permissions, Roles.GLOBAL_GROUP))) {\n    return Meteor.users.find({\n      _id: profileUserId\n    }, {\n      fields: fields\n    });\n  }\n\n  return Meteor.users.find({\n    _id: this.userId\n  }, {\n    fields: fields\n  });\n});\n"]},"env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/server/publications/collections/accounts.js.map","sourceFileName":"/server/publications/collections/accounts.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"accounts"},"ignored":false,"code":"var _map = void 0;\n\nmodule.importSync(\"lodash/map\", {\n  \"default\": function (v) {\n    _map = v;\n  }\n}, 0);\nvar Collections = Object.create(null);\nmodule.importSync(\"/lib/collections\", {\n  \"*\": function (v, n) {\n    Collections[n] = v;\n  }\n}, 1);\nvar Reaction = void 0;\nmodule.importSync(\"/server/api\", {\n  Reaction: function (v) {\n    Reaction = v;\n  }\n}, 2);\n/**\n * accounts\n */Meteor.publish(\"Accounts\", function (userId) {\n  var _Meteor$users$find;\n\n  check(userId, Match.OneOf(String, null)); // we could additionally make checks of useId defined, but this could lead to\n  // situation when user will may not have time to get an account\n\n  if (this.userId === null) {\n    return this.ready();\n  }\n\n  var shopId = Reaction.getShopId();\n\n  if (!shopId) {\n    return this.ready();\n  }\n\n  var nonAnonUsers = _map(Meteor.users.find((_Meteor$users$find = {}, _Meteor$users$find[\"roles.\" + shopId] = {\n    $nin: [\"anonymous\"]\n  }, _Meteor$users$find), {\n    fields: {\n      _id: 1\n    }\n  }).fetch(), \"_id\"); // global admin can get all accounts\n\n\n  if (Roles.userIsInRole(this.userId, [\"owner\"], Roles.GLOBAL_GROUP)) {\n    return Collections.Accounts.find({\n      _id: {\n        $in: nonAnonUsers\n      }\n    }); // shop admin gets accounts for just this shop\n  } else if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    return Collections.Accounts.find({\n      _id: {\n        $in: nonAnonUsers\n      },\n      shopId: shopId\n    });\n  } // regular users should get just their account\n\n\n  return Collections.Accounts.find({\n    userId: this.userId\n  });\n}); /**\n     * Single account\n     * @params {String} userId -  id of user to find\n     */\nMeteor.publish(\"UserAccount\", function (userId) {\n  check(userId, Match.OneOf(String, null));\n  var shopId = Reaction.getShopId();\n\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    return Collections.Accounts.find({\n      userId: userId\n    });\n  }\n\n  return this.ready();\n}); /**\n     * userProfile\n     * @deprecated since version 0.10.2\n     * get any user name,social profile image\n     * should be limited, secure information\n     * users with permissions  [\"dashboard/orders\", \"owner\", \"admin\", \"dashboard/\n     * customers\"] may view the profileUserId\"s profile data.\n     *\n     * @params {String} profileUserId -  view this users profile when permitted\n     */\nMeteor.publish(\"UserProfile\", function (profileUserId) {\n  check(profileUserId, Match.OneOf(String, null));\n\n  if (this.userId === null) {\n    return this.ready();\n  }\n\n  var shopId = Reaction.getShopId();\n\n  if (!shopId) {\n    return this.ready();\n  }\n\n  var permissions = [\"dashboard/orders\", \"owner\", \"admin\", \"dashboard/customers\"]; // no need to normal user so see his password hash\n\n  var fields = {\n    \"emails\": 1,\n    \"profile.lang\": 1,\n    \"profile.firstName\": 1,\n    \"profile.lastName\": 1,\n    \"profile.familyName\": 1,\n    \"profile.secondName\": 1,\n    \"profile.name\": 1,\n    \"services.twitter.profile_image_url_https\": 1,\n    \"services.facebook.id\": 1,\n    \"services.google.picture\": 1,\n    \"services.github.username\": 1,\n    \"services.instagram.profile_picture\": 1\n  }; // TODO: this part currently not working as expected.\n  // we could have three situation here:\n  // 1 - registered user log in.\n  // 2 - admin log in\n  // 3 - admin want to get user data\n  // I'm not sure about the 3rd case, but we do not cover 2nd case here, because\n  // we can see a situation when anonymous user still represented by\n  // `profileUserId`, but admin user already could be found by `this.userId`\n  // In that case what we should do here?\n\n  if (profileUserId !== this.userId && Roles.userIsInRole(this.userId, permissions, shopId || Roles.userIsInRole(this.userId, permissions, Roles.GLOBAL_GROUP))) {\n    return Meteor.users.find({\n      _id: profileUserId\n    }, {\n      fields: fields\n    });\n  }\n\n  return Meteor.users.find({\n    _id: this.userId\n  }, {\n    fields: fields\n  });\n});","map":{"version":3,"sources":["/server/publications/collections/accounts.js"],"names":["Collections","Reaction","Meteor","publish","userId","check","Match","OneOf","String","ready","shopId","getShopId","nonAnonUsers","users","find","$nin","fields","_id","fetch","Roles","userIsInRole","GLOBAL_GROUP","Accounts","$in","profileUserId","permissions"],"mappings":"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","file":"/server/publications/collections/accounts.js.map","sourcesContent":["import _ from \"lodash\";\nimport * as Collections from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * accounts\n */\n\nMeteor.publish(\"Accounts\", function (userId) {\n  check(userId, Match.OneOf(String, null));\n  // we could additionally make checks of useId defined, but this could lead to\n  // situation when user will may not have time to get an account\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  const nonAnonUsers = _.map(Meteor.users.find({\n    [`roles.${shopId}`]: {\n      $nin: [ \"anonymous\" ]\n    }\n  }, {\n    fields: { _id: 1 }\n  }).fetch(), \"_id\");\n\n  // global admin can get all accounts\n  if (Roles.userIsInRole(this.userId, [\"owner\"], Roles.GLOBAL_GROUP)) {\n    return Collections.Accounts.find({\n      _id: { $in: nonAnonUsers }\n    });\n  // shop admin gets accounts for just this shop\n  } else if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    return Collections.Accounts.find({\n      _id: { $in: nonAnonUsers },\n      shopId: shopId\n    });\n  }\n  // regular users should get just their account\n  return Collections.Accounts.find({\n    userId: this.userId\n  });\n});\n\n/**\n * Single account\n * @params {String} userId -  id of user to find\n */\nMeteor.publish(\"UserAccount\", function (userId) {\n  check(userId, Match.OneOf(String, null));\n\n  const shopId = Reaction.getShopId();\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    return Collections.Accounts.find({\n      userId: userId\n    });\n  }\n  return this.ready();\n});\n\n/**\n * userProfile\n * @deprecated since version 0.10.2\n * get any user name,social profile image\n * should be limited, secure information\n * users with permissions  [\"dashboard/orders\", \"owner\", \"admin\", \"dashboard/\n * customers\"] may view the profileUserId\"s profile data.\n *\n * @params {String} profileUserId -  view this users profile when permitted\n */\nMeteor.publish(\"UserProfile\", function (profileUserId) {\n  check(profileUserId, Match.OneOf(String, null));\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  const permissions = [\"dashboard/orders\", \"owner\", \"admin\",\n    \"dashboard/customers\"];\n  // no need to normal user so see his password hash\n  const fields = {\n    \"emails\": 1,\n    \"profile.lang\": 1,\n    \"profile.firstName\": 1,\n    \"profile.lastName\": 1,\n    \"profile.familyName\": 1,\n    \"profile.secondName\": 1,\n    \"profile.name\": 1,\n    \"services.twitter.profile_image_url_https\": 1,\n    \"services.facebook.id\": 1,\n    \"services.google.picture\": 1,\n    \"services.github.username\": 1,\n    \"services.instagram.profile_picture\": 1\n  };\n  // TODO: this part currently not working as expected.\n  // we could have three situation here:\n  // 1 - registered user log in.\n  // 2 - admin log in\n  // 3 - admin want to get user data\n  // I'm not sure about the 3rd case, but we do not cover 2nd case here, because\n  // we can see a situation when anonymous user still represented by\n  // `profileUserId`, but admin user already could be found by `this.userId`\n  // In that case what we should do here?\n  if (profileUserId !== this.userId && Roles.userIsInRole(this.userId,\n    permissions, shopId ||\n    Roles.userIsInRole(this.userId, permissions, Roles.GLOBAL_GROUP))) {\n    return Meteor.users.find({\n      _id: profileUserId\n    }, {\n      fields: fields\n    });\n  }\n\n  return Meteor.users.find({\n    _id: this.userId\n  }, {\n    fields: fields\n  });\n});\n"]},"hash":"d4f4fec57aa81208eeea3e17a5e8d2ad8fc0d664"}
