{"version":3,"sources":["meteor://ðŸ’»app/imports/plugins/core/discounts/lib/collections/schemas/config.js","meteor://ðŸ’»app/imports/plugins/core/discounts/lib/collections/schemas/discounts.js","meteor://ðŸ’»app/imports/plugins/core/discounts/lib/collections/schemas/index.js","meteor://ðŸ’»app/imports/plugins/core/discounts/lib/collections/collections.js","meteor://ðŸ’»app/imports/plugins/core/discounts/lib/collections/index.js","meteor://ðŸ’»app/imports/plugins/core/discounts/server/api/import.js","meteor://ðŸ’»app/imports/plugins/core/discounts/server/api/index.js","meteor://ðŸ’»app/imports/plugins/core/discounts/server/hooks/cart.js","meteor://ðŸ’»app/imports/plugins/core/discounts/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/discounts/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/core/discounts/server/methods/methods.js","meteor://ðŸ’»app/imports/plugins/core/discounts/server/publications/discounts.js","meteor://ðŸ’»app/imports/plugins/core/discounts/server/security/discounts.js","meteor://ðŸ’»app/imports/plugins/core/discounts/server/index.js","meteor://ðŸ’»app/imports/plugins/core/discounts/register.js","meteor://ðŸ’»app/imports/plugins/core/taxes/lib/collections/schemas/config.js","meteor://ðŸ’»app/imports/plugins/core/taxes/lib/collections/schemas/index.js","meteor://ðŸ’»app/imports/plugins/core/taxes/lib/collections/schemas/taxcodes.js","meteor://ðŸ’»app/imports/plugins/core/taxes/lib/collections/schemas/taxes.js","meteor://ðŸ’»app/imports/plugins/core/taxes/lib/collections/schemas/taxrates.js","meteor://ðŸ’»app/imports/plugins/core/taxes/lib/collections/collections.js","meteor://ðŸ’»app/imports/plugins/core/taxes/lib/collections/index.js","meteor://ðŸ’»app/imports/plugins/core/taxes/server/api/import.js","meteor://ðŸ’»app/imports/plugins/core/taxes/server/api/index.js","meteor://ðŸ’»app/imports/plugins/core/taxes/server/hooks/taxes.js","meteor://ðŸ’»app/imports/plugins/core/taxes/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/taxes/server/methods/methods.js","meteor://ðŸ’»app/imports/plugins/core/taxes/server/publications/taxes.js","meteor://ðŸ’»app/imports/plugins/core/taxes/server/index.js","meteor://ðŸ’»app/imports/plugins/core/taxes/register.js","meteor://ðŸ’»app/imports/plugins/core/templates/lib/collections/schemas/emailtemplates.js","meteor://ðŸ’»app/imports/plugins/core/templates/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/templates/server/index.js","meteor://ðŸ’»app/imports/plugins/core/templates/server/methods.js","meteor://ðŸ’»app/imports/plugins/core/templates/register.js","meteor://ðŸ’»app/imports/plugins/core/revisions/lib/api/index.js","meteor://ðŸ’»app/imports/plugins/core/revisions/lib/api/revisions.js","meteor://ðŸ’»app/imports/plugins/core/revisions/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/revisions/server/hooks.js","meteor://ðŸ’»app/imports/plugins/core/revisions/server/index.js","meteor://ðŸ’»app/imports/plugins/core/revisions/server/methods.js","meteor://ðŸ’»app/imports/plugins/core/revisions/register.js","meteor://ðŸ’»app/imports/plugins/core/shipping/server/lib/roles.js","meteor://ðŸ’»app/imports/plugins/core/shipping/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/shipping/server/methods/methods.js","meteor://ðŸ’»app/imports/plugins/core/shipping/server/index.js","meteor://ðŸ’»app/imports/plugins/core/shipping/register.js","meteor://ðŸ’»app/imports/plugins/core/layout/lib/blazeLayout.js","meteor://ðŸ’»app/imports/plugins/core/layout/lib/components.js","meteor://ðŸ’»app/imports/plugins/core/layout/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/layout/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/core/layout/server/methods/templates.js","meteor://ðŸ’»app/imports/plugins/core/layout/server/publications/templates.js","meteor://ðŸ’»app/imports/plugins/core/layout/server/index.js","meteor://ðŸ’»app/imports/plugins/core/layout/server/theme.js","meteor://ðŸ’»app/imports/plugins/core/layout/register.js","meteor://ðŸ’»app/imports/plugins/core/router/lib/hooks.js","meteor://ðŸ’»app/imports/plugins/core/router/lib/index.js","meteor://ðŸ’»app/imports/plugins/core/router/lib/router.js","meteor://ðŸ’»app/imports/plugins/core/router/register.js","meteor://ðŸ’»app/imports/plugins/core/accounts/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/accounts/server/index.js","meteor://ðŸ’»app/imports/plugins/core/accounts/register.js","meteor://ðŸ’»app/imports/plugins/core/catalog/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/catalog/server/index.js","meteor://ðŸ’»app/imports/plugins/core/catalog/register.js","meteor://ðŸ’»app/imports/plugins/core/checkout/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/checkout/server/methods/workflow.js","meteor://ðŸ’»app/imports/plugins/core/checkout/server/index.js","meteor://ðŸ’»app/imports/plugins/core/checkout/register.js","meteor://ðŸ’»app/imports/plugins/core/dashboard/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/dashboard/server/index.js","meteor://ðŸ’»app/imports/plugins/core/dashboard/register.js","meteor://ðŸ’»app/imports/plugins/core/email/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/email/server/index.js","meteor://ðŸ’»app/imports/plugins/core/email/register.js","meteor://ðŸ’»app/imports/plugins/core/i18n/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/i18n/server/index.js","meteor://ðŸ’»app/imports/plugins/core/i18n/register.js","meteor://ðŸ’»app/imports/plugins/core/orders/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/orders/server/index.js","meteor://ðŸ’»app/imports/plugins/core/orders/server/startup.js","meteor://ðŸ’»app/imports/plugins/core/orders/register.js","meteor://ðŸ’»app/imports/plugins/core/payments/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/payments/server/index.js","meteor://ðŸ’»app/imports/plugins/core/payments/register.js","meteor://ðŸ’»app/imports/plugins/core/ui/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/ui/server/index.js","meteor://ðŸ’»app/imports/plugins/core/ui/register.js","meteor://ðŸ’»app/imports/plugins/core/ui-grid/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/ui-grid/server/index.js","meteor://ðŸ’»app/imports/plugins/core/ui-grid/register.js","meteor://ðŸ’»app/imports/plugins/core/ui-navbar/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/ui-navbar/server/index.js","meteor://ðŸ’»app/imports/plugins/core/ui-navbar/register.js","meteor://ðŸ’»app/imports/plugins/core/ui-tagnav/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/ui-tagnav/server/index.js","meteor://ðŸ’»app/imports/plugins/core/ui-tagnav/register.js","meteor://ðŸ’»app/imports/plugins/core/versions/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/core/versions/server/migrations/1_rebuild_account_and_order_search_collections.js","meteor://ðŸ’»app/imports/plugins/core/versions/server/migrations/2_add_key_to_search_ui.js","meteor://ðŸ’»app/imports/plugins/core/versions/server/migrations/3_reset_package_registry.js","meteor://ðŸ’»app/imports/plugins/core/versions/server/migrations/4_update_templates_priority.js","meteor://ðŸ’»app/imports/plugins/core/versions/server/migrations/index.js","meteor://ðŸ’»app/imports/plugins/core/versions/server/index.js","meteor://ðŸ’»app/imports/plugins/core/versions/server/startup.js","meteor://ðŸ’»app/imports/plugins/core/versions/index.js","meteor://ðŸ’»app/imports/plugins/core/versions/register.js","meteor://ðŸ’»app/imports/plugins/core/logging/server/index.js","meteor://ðŸ’»app/imports/plugins/core/logging/server/methods.js","meteor://ðŸ’»app/imports/plugins/core/logging/server/publications.js","meteor://ðŸ’»app/imports/plugins/core/logging/register.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/lib/collections/schemas/codes.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/lib/collections/schemas/config.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/lib/collections/schemas/index.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/server/hooks/orders.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/server/methods/methods.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/server/publications/discounts.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/server/security/discounts.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/server/index.js","meteor://ðŸ’»app/imports/plugins/included/discount-codes/register.js","meteor://ðŸ’»app/imports/plugins/included/discount-rates/lib/collections/schemas/config.js","meteor://ðŸ’»app/imports/plugins/included/discount-rates/lib/collections/schemas/index.js","meteor://ðŸ’»app/imports/plugins/included/discount-rates/lib/collections/schemas/rates.js","meteor://ðŸ’»app/imports/plugins/included/discount-rates/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/discount-rates/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/included/discount-rates/server/methods/methods.js","meteor://ðŸ’»app/imports/plugins/included/discount-rates/server/publications/discounts.js","meteor://ðŸ’»app/imports/plugins/included/discount-rates/server/security/discounts.js","meteor://ðŸ’»app/imports/plugins/included/discount-rates/server/index.js","meteor://ðŸ’»app/imports/plugins/included/shippo/lib/collections/schemas/index.js","meteor://ðŸ’»app/imports/plugins/included/shippo/lib/collections/schemas/shippo.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/lib/roles.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/lib/shippoApiSchema.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/hooks/index.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/hooks/rates.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/hooks/tracking.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/jobs/index.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/jobs/shippo.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/methods/carriers.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/methods/shippo.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/methods/shippoapi.js","meteor://ðŸ’»app/imports/plugins/included/shippo/server/index.js","meteor://ðŸ’»app/imports/plugins/included/shippo/register.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/lib/api/express.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/lib/api/index.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/lib/api/payflow.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/server/methods/express.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/server/methods/payflow.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/server/methods/payflowproApi.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/server/methods/payflowproMethods.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/server/security/paypal.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/server/startup/startup.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/server/index.js","meteor://ðŸ’»app/imports/plugins/included/payments-paypal/register.js","meteor://ðŸ’»app/imports/plugins/included/product-detail-simple/lib/layout/simple.js","meteor://ðŸ’»app/imports/plugins/included/product-detail-simple/lib/layout/twoColumn.js","meteor://ðŸ’»app/imports/plugins/included/product-detail-simple/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/product-detail-simple/server/index.js","meteor://ðŸ’»app/imports/plugins/included/product-detail-simple/register.js","meteor://ðŸ’»app/imports/plugins/included/shipping-rates/server/lib/roles.js","meteor://ðŸ’»app/imports/plugins/included/shipping-rates/server/hooks/hooks.js","meteor://ðŸ’»app/imports/plugins/included/shipping-rates/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/shipping-rates/server/methods/rates.js","meteor://ðŸ’»app/imports/plugins/included/shipping-rates/server/index.js","meteor://ðŸ’»app/imports/plugins/included/shipping-rates/register.js","meteor://ðŸ’»app/imports/plugins/included/email-templates/lib/paths.js","meteor://ðŸ’»app/imports/plugins/included/email-templates/server/index.js","meteor://ðŸ’»app/imports/plugins/included/launchdock-connect/lib/collections.js","meteor://ðŸ’»app/imports/plugins/included/launchdock-connect/lib/launchdock.js","meteor://ðŸ’»app/imports/plugins/included/launchdock-connect/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/launchdock-connect/server/hooks.js","meteor://ðŸ’»app/imports/plugins/included/launchdock-connect/server/index.js","meteor://ðŸ’»app/imports/plugins/included/launchdock-connect/server/methods.js","meteor://ðŸ’»app/imports/plugins/included/launchdock-connect/server/publications.js","meteor://ðŸ’»app/imports/plugins/included/launchdock-connect/register.js","meteor://ðŸ’»app/imports/plugins/included/analytics/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/analytics/server/index.js","meteor://ðŸ’»app/imports/plugins/included/analytics/server/policy.js","meteor://ðŸ’»app/imports/plugins/included/analytics/server/publications.js","meteor://ðŸ’»app/imports/plugins/included/analytics/server/security.js","meteor://ðŸ’»app/imports/plugins/included/analytics/register.js","meteor://ðŸ’»app/imports/plugins/included/default-theme/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/default-theme/server/index.js","meteor://ðŸ’»app/imports/plugins/included/default-theme/register.js","meteor://ðŸ’»app/imports/plugins/included/inventory/server/hooks/hooks.js","meteor://ðŸ’»app/imports/plugins/included/inventory/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/inventory/server/methods/inventory.js","meteor://ðŸ’»app/imports/plugins/included/inventory/server/methods/statusChanges.js","meteor://ðŸ’»app/imports/plugins/included/inventory/server/publications/inventory.js","meteor://ðŸ’»app/imports/plugins/included/inventory/server/startup/init.js","meteor://ðŸ’»app/imports/plugins/included/inventory/server/index.js","meteor://ðŸ’»app/imports/plugins/included/inventory/register.js","meteor://ðŸ’»app/imports/plugins/included/jobcontrol/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/jobcontrol/server/jobs/cart.js","meteor://ðŸ’»app/imports/plugins/included/jobcontrol/server/jobs/cleanup.js","meteor://ðŸ’»app/imports/plugins/included/jobcontrol/server/jobs/exchangerates.js","meteor://ðŸ’»app/imports/plugins/included/jobcontrol/server/index.js","meteor://ðŸ’»app/imports/plugins/included/jobcontrol/register.js","meteor://ðŸ’»app/imports/plugins/included/notifications/server/hooks/notification.js","meteor://ðŸ’»app/imports/plugins/included/notifications/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/notifications/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/included/notifications/server/methods/notifications.js","meteor://ðŸ’»app/imports/plugins/included/notifications/server/publications/notifications.js","meteor://ðŸ’»app/imports/plugins/included/notifications/server/index.js","meteor://ðŸ’»app/imports/plugins/included/notifications/server/init.js","meteor://ðŸ’»app/imports/plugins/included/notifications/register.js","meteor://ðŸ’»app/imports/plugins/included/payments-authnet/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/payments-authnet/server/methods/authnet.js","meteor://ðŸ’»app/imports/plugins/included/payments-authnet/server/index.js","meteor://ðŸ’»app/imports/plugins/included/payments-authnet/register.js","meteor://ðŸ’»app/imports/plugins/included/payments-braintree/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/payments-braintree/server/methods/braintree.js","meteor://ðŸ’»app/imports/plugins/included/payments-braintree/server/methods/braintreeApi.js","meteor://ðŸ’»app/imports/plugins/included/payments-braintree/server/methods/braintreeMethods.js","meteor://ðŸ’»app/imports/plugins/included/payments-braintree/server/index.js","meteor://ðŸ’»app/imports/plugins/included/payments-braintree/register.js","meteor://ðŸ’»app/imports/plugins/included/payments-stripe/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/payments-stripe/server/methods/stripe.js","meteor://ðŸ’»app/imports/plugins/included/payments-stripe/server/methods/stripeapi.js","meteor://ðŸ’»app/imports/plugins/included/payments-stripe/server/index.js","meteor://ðŸ’»app/imports/plugins/included/payments-stripe/register.js","meteor://ðŸ’»app/imports/plugins/included/product-admin/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/product-admin/server/index.js","meteor://ðŸ’»app/imports/plugins/included/product-admin/register.js","meteor://ðŸ’»app/imports/plugins/included/product-variant/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/product-variant/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/included/product-variant/server/methods/populateTaxCodes.js","meteor://ðŸ’»app/imports/plugins/included/product-variant/server/index.js","meteor://ðŸ’»app/imports/plugins/included/product-variant/register.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/hooks/search.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/jobs/buildSearchCollections.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/jobs/index.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/methods/common.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/methods/formHandler.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/methods/searchcollections.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/methods/transformations.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/publications/searchresults.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/server/index.js","meteor://ðŸ’»app/imports/plugins/included/search-mongo/register.js","meteor://ðŸ’»app/imports/plugins/included/sms/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/sms/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/included/sms/server/methods/sms.js","meteor://ðŸ’»app/imports/plugins/included/sms/server/publications/smsPublication.js","meteor://ðŸ’»app/imports/plugins/included/sms/server/index.js","meteor://ðŸ’»app/imports/plugins/included/sms/register.js","meteor://ðŸ’»app/imports/plugins/included/social/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/social/server/index.js","meteor://ðŸ’»app/imports/plugins/included/social/server/methods.js","meteor://ðŸ’»app/imports/plugins/included/social/server/policy.js","meteor://ðŸ’»app/imports/plugins/included/social/register.js","meteor://ðŸ’»app/imports/plugins/included/taxes-avalara/server/hooks/hooks.js","meteor://ðŸ’»app/imports/plugins/included/taxes-avalara/server/hooks/index.js","meteor://ðŸ’»app/imports/plugins/included/taxes-avalara/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/taxes-avalara/server/jobs/cleanup.js","meteor://ðŸ’»app/imports/plugins/included/taxes-avalara/server/methods/avalogger.js","meteor://ðŸ’»app/imports/plugins/included/taxes-avalara/server/methods/taxCalc.js","meteor://ðŸ’»app/imports/plugins/included/taxes-avalara/server/index.js","meteor://ðŸ’»app/imports/plugins/included/taxes-avalara/register.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxcloud/server/hooks/hooks.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxcloud/server/hooks/index.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxcloud/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxcloud/server/methods/index.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxcloud/server/methods/methods.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxcloud/server/index.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxcloud/register.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxjar/server/hooks/hooks.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxjar/server/hooks/index.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxjar/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/taxes-taxjar/server/index.js","meteor://ðŸ’»app/imports/plugins/included/ui-search/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/included/ui-search/server/index.js","meteor://ðŸ’»app/imports/plugins/included/ui-search/register.js","meteor://ðŸ’»app/imports/plugins/custom/payments-example/server/i18n/index.js","meteor://ðŸ’»app/imports/plugins/custom/payments-example/server/methods/example.js","meteor://ðŸ’»app/imports/plugins/custom/payments-example/server/methods/exampleapi.js","meteor://ðŸ’»app/imports/plugins/custom/payments-example/server/index.js","meteor://ðŸ’»app/imports/plugins/custom/payments-example/register.js","meteor://ðŸ’»app/lib/api/router/metadata.js","meteor://ðŸ’»app/lib/api/account-validation.js","meteor://ðŸ’»app/lib/api/catalog.js","meteor://ðŸ’»app/lib/api/compose.js","meteor://ðŸ’»app/lib/api/files.js","meteor://ðŸ’»app/lib/api/helpers.js","meteor://ðŸ’»app/lib/api/index.js","meteor://ðŸ’»app/lib/api/match.js","meteor://ðŸ’»app/lib/api/products.js","meteor://ðŸ’»app/lib/api/prop-types.js","meteor://ðŸ’»app/lib/collections/schemas/accounts.js","meteor://ðŸ’»app/lib/collections/schemas/address.js","meteor://ðŸ’»app/lib/collections/schemas/analytics.js","meteor://ðŸ’»app/lib/collections/schemas/assets.js","meteor://ðŸ’»app/lib/collections/schemas/cart.js","meteor://ðŸ’»app/lib/collections/schemas/emails.js","meteor://ðŸ’»app/lib/collections/schemas/helpers.js","meteor://ðŸ’»app/lib/collections/schemas/index.js","meteor://ðŸ’»app/lib/collections/schemas/inventory.js","meteor://ðŸ’»app/lib/collections/schemas/layouts.js","meteor://ðŸ’»app/lib/collections/schemas/logs.js","meteor://ðŸ’»app/lib/collections/schemas/metafield.js","meteor://ðŸ’»app/lib/collections/schemas/notifications.js","meteor://ðŸ’»app/lib/collections/schemas/orders.js","meteor://ðŸ’»app/lib/collections/schemas/payments.js","meteor://ðŸ’»app/lib/collections/schemas/products.js","meteor://ðŸ’»app/lib/collections/schemas/registry.js","meteor://ðŸ’»app/lib/collections/schemas/revisions.js","meteor://ðŸ’»app/lib/collections/schemas/shipping.js","meteor://ðŸ’»app/lib/collections/schemas/shops.js","meteor://ðŸ’»app/lib/collections/schemas/sms.js","meteor://ðŸ’»app/lib/collections/schemas/social.js","meteor://ðŸ’»app/lib/collections/schemas/tags.js","meteor://ðŸ’»app/lib/collections/schemas/templates.js","meteor://ðŸ’»app/lib/collections/schemas/themes.js","meteor://ðŸ’»app/lib/collections/schemas/translations.js","meteor://ðŸ’»app/lib/collections/schemas/workflow.js","meteor://ðŸ’»app/lib/collections/transform/cart.js","meteor://ðŸ’»app/lib/collections/transform/order.js","meteor://ðŸ’»app/lib/collections/collectionFS.js","meteor://ðŸ’»app/lib/collections/collections.js","meteor://ðŸ’»app/lib/collections/index.js","meteor://ðŸ’»app/lib/collections/jobs.js","meteor://ðŸ’»app/lib/collections/search.js","meteor://ðŸ’»app/lib/core/templates.js","meteor://ðŸ’»app/lib/selectors/tags.js","meteor://ðŸ’»app/lib/selectors/variants.js","meteor://ðŸ’»app/server/api/core/accounts/index.js","meteor://ðŸ’»app/server/api/core/accounts/password.js","meteor://ðŸ’»app/server/api/core/email/config.js","meteor://ðŸ’»app/server/api/core/email/email.js","meteor://ðŸ’»app/server/api/core/email/index.js","meteor://ðŸ’»app/server/api/core/addDefaultRoles.js","meteor://ðŸ’»app/server/api/core/assignRoles.js","meteor://ðŸ’»app/server/api/core/core.js","meteor://ðŸ’»app/server/api/core/import.js","meteor://ðŸ’»app/server/api/core/index.js","meteor://ðŸ’»app/server/api/core/loadSettings.js","meteor://ðŸ’»app/server/api/core/rightJoin.js","meteor://ðŸ’»app/server/api/core/setDomain.js","meteor://ðŸ’»app/server/api/core/shopName.js","meteor://ðŸ’»app/server/api/core/templates.js","meteor://ðŸ’»app/server/api/core/ui.js","meteor://ðŸ’»app/server/api/core/utils.js","meteor://ðŸ’»app/server/api/geocoder.js","meteor://ðŸ’»app/server/api/hooks.js","meteor://ðŸ’»app/server/api/index.js","meteor://ðŸ’»app/server/api/logger.js","meteor://ðŸ’»app/server/api/method-hooks.js","meteor://ðŸ’»app/server/api/router.js","meteor://ðŸ’»app/server/methods/core/hooks/cart.js","meteor://ðŸ’»app/server/methods/core/hooks/shop.js","meteor://ðŸ’»app/server/methods/core/workflows/orders.js","meteor://ðŸ’»app/server/methods/core/cart.js","meteor://ðŸ’»app/server/methods/core/orders.js","meteor://ðŸ’»app/server/methods/core/payments.js","meteor://ðŸ’»app/server/methods/core/registry.js","meteor://ðŸ’»app/server/methods/core/shipping.js","meteor://ðŸ’»app/server/methods/core/shop.js","meteor://ðŸ’»app/server/methods/accounts/accounts-password.js","meteor://ðŸ’»app/server/methods/accounts/accounts.js","meteor://ðŸ’»app/server/methods/accounts/serviceConfiguration.js","meteor://ðŸ’»app/server/methods/catalog.js","meteor://ðŸ’»app/server/methods/email.js","meteor://ðŸ’»app/server/methods/i18n.js","meteor://ðŸ’»app/server/methods/index.js","meteor://ðŸ’»app/server/methods/media.js","meteor://ðŸ’»app/server/publications/accounts/serviceConfiguration.js","meteor://ðŸ’»app/server/publications/collections/accounts.js","meteor://ðŸ’»app/server/publications/collections/cart.js","meteor://ðŸ’»app/server/publications/collections/media.js","meteor://ðŸ’»app/server/publications/collections/members.js","meteor://ðŸ’»app/server/publications/collections/orders.js","meteor://ðŸ’»app/server/publications/collections/packages.js","meteor://ðŸ’»app/server/publications/collections/product.js","meteor://ðŸ’»app/server/publications/collections/products.js","meteor://ðŸ’»app/server/publications/collections/revisions.js","meteor://ðŸ’»app/server/publications/collections/sessions.js","meteor://ðŸ’»app/server/publications/collections/shipping.js","meteor://ðŸ’»app/server/publications/collections/shops.js","meteor://ðŸ’»app/server/publications/collections/tags.js","meteor://ðŸ’»app/server/publications/collections/themes.js","meteor://ðŸ’»app/server/publications/collections/translations.js","meteor://ðŸ’»app/server/publications/counts.js","meteor://ðŸ’»app/server/publications/email.js","meteor://ðŸ’»app/server/startup/registry/core.js","meteor://ðŸ’»app/server/startup/registry/index.js","meteor://ðŸ’»app/server/startup/registry/router.js","meteor://ðŸ’»app/server/startup/accounts.js","meteor://ðŸ’»app/server/startup/i18n.js","meteor://ðŸ’»app/server/startup/index.js","meteor://ðŸ’»app/server/startup/init.js","meteor://ðŸ’»app/server/startup/load-data.js","meteor://ðŸ’»app/server/startup/packages.js","meteor://ðŸ’»app/server/startup/prerender.js","meteor://ðŸ’»app/server/startup/registry.js","meteor://ðŸ’»app/server/jobs/email.js","meteor://ðŸ’»app/server/jobs/index.js","meteor://ðŸ’»app/server/security/collections.js","meteor://ðŸ’»app/server/security/index.js","meteor://ðŸ’»app/server/security/policy.js","meteor://ðŸ’»app/server/security/rate-limits.js","meteor://ðŸ’»app/server/plugins.js","meteor://ðŸ’»app/server/main.js"],"names":[],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BA;AACA;AACA;;AAC8G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","file":"/app.js","sourcesContent":["import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { PackageConfig } from \"/lib/collections/schemas/registry\";\nimport { Discounts } from \"./discounts\";\n\n/**\n* DiscountsPackageConfig Schema\n*/\n\nexport const DiscountsPackageConfig = new SimpleSchema([\n  PackageConfig, {\n    \"settings.rates\": {\n      type: Object,\n      optional: true\n    },\n    \"settings.rates.enabled\": {\n      type: Boolean,\n      optional: true,\n      defaultValue: false\n    },\n    \"settings.rates.discounts\": {\n      type: [Discounts],\n      optional: true\n    }\n  }\n]);\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { shopIdAutoValue } from \"/lib/collections/schemas/helpers\";\n\n// The Discounts Schema validates using multiple schemas\n// be sure to use `{ selector: { discountMethod: \"code\" } }`\n// to indicate which schema to apply in all updates\n\n/*\n* Discounts Tranaction History Schema\n*/\nexport const Transactions = new SimpleSchema({\n  cartId: {\n    type: String,\n    index: 1\n  },\n  userId: {\n    type: String,\n    index: 1\n  },\n  appliedAt: {\n    type: Date,\n    optional: true\n  }\n});\n\n/*\n* Discounts Schema\n*/\n\nexport const Discounts = new SimpleSchema({\n  \"shopId\": {\n    type: String,\n    autoValue: shopIdAutoValue,\n    index: 1,\n    label: \"Discounts shopId\"\n  },\n  \"label\": {\n    type: String,\n    optional: true\n  },\n  \"description\": {\n    type: String,\n    optional: true\n  },\n  \"discountMethod\": {\n    label: \"Discount Method Type\",\n    type: String,\n    index: 1,\n    allowedValues: [\"code\", \"rate\"]\n  },\n  // discount is allowed to be string or number.\n  // it's a formula value (could be shipping code)\n  \"discount\": {\n    type: String,\n    optional: true\n  },\n  \"transactions\": {\n    type: [Transactions],\n    optional: true\n  },\n  \"calculation\": {\n    type: Object,\n    optional: true,\n    label: \"Calculation\"\n  },\n  \"calculation.method\": {\n    type: String,\n    index: 1,\n    defaultValue: \"discount\",\n    allowedValues: [\"credit\", \"discount\", \"sale\", \"shipping\"]\n  },\n  \"conditions\": {\n    type: Object,\n    optional: true,\n    label: \"Conditions\"\n  },\n  \"conditions.order\": {\n    type: Object\n  },\n  \"conditions.order.min\": {\n    type: Number,\n    label: \"Mininum\",\n    decimal: true,\n    defaultValue: 0.00\n  },\n  \"conditions.order.max\": {\n    type: Number,\n    label: \"Maximum\",\n    decimal: true,\n    optional: true\n  },\n  \"conditions.order.startDate\": {\n    type: Date,\n    label: \"Start\",\n    optional: true\n  },\n  \"conditions.order.endDate\": {\n    type: Date,\n    label: \"End\",\n    optional: true\n  },\n  \"conditions.enabled\": {\n    type: Boolean,\n    label: \"Enabled\",\n    defaultValue: true,\n    optional: true\n  },\n  \"conditions.audience\": {\n    type: [String],\n    optional: true,\n    label: \"Audience\"\n  },\n  \"conditions.permissions\": {\n    type: [String],\n    optional: true,\n    label: \"Permissions\"\n  },\n  \"conditions.products\": {\n    type: [String],\n    optional: true,\n    label: \"Products\"\n  },\n  \"conditions.tags\": {\n    type: [String],\n    optional: true,\n    label: \"Tags\"\n  }\n});\n","export * from \"./discounts\";\nexport * from \"./config\";\n","import { Mongo } from \"meteor/mongo\";\nimport * as Schemas from \"./schemas\";\n\n/**\n* Discounts Collection\n* @type {Object}\n* @desc Collection for custom discount rates\n* for dollar, percentage, and shipping\n* discount rates.\n*/\nexport const Discounts = new Mongo.Collection(\"Discounts\");\n\nDiscounts.attachSchema(Schemas.Discounts);\n","export * from \"./collections\";\n","import { Reaction } from \"/server/api\";\nimport { Import } from \"/server/api/core/import\";\nimport * as Collections from \"../../lib/collections\";\n\n// plugin Import helpers\nconst DiscountImport = Import;\n\n// Import helper to store a discountRate in the import buffer.\nDiscountImport.discountRate = function (key, discountRate) {\n  return this.object(Collections.Discounts, key, discountRate);\n};\n\n// configure Import key detection\nDiscountImport.indication(\"discount\", Collections.Discounts, 0.5);\n\n// should assign to global\nObject.assign(Reaction.Import, DiscountImport);\n\n// exports Reaction.Import with new discount helper\nexport default Reaction;\n","import Reaction from \"./import\";\n\nexport default Reaction;\n","import { indexOf } from \"lodash\";\nimport { Cart } from \"/lib/collections\";\n\n/**\n* Cart Hooks for Discounts\n* @type {Object}\n* @desc After cart update apply discounts.\n* if items are changed, recalculating discounts\n* we could have done this in the core/cart transform\n* but this way this file controls the events from\n* the core/discounts plugin.\n* @todo just move so a single Hook.event and move all the\n* cart hooks to a single location.\n*/\nCart.after.update((userId, cart, fieldNames) => {\n  const trigger = [\"discount\", \"billing\", \"shipping\"];\n  let discount = 0;\n  if (cart) {\n    for (const field of fieldNames) {\n      if (indexOf(trigger, field) !== -1) {\n        discount = Meteor.call(\"discounts/calculate\", cart);\n      }\n    }\n    // Update cart (without triggering more updates.)\n    Cart.direct.update({ _id: cart._id }, { $set: { discount: discount } });\n  }\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./methods\";\n","import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Cart } from \"/lib/collections\";\nimport { Discounts } from \"../../lib/collections\";\nimport Reaction from \"../api\";\n\n//\n// make all discount methods available\n//\nexport const methods = {\n  /**\n   * discounts/deleteRate\n   * @param  {String} discountId discount id to delete\n   * @return {String} returns update/insert result\n   */\n  \"discounts/deleteRate\": function (discountId) {\n    check(discountId, String);\n\n    // check permissions to delete\n    if (!Reaction.hasPermission(\"discounts\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Discounts.direct.remove({ _id: discountId });\n  },\n\n  /**\n   * discounts/setRate\n   * update the cart discounts without hooks\n   * @param  {String} cartId cartId\n   * @param  {Number} discountRate discountRate\n   * @param  {Object} discounts discounts\n   * @return {Number} returns update result\n   */\n  \"discounts/setRate\": function (cartId, discountRate, discounts) {\n    check(cartId, String);\n    check(discountRate, Number);\n    check(discounts, Match.Optional(Array));\n\n    return Cart.direct.update(cartId, {\n      $set: {\n        discounts: discounts,\n        discount: discountRate\n      }\n    });\n  },\n  /**\n   * discounts/transaction\n   * applies a transaction to discounts for history\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {String} returns update result\n   */\n  \"discounts/transaction\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n\n    const transaction = {\n      cartId: cartId,\n      userId: Meteor.userId(),\n      appliedAt: new Date\n    };\n    // double duty validation, plus we need the method\n    const discount = Discounts.findOne(discountId);\n    return Discounts.update(\n      { _id: discountId },\n      { $addToSet: { transactions: transaction } },\n      { selector: { discountMethod: discount.discountMethod } }\n    );\n  },\n  /**\n   * discounts/calculate\n   * @param  {String} cart cartId\n   * @return {Object}  returns discount object\n   */\n  \"discounts/calculate\": function (cart) {\n    check(cart, Object); // Reaction.Schemas.Cart\n\n    let currentDiscount = 0;\n    // what's going on here?\n    // well, we're getting the real details of the discounts from\n    // the collection, because the publicly stored cart\n    // paymentMethod doesn't quite have all of the pieces (intentionally)\n    if (cart && cart.billing) {\n      for (const billing of cart.billing) {\n        if (billing.paymentMethod) {\n          const discount = Discounts.findOne(billing.paymentMethod.id);\n          if (discount && discount.calculation) {\n            const processor = billing.paymentMethod.processor;\n            const calculation = discount.calculation.method;\n            // we're using processor/calculation\n            // as a convention that can be easily\n            // added in external discount methods\n            // example: discounts/codes/discount\n            // will also not reprocess invoiced orders\n            if (!billing.invoice && processor === \"code\" || processor === \"rate\") {\n              // discounts are additive, if we allow more than one.\n              currentDiscount += Meteor.call(`discounts/${processor}s/${calculation}`, cart._id, discount._id);// note the added s.\n            }\n          }\n        }\n      }\n    }\n    return currentDiscount;\n  }\n};\n\n// export methods to Meteor\nMeteor.methods(methods);\n","import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Counts } from \"meteor/tmeasday:publish-counts\";\nimport { Discounts } from \"../../lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * Discounts\n * @type {Publication}\n * @param {Object} query\n * @param {Object} options\n */\nMeteor.publish(\"Discounts\", function (query, options) {\n  check(query, Match.Optional(Object));\n  check(options, Match.Optional(Object));\n\n  // check shopId\n  const shopId = Reaction.getShopId();\n  if (!shopId && query) {\n    return this.ready();\n  }\n\n  const select = query || {};\n  // append shopId to query\n  // applicable discounts are published\n  // for this users cartId;\n  select.shopId = shopId;\n  // select.cartId = cartId;\n\n  // appends a count to the collection\n  // we're doing this for use with griddleTable\n  Counts.publish(this, \"discounts-count\", Discounts.find(\n    select,\n    options\n  ));\n\n  return Discounts.find(\n    select,\n    options\n  );\n});\n","import { Security } from \"meteor/ongoworks:security\";\nimport { Discounts } from \"../../lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n//\n// Security definitions\n//\nSecurity.permit([\"read\", \"insert\", \"update\", \"remove\"]).collections([\n  Discounts\n]).ifHasRole({\n  role: \"discounts\",\n  group: Reaction.getShopId()\n});\n","// assemble server api\nimport \"./i18n\";\nimport \"./hooks/cart\";\nimport \"./security/discounts\";\nimport \"./publications/discounts\";\nimport \"./methods\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Discounts\",\n  name: \"reaction-discounts\",\n  icon: \"fa fa-gift\",\n  autoEnable: true\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { PackageConfig } from \"/lib/collections/schemas/registry\";\nimport { Taxes } from \"./taxes\";\n\n/**\n* TaxPackageConfig Schema\n*/\n\nexport const TaxPackageConfig = new SimpleSchema([\n  PackageConfig, {\n    \"settings.defaultTaxCode\": {\n      type: String,\n      optional: true\n    },\n    \"settings.taxIncluded\": {\n      type: Boolean,\n      defaultValue: false\n    },\n    \"settings.taxShipping\": {\n      type: Boolean,\n      defaultValue: false\n    },\n    \"settings.rates\": {\n      type: Object,\n      optional: true\n    },\n    \"settings.rates.enabled\": {\n      type: Boolean,\n      optional: true,\n      defaultValue: false\n    },\n    \"settings.rates.taxes\": {\n      type: [Taxes],\n      optional: true\n    }\n  }\n]);\n","export * from \"./taxrates\";\nexport * from \"./taxes\";\nexport * from \"./taxcodes\";\nexport * from \"./config\";\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\n/**\n* TaxCodes Schema\n*/\n\nexport const TaxCodes = new SimpleSchema({\n  id: {\n    type: String,\n    label: \"Tax Id\",\n    unique: true\n  },\n  shopId: {\n    type: String\n  },\n  taxCode: {\n    type: String,\n    label: \"Tax Code\"\n  },\n  taxCodeProvider: {\n    type: String,\n    label: \"Tax Code Provider\"\n  },\n  ssuta: {\n    type: Boolean,\n    label: \"Streamlined Sales Tax\",\n    optional: true,\n    defaultValue: false\n  },\n  title: {\n    type: String,\n    optional: true\n  },\n  label: {\n    type: String,\n    optional: true\n  },\n  parent: {\n    type: String,\n    optional: true\n  },\n  children: {\n    type: [Object],\n    optional: true,\n    blackbox: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { shopIdAutoValue } from \"/lib/collections/schemas/helpers\";\n\n/**\n* Taxes Schema\n*/\n\nexport const Taxes = new SimpleSchema({\n  \"shopId\": {\n    type: String,\n    autoValue: shopIdAutoValue,\n    index: 1,\n    label: \"Taxes shopId\"\n  },\n  \"taxCode\": {\n    type: String,\n    label: \"Tax Identifier\",\n    defaultValue: \"RC_TAX\",\n    index: 1\n  },\n  \"cartMethod\": {\n    label: \"Calculation Method\",\n    type: String,\n    allowedValues: [\"unit\", \"row\", \"total\"],\n    defaultValue: \"total\"\n  },\n  \"taxLocale\": {\n    label: \"Taxation Location\",\n    type: String,\n    allowedValues: [\"shipping\", \"billing\", \"origination\", \"destination\"],\n    defaultValue: \"destination\"\n  },\n  \"taxShipping\": {\n    label: \"Tax Shipping\",\n    type: Boolean,\n    defaultValue: false\n  },\n  \"taxIncluded\": {\n    label: \"Taxes included in product prices\",\n    type: Boolean,\n    defaultValue: false,\n    optional: true\n  },\n  \"discountsIncluded\": {\n    label: \"Tax before discounts\",\n    type: Boolean,\n    defaultValue: false,\n    optional: true\n  },\n  \"region\": {\n    label: \"State/Province/Region\",\n    type: String,\n    optional: true,\n    index: 1\n  },\n  \"postal\": {\n    label: \"ZIP/Postal Code\",\n    type: String,\n    optional: true,\n    index: 1\n  },\n  \"country\": {\n    type: String,\n    label: \"Country\",\n    optional: true,\n    index: 1\n  },\n  \"isCommercial\": {\n    label: \"Commercial address.\",\n    type: Boolean,\n    optional: true\n  },\n  \"rate\": {\n    type: Number,\n    decimal: true\n  },\n  \"method\": {\n    type: Array,\n    optional: true,\n    label: \"Tax Methods\"\n  },\n  \"method.$\": {\n    type: Object\n  },\n  \"method.$.plugin\": {\n    type: String,\n    label: \"Plugin\",\n    defaultValue: \"Custom\",\n    optional: true\n  },\n  \"method.$.enabled\": {\n    type: Boolean,\n    label: \"Enabled\",\n    defaultValue: true,\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\n/**\n* TaxRates Schema\n*/\n\nexport const TaxRates = new SimpleSchema({\n  country: {\n    type: String\n  },\n  county: {\n    type: String,\n    optional: true\n  },\n  postal: {\n    type: String,\n    optional: true\n  },\n  rate: {\n    type: Number,\n    decimal: true\n  }\n});\n","import { Mongo } from \"meteor/mongo\";\nimport * as Schemas from \"./schemas\";\n\n/**\n* ReactionCore Collections TaxCodes\n*/\n\n/**\n* Taxes Collection\n*/\nexport const Taxes = new Mongo.Collection(\"Taxes\");\n\nTaxes.attachSchema(Schemas.Taxes);\n\n\n/**\n* TaxCodes Collection\n*/\nexport const TaxCodes = new Mongo.Collection(\"TaxCodes\");\n\nTaxCodes.attachSchema(Schemas.TaxCodes);\n","export * from \"./collections\";\n","import { Reaction } from \"/server/api\";\nimport { Import } from \"/server/api/core/import\";\nimport * as Collections from \"../../lib/collections\";\n\n// plugin Import helpers\nconst TaxImport = Import;\n\n// Import helper to store a taxCode in the import buffer.\nTaxImport.taxCode = function (key, taxCode) {\n  return this.object(Collections.TaxCodes, key, taxCode);\n};\n\n// configure Import key detection\nTaxImport.indication(\"ssuta\", Collections.TaxCodes, 0.5);\n\n// should assign to global\nObject.assign(Reaction.Import, TaxImport);\n\n// exports Reaction.Import with new taxcode helper\nexport default Reaction;\n","import Reaction from \"./import\";\n\nexport default Reaction;\n","import { indexOf } from \"lodash\";\nimport { Cart } from \"/lib/collections\";\n\n/**\n * Cart Hooks for Taxes\n*/\n\n/**\n * After cart update apply taxes.\n * if items are changed, recalculating taxes\n * we could have done this in the core/cart transform\n * but this way this file controls the events from\n * the core/taxes plugin.\n */\nCart.after.update((userId, cart, fieldNames) => {\n  const trigger = [\"discount\", \"billing\", \"shipping\"];\n\n  for (const field of fieldNames) {\n    if (indexOf(trigger, field) !== -1) {\n      Meteor.call(\"taxes/calculate\", cart._id);\n    }\n  }\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Cart, Packages } from \"/lib/collections\";\nimport { Taxes } from \"../../lib/collections\";\nimport Reaction from \"../api\";\nimport { Logger } from \"/server/api\";\n\n//\n// make all tax methods available\n//\nexport const methods = {\n  /**\n   * taxes/deleteRate\n   * @param  {String} taxId tax taxId to delete\n   * @return {String} returns update/insert result\n   */\n  \"taxes/deleteRate\": function (taxId) {\n    check(taxId, String);\n\n    // check permissions to delete\n    if (!Reaction.hasPermission(\"taxes\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Taxes.remove(taxId);\n  },\n\n  /**\n   * taxes/setRate\n   * update the cart without hooks\n   * @param  {String} cartId cartId\n   * @param  {Number} taxRate taxRate\n   * @param  {Object} taxes taxes\n   * @return {Number} returns update result\n   */\n  \"taxes/setRate\": function (cartId, taxRate, taxes) {\n    check(cartId, String);\n    check(taxRate, Number);\n    check(taxes, Match.Optional(Array));\n\n    return Cart.direct.update(cartId, {\n      $set: {\n        taxes: taxes,\n        tax: taxRate\n      }\n    });\n  },\n\n  /**\n   * taxes/addRate\n   * @param  {String} modifier update statement\n   * @param  {String} docId    tax docId\n   * @return {String} returns update/insert result\n   */\n  \"taxes/addRate\": function (modifier, docId) {\n    check(modifier, Object);\n    check(docId, Match.OneOf(String, null, undefined));\n\n    // check permissions to add\n    if (!Reaction.hasPermission(\"taxes\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // if no doc, insert\n    if (!docId) {\n      return Taxes.insert(modifier);\n    }\n    // else update and return\n    return Taxes.update(docId, modifier);\n  },\n\n  /**\n   * taxes/calculate\n   * @param  {String} cartId cartId\n   * @return {Object}  returns tax object\n   */\n  \"taxes/calculate\": function (cartId) {\n    check(cartId, String);\n    const cartToCalc = Cart.findOne(cartId);\n    const shopId = cartToCalc.shopId;\n    let taxRate = 0;\n    // get all tax packages\n    //\n    // TODO FIND IN LAYOUT/REGISTRY\n    //\n    const pkg = Packages.findOne({\n      shopId: shopId,\n      name: \"reaction-taxes\"\n    });\n    //\n    // custom rates\n    // TODO Determine calculation method (row, total, shipping)\n    // TODO method for order tax updates\n    // additional logic will be needed for refunds\n    // or tax adjustments\n    //\n    // check if plugin is enabled and this calculation method is enabled\n    if (pkg && pkg.enabled === true && pkg.settings.rates.enabled === true) {\n      Logger.debug(\"Calculating custom tax rates\");\n\n      if (typeof cartToCalc.shipping !== \"undefined\" && typeof cartToCalc.items !== \"undefined\") {\n        const shippingAddress = cartToCalc.shipping[0].address;\n        //\n        // custom rates that match shipping info\n        // high chance this needs more review as\n        // it's unlikely this matches all potential\n        // here we just sort by postal, so if it's an exact\n        // match we're taking the first record, where the most\n        // likely tax scenario is a postal code falling\n        // back to a regional tax.\n\n        if (shippingAddress) {\n          let customTaxRate = 0;\n          let totalTax = 0;\n          // lookup custom tax rate\n          const addressTaxData = Taxes.find(\n            {\n              $and: [{\n                $or: [{\n                  postal: shippingAddress.postal\n                }, {\n                  postal: { $exists: false },\n                  region: shippingAddress.region,\n                  country: shippingAddress.country\n                }, {\n                  postal: { $exists: false },\n                  region: { $exists: false },\n                  country: shippingAddress.country\n                }]\n              }, {\n                shopId: shopId\n              }]\n            }, { sort: { postal: -1 } }\n          ).fetch();\n\n          // return custom rates\n          // TODO  break down the product origination, taxability\n          // by qty and an originating shop and inventory\n          // for location of each item in the cart.\n          if (addressTaxData.length > 0) {\n            customTaxRate = addressTaxData[0].rate;\n          }\n\n          // calculate line item taxes\n          for (const items of cartToCalc.items) {\n            // only processs taxable products\n            if (items.variants.taxable === true) {\n              const subTotal = items.variants.price * items.quantity;\n              const tax = subTotal * (customTaxRate / 100);\n              totalTax += tax;\n            }\n          }\n          // calculate overall cart rate\n          if (totalTax > 0) {\n            taxRate = (totalTax / cartToCalc.cartSubTotal());\n          }\n          // store tax on cart\n          Meteor.call(\"taxes/setRate\", cartToCalc._id, taxRate, addressTaxData);\n        } // end custom rates\n      } // end shippingAddress calculation\n    } else {\n      // we are here because the custom rate package is disabled.\n      // we're going to set an inital rate of 0\n      // all methods that trigger when taxes/calculate will\n      // recalculate this rate as needed.\n      Meteor.call(\"taxes/setRate\", cartToCalc._id, taxRate);\n    }\n  } // end taxes/calculate\n};\n\n// export tax methods to Meteor\nMeteor.methods(methods);\n","import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Counts } from \"meteor/tmeasday:publish-counts\";\nimport { Taxes, TaxCodes } from \"../../lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n//\n// Security\n// import \"/server/security/collections\";\n// Security definitions\n//\nSecurity.permit([\"insert\", \"update\", \"remove\"]).collections([\n  Taxes,\n  TaxCodes\n]).ifHasRole({\n  role: \"admin\",\n  group: Reaction.getShopId()\n});\n/**\n * taxes\n */\nMeteor.publish(\"Taxes\", function (query, options) {\n  check(query, Match.Optional(Object));\n  check(options, Match.Optional(Object));\n\n  // check shopId\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  const select = query || {};\n  // append shopId to query\n  // taxes could be shared\n  // if you disregarded shopId\n  select.shopId = shopId;\n\n  // appends a count to the collection\n  // we're doing this for use with griddleTable\n  Counts.publish(this, \"taxes-count\", Taxes.find(\n    select,\n    options\n  ));\n\n  return Taxes.find(\n    select,\n    options\n  );\n});\n\n/**\n * tax codes\n */\nMeteor.publish(\"TaxCodes\", function (query, params) {\n  check(query, Match.Optional(Object));\n  check(params, Match.Optional(Object));\n\n  // check shopId\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  const select = query || {};\n\n  // for now, not adding shopId to query\n  // taxCodes are reasonable shared??\n  //  select.shopId = shopId;\n\n  const options = params || {};\n  // const options = params || {\n  //   fields: {\n  //     id: 1,\n  //     label: 1\n  //   },\n  //   sort: {\n  //     label: 1\n  //   }\n  // };\n\n  // appends a count to the collection\n  // we're doing this for use with griddleTable\n  Counts.publish(this, \"taxcode-count\", TaxCodes.find(\n    select,\n    options\n  ));\n\n  return TaxCodes.find(\n    select,\n    options\n  );\n});\n","import \"./i18n\";\n// assemble server api\nimport \"./methods/methods\";\nimport \"./publications/taxes\";\nimport \"./hooks/taxes\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Taxes\",\n  name: \"reaction-taxes\",\n  icon: \"fa fa-university\",\n  autoEnable: true,\n  settings: {\n    custom: {\n      enabled: true\n    },\n    rates: {\n      enabled: false\n    }\n  },\n  registry: [\n    {\n      provides: \"dashboard\",\n      name: \"taxes\",\n      label: \"Taxes\",\n      description: \"Provide tax rates\",\n      icon: \"fa fa-university\",\n      priority: 1,\n      container: \"core\",\n      workflow: \"coreDashboardWorkflow\"\n    },\n    {\n      label: \"Tax Settings\",\n      icon: \"fa fa-university\",\n      name: \"taxes/settings\",\n      provides: \"settings\",\n      template: \"taxSettings\"\n    },\n    {\n      label: \"Custom Rates\",\n      name: \"taxes/settings/rates\",\n      provides: \"taxSettings\",\n      template: \"customTaxRates\"\n    },\n    {\n      template: \"flatRateCheckoutTaxes\",\n      provides: \"taxMethod\"\n    }\n  ]\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Templates } from \"/lib/collections\";\nimport { shopIdAutoValue } from \"/lib/collections/schemas/helpers\";\n\n/**\n * EmailTemplates Schema\n*/\n\nexport const EmailTemplates = new SimpleSchema({\n  shopId: {\n    type: String,\n    index: 1,\n    autoValue: shopIdAutoValue,\n    label: \"Template ShopId\"\n  },\n  name: {\n    type: String,\n    optional: true\n  },\n  priority: {\n    type: Number,\n    optional: true,\n    defaultValue: 1\n  },\n  enabled: {\n    type: Boolean,\n    defaultValue: true\n  },\n  route: {\n    type: String,\n    optional: true\n  },\n  audience: {\n    type: [String],\n    optional: true\n  },\n  type: {\n    type: String,\n    defaultValue: \"email\",\n    optional: true\n  },\n  provides: {\n    type: String,\n    defaultValue: \"template\"\n  },\n  block: {\n    type: String,\n    optional: true\n  },\n  defaultData: {\n    type: Object,\n    blackbox: true,\n    optional: true\n  },\n  template: {\n    type: String,\n    optional: true\n  },\n  parser: {\n    type: String,\n    optional: true\n  },\n  language: {\n    type: String,\n    optional: true,\n    defaultValue: \"en\"\n  },\n  source: {\n    type: String,\n    optional: true\n  },\n  title: {\n    type: String,\n    optional: true\n  },\n  subject: {\n    type: String,\n    optional: true\n  }\n});\n\nTemplates.attachSchema(EmailTemplates, { selector: { type: \"email\" } });\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\nimport \"./methods\";\nimport \"../lib/collections/schemas/emailtemplates\";\n","import { Templates } from \"/lib/collections\";\n\nexport const methods = {\n  /**\n   * templates/email/update\n   * @summary updates email template in Templates collection\n   * @param {String} templateId - id of template to remove\n   * @param {Object} doc - data to update\n   * @return {Number} remove template\n   */\n  \"templates/email/update\": function (templateId, doc) {\n    check(templateId, String);\n    check(doc, Object);\n    // TODO: add permissions\n    // if (!Reaction.hasPermission(\"shipping\")) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n    return Templates.update({\n      _id: templateId,\n      type: \"email\"\n    }, {\n      $set: {\n        title: doc.title,\n        name: doc.name,\n        language: doc.language,\n        template: doc.template,\n        subject: doc.subject,\n        enabled: doc.enabled\n      }\n    });\n  }\n};\n\nMeteor.methods(methods);\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Templates\",\n  name: \"reaction-templates\",\n  icon: \"fa fa-columns\",\n  autoEnable: true,\n  settings: {\n    name: \"Templates\",\n    custom: {\n      enabled: true\n    }\n  },\n  registry: [\n    {\n      provides: \"dashboard\",\n      workflow: \"coreDashboardWorkflow\",\n      name: \"Templates\",\n      label: \"Templates\",\n      description: \"App Templates\",\n      icon: \"fa fa-columns\",\n      priority: 1,\n      container: \"appearance\"\n    },\n    {\n      label: \"Template Settings\",\n      icon: \"fa fa-columns\",\n      name: \"templates/settings\",\n      provides: \"settings\",\n      template: \"templateSettings\"\n    },\n    {\n      label: \"Email Templates\",\n      name: \"templates/settings/email\",\n      provides: \"templateSettings\",\n      template: \"emailTemplates\"\n    }\n  ]\n});\n","export * from \"./revisions\";\n","import { Packages } from \"/lib/collections\";\n\nexport function getPackageSettings() {\n  const packageInfo = Packages.findOne({\n    name: \"reaction-revisions\"\n  });\n\n  if (packageInfo && packageInfo.enabled && packageInfo.settings) {\n    return packageInfo.settings;\n  }\n\n  return null;\n}\n\nexport function isRevisionControlEnabled() {\n  const settings = getPackageSettings();\n\n  if (settings && settings.general && typeof settings.general.enabled === \"boolean\") {\n    return settings.general.enabled;\n  }\n\n  return false;\n}\n\nexport const RevisionApi = {\n  isRevisionControlEnabled,\n  getPackageSettings\n};\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import _ from \"lodash\";\nimport { diff } from \"deep-diff\";\nimport { Products, Revisions, Tags, Media } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\nimport { RevisionApi } from \"../lib/api\";\nimport { getSlug } from \"/lib/api\";\n\nfunction convertMetadata(modifierObject) {\n  const metadata = {};\n  for (const prop in modifierObject) {\n    if (modifierObject.hasOwnProperty(prop)) {\n      if (prop.indexOf(\"metadata\") !== -1) {\n        const splitName = _.split(prop, \".\")[1];\n        metadata[splitName] = modifierObject[prop];\n      }\n    }\n  }\n  return metadata;\n}\n\nexport const ProductRevision = {\n  getProductPriceRange(productId) {\n    const product = Products.findOne(productId);\n    if (!product) {\n      return \"\";\n    }\n    const variants = this.getTopVariants(product._id);\n\n    if (variants.length > 0) {\n      const variantPrices = [];\n      variants.forEach(variant => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n      const priceMin = _.min(variantPrices);\n      const priceMax = _.max(variantPrices);\n      let priceRange = `${priceMin} - ${priceMax}`;\n      // if we don't have a range\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n      const priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    }\n    // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n    return product.price;\n  },\n\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter(child => child.isVisible);\n\n    switch (visibleChildren.length) {\n      case 0:\n        const topVariant = this.getProduct(variantId);\n        // topVariant could be undefined when we removing last top variant\n        return topVariant && topVariant.price;\n      case 1:\n        return visibleChildren[0].price;\n      default:\n        let priceMin = Number.POSITIVE_INFINITY;\n        let priceMax = Number.NEGATIVE_INFINITY;\n\n        visibleChildren.map(child => {\n          if (child.price < priceMin) {\n            priceMin = child.price;\n          }\n          if (child.price > priceMax) {\n            priceMax = child.price;\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n        return `${priceMin} - ${priceMax}`;\n    }\n  },\n\n  findRevision({ documentId }) {\n    return Revisions.findOne({\n      \"documentId\": documentId,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    });\n  },\n\n  getProduct(variantId) {\n    const product = Products.findOne(variantId);\n    const revision = this.findRevision({\n      documentId: variantId\n    });\n\n    return revision && revision.documentData || product;\n  },\n\n  getTopVariants(id) {\n    const variants = [];\n\n    Products.find({\n      ancestors: [id],\n      type: \"variant\",\n      isDeleted: false\n    }).map((product) => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n\n    return variants;\n  },\n\n  getVariants(id, type) {\n    const variants = [];\n\n    Products.find({\n      ancestors: { $in: [id] },\n      type: type || \"variant\",\n      isDeleted: false\n    }).forEach((product) => {\n      const revision = this.findRevision({\n        documentId: product._id\n      });\n\n      if (revision && revision.documentData.isVisible) {\n        variants.push(revision.documentData);\n      } else if (!revision && product.isVisible) {\n        variants.push(product);\n      }\n    });\n    return variants;\n  },\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n    if (options && options.length) {\n      return options.reduce((sum, option) =>\n      sum + option.inventoryQuantity || 0, 0);\n    }\n    return variant.inventoryQuantity || 0;\n  }\n};\n\nMedia.files.before.insert((userid, media) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  if (media.metadata.productId) {\n    const revisionMetadata = Object.assign({}, media.metadata);\n    revisionMetadata.workflow = \"published\";\n    Revisions.insert({\n      documentId: media._id,\n      documentData: revisionMetadata,\n      documentType: \"image\",\n      parentDocument: media.metadata.productId,\n      changeType: \"insert\",\n      workflow: {\n        status: \"revision/update\"\n      }\n    });\n    media.metadata.workflow = \"unpublished\";\n  } else {\n    media.metadata.workflow = \"published\";\n  }\n  return true;\n});\n\nMedia.files.before.update((userId, media, fieldNames, modifier) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  // if it's not metadata ignore it, as LOTS of othing things change on this record\n  if (!_.includes(fieldNames, \"metadata\")) {\n    return true;\n  }\n\n  if (media.metadata.productId) {\n    const convertedModifier = convertMetadata(modifier.$set);\n    const convertedMetadata = Object.assign({}, media.metadata, convertedModifier);\n    const existingRevision = Revisions.findOne({\n      \"documentId\": media._id,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    });\n    if (existingRevision) {\n      const updatedMetadata = Object.assign({}, existingRevision.documentData, convertedMetadata);\n      // Special case where if we have both added and reordered images before publishing we don't want to overwrite\n      // the workflow status since it would be \"unpublished\"\n      if (existingRevision.documentData.workflow === \"published\" || existingRevision.changeType === \"insert\") {\n        updatedMetadata.workflow = \"published\";\n      }\n      Revisions.update({ _id: existingRevision._id }, {\n        $set: {\n          documentData: updatedMetadata\n        }\n      });\n    } else {\n      Revisions.insert({\n        documentId: media._id,\n        documentData: convertedMetadata,\n        documentType: \"image\",\n        parentDocument: media.metadata.productId,\n        changeType: \"update\",\n        workflow: {\n          status: \"revision/update\"\n        }\n      });\n    }\n\n    return false; // prevent actual update of image. This also stops other hooks from running :/\n  }\n  // for non-product images, just ignore and keep on moving\n  return true;\n});\n\nMedia.files.before.remove((userId, media) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  // if the media is unpublished, then go ahead and just delete it\n  if (media.metadata.workflow && media.metadata.workflow === \"unpublished\") {\n    Revisions.remove({\n      documentId: media._id\n    });\n    return true;\n  }\n  if (media.metadata.productId) {\n    Revisions.insert({\n      documentId: media._id,\n      documentData: media.metadata,\n      documentType: \"image\",\n      parentDocument: media.metadata.productId,\n      changeType: \"remove\",\n      workflow: {\n        status: \"revision/update\"\n      }\n    });\n    return false; // prevent actual deletion of image. This also stops other hooks from running :/\n  }\n  return true;\n});\n\n\nProducts.before.insert((userId, product) => {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  const productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  });\n\n  // Prevent this product from being created if a parent product / varaint ancestor is deleted.\n  //\n  // This will prevent cases where a parent variant hase been deleted and a user tries to create a\n  // child variant. You cannot create the child variant becuase the parent will no longer exist when\n  // changes have been published; resulting in a broken inheretence and UI\n  const productHasAncestors = Array.isArray(product.ancestors);\n\n  if (productHasAncestors) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": { $in: product.ancestors },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot create product ${product._id} as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"Unable to create product variant\");\n    }\n  }\n\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n  }\n});\n\n\nProducts.before.update(function (userId, product, fieldNames, modifier, options) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  let productRevision = Revisions.findOne({\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  });\n\n  // Prevent this product revision from beign restored from isDeleted state if a product / varaint\n  // ancestor is also deleted.\n  //\n  // This will prevent cases where a parent variant hase been deleted and a user tries to undeleted a\n  // child variant. You cannot undeleted the child variant, becuase the parent will no longer exist when\n  // changes have been published; resulting in a broken inheretence and UI\n  const revisionHasAncestors = productRevision && productRevision.documentData && Array.isArray(productRevision.documentData.ancestors);\n  const modiferContainsIsDeleted = modifier.$set && modifier.$set.isDeleted === false;\n\n  if (revisionHasAncestors && modiferContainsIsDeleted) {\n    // Verify there are no deleted ancestors,\n    // Variants cannot be restored if their parent product / variant is deleted\n    const archivedCount = Revisions.find({\n      \"documentId\": { $in: productRevision.documentData.ancestors },\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": {\n        $nin: [\n          \"revision/published\"\n        ]\n      }\n    }).count();\n\n    if (archivedCount > 0) {\n      Logger.debug(`Cannot restore product ${product._id} as a product/variant higher in it's ancestors tree is marked as 'isDeleted'.`);\n      throw new Meteor.Error(\"Unable to delete product variant\");\n    }\n  }\n\n  const originalSelector = this.args[0];\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    // Create a new revision\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n\n    // Fetch newly created revision\n    productRevision = Revisions.findOne({\n      documentId: product._id\n    });\n  }\n\n  // Create a new selector for the revision\n  //\n  // This is especially important since we may need to update some fields\n  // like metadata, and the selector is very important to that.\n  const revisionSelector = {\n    \"documentId\": product._id,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  };\n\n  // Create a new modifier for the revision\n  const revisionModifier = {\n    $set: {\n      \"workflow.status\": \"revision/update\"\n    }\n  };\n\n  if (options.publish === true || (product.workflow && product.workflow.status === \"product/publish\")) {\n    // Maybe mark the revision as published\n\n    Logger.debug(`Publishing revison for product ${product._id}.`);\n    Revisions.update(revisionSelector, {\n      $set: {\n        \"workflow.status\": \"revision/published\"\n      }\n    });\n\n    return true;\n  }\n\n  const hasAncestors = Array.isArray(product.ancestors) && product.ancestors.length > 0;\n\n  for (const operation in modifier) {\n    if (Object.hasOwnProperty.call(modifier, operation)) {\n      if (!revisionModifier[operation]) {\n        revisionModifier[operation] = {};\n      }\n\n      for (const property in modifier[operation]) {\n        if (modifier[operation].hasOwnProperty(property)) {\n          if (operation === \"$set\" && property === \"metafields.$\") {\n            // Special handling for meta fields with $ operator\n            // We need to update the selector otherwise the operation would completly fail.\n            //\n            // This does NOT apply to metafield.0, metafield.1, metafield.n operations\n            // where 0, 1, n represent an array index.\n            revisionSelector[\"documentData.metafields\"] = originalSelector.metafields;\n            revisionModifier.$set[`documentData.${property}`] = modifier.$set[property];\n          } else if (operation === \"$push\" && property === \"hashtags\") {\n            if (!revisionModifier.$addToSet) {\n              revisionModifier.$addToSet = {};\n            }\n            revisionModifier.$addToSet[`documentData.${property}`] = modifier.$push[property];\n          } else if (operation === \"$set\" && property === \"price\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.price\": modifier.$set.price\n              }\n            });\n\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && property === \"isVisible\" && hasAncestors) {\n            Revisions.update(revisionSelector, {\n              $set: {\n                \"documentData.isVisible\": modifier.$set.isVisible\n              }\n            });\n\n            const updateId = product.ancestors[0] || product._id;\n            const priceRange = ProductRevision.getProductPriceRange(updateId);\n\n            Meteor.call(\"products/updateProductField\", updateId, \"price\", priceRange);\n          } else if (operation === \"$set\" && (property === \"title\" || property === \"handle\") && hasAncestors === false) {\n            // Special handling for product title and handle\n            //\n            // Summary:\n            // When a user updates the product title, if the handle matches the product id,\n            // then update the handle to be a sligified version of the title\n            //\n            // This block ensures that the handle is either a custom slug, slug of the title, or\n            // the _id of the product, but is never blank\n\n            // New data\n            const newValue = modifier.$set[property];\n            const newTitle = modifier.$set.title;\n            const newHandle = modifier.$set.handle;\n\n            // Current revision data\n            const documentId = productRevision.documentId;\n            const slugDocId = getSlug(documentId);\n            const revisionTitle = productRevision.documentData.title;\n            const revisionHandle = productRevision.documentData.handle;\n\n            // Checks\n            const hasNewHandle = _.isEmpty(newHandle) === false;\n            const hasExistingTitle = _.isEmpty(revisionTitle) === false;\n            const hasNewTitle = _.isEmpty(newTitle) === false;\n            const hasHandle = _.isEmpty(revisionHandle) === false;\n            const handleMatchesId = revisionHandle === documentId || revisionHandle === slugDocId || newValue === documentId || newValue === slugDocId;\n\n            // Continue to set the title / handle as origionally requested\n            // Handle will get changed if conditions are met in the below if block\n            revisionModifier.$set[`documentData.${property}`] = newValue;\n\n            if ((handleMatchesId || hasHandle === false) && (hasExistingTitle || hasNewTitle) && hasNewHandle === false) {\n              // Set the handle to be the slug of the product.title\n              // when documentId (product._id) matches the handle, then handle is enpty, and a title exists\n              revisionModifier.$set[\"documentData.handle\"] = getSlug(newTitle || revisionTitle);\n            } else if (hasHandle === false && hasExistingTitle === false && hasNewHandle === false) {\n              // If the handle & title is empty, the handle becomes the product id\n              revisionModifier.$set[\"documentData.handle\"] = documentId;\n            } else if (hasNewHandle === false && property === \"handle\") {\n              // If the handle is empty, the handle becomes the sligified product title, or document id if title does not exist.\n              // const newTitle = modifier.$set[\"title\"];\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle ? getSlug(newTitle || revisionTitle) : documentId;\n            }\n          } else if (operation === \"$unset\" && property === \"handle\" && hasAncestors === false) {\n            // Special handling for product handle when it is going to be unset\n            //\n            // Summary:\n            // When a user updates the handle to a black string e.g. deltes all text in field in UI and saves,\n            // the handle will be adjusted so it will not be blank\n            const newValue = modifier.$unset[property];\n            const revisionTitle = productRevision.documentData.title;\n            const hasExistingTitle = _.isEmpty(revisionTitle) === false;\n\n            // If the new handle is going to be empty, the handle becomes the sligified product title, or document id if title does not exist.\n            if (_.isEmpty(newValue)) {\n              revisionModifier.$set[\"documentData.handle\"] = hasExistingTitle ? getSlug(revisionTitle) : documentId;\n            }\n          } else {\n            // Let everything else through\n            revisionModifier[operation][`documentData.${property}`] = modifier[operation][property];\n          }\n        }\n      }\n    }\n  }\n\n  Revisions.update(revisionSelector, revisionModifier);\n\n  Logger.debug(`Revison updated for product ${product._id}.`);\n\n  if (modifier.$pull && modifier.$pull.hashtags) {\n    const tagId = modifier.$pull.hashtags;\n\n    const productCount = Products.find({\n      hashtags: {\n        $in: [tagId]\n      }\n    }).count();\n\n    const relatedTagsCount = Tags.find({\n      relatedTagIds: {\n        $in: [tagId]\n      }\n    }).count();\n\n    if (productCount === 0 && relatedTagsCount === 0) {\n      // Mark tag as deleted\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: true\n        }\n      });\n    } else {\n      Tags.update({\n        _id: tagId\n      }, {\n        $set: {\n          isDeleted: false\n        }\n      });\n    }\n  }\n\n  // If we are using $set or $inc, and the fields are one of the ignoredFields,\n  // allow product to be updated without going through revision control\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    const newSet = {};\n    const newInc = {};\n    let hasIgnoredFields = false;\n    const ignoredFields = [\n      \"isLowQuantity\",\n      \"isSoldOut\",\n      \"inventoryQuantity\"\n    ];\n\n    for (const field of ignoredFields) {\n      if (modifier.$set && (typeof modifier.$set[field] === \"number\" || typeof modifier.$set[field] === \"boolean\")) {\n        newSet[field] = modifier.$set[field];\n        hasIgnoredFields = true;\n      }\n\n      if (modifier.$inc && (typeof modifier.$inc[field] === \"number\" || typeof modifier.$inc[field] === \"boolean\")) {\n        newInc[field] = modifier.$inc[field];\n        hasIgnoredFields = true;\n      }\n    }\n    if (_.isEmpty(newSet) === false) {\n      modifier.$set = newSet;\n    }\n\n    if (_.isEmpty(newInc) === false) {\n      modifier.$inc = newInc;\n    }\n\n    return hasIgnoredFields === true;\n  }\n\n  // prevent the underlying document from being modified as it is in draft mode\n  return false;\n});\n\nProducts.before.remove(function (userId, product) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n\n  let productRevision = Revisions.findOne({\n    documentId: product._id\n  });\n\n  if (!productRevision) {\n    Logger.debug(`No revision found for product ${product._id}. Creating new revision`);\n\n    Revisions.insert({\n      documentId: product._id,\n      documentData: product\n    });\n    productRevision =  Revisions.findOne({\n      documentId: product._id\n    });\n  }\n\n  // Set the revision as deleted \"isDeleted: true\"\n  Revisions.update({\n    documentId: product._id\n  }, {\n    $set: {\n      \"documentData.isDeleted\": true,\n      \"workflow.status\": \"revision/remove\"\n    }\n  });\n\n  Logger.debug(`Revison updated for product ${product._id}.`);\n  Logger.debug(`Product ${product._id} is now marked as deleted.`);\n\n  // If the original product is deleted, and the user is trying to delete it again,\n  // then actually remove it completly.\n  //\n  // This acts like a trash. Where the product is sent to trash before it can actually\n  // be deleted perminately.\n  if (product.isDeleted === true) {\n    Logger.debug(`Allowing write to product ${product._id} for Collection.remove().`);\n\n    return true;\n  }\n\n  Logger.debug(`Preventing write to product ${product._id} for Collection.remove().`);\n\n  return false;\n});\n\nRevisions.after.update(function (userId, revision) {\n  if (RevisionApi.isRevisionControlEnabled() === false) {\n    return true;\n  }\n  let differences;\n\n\n  if (!revision.documentType || revision.documentType === \"product\") {\n    // Make diff\n    const product = Products.findOne({\n      _id: revision.documentId\n    });\n    differences = diff(product, revision.documentData);\n  }\n\n  if (revision.documentType && revision.documentType === \"image\") {\n    const image = Media.findOne(revision.documentId);\n    differences = diff(image.metadata, revision.documentData);\n  }\n\n  Revisions.direct.update({\n    _id: revision._id\n  }, {\n    $set: {\n      diff: differences && differences.map((d) => Object.assign({}, d))\n    }\n  });\n}, {\n  fetchPrevious: false\n});\n","import \"./hooks\";\nimport \"./methods\";\nimport \"./i18n\";\n","import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Products, Media, Revisions, Packages } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\n\nexport function updateSettings(settings) {\n  check(settings, Object);\n\n  Packages.update({\n    name: \"reaction-revisions\"\n  }, {\n    $set: {\n      settings\n    }\n  });\n}\n\nexport function discardDrafts(documentIds) {\n  check(documentIds, Match.OneOf(String, Array));\n\n  let documentIdArray;\n\n  if (Array.isArray(documentIds)) {\n    documentIdArray = documentIds;\n  } else {\n    documentIdArray = [documentIds];\n  }\n\n  const selector = {\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    },\n    \"$or\": [\n      {\n        documentId: {\n          $in: documentIdArray\n        }\n      },\n      {\n        \"documentData.ancestors\": {\n          $in: documentIdArray\n        }\n      },\n      {\n        parentDocument: {\n          $in: documentIds\n        }\n      }\n    ]\n  };\n\n  const result = Revisions.remove(selector);\n\n  return result > 0;\n}\n\nMeteor.methods({\n  \"revisions/settings/update\": updateSettings,\n  \"revisions/discard\": discardDrafts,\n  \"revisions/publish\"(documentIds) {\n    check(documentIds, Match.OneOf(String, Array));\n\n    // Also publish variants if they have a draft\n    let revisions;\n\n    if (Array.isArray(documentIds)) {\n      revisions = Revisions.find({\n        \"workflow.status\": {\n          $nin: [\n            \"revision/published\"\n          ]\n        },\n        \"$or\": [\n          {\n            documentId: {\n              $in: documentIds\n            }\n          },\n          {\n            \"documentData.ancestors\": {\n              $in: documentIds\n            }\n          },\n          {\n            parentDocument: {\n              $in: documentIds\n            }\n          }\n        ]\n      }).fetch();\n    } else {\n      revisions = Revisions.find({\n        \"workflow.status\": {\n          $nin: [\n            \"revision/published\"\n          ]\n        },\n        \"$or\": [\n          { documentId: documentIds },\n          {\n            \"documentData.ancestors\": {\n              $in: [documentIds]\n            }\n          }\n        ]\n      }).fetch();\n    }\n\n    let updatedDocuments = 0;\n    const previousDocuments = [];\n\n    if (revisions) {\n      for (const revision of revisions) {\n        if (!revision.documentType || revision.documentType === \"product\") {\n          previousDocuments.push(Products.findOne(revision.documentId));\n\n          const res = Products.update({\n            _id: revision.documentId\n          }, {\n            $set: revision.documentData\n          }, {\n            publish: true\n          });\n          updatedDocuments += res;\n        } else if (revision.documentType === \"image\") {\n          if (revision.changeType === \"insert\") {\n            const res = Media.files.direct.update({\n              _id: revision.documentId\n            }, {\n              $set: {\n                metadata: revision.documentData\n              }\n            });\n            updatedDocuments += res;\n          } else if (revision.changeType === \"remove\") {\n            const res = Media.files.direct.update({\n              _id: revision.documentId\n            }, {\n              $set: {\n                \"metadata.workflow\": \"archived\"\n              }\n            });\n            updatedDocuments += res;\n          } else if (revision.changeType === \"update\") {\n            const res = Media.files.direct.update({\n              _id: revision.documentId\n            }, {\n              $set: {\n                metadata: revision.documentData\n              }\n            });\n            updatedDocuments += res;\n            Logger.debug(`setting metadata for ${revision.documentId} to ${JSON.stringify(revision.documentData, null, 4)}`);\n          }\n          // mark revision published whether we are publishing the image or not\n          Revisions.direct.update({\n            _id: revision._id\n          }, {\n            $set: {\n              \"workflow.status\": \"revision/published\"\n            }\n          });\n        }\n      }\n    }\n\n    if (updatedDocuments > 0) {\n      return {\n        status: \"success\",\n        previousDocuments\n      };\n    }\n\n    return false;\n  }\n});\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Revisions\",\n  name: \"reaction-revisions\",\n  autoEnable: true,\n  settings: {\n    general: {\n      enabled: true\n    }\n  },\n  registry: [\n    // Settings Panel in Catalog\n    {\n      label: \"Product Revisions\",\n      name: \"catalog/settings/revisions/general\",\n      provides: \"catalogSettings\",\n      template: \"revisionControlSettings\"\n    }\n  ]\n});\n","export const shippingRoles = [\"admin\", \"owner\", \"shipping\"];\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Shipping, Packages } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport { shippingRoles } from \"../lib/roles\";\n\nexport const methods = {\n  \"shipping/status/refresh\": function (orderId) {\n    check(orderId, String);\n    // this is a stub for future core processing\n    // it also serves as a place for Method Hooks\n    // in other shipping packages, like Shippo\n    return orderId;\n  },\n  /**\n   * shipping/provider/toggle\n   * @summary toggle enabled provider\n   * @param { String } packageId - packageId\n   * @param { String } provider - provider name\n   * @return { Number } update - result\n   */\n  \"shipping/provider/toggle\": function (packageId, provider) {\n    check(packageId, String);\n    check(provider, String);\n    if (!Reaction.hasPermission(shippingRoles)) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const pkg = Packages.findOne(packageId);\n    if (pkg && pkg.settings[provider]) {\n      const current = Shipping.findOne({ \"provider.name\": provider });\n      const enabled = pkg.settings[provider].enabled;\n      // const enabled = !current.provider.enabled;\n      if (current && current.provider) {\n        return Shipping.update({\n          \"_id\": current._id,\n          \"provider.name\": provider\n        }, {\n          $set: {\n            \"provider.enabled\": enabled\n          }\n        }, {\n          multi: true\n        });\n      }\n    }\n  }\n};\n\nMeteor.methods(methods);\n","import \"./i18n\";\nimport \"./methods/methods\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Shipping\",\n  name: \"reaction-shipping\",\n  icon: \"fa fa-truck\",\n  autoEnable: true,\n  settings: {\n    name: \"Shipping\",\n    shipping: {\n      enabled: true\n    }\n  },\n  registry: [\n    {\n      provides: \"dashboard\",\n      route: \"/dashboard/shipping\",\n      name: \"shipping\",\n      label: \"Shipping\",\n      description: \"Shipping dashboard\",\n      icon: \"fa fa-truck\",\n      priority: 1,\n      container: \"core\",\n      workflow: \"coreDashboardWorkflow\"\n    },\n    {\n      provides: \"settings\",\n      name: \"settings/shipping\",\n      label: \"Shipping\",\n      description: \"Configure shipping\",\n      icon: \"fa fa-truck\",\n      template: \"shippingSettings\"\n    }\n  ]\n});\n","import ReactDOM from \"react-dom\";\nimport { Blaze } from \"meteor/blaze\";\nimport { ReactiveVar } from \"meteor/reactive-var\";\nimport { Template } from \"meteor/templating\";\nimport BlazeComponent from \"meteor/gadicc:blaze-react-component\";\nimport PropTypes from \"prop-types\";\n\nclass BlazeLayout extends BlazeComponent {\n  static propTypes = {\n    blazeLayout: PropTypes.any\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.blazeTemplate !== this.props.blazeTemplate) {\n      Blaze.remove(this._blazeView);\n      this.renderBlazeView();\n    }\n  }\n\n  renderBlazeView() {\n    this._blazeData = new ReactiveVar(_.omit(this.props, \"blazeTemplate\"));\n\n    let template;\n    const tArg = this.props.blazeTemplate;\n\n    if (typeof tArg === \"string\") {\n      template = Template[tArg];\n      if (!template) {\n        throw new Error(`No Template[\"${tArg}\"] exists.  If this template `\n          + \"originates in your app, make sure you have the `templating` \"\n          + \"package installed (and not, for e.g. `static-html`)\");\n      }\n    } else if (tArg instanceof Blaze.Template) {\n      template = tArg;\n    } else {\n      throw new Error(\"Invalid blazeTemplate= argument specified.  Expected \"\n        + \"the string name of an existing Template, or the template \"\n        + \"itself, instead got ''\" + typeof tArg + \": \"\n        + JSON.stringify(tArg));\n    }\n\n    this._blazeView = Blaze.renderWithData(\n      template,\n      () => this._blazeData.get(),\n      ReactDOM.findDOMNode(this._blazeRef)\n    );\n  }\n\n  shouldComponentUpdate(nextProps) {\n    // Never call render() for props except template again; Blaze will do what's necessary.\n    return nextProps.blazeTemplate !== this.props.blazeTemplate;\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this._blazeData.set(_.omit(nextProps, \"blazeTemplate\"));\n  }\n}\n\nexport default BlazeLayout;\n","import Immutable from \"immutable\";\n\nlet registeredComponents = Immutable.Map();\n\nexport function registerComponent(componentInfo) {\n  registeredComponents = registeredComponents.set(\n    componentInfo.name,\n    componentInfo\n  );\n}\n\nexport function getComponent(name) {\n  const componentInfo = registeredComponents.get(name);\n  return componentInfo && componentInfo.component || null;\n}\n\nexport function getAllComponents() {\n  return registeredComponents.toObject();\n}\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import { getTemplateByName } from \"./templates\";\n\nexport function registerMethods() {\n  Meteor.methods({\n    getTemplateByName\n  });\n}\n\nexport {\n  getTemplateByName\n};\n","import { check } from \"meteor/check\";\nimport { Templates } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nexport function getTemplateByName(name, shopId) {\n  check(name, String);\n\n  const template = Templates.findOne({\n    name: name,\n    shopId: shopId || Reaction.getShopId()\n  });\n\n  return template;\n}\n","import { Reaction } from \"/server/api\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Templates } from \"/lib/collections\";\n\nMeteor.publish(\"Templates\", function (query, options) {\n  check(query, Match.Optional(Object));\n  check(options, Match.Optional(Object));\n\n  const shopId = Reaction.getShopId();\n\n  if (!shopId) {\n    return this.ready();\n  }\n\n  const select = query || {};\n  // append shopId to query\n  // templates could be shared\n  // if you disregarded shopId\n  select.shopId = shopId;\n\n  // appends a count to the collection\n  // we're doing this for use with griddleTable\n  Counts.publish(this, \"templates-count\", Templates.find(\n    select,\n    options\n  ));\n\n  return Templates.find({\n    shopId\n  });\n});\n","import \"./theme\";\nimport { registerMethods } from \"./methods\";\nimport \"./publications/templates\";\nimport \"./i18n\";\n\nregisterMethods();\n","import { Reaction } from \"/server/api\";\n\n// Register Themes\nReaction.registerTheme(Assets.getText(\"themes/notFound.css\"));\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Layout\",\n  name: \"reaction-layout\",\n  icon: \"fa fa-object-group\",\n  autoEnable: true,\n  settings: {\n    name: \"Layout\"\n  },\n  registry: [{\n    provides: \"dashboard\",\n    label: \"Layout\",\n    description: \"Layout utilities\",\n    icon: \"fa fa-object-group\",\n    priority: 1,\n    container: \"appearance\"\n  }]\n});\n","\n/**\n * Route Hook Methods\n */\nconst Hooks = {\n  _hooks: {\n    onEnter: {},\n    onExit: {}\n  },\n\n  _addHook(type, routeName, callback) {\n    if (typeof this._hooks[type][routeName] === \"undefined\") {\n      this._hooks[type][routeName] = [];\n    }\n    this._hooks[type][routeName].push(callback);\n  },\n\n  enter(callback) {\n    if (Array.isArray(callback)) {\n      callback.forEach((cb) => {\n        this.onEnter(cb);\n      });\n    } else {\n      this.onEnter(callback);\n    }\n  },\n\n  leave(callback) {\n    if (Array.isArray(callback)) {\n      callback.forEach((cb) => {\n        this.onExit(cb);\n      });\n    } else {\n      return this.onExit(callback);\n    }\n  },\n\n  onEnter(routeName, callback) {\n    // global onEnter callback\n    if (arguments.length === 1 && typeof arguments[0] === \"function\") {\n      const cb = routeName;\n      return this._addHook(\"onEnter\", \"GLOBAL\", cb);\n    }\n    // route-specific onEnter callback\n    return this._addHook(\"onEnter\", routeName, callback);\n  },\n\n  onExit(routeName, callback) {\n    // global onExit callback\n    if (arguments.length === 1 && typeof arguments[0] === \"function\") {\n      const cb = routeName;\n      return this._addHook(\"onExit\", \"GLOBAL\", cb);\n    }\n    // route-specific onExit callback\n    return this._addHook(\"onExit\", routeName, callback);\n  },\n\n  get(type, name) {\n    const group = this._hooks[type] || {};\n    const callbacks = group[name];\n    return (typeof callbacks !== \"undefined\" && !!callbacks.length) ? callbacks : [];\n  },\n\n  run(type, name, constant) {\n    const callbacks = this.get(type, name);\n    if (typeof callbacks !== \"undefined\" && !!callbacks.length) {\n      return callbacks.forEach((callback) => {\n        return callback(constant);\n      });\n    }\n    return null;\n  }\n};\n\nexport default Hooks;\n","export { default as Router } from \"./router\";\n","import React from \"react\";\nimport { Route } from \"react-router\";\nimport createBrowserHistory from \"history/createBrowserHistory\";\nimport createMemoryHistory from \"history/createMemoryHistory\";\nimport pathToRegexp from \"path-to-regexp\";\nimport queryParse from \"query-parse\";\nimport Immutable from \"immutable\";\nimport { Meteor } from \"meteor/meteor\";\nimport Blaze from \"meteor/gadicc:blaze-react-component\";\nimport { Tracker } from \"meteor/tracker\";\nimport { Packages, Shops } from \"/lib/collections\";\nimport { getComponent } from \"/imports/plugins/core/layout/lib/components\";\nimport BlazeLayout from \"/imports/plugins/core/layout/lib/blazeLayout\";\nimport Hooks from \"./hooks\";\n\n\nexport let history;\n\n// Private vars\n// const currentRoute = new ReactiveVar({});\nlet currentRoute = Immutable.Map();\nconst routerReadyDependency = new Tracker.Dependency;\nconst routerChangeDependency = new Tracker.Dependency;\n\n// Create history object depending on if this is client or server\nif (Meteor.isClient) {\n  history = createBrowserHistory();\n} else {\n  history = createMemoryHistory();\n}\n\n// Base router class (static)\nclass Router {\n  static history = history\n  static Hooks = Hooks\n  static routes = []\n  static _routes = Router.routes // for legacy\n  static _initialized = false;\n\n  static ready() {\n    routerReadyDependency.depend();\n    return Router._initialized;\n  }\n\n  static triggerRouterReady() {\n    routerReadyDependency.changed();\n  }\n\n  static get triggers() {\n    return Hooks;\n  }\n\n  static current() {\n    return currentRoute.toJS();\n  }\n\n  static setCurrentRoute(routeData) {\n    currentRoute = Immutable.Map(routeData);\n    routerChangeDependency.changed();\n  }\n\n  static getRouteName() {\n    const current = Router.current();\n\n    return current.options && current.options.name || \"\";\n  }\n\n  static getParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n\n    return current.params && current.params[name] || undefined;\n  }\n\n  static getQueryParam(name) {\n    routerChangeDependency.depend();\n    const current = Router.current();\n\n    return current.query && current.query[name] || undefined;\n  }\n\n  static watchPathChange() {\n    routerChangeDependency.depend();\n  }\n}\n\n/**\n * pathFor\n * @summary get current router path\n * @param {String} path - path to fetch\n * @param {Object} options - url params\n * @return {String} returns current router path\n */\nRouter.pathFor = (path, options = {}) => {\n  // const params = options.hash || {};\n  // const query = params.query ? Router._qs.parse(params.query) : {};\n  // // prevent undefined param error\n  // for (const i in params) {\n  //   if (params[i] === null || params[i] === undefined) {\n  //     params[i] = \"/\";\n  //   }\n  // }\n  // return Router.path(path, params, query);\n\n  const foundPath = Router.routes.find((pathObject) => {\n    // console.log(pathObject.options.name, path);\n    if (pathObject.options.name === path) {\n      return true;\n    }\n    return false;\n  });\n\n  if (foundPath) {\n    // Pull the hash out of options\n    //\n    // This is becuase of Spacebars that we have hash.\n    // Spacebars takes all params passed into a template tag and places\n    // them into the options.hash object. This will also include any `query` params\n    const hash = options && options.hash || {};\n\n    // Create an executable function based on the route regex\n    const toPath = pathToRegexp.compile(foundPath.route);\n\n    // Compile the regex path with the params from the hash\n    const compiledPath = toPath(hash);\n\n    // Convert the query object to a string\n    // e.g. { a: \"one\", b: \"two\"} => \"a=one&b=two\"\n    const queryString = queryParse.toString(hash.query);\n\n    // Return the compiled path + query string if we have one\n    if (typeof queryString === \"string\" && queryString.length) {\n      return `${compiledPath}?${queryString}`;\n    }\n\n    // Return only the compiled path\n    return compiledPath;\n  }\n\n  return \"/\";\n};\n\n\nRouter.go = (path, params, query) => {\n  let actualPath;\n\n  if (typeof path === \"string\" && path.startsWith(\"/\")) {\n    actualPath = path;\n  } else {\n    actualPath = Router.pathFor(path, {\n      hash: {\n        ...params,\n        query\n      }\n    });\n  }\n\n  if (window) {\n    history.push(actualPath);\n  }\n};\n\nRouter.replace = (path, params, query) => {\n  const actualPath = Router.pathFor(path, {\n    hash: {\n      ...params,\n      query\n    }\n  });\n\n  if (window) {\n    history.replace(actualPath);\n  }\n};\n\nRouter.reload = () => {\n  const current = Router.current();\n\n  if (window) {\n    history.replace(current.route.fullPath || \"/\");\n  }\n};\n\n/**\n * isActive\n * @summary general helper to return \"active\" when on current path\n * @example {{active \"name\"}}\n * @param {String} routeName - route name as defined in registry\n * @return {String} return \"active\" or null\n */\nRouter.isActiveClassName = (routeName) => {\n  const current = Router.current();\n  const group = current.route.group;\n  const path = current.route.path;\n  let prefix;\n\n  if (group && group.prefix) {\n    prefix = current.route.group.prefix;\n  } else {\n    prefix = \"\";\n  }\n\n  if (typeof path === \"string\") {\n    const routeDef = path.replace(prefix + \"/\", \"\");\n    return routeDef === routeName ? \"active\" : \"\";\n  }\n\n  return \"\";\n};\n\n/**\n * hasRoutePermission\n * check if user has route permissions\n * @param  {Object} route - route context\n * @return {Boolean} returns `true` if route is autoriized, `false` otherwise\n */\nfunction hasRoutePermission(route) {\n  const routeName = route.name;\n\n  if (routeName === \"index\" || routeName === \"not-found\") {\n    return true;\n  } else if (Router.Reaction.hasPermission(routeName, Meteor.userId())) {\n    return true;\n  }\n\n  return false;\n}\n\n\n/**\n * getRouteName\n * assemble route name to be standard\n * prefix/package name + registry name or route\n * @param  {String} packageName  [package name]\n * @param  {Object} registryItem [registry object]\n * @return {String}              [route name]\n */\nfunction getRegistryRouteName(packageName, registryItem) {\n  let routeName;\n  if (packageName && registryItem) {\n    if (registryItem.name) {\n      routeName = registryItem.name;\n    } else if (registryItem.template) {\n      routeName = `${packageName}/${registryItem.template}`;\n    } else {\n      routeName = packageName;\n    }\n    // dont include params in the name\n    routeName = routeName.split(\":\")[0];\n    return routeName;\n  }\n  return null;\n}\n\n/**\n * selectLayout\n * @param {Object} layout - element of shops.layout array\n * @param {Object} setLayout - layout\n * @param {Object} setWorkflow - workflow\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\nfunction selectLayout(layout, setLayout, setWorkflow) {\n  const currentLayout = setLayout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const currentWorkflow = setWorkflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n  if (layout.layout === currentLayout && layout.workflow === currentWorkflow && layout.enabled === true) {\n    return layout;\n  }\n  return null;\n}\n\n/**\n * ReactionLayout\n * sets and returns reaction layout structure\n * @param {Object} options - this router context\n * @param {String} options.layout - string of shop.layout.layout (defaults to coreLayout)\n * @param {String} options.workflow - string of shop.layout.workflow (defaults to coreLayout)\n * @returns {Object} layout - return object of template definitions for Blaze Layout\n */\nexport function ReactionLayout(options = {}) {\n  // Find a workflow layout to render\n  // Get the current shop data\n  const shop = Shops.findOne(Router.Reaction.getShopId());\n\n  // get the layout & workflow from options if they exist\n  // Otherwise get them from the Session. this is set in `/client/config/defaults`\n  // Otherwise, default to hard-coded values\n  const layoutName = options.layout || Session.get(\"DEFAULT_LAYOUT\") || \"coreLayout\";\n  const workflowName = options.workflow || Session.get(\"DEFAULT_WORKFLOW\") || \"coreWorkflow\";\n\n  // Layout object used to render\n  // Defaults provided for reference\n  let layoutStructure = {\n    template: \"\",\n    layoutHeader: \"\",\n    layoutFooter: \"\",\n    notFound: \"notFound\",\n    dashboardHeader: \"\",\n    dashboardControls: \"\",\n    dashboardHeaderControls: \"\",\n    adminControlsFooter: \"\"\n  };\n\n  // Find a registered layout using the layoutName and workflowName\n  if (shop) {\n    const sortedLayout = shop.layout.sort((prev, next) => prev.priority - next.priority);\n    const foundLayout = sortedLayout.find((x) => selectLayout(x, layoutName, workflowName));\n\n    if (foundLayout && foundLayout.structure) {\n      layoutStructure = {\n        ...foundLayout.structure\n      };\n    }\n  }\n\n  // If the original options did not include a workflow, but did have a template,\n  // then we override the template from the layout with the one provided by the options.\n  //\n  // Why is this? We always need a workflow to render the entire layout of the app.\n  // The default layout has a default template that may not be the one we want to render.\n  // Some routes, such as `/account/profile` do no have a workflow, but define a template.\n  // Without the logic below, it would end up rendering the homepage instead of the profile\n  // page.\n  // const optionsHasWorkflow = typeof options.workflow === \"string\";\n  const optionsHasTemplate = typeof options.template === \"string\";\n\n  if (optionsHasTemplate) {\n    layoutStructure.template = options.template;\n  }\n\n  // If there is no Blaze Template (Template[]) or React Component (getComponent)\n  // Then use the notFound template instead\n  if (!Template[layoutStructure.template] && !getComponent(layoutStructure.template)) {\n    return (\n      <Blaze template={layoutStructure.notFound} />\n    );\n  }\n\n  // Render the layout\n  return {\n    structure: layoutStructure,\n    component: (props) => { // eslint-disable-line react/no-multi-comp, react/display-name\n      const route = Router.current().route;\n      const structure = {\n        ...layoutStructure\n      };\n\n      // If the current route is unauthorized, and is not the \"not-found\" route,\n      // then override the template to use the default unauthroized template\n      if (hasRoutePermission(route) === false && route.name !== \"not-found\") {\n        structure.template = \"unauthorized\";\n      }\n\n      if (getComponent(layoutName)) {\n        return React.createElement(getComponent(layoutName), {\n          ...props,\n          structure: structure\n        });\n      } else if (Template[layoutName]) {\n        return (\n          <BlazeLayout\n            {...structure}\n            blazeTemplate={layoutName}\n          />\n        );\n      }\n\n      return <Blaze template={structure.notFound} />;\n    }\n  };\n}\n\n/**\n * initPackageRoutes\n * registers route and template when registry item has\n * registryItem.route && registryItem.template\n * @param {Object} options - options and context for route creation\n * @returns {undefined} returns undefined\n */\nRouter.initPackageRoutes = (options) => {\n  Router.Reaction = options.reactionContext;\n  Router.routes = [];\n\n  const pkgs = Packages.find().fetch();\n  const prefix = Router.Reaction.getShopPrefix();\n  const reactRouterRoutes = [];\n\n  // prefixing isnt necessary if we only have one shop\n  // but we need to bypass the current\n  // subscription to determine this.\n  const shopSub = Meteor.subscribe(\"shopsCount\");\n  if (shopSub.ready()) {\n    // using tmeasday:publish-counts\n    const shopCount = Counts.get(\"shops-count\");\n\n    // Index layout\n    const indexLayout = ReactionLayout(options.indexRoute);\n    const indexRoute = {\n      route: \"/\",\n      name: \"index\",\n      options: {\n        name: \"index\",\n        ...options.indexRoute,\n        component: indexLayout.component,\n        structure: indexLayout.structure\n      }\n    };\n\n    reactRouterRoutes.push(\n      <Route\n        exact={true}\n        key=\"index\"\n        path=\"/\"\n        render={indexLayout.component}\n      />\n    );\n\n    const notFoundLayout = ReactionLayout({ template: \"notFound\" });\n    const notFoundRoute = {\n      route: \"/not-found\",\n      name: \"not-found\",\n      options: {\n        name: \"not-found\",\n        ...notFoundLayout.indexRoute,\n        component: notFoundLayout.component,\n        structure: notFoundLayout.structure\n      }\n    };\n\n    reactRouterRoutes.push(\n      <Route\n        key=\"not-found\"\n        path=\"/not-found\"\n        render={notFoundLayout.component}\n      />\n    );\n\n    Router.routes.push(indexRoute);\n    Router.routes.push(notFoundRoute);\n\n    // get package registry route configurations\n    for (const pkg of pkgs) {\n      const newRoutes = [];\n      // pkg registry\n      if (pkg.registry && pkg.enabled) {\n        const registry = Array.from(pkg.registry);\n        for (const registryItem of registry) {\n          // registryItems\n          if (registryItem.route) {\n            const {\n              meta,\n              route,\n              template,\n              layout,\n              workflow\n            } = registryItem;\n\n            // get registry route name\n            const name = getRegistryRouteName(pkg.name, registryItem);\n\n            // define new route\n            // we could allow the options to be passed in the registry if we need to be more flexible\n            const reactionLayout = ReactionLayout({ template, workflow, layout });\n            const newRouteConfig = {\n              route,\n              name,\n              options: {\n                meta,\n                name,\n                template,\n                layout,\n                triggersEnter: Router.Hooks.get(\"onEnter\", name),\n                triggersExit: Router.Hooks.get(\"onExit\", name),\n                component: reactionLayout.component,\n                structure: reactionLayout.structure\n              }\n            };\n\n            // push new routes\n            newRoutes.push(newRouteConfig);\n          } // end registryItems\n        } // end package.registry\n\n        //\n        // add group and routes to routing table\n        //\n        const uniqRoutes = new Set(newRoutes);\n        let index = 0;\n        for (const route of uniqRoutes) {\n          // allow overriding of prefix in route definitions\n          // define an \"absolute\" url by excluding \"/\"\n          route.group = {};\n\n          if (route.route.substring(0, 1) !== \"/\") {\n            route.route = \"/\" + route.route;\n            route.group.prefix = \"\";\n          } else if (shopCount <= 1) {\n            route.group.prefix = \"\";\n          } else {\n            route.group.prefix = prefix;\n            route.route = `${prefix}${route.route}`;\n          }\n\n          // Add the route to the routing table\n          reactRouterRoutes.push(\n            <Route\n              key={`${pkg.name}-${route.name}-${index++}`}\n              path={route.route}\n              exact={true}\n              render={route.options.component}\n            />\n          );\n\n          Router.routes.push(route);\n        }\n      }\n    } // end package loop\n\n    Router._initialized = true;\n    Router.reactComponents = reactRouterRoutes;\n    Router._routes = Router.routes;\n\n    routerReadyDependency.changed();\n  }\n};\n\n\nexport default Router;\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Router\",\n  name: \"reaction-router\",\n  icon: \"fa fa-share\",\n  autoEnable: true,\n  settings: {},\n  registry: []\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Accounts\",\n  name: \"reaction-accounts\",\n  icon: \"fa fa-users\",\n  autoEnable: true,\n  settings: {},\n  registry: [{\n    route: \"/dashboard/accounts\",\n    name: \"accounts\",\n    provides: \"dashboard\",\n    label: \"Accounts\",\n    description: \"Manage how members sign into your shop.\",\n    icon: \"fa fa-users\",\n    container: \"core\",\n    template: \"accountsDashboard\",\n    workflow: \"coreAccountsWorkflow\",\n    priority: 1\n  }, {\n    label: \"Account Settings\",\n    icon: \"fa fa-sign-in\",\n    provides: \"settings\",\n    route: \"/dashboard/account/settings\",\n    container: \"accounts\",\n    workflow: \"coreAccountsWorkflow\",\n    template: \"accountsSettings\"\n  }, {\n    route: \"/dashboard/accounts\",\n    name: \"dashboard/accounts\",\n    workflow: \"coreAccountsWorkflow\",\n    provides: \"shortcut\",\n    label: \"Accounts\",\n    icon: \"fa fa-users\",\n    priority: 1,\n    container: \"dashboard\",\n    template: \"accountsDashboard\"\n  }, {\n    route: \"/account/profile\",\n    template: \"accountProfile\",\n    name: \"account/profile\",\n    label: \"Profile\",\n    icon: \"fa fa-user\",\n    provides: \"userAccountDropdown\"\n  }],\n  layout: [{\n    layout: \"coreLayout\",\n    workflow: \"coreAccountsWorkflow\",\n    collection: \"Accounts\",\n    theme: \"default\",\n    enabled: true,\n    structure: {\n      template: \"accountsDashboard\",\n      layoutHeader: \"layoutHeader\",\n      layoutFooter: \"\",\n      notFound: \"notFound\",\n      dashboardHeader: \"dashboardHeader\",\n      dashboardControls: \"\",\n      dashboardHeaderControls: \"\",\n      adminControlsFooter: \"adminControlsFooter\"\n    }\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Catalog\",\n  name: \"reaction-catalog\",\n  icon: \"fa fa-book\",\n  autoEnable: true,\n  settings: {\n    name: \"Catalog\"\n  },\n  registry: [\n    {\n      provides: \"dashboard\",\n      label: \"Catalog\",\n      description: \"Product catalog\",\n      icon: \"fa fa-book\",\n      container: \"core\"\n    },\n    {\n      label: \"Catalog Settings\",\n      icon: \"fa fa-book\",\n      name: \"catalog/settings\",\n      provides: \"settings\",\n      template: \"catalogSettings\"\n    }\n  ]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Cart, Orders, Packages, Shops } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/* eslint no-shadow: 0 */\n\nMeteor.methods({\n  /**\n   * workflow/pushCartWorkflow\n   * @summary updates cart workflow status\n   * @description status in the workflow is stored as the current active\n   * workflow step.\n   *\n   * first sets, second call moves status to next workflow\n   * additional calls do nothing\n   * user permissions to template are verified\n   * @param {String} workflow - name of workflow\n   * @param {String} newWorkflowStatus - name of the next workflow stage\n   * @param {String} [cartId] - cart._id\n   * @return {Array|Boolean|Number} return\n   */\n  \"workflow/pushCartWorkflow\": function (workflow, newWorkflowStatus, cartId) {\n    check(workflow, String);\n    check(newWorkflowStatus, String);\n    check(cartId, Match.Optional(String));\n    this.unblock();\n\n    let currentCart;\n    const defaultPackageWorkflows = [];\n    let nextWorkflowStep = {\n      template: \"\"\n    };\n\n    // This method could be called indirectly from publication method in a time\n    // when `this.userId` will be null, that's why we have a third argument in\n    // this method - `cartId`. So, we can't completely rely on `Meteor.userId()`\n    // here.\n    if (typeof cartId === \"string\") {\n      currentCart = Cart.findOne(cartId);\n    } else {\n      currentCart = Cart.findOne({\n        userId: this.userId\n      });\n    }\n    // exit if a cart doesn't exist.\n    if (!currentCart) return [];\n    // TODO doc this\n    const currentWorkflowStatus = currentCart.workflow.status;\n    const packages = Packages.find({\n      \"shopId\": Reaction.getShopId(),\n      \"layout.workflow\": workflow\n    });\n\n    // loop through packages and set the defaultPackageWorkflows\n    packages.forEach(function (reactionPackage) {\n      // todo fix this hack for not filtering nicely\n      if (!reactionPackage.layout.layout) {\n        const layouts = _.filter(reactionPackage.layout, {\n          workflow: workflow\n        });\n        // for every layout, process the associated workflows\n        _.each(layouts, function (layout) {\n          // audience is the layout permissions\n          if (typeof layout.audience !== \"object\") {\n            const defaultRoles = Shops.findOne(\n              Reaction.getShopId(), {\n                sort: {\n                  priority: 1\n                }\n              }).defaultRoles;\n            layout.audience = defaultRoles;\n          }\n          // check permissions so you don't have to on template. For a case, when\n          // this method calls indirectly from publication method, we do this\n          // check which is looks not pretty secure\n          let hasPermission;\n          if (typeof Meteor.userId() !== \"string\") {\n            hasPermission = Roles.userIsInRole(currentCart.userId, layout.audience, Reaction.getShopId());\n          } else {\n            hasPermission = Roles.userIsInRole(Meteor.userId(), layout.audience, Reaction.getShopId());\n          }\n\n          if (hasPermission  && !layout.layout) {\n            defaultPackageWorkflows.push(layout);\n          }\n        });\n      }\n    });\n\n    // statusExistsInWorkflow boolean\n    const statusExistsInWorkflow = _.includes(currentCart.workflow.workflow, newWorkflowStatus);\n    const maxSteps = defaultPackageWorkflows.length;\n    let nextWorkflowStepIndex;\n    let templateProcessedinWorkflow = false;\n    let gotoNextWorkflowStep = false;\n\n    // if we haven't populated workflows lets exit\n    if (!defaultPackageWorkflows.length > 0) {\n      return [];\n    }\n\n    // loop through all shop configured layouts, and their default workflows\n    // to determine what the next workflow step should be\n    // the cart workflow status while processing is neither true nor false (set to template)\n    _.each(defaultPackageWorkflows, function (workflow, currentStatusIndex) {\n      if (workflow.template === currentWorkflowStatus) {\n        // don't go past the end of the workflow\n        if (currentStatusIndex < maxSteps - 1) {\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          Logger.debug(\"currentStatusIndex, maxSteps\", currentStatusIndex, maxSteps);\n          nextWorkflowStepIndex = currentStatusIndex + 1;\n        } else {\n          nextWorkflowStepIndex = currentStatusIndex;\n        }\n\n        Logger.debug(\"nextWorkflowStepIndex\", nextWorkflowStepIndex);\n        // set the nextWorkflowStep as the next workflow object from registry\n        nextWorkflowStep = defaultPackageWorkflows[nextWorkflowStepIndex];\n\n        Logger.debug(\"setting nextWorkflowStep\", nextWorkflowStep.template);\n      }\n    });\n\n    // check to see if the next step has already been processed.\n    // templateProcessedinWorkflow boolean\n    gotoNextWorkflowStep = nextWorkflowStep.template;\n    templateProcessedinWorkflow = _.includes(currentCart.workflow.workflow,\n      nextWorkflowStep.template);\n\n    // debug info\n    Logger.debug(\"currentWorkflowStatus: \", currentWorkflowStatus);\n    Logger.debug(\"workflow/pushCartWorkflow workflow: \", workflow);\n    Logger.debug(\"newWorkflowStatus: \", newWorkflowStatus);\n    Logger.debug(\"current cartId: \", currentCart._id);\n    Logger.debug(\"currentWorkflow: \", currentCart.workflow.workflow);\n    Logger.debug(\"nextWorkflowStep: \", nextWorkflowStep.template || defaultPackageWorkflows[0].template);\n    Logger.debug(\"statusExistsInWorkflow: \", statusExistsInWorkflow);\n    Logger.debug(\"templateProcessedinWorkflow: \", templateProcessedinWorkflow);\n    Logger.debug(\"gotoNextWorkflowStep: \", gotoNextWorkflowStep);\n\n    // Condition One\n    // if you're going to join the workflow you need a status that is a template name.\n    // this status/template is how we know\n    // where you are in the flow and configures `gotoNextWorkflowStep`\n\n    if (!gotoNextWorkflowStep && currentWorkflowStatus !== newWorkflowStatus) {\n      Logger.debug(\n        `######## Condition One #########: initialise the ${currentCart._id} ${workflow}: ${defaultPackageWorkflows[0].template}`\n      );\n      const result = Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": defaultPackageWorkflows[0].template\n        }\n      });\n      Logger.debug(result);\n      return result;\n    }\n\n    // Condition Two\n    // your're now accepted into the workflow,\n    // but to begin the workflow you need to have a next step\n    // and you should have already be in the current workflow template\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === false &&\n      templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Two #########: set status to: \",\n        nextWorkflowStep.template);\n\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    }\n\n    // Condition Three\n    // If you got here by skipping around willy nilly\n    // we're going to do our best to ignore you.\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true &&\n      templateProcessedinWorkflow === false) {\n      Logger.debug(\"######## Condition Three #########: complete workflow \" +\n        currentWorkflowStatus + \" updates and move to: \",\n        nextWorkflowStep.template);\n      return Cart.update(currentCart._id, {\n        $set: {\n          \"workflow.status\": nextWorkflowStep.template\n        },\n        $addToSet: {\n          \"workflow.workflow\": currentWorkflowStatus\n        }\n      });\n    }\n\n    // Condition Four\n    // you got here through hard work, and processed the previous template\n    // nice job. now start over with the next step.\n    if (gotoNextWorkflowStep && statusExistsInWorkflow === true &&\n      templateProcessedinWorkflow === true) {\n      Logger.debug(\n        \"######## Condition Four #########: previously ran, doing nothing. : \",\n        newWorkflowStatus);\n      return true;\n    }\n  },\n\n  /**\n   * workflow/revertCartWorkflow\n   * @description if something was changed on the previous `cartWorkflow` steps\n   * we need to revert to this step to renew the order\n   * @param {String} newWorkflowStatus - name of `cartWorkflow` step, which\n   * we need to revert\n   * @todo need tests\n   * @return {Number|Boolean} cart update results\n   */\n  \"workflow/revertCartWorkflow\": function (newWorkflowStatus) {\n    check(newWorkflowStatus, String);\n    this.unblock();\n\n    const cart = Cart.findOne({\n      userId: this.userId\n    });\n\n    if (!cart || typeof cart.workflow !== \"object\") return false;\n    if (typeof cart.workflow.workflow !== \"object\") return false;\n\n    const { workflow } = cart.workflow;\n    // get index of `newWorkflowStatus`\n    const resetToIndex = workflow.indexOf(newWorkflowStatus);\n    // exit if no such step in workflow\n    if (!~resetToIndex) return false;\n    // remove all steps that further `newWorkflowStatus` and itself\n    const resetedWorkflow = workflow.slice(0, resetToIndex);\n\n    return Cart.update(cart._id, {\n      $set: {\n        \"workflow.status\": newWorkflowStatus,\n        \"workflow.workflow\": resetedWorkflow\n      }\n    });\n  },\n\n  /**\n   * workflow/pushOrderWorkflow\n   * Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   *\n   * Step 1 meteor call to push a new workflow\n   * Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", this);\n   * NOTE: \"coreOrderWorkflow\", \"processing\" will be combined into \"coreOrderWorkflow/processing\"\n   * and set as the status\n   *\n   * Step 2 (this method) of the \"workflow/pushOrderWorkflow\" flow; Try to update the current status\n   *\n   * @summary Update the order workflow\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pushOrderWorkflow\": function (workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Object); // TODO: Validatate as Schemas.Order\n    this.unblock();\n\n    const workflowStatus = `${workflow}/${status}`;\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        // Combine (workflow) \"coreOrderWorkflow\", (status) \"processing\" into \"coreOrderWorkflow/processing\".\n        // This comoniation will be used to call the method \"workflow/coreOrderWorkflow/processing\", if it exists.\n        \"workflow.status\": `${workflow}/${status}`\n      },\n      $addToSet: {\n        \"workflow.workflow\": workflowStatus\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * workflow/pullOrderWorkflow\n   * Push the status as the current workflow step,\n   * move the current status to completed worflow steps\n   * @summary Pull a previous order status\n   * @param  {String} workflow workflow to push to\n   * @param  {String} status - Workflow status\n   * @param  {Order} order - Schemas.Order, an order object\n   * @return {Boolean} true if update was successful\n   */\n  \"workflow/pullOrderWorkflow\": function (workflow, status, order) {\n    check(workflow, String);\n    check(status, String);\n    check(order, Object);\n    this.unblock();\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        \"workflow.status\": status\n      },\n      $pull: {\n        \"workflow.workflow\": order.workflow.status\n      }\n    });\n\n    return result;\n  },\n\n  \"workflow/pushItemWorkflow\": function (status, order, itemIds) {\n    check(status, String);\n    check(order, Object);\n    check(itemIds, Array);\n\n    const items = order.items.map((item) => {\n      // Add the current status to completed workflows\n      if (item.workflow.status !== \"new\") {\n        const workflows = item.workflow.workflow || [];\n\n        workflows.push(status);\n        item.workflow.workflow = _.uniq(workflows);\n      }\n\n      // Set the new item status\n      item.workflow.status = status;\n      return item;\n    });\n\n    const result = Orders.update({\n      _id: order._id\n    }, {\n      $set: {\n        items: items\n      }\n    });\n\n    return result;\n  }\n});\n","import \"./methods/workflow\";\nimport \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Checkout\",\n  name: \"reaction-checkout\",\n  icon: \"fa fa-shopping-cart\",\n  autoEnable: true,\n  settings: {\n    name: \"Checkout\"\n  },\n  registry: [{\n    route: \"/cart/checkout\",\n    name: \"cart/checkout\",\n    workflow: \"coreCartWorkflow\",\n    label: \"Checkout\",\n    template: \"cartCheckout\"\n  }, {\n    route: \"/cart/completed/:_id?\",\n    name: \"cart/completed\",\n    template: \"cartCompleted\",\n    workflow: \"coreCartWorkflow\"\n  }],\n  layout: [{\n    layout: \"coreLayout\",\n    workflow: \"coreCartWorkflow\",\n    collection: \"Cart\",\n    theme: \"default\",\n    enabled: true,\n    structure: {\n      template: \"cartCheckout\",\n      layoutHeader: \"checkoutHeader\",\n      layoutFooter: \"\",\n      notFound: \"notFound\",\n      dashboardHeader: \"\",\n      dashboardControls: \"dashboardControls\",\n      dashboardHeaderControls: \"\",\n      adminControlsFooter: \"adminControlsFooter\"\n    }\n  }, {\n    template: \"checkoutLogin\",\n    label: \"Login\",\n    workflow: \"coreCartWorkflow\",\n    container: \"checkout-steps-main\",\n    audience: [\"guest\", \"anonymous\"],\n    position: \"1\"\n  }, {\n    template: \"checkoutAddressBook\",\n    label: \"Shipping Billing\",\n    workflow: \"coreCartWorkflow\",\n    container: \"checkout-steps-main\",\n    audience: [\"guest\", \"anonymous\"],\n    position: \"2\"\n  }, {\n    template: \"coreCheckoutShipping\",\n    label: \"Shipping Options\",\n    workflow: \"coreCartWorkflow\",\n    container: \"checkout-steps-main\",\n    audience: [\"guest\", \"anonymous\"],\n    position: \"3\"\n  }, {\n    template: \"checkoutReview\",\n    label: \"Review Payment\",\n    workflow: \"coreCartWorkflow\",\n    container: \"checkout-steps-side\",\n    audience: [\"guest\", \"anonymous\"],\n    position: \"4\"\n  }, {\n    template: \"checkoutPayment\",\n    label: \"Complete\",\n    workflow: \"coreCartWorkflow\",\n    container: \"checkout-steps-side\",\n    audience: [\"guest\", \"anonymous\"],\n    position: \"5\"\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Dashboard\",\n  name: \"reaction-dashboard\",\n  icon: \"fa fa-th\",\n  autoEnable: true,\n  settings: {\n    name: \"Dashboard\"\n  },\n  registry: [{\n    provides: \"dashboard\",\n    workflow: \"coreDashboardWorkflow\",\n    name: \"dashboardPackages\",\n    label: \"Core\",\n    description: \"Reaction core shop configuration\",\n    icon: \"fa fa-th\",\n    priority: 0,\n    container: \"core\",\n    permissions: [{\n      label: \"Dashboard\",\n      permission: \"dashboard\"\n    }]\n  }, {\n    route: \"/dashboard\",\n    name: \"dashboard\",\n    workflow: \"coreDashboardWorkflow\",\n    provides: \"shortcut\",\n    label: \"Dashboard\",\n    template: \"dashboardPackages\",\n    icon: \"icon-reaction-logo\",\n    priority: 0\n  }, {\n    route: \"/dashboard/shop/settings\",\n    template: \"shopSettings\",\n    name: \"shopSettings\",\n    label: \"Shop Settings\",\n    icon: \"fa fa-th\",\n    provides: \"settings\",\n    container: \"dashboard\"\n  }],\n  layout: [{\n    layout: \"coreLayout\",\n    workflow: \"coreDashboardWorkflow\",\n    theme: \"default\",\n    enabled: true,\n    structure: {\n      template: \"dashboardPackages\",\n      layoutHeader: \"layoutHeader\",\n      layoutFooter: \"\",\n      notFound: \"notFound\",\n      dashboardHeader: \"dashboardHeader\",\n      dashboardControls: \"dashboardControls\",\n      dashboardHeaderControls: \"dashboardHeaderControls\",\n      adminControlsFooter: \"adminControlsFooter\"\n    }\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Email\",\n  name: \"reaction-email\",\n  icon: \"fa fa-envelope-o\",\n  autoEnable: true,\n  settings: {\n    name: \"Email\"\n  },\n  registry: [{\n    label: \"Email Settings\",\n    description: \"Email settings\",\n    icon: \"fa fa-envelope-o\",\n    name: \"email/settings\",\n    provides: \"settings\",\n    workflow: \"coreEmailWorkflow\",\n    template: \"emailSettings\",\n    meta: {\n      actionView: {\n        dashboardSize: \"md\"\n      }\n    }\n  }],\n  layout: [{\n    layout: \"coreLayout\",\n    workflow: \"coreEmailWorkflow\",\n    theme: \"default\",\n    enabled: true,\n    structure: {\n      template: \"email\",\n      layoutHeader: \"layoutHeader\",\n      layoutFooter: \"\",\n      notFound: \"notFound\",\n      dashboardHeader: \"dashboardHeader\",\n      dashboardControls: \"dashboardControls\",\n      adminControlsFooter: \"adminControlsFooter\"\n    }\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"i18n\",\n  name: \"reaction-i18n\",\n  icon: \"fa fa-language\",\n  autoEnable: true,\n  settings: {\n    name: \"i18n\"\n  },\n  registry: [{\n    provides: \"dashboard\",\n    label: \"i18n\",\n    description: \"Internationalization utilities\",\n    icon: \"fa fa-language\",\n    priority: 1,\n    container: \"utilities\"\n  }, {\n    provides: \"settings\",\n    template: \"i18nSettings\",\n    label: \"Localization and i18n\",\n    icon: \"fa fa-language\",\n    container: \"reaction-i18n\"\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./startup\";\nimport \"./i18n\";\n","import { AnalyticsEvents, Orders } from \"/lib/collections\";\n\n\nOrders.before.insert((userId, order) => {\n  const analyticsEvent = {\n    eventType: \"buy\",\n    value: order._id,\n    label: \"bought products\"\n  };\n  AnalyticsEvents.insert(analyticsEvent);\n});\n\n/**\n*  Step 3 of the \"workflow/pushOrderWorkflow\" flow\n*\n*\tThe following methods are called from Orders.before.update hook.\n*\t@see packages/reaction-schema/common/hooks/orders.js\n  * @see packages/reaction-core/common/methods/workflow.js\n*/\n\n/**\n * Orders collection before update\n * @param {String} userId - User wanting to update this documen\n * @param {Order} order - Order object, before any modifications\n * @param {Array} fieldNames - Array of field names to update\n * @param {Object} modifier - Mongo modifier object\n * @return {Boolean} true if document should be updated, false otherwise\n*/\nOrders.before.update((userId, order, fieldNames, modifier) => {\n  // if we're adding a new product or variant to the cart\n  if (modifier.$set) {\n    // Updating status of order e.g. \"coreOrderWorkflow/processing\"\n    if (modifier.$set[\"workflow.status\"]) {\n      const status = modifier.$set[\"workflow.status\"];\n      const workflowMethod = `workflow/${status}`;\n\n      if (Meteor.server.method_handlers[workflowMethod]) {\n        const result = Meteor.call(workflowMethod, {\n          userId,\n          order,\n          modifier\n        });\n        // Result should be true / false to all or disallow updating the status\n        return result;\n      }\n    }\n  }\n});\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Orders\",\n  name: \"reaction-orders\",\n  icon: \"fa fa-sun-o\",\n  autoEnable: true,\n  settings: {\n    name: \"Orders\"\n  },\n  registry: [{\n    route: \"/dashboard/orders\",\n    provides: \"dashboard\",\n    workflow: \"coreOrderWorkflow\",\n    name: \"orders\",\n    label: \"Orders\",\n    description: \"Fulfill your orders\",\n    icon: \"fa fa-sun-o\",\n    priority: 0,\n    container: \"core\",\n    template: \"orders\"\n  }, {\n    route: \"/dashboard/orders\",\n    name: \"dashboard/orders\",\n    provides: \"shortcut\",\n    label: \"Orders\",\n    description: \"Fulfill your orders\",\n    icon: \"fa fa-sun-o\",\n    priority: 1,\n    container: \"dashboard\",\n    template: \"orders\"\n  }, {\n    route: \"/dashboard/pdf/orders/:id\",\n    workflow: \"coreOrderPrintWorkflow\",\n    layout: \"printLayout\",\n    name: \"dashboard/pdf/orders\",\n    template: \"completedPDFLayout\"\n  }],\n  layout: [{\n    layout: \"coreLayout\",\n    workflow: \"coreOrderWorkflow\",\n    collection: \"Orders\",\n    theme: \"default\",\n    enabled: true,\n    structure: {\n      template: \"orders\",\n      layoutHeader: \"layoutHeader\",\n      layoutFooter: \"layoutFooter\",\n      notFound: \"notFound\",\n      dashboardHeader: \"dashboardHeader\",\n      dashboardHeaderControls: \"orderListFilters\",\n      dashboardControls: \"dashboardControls\",\n      adminControlsFooter: \"adminControlsFooter\"\n    }\n  }, {\n    layout: \"printLayout\",\n    workflow: \"coreOrderPrintWorkflow\",\n    collection: \"Orders\",\n    enabled: true,\n    structure: {\n      template: \"completedPDFLayout\",\n      layoutHeader: \"layoutHeader\",\n      layoutFooter: \"layoutFooter\"\n    }\n  }, {\n    layout: \"coreLayout\",\n    workflow: \"coreOrderShipmentWorkflow\",\n    collection: \"Orders\",\n    theme: \"default\",\n    enabled: true\n  }, {\n    label: \"Order Processing\",\n    status: \"created\",\n    workflow: \"coreOrderWorkflow\",\n    audience: [\"dashboard/orders\"]\n  }, {\n    template: \"coreOrderProcessing\",\n    label: \"Order Processing\",\n    status: \"processing\",\n    workflow: \"coreOrderWorkflow\",\n    audience: [\"dashboard/orders\"]\n  }, {\n    template: \"coreOrderCompleted\",\n    label: \"Order Completed\",\n    status: \"completed\",\n    workflow: \"coreOrderWorkflow\",\n    audience: [\"dashboard/orders\"]\n  }, { // Standard Order Fulfillment with shipping\n    template: \"coreOrderShippingSummary\",\n    label: \"Summary\",\n    workflow: \"coreOrderShipmentWorkflow\",\n    audience: [\"dashboard/orders\"]\n  }, {\n    template: \"coreOrderShippingInvoice\",\n    label: \"Invoice\",\n    workflow: \"coreOrderShipmentWorkflow\",\n    audience: [\"dashboard/orders\"]\n  }, {\n    template: \"coreOrderShippingTracking\",\n    label: \"Shipment Tracking\",\n    workflow: \"coreOrderShipmentWorkflow\",\n    audience: [\"dashboard/orders\"]\n  }, { // Standard Order Item workflow\n    label: \"Inventory Adjust\",\n    workflow: \"coreOrderItemWorkflow\",\n    status: \"inventoryAdjusted\",\n    audience: [\"dashboard/orders\"]\n  }, {\n    label: \"Item Payment Captured\",\n    workflow: \"coreOrderItemWorkflow\",\n    status: \"captured\",\n    audience: [\"dashboard/orders\"]\n  }, {\n    label: \"Item Ship\",\n    workflow: \"coreOrderItemWorkflow\",\n    status: \"shipped\",\n    audience: [\"dashboard/orders\"]\n  }, {\n    label: \"Item Delivered\",\n    workflow: \"coreOrderItemWorkflow\",\n    status: \"completed\",\n    audience: [\"dashboard/orders\"]\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Payments\",\n  name: \"reaction-payments\",\n  icon: \"fa fa-credit-card\",\n  autoEnable: true,\n  settings: {\n    payments: {\n      enabled: true\n    }\n  },\n  registry: [\n    {\n      provides: \"dashboard\",\n      name: \"payments\",\n      label: \"Payments\",\n      description: \"Payment Methods\",\n      icon: \"fa fa-credit-card\",\n      priority: 1,\n      container: \"core\",\n      workflow: \"coreDashboardWorkflow\"\n    },\n    {\n      label: \"Payment Settings\",\n      icon: \"fa fa-credit-card\",\n      name: \"payment/settings\",\n      provides: \"settings\",\n      template: \"paymentSettings\"\n    }\n  ]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"UI\",\n  name: \"reaction-ui\",\n  icon: \"fa fa-html5\",\n  autoEnable: true,\n  settings: \"\",\n  registry: [{\n    route: \"/dashboard/ui\",\n    name: \"reaction-ui/uiDashboard\",\n    provides: \"dashboard\",\n    workflow: \"coreUIWorkflow\",\n    container: \"appearance\",\n    label: \"Themes\",\n    description: \"Themes and UI Components\",\n    icon: \"fa fa-html5\",\n    priority: 1\n  }, {\n    route: \"/dashboard/ui/:id\",\n    workflow: \"coreUIWorkflow\",\n    name: \"dashboard/uiThemeDetails\",\n    template: \"uiThemeDetails\"\n  }],\n  layout: [{\n    layout: \"coreLayout\",\n    workflow: \"coreUIWorkflow\",\n    collection: \"Themes\",\n    theme: \"default\",\n    enabled: true,\n    structure: {\n      template: \"uiDashboard\",\n      layoutHeader: \"layoutHeader\",\n      layoutFooter: \"\",\n      notFound: \"notFound\",\n      dashboardHeader: \"dashboardHeader\",\n      dashboardControls: \"\",\n      dashboardHeaderControls: \"\",\n      adminControlsFooter: \"adminControlsFooter\"\n    }\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"UI Grid\",\n  name: \"reaction-ui-grid\",\n  autoEnable: true\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"UI Navbar\",\n  name: \"reaction-ui-navbar\",\n  autoEnable: true\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"UI TagNav\",\n  name: \"reaction-ui-tagnav\",\n  autoEnable: true\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import { Migrations } from \"/imports/plugins/core/versions\";\nimport { OrderSearch, AccountSearch } from \"/lib/collections\";\nimport { buildOrderSearch,\n  buildAccountSearch } from \"/imports/plugins/included/search-mongo/server/methods/searchcollections\";\n\nMigrations.add({\n  version: 1,\n  up: function () {\n    OrderSearch.remove({});\n    AccountSearch.remove();\n    buildOrderSearch();\n    buildAccountSearch();\n  },\n  down: function () {\n    // whether we are going up or down we just want to update the search collections\n    // to match whatever the current code in the build methods are.\n    OrderSearch.remove({});\n    AccountSearch.remove();\n    buildOrderSearch();\n    buildAccountSearch();\n  }\n});\n","import { Migrations } from \"/imports/plugins/core/versions\";\nimport { Packages } from \"/lib/collections\";\n\n// Add keys to search so that stock search is enabled by default\nMigrations.add({\n  version: 2,\n  up() {\n    Packages.update({ name: \"reaction-ui-search\" },\n      {\n        $set: {\n          registry: [{\n            name: \"Search Modal\",\n            provides: \"ui-search\",\n            template: \"searchModal\"\n          }]\n        }\n      },\n      { multi: true }\n    );\n  }\n});\n","import { Migrations } from \"/imports/plugins/core/versions\";\nimport { Packages } from \"/lib/collections\";\nimport { Reaction } from \"/server/api/\";\n// Add keys to search so that stock search is enabled by default\nMigrations.add({\n  version: 3,\n  up() {\n    Packages.update({},\n      {\n        $set: {\n          registry: []\n        }\n      },\n      { multi: true }\n    );\n    Reaction.loadPackages();\n    Reaction.Import.flush();\n  }\n});\n","import { Migrations } from \"/imports/plugins/core/versions\";\nimport { Packages } from \"/lib/collections\";\n\nconst reactionPkgs = [ // reaction packages with layouts\n  \"reaction-accounts\",\n  \"reaction-checkout\",\n  \"reaction-dashboard\",\n  \"reaction-email\",\n  \"reaction-orders\",\n  \"reaction-ui\",\n  \"reaction-inventory\",\n  \"reaction-product-variant\"];\n\nconst query = {\n  name: { $in: reactionPkgs },\n  layout: { $type: 3 } // docs with layouts set\n};\n\nMigrations.add({\n  version: 4,\n  up() {\n    const packages = Packages.find(query).fetch();\n    packages.forEach(updateHandler(1, 999));\n  },\n  down() {\n    const packages = Packages.find(query).fetch();\n    packages.forEach(updateHandler(999, 1));\n  }\n});\n\nfunction updateHandler(oldValue, newValue) {\n  return function (pkg) {\n    let changed = false; // to track if updating is needed\n    pkg.layout.forEach((layout) => {\n      if (!layout.priority || layout.priority === oldValue) {\n        layout.priority = newValue;\n        changed = true;\n      }\n    });\n\n    if (changed) {\n      Packages.update(pkg._id, {\n        $set: { layout: pkg.layout }\n      });\n    }\n  };\n}\n","import \"./1_rebuild_account_and_order_search_collections\";\nimport \"./2_add_key_to_search_ui\";\nimport \"./3_reset_package_registry\";\nimport \"./4_update_templates_priority\";\n","import \"./startup\";\nimport \"./migrations/\";\nimport \"./i18n\";\n","import _ from \"lodash\";\nimport { Hooks, Logger } from \"/server/api\";\nimport { Migrations } from \"/imports/plugins/core/versions\";\n\nfunction reactionLogger(opts) {\n  if (_.includes([\"warn\", \"info\", \"error\"], opts.level)) {\n    Logger[opts.level](opts.message);\n  }\n}\n\nMigrations.config({\n  logger: reactionLogger,\n  log: true,\n  logIfLatest: false,\n  collectionName: \"Migrations\"\n});\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  Migrations.migrateTo(\"latest\");\n});\n","export { Migrations as Migrations } from \"meteor/percolate:migrations\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Migrations\",\n  name: \"reaction-migrations\",\n  icon: \"fa fa-database\",\n  autoEnable: true,\n  settings: {},\n  registry: []\n});\n","import \"./publications\";\nimport \"./methods\";\n","import { Meteor } from \"meteor/meteor\";\nimport { Logs } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nexport function writeToLog(logType, logLevel, logData, source = \"client\") {\n  check(logType, String);\n  check(logLevel, String);\n  check(logData, Object);\n\n  const logEntry = {\n    logType: logType,\n    shopId: Reaction.getShopId(),\n    data: logData,\n    level: logLevel,\n    source: source\n  };\n  Logs.insert(logEntry);\n}\n\nfunction logError(logType, logData) {\n  check(logType, String);\n  check(logData, Object);\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"])) {\n    writeToLog(logType, \"error\", logData);\n  }\n}\n\nfunction logWarning(logType, logData) {\n  check(logType, String);\n  check(logData, Object);\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"])) {\n    writeToLog(logType, \"warn\", logData);\n  }\n}\n\nMeteor.methods({\n  \"logging/logError\": logError,\n  \"logging/logWarning\": logWarning\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { Counts } from \"meteor/tmeasday:publish-counts\";\nimport { Logs } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n\n/**\n * Publish logs\n * Poor admins get swamped with a ton of data so let's just only subscribe to one\n * logType at a time\n */\nMeteor.publish(\"Logs\", function (query, options) {\n  check(query, Match.OneOf(undefined, Object));\n  check(options, Match.OneOf(undefined, Object));\n\n  const shopId = Reaction.getShopId();\n  if (!query || !query.logType || !shopId) {\n    return this.ready();\n  }\n\n  const logType = query.logType;\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"])) {\n    Counts.publish(this, \"logs-count\", Logs.find({ shopId, logType }));\n    return Logs.find({ shopId, logType }, { sort: { date: 1 } });\n  }\n});\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Logging\",\n  name: \"reaction-logging\",\n  autoEnable: true\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Discounts } from \"/imports/plugins/core/discounts/lib/collections/schemas\";\n\n/**\n* Discount Codes Schema\n* @type {Object}\n* @desc schema that extends discount schema\n* with properties for discount codes.\n*/\nexport const DiscountCodes = new SimpleSchema([\n  Discounts, {\n    \"discountMethod\": {\n      label: \"Method\",\n      type: String,\n      defaultValue: \"code\"\n    },\n    \"calculation.method\": {\n      type: String,\n      index: 1,\n      defaultValue: \"discount\"\n    },\n    \"code\": {\n      label: \"Discount Code\",\n      type: String\n    },\n    \"conditions.redemptionLimit\": {\n      type: Number,\n      label: \"Total Limit\",\n      optional: true\n    },\n    \"conditions.accountLimit\": {\n      type: Number,\n      label: \"Account Limit\",\n      defaultValue: 1,\n      optional: true\n    }\n  }\n]);\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { DiscountsPackageConfig } from \"/imports/plugins/core/discounts/lib/collections/schemas\";\n\n/**\n* Discount Codes Package Config Schema\n* @type {Object}\n* @desc schema that extends discount schema\n* with properties for discount rates.\n*/\nexport const DiscountCodesPackageConfig = new SimpleSchema([\n  DiscountsPackageConfig, {\n    \"settings.codes\": {\n      type: Object,\n      optional: true\n    },\n    \"settings.codes.enabled\": {\n      type: Boolean,\n      optional: true,\n      defaultValue: false\n    }\n  }\n]);\n","export * from \"./config\";\nexport * from \"./codes\";\n","import { Cart } from \"/lib/collections\";\nimport { MethodHooks } from \"/server/api\";\n\n// this hook runs before a cart is converted to an order\n// it looks at any discounts that have been applied to the cart\n// and updates the discount document with a transaction history\nMethodHooks.before(\"cart/copyCartToOrder\", function (options) {\n  const cartId = options.arguments[0];\n  const cart = Cart.findOne(cartId);\n  // record that discounts have been applied to order\n  if (cart && cart.billing) {\n    for (const billing of cart.billing) {\n      // TODO should we enable transactions for rates as well?\n      if (billing.paymentMethod && billing.paymentMethod.processor === \"code\") {\n        Meteor.call(\"discounts/transaction\", cartId, billing.paymentMethod.id);\n      }\n    }\n  }\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./methods\";\n","import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Reaction } from \"/server/api\";\nimport { Cart } from \"/lib/collections\";\nimport { Discounts } from  \"/imports/plugins/core/discounts/lib/collections\";\nimport { DiscountCodes as DiscountSchema } from \"../../lib/collections/schemas\";\n\n// attach discount code specific schema\nDiscounts.attachSchema(DiscountSchema, { selector: { discountMethod: \"code\" } });\n\n//\n// make all discount methods available\n//\nexport const methods = {\n  /**\n   * discounts/codes/discount\n   * calculates percentage off discount rates\n   * we intentionally passed ids, instead\n   * of the cart,discount Object\n   * for a smaller request providing an\n   * additional level of validation.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/discount\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    for (const item of cart.items) {\n      const preDiscount = item.quantity * item.variants.price;\n      discount += preDiscount * discountMethod.discount / 100;\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/credit\n   * calculates a credit off cart\n   * for discount codes\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/credit\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    discount = discountMethod.discount;\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/sale\n   * calculates a new price for an item\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/sale\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    // TODO add item specific conditions to sale calculations.\n    for (const item of cart.items) {\n      const preDiscountItemTotal = item.quantity * item.variants.price;\n      const salePriceItemTotal = item.quantity * discountMethod.discount;\n      // we if the sale is below 0, we won't discount at all. that's invalid.\n      discount += Math.max(0, preDiscountItemTotal - salePriceItemTotal);\n    }\n\n    return discount;\n  },\n  /**\n   * TODO discounts/codes/shipping\n   * calculates a discount based on the value\n   * of a calculated shipping rate in the cart.\n   * @param  {String} cartId cartId\n   * @param  {String} discountId discountId\n   * @return {Number} returns discount total\n   */\n  \"discounts/codes/shipping\": function (cartId, discountId) {\n    check(cartId, String);\n    check(discountId, String);\n    let discount = 0;\n    const discountMethod = Discounts.findOne(discountId);\n    const cart = Cart.findOne(cartId);\n\n    for (const shipping of cart.shipping) {\n      if (shipping.shipmentMethod && shipping.shipmentMethod.name === discountMethod.discount) {\n        discount += Math.max(0, shipping.shipmentMethod.rate);\n      }\n    }\n\n    return discount;\n  },\n  /**\n   * discounts/addCode\n   * @param  {String} modifier update statement\n   * @param  {String} docId discount docId\n   * @param  {String} qty create this many additional codes\n   * @return {String} returns update/insert result\n   */\n  \"discounts/addCode\": function (modifier, docId) {\n    check(modifier, Object);\n    check(docId, Match.OneOf(String, null, undefined));\n\n    // check permissions to add\n    if (!Reaction.hasPermission(\"discount-codes\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // if no doc, insert\n    if (!docId) {\n      return Discounts.insert(modifier);\n    }\n    // else update and return\n    return Discounts.update(docId, modifier);\n  },\n  /**\n   * discounts/codes/remove\n   * removes discounts that have been previously applied\n   * to a cart.\n   * @param  {String} id cart id of which to remove a code\n   * @param  {String} codeId discount Id from cart.billing\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {String} returns update/insert result\n   */\n  \"discounts/codes/remove\": function (id, codeId, collection = \"Cart\") {\n    check(id, String);\n    check(codeId, String);\n    check(collection, String);\n    const Collection = Reaction.Collections[collection];\n    //\n    // delete code from cart\n    //\n    const cart = Collection.findOne(id);\n    let hasInvoice = false;\n    let currentDiscount = 0;\n    for (const billing of cart.billing) {\n      if (billing.paymentMethod && billing.paymentMethod.processor === \"code\" && billing._id !== codeId) {\n        currentDiscount += parseFloat(billing.paymentMethod.amount);\n      }\n      if (billing.paymentMethod && billing.invoice) {\n        hasInvoice = true;\n      }\n    }\n    // only if this is an order\n    if (hasInvoice) {\n      const selector = {\n        \"_id\": id,\n        \"billing._id\": cart.billing[0]._id\n      };\n      const update = {\n        $set: {\n          \"billing.$.invoice.discounts\": currentDiscount\n        }\n      };\n      Collection.update(selector, update);\n    }\n    // TODO: update a history record of transaction\n    // TODO: recalculate cart discounts (not simply 0)\n    return Collection.update(\n      { _id: id },\n      { $set: { discount: currentDiscount }, $pull: { billing: { _id: codeId } } },\n      { multi: true }\n    );\n  },\n  /**\n   * discounts/codes/apply\n   * checks validity of code conditions and then\n   * applies a discount as a paymentMethod to cart\n   * @param  {String} id cart/order id of which to remove a code\n   * @param  {String} code valid discount code\n   * @param  {String} collection collection (either Orders or Cart)\n   * @return {Boolean} returns true if successfully applied\n   */\n  \"discounts/codes/apply\": function (id, code, collection = \"Cart\") {\n    check(id, String);\n    check(code, String);\n    check(collection, String);\n    let userCount = 0;\n    let orderCount = 0;\n\n    // TODO: further expand to meet all condition rules\n    // const conditions = {\n    //   enabled: true\n    // };\n\n    // TODO: add  conditions: conditions\n    const discount = Discounts.findOne({ code: code });\n\n    // TODO: check usage limit\n    // don't apply if cart has exceeded usage limit\n    // will also need to check all time usage.\n    // which means storing the use data with the Discounts\n    // or searching all user's order history\n    // and if a user cancels an order,\n    // is the discount now re-activated\n\n    if (discount) {\n      const { conditions } = discount;\n      let accountLimitExceeded = false;\n      let discountLimitExceeded = false;\n\n      // existing usage count\n      if (discount.transactions) {\n        const users = Array.from(discount.transactions, (t) => t.userId);\n        const transactionCount = new Map([...new Set(users)].map(\n          x => [x, users.filter(y => y === x).length]\n        ));\n        const orders = Array.from(discount.transactions, (t) => t.cartId);\n        userCount = transactionCount.get(Meteor.userId());\n        orderCount = orders.length;\n      }\n      // check limits\n      if (conditions) {\n        if (conditions.accountLimit) accountLimitExceeded = conditions.accountLimit <= userCount;\n        if (conditions.redemptionLimit) discountLimitExceeded = conditions.redemptionLimit <= orderCount;\n      }\n\n      // validate basic limit handling\n      if (accountLimitExceeded === true || discountLimitExceeded === true) {\n        return { i18nKeyLabel: \"Code is expired\", i18nKey: \"discounts.codeIsExpired\" };\n      }\n\n      // save to payment methods\n      // and update status in Discounts\n      // payment methods can be debit or credit.\n      const paymentMethod = {\n        id: discount._id,\n        processor: discount.discountMethod,\n        method: discount.calculation.method,\n        code: discount.code,\n        transactionId: Random.id(),\n        amount: discount.discount, // pre-process to amount.\n        status: \"created\"\n      };\n      return Meteor.call(\"payments/apply\", id, paymentMethod, collection);\n    }\n  }\n};\n\n// export methods to Meteor\nMeteor.methods(methods);\n","import { Mongo } from \"meteor/mongo\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Counts } from \"meteor/tmeasday:publish-counts\";\nimport { Discounts } from \"/imports/plugins/core/discounts/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * Discounts\n * @type {Publication}\n * @param {Object} query\n * @param {Object} options\n */\nMeteor.publish(\"DiscountCodes\", function (query, options) {\n  check(query, Match.Optional(Object));\n  check(options, Match.Optional(Object));\n\n  // check shopId\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  const select = query || {};\n  // append shopId to query\n  select.shopId = shopId;\n  // select.cartId = cartId;\n  if (!select.discountMethod) {\n    select.discountMethod = \"code\";\n  }\n\n  // appends a count to the collection\n  // we're doing this for use with griddleTable\n  Counts.publish(this, \"discount-codes-count\", Discounts.find(\n    select,\n    options\n  ));\n\n  // Publishing our Discounts to a client side collection \"DiscountCodes\"\n  Mongo.Collection._publishCursor(Discounts.find(select, options), this, \"DiscountCodes\");\n\n  return this.ready();\n});\n","import { Security } from \"meteor/ongoworks:security\";\nimport { Discounts } from \"/imports/plugins/core/discounts/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n//\n// Security definitions\n//\nSecurity.permit([\"read\", \"insert\", \"update\", \"remove\"]).collections([\n  Discounts\n]).ifHasRole({\n  role: \"discount-codes\",\n  group: Reaction.getShopId()\n});\n","import \"./publications/discounts\";\nimport \"./security/discounts\";\nimport \"./i18n\";\nimport \"./methods\";\nimport \"./hooks/orders\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Codes\",\n  name: \"discount-codes\",\n  icon: \"fa fa-gift\",\n  autoEnable: true,\n  settings: {\n    \"discount-codes\": {\n      enabled: false\n    }\n  },\n  registry: [\n    {\n      label: \"Codes\",\n      provides: \"paymentSettings\",\n      template: \"customDiscountCodes\"\n    }, {\n      provides: \"paymentMethod\",\n      template: \"discountCodesCheckout\"\n    }\n  ]\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { DiscountsPackageConfig } from \"/imports/plugins/core/discounts/lib/collections/schemas\";\n\n/**\n* Discount Rates Package Config Schema\n* @type {Object}\n* @desc schema that extends discount schema\n* with properties for discount rates.\n*/\nexport const DiscountRatesPackageConfig = new SimpleSchema([\n  DiscountsPackageConfig, {\n    \"settings.rates\": {\n      type: Object,\n      optional: true\n    },\n    \"settings.rates.enabled\": {\n      type: Boolean,\n      optional: true,\n      defaultValue: false\n    }\n  }\n]);\n","export * from \"./config\";\nexport * from \"./rates\";\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Discounts } from \"/imports/plugins/core/discounts/lib/collections/schemas/discounts\";\n\n/**\n* Discount Codes Schema\n* @type {Object}\n* @desc schema that extends discount schema\n* with properties for discount codes.\n*/\nexport const DiscountRates = new SimpleSchema([\n  Discounts, {\n    discountMethod: {\n      label: \"Calculation Method\",\n      type: String,\n      defaultValue: \"rate\"\n    }\n  }\n]);\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./methods\";\n","import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Reaction } from \"/server/api\";\nimport { Discounts } from  \"/imports/plugins/core/discounts/lib/collections\";\nimport { DiscountRates as DiscountSchema } from \"../../lib/collections/schemas\";\n\n// attach discount code specific schema\nDiscounts.attachSchema(DiscountSchema, { selector: { discountMethod: \"rate\" } });\n\n//\n// make all discount methods available\n//\nexport const methods = {\n  /**\n   * discounts/rates/amount\n   * for discount rates\n   * @param  {String} cartId cartId\n   * @param  {String} rateId rateid\n   * @return {Number} returns discount total\n   */\n  \"discounts/rates/amount\": function (cartId, rateId) {\n    check(cartId, String);\n    check(rateId, String);\n    const rate = 0;\n    // TODO: discounts/rates/amount\n    // should be pricing rate lookup.\n    return rate;\n  },\n  \"discounts/rates/discount\": function (cartId, rateId) {\n    check(cartId, String);\n    check(rateId, String);\n    const rate = 0;\n    // TODO: discounts/rates/discount\n    return rate;\n  },\n  /**\n   * discounts/addRate\n   * @param  {String} modifier update statement\n   * @param  {String} docId discount docId\n   * @return {String} returns update/insert result\n   */\n  \"discounts/addRate\": function (modifier, docId) {\n    check(modifier, Object);\n    check(docId, Match.OneOf(String, null, undefined));\n\n    // check permissions to add\n    if (!Reaction.hasPermission(\"discount-rates\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // if no doc, insert\n    if (!docId) {\n      return Discounts.insert(modifier);\n    }\n    // else update and return\n    return Discounts.update(docId, modifier);\n  }\n};\n\n// export methods to Meteor\nMeteor.methods(methods);\n","import { Mongo } from \"meteor/mongo\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Counts } from \"meteor/tmeasday:publish-counts\";\nimport { Discounts } from \"/imports/plugins/core/discounts/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * Discounts\n * @type {Publication}\n * @param {Object} query\n * @param {Object} options\n */\nMeteor.publish(\"DiscountRates\", function (query, options) {\n  check(query, Match.Optional(Object));\n  check(options, Match.Optional(Object));\n\n  // check shopId\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  const select = query || {};\n  // append shopId to query\n  select.shopId = shopId;\n\n  if (!select.discountMethod) {\n    select.discountMethod = \"rate\";\n  }\n\n  // appends a count to the collection\n  // we're doing this for use with griddleTable\n  Counts.publish(this, \"discount-rates-count\", Discounts.find(\n    select,\n    options\n  ));\n\n  // Publishing our Discounts to a client side collection \"DiscountRates\"\n  Mongo.Collection._publishCursor(Discounts.find(select, options), this, \"DiscountRates\");\n\n  return this.ready();\n});\n","import { Security } from \"meteor/ongoworks:security\";\nimport { Discounts } from \"/imports/plugins/core/discounts/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n//\n// Security definitions\n//\nSecurity.permit([\"read\", \"insert\", \"update\", \"remove\"]).collections([\n  Discounts\n]).ifHasRole({\n  role: \"discount-rates\",\n  group: Reaction.getShopId()\n});\n","import \"./publications/discounts\";\nimport \"./security/discounts\";\nimport \"./i18n\";\nimport \"./methods\";\n","export * from \"./shippo\";\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { PackageConfig } from \"/lib/collections/schemas/registry\";\n\nexport const ShippoPackageConfig = new SimpleSchema([\n  PackageConfig, {\n    \"settings.apiKey\": {\n      type: String,\n      label: \"API Key\",\n      min: 10,\n      optional: true\n    }\n  }\n]);\n","export const shippingRoles = [\"admin\", \"owner\", \"shipping\", \"reaction-shipping-rates\"];\n","/* eslint camelcase: 0 */\nimport { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\nexport const addressSchema = new SimpleSchema({\n  object_purpose: { type: String, allowedValues: [\"QUOTE\", \"PURCHASE\"] },\n  name: { type: String, optional: true },\n  company: { type: String, optional: true },\n  street1: { type: String, optional: true },\n  street_no: { type: String, optional: true },   // only needed for DHL , the others get it from street1\n  street2: { type: String, optional: true },\n  city: { type: String, optional: true },\n  state: { type: String, optional: true },\n  zip: { type: String, optional: true },\n  country: { type: String }, // maybe iso 2\n  phone: { type: String, optional: true },\n  email: { type: String, regEx: SimpleSchema.RegEx.Email, optional: true },\n  is_residential: { type: Boolean, optional: true },\n  validate: { type: Boolean, optional: true },\n  metadata: { type: String, optional: true }\n});\n\n// Overrides the properties required for purchasing labels/shipping.\n// we don't override the purpose because for some cases like getRatesForCart we don't want to\n// purchase Labels(purpose=\"QUOTE\" but we want all the fields required for purchasing to be present.\nexport const purchaseAddressSchema = new SimpleSchema([addressSchema, {\n  name: { type: String, optional: false },\n  street1: { type: String, optional: false },\n  city: { type: String, optional: false },\n  state: { type: String, optional: false },\n  zip: { type: String, optional: false },\n  phone: { type: String, optional: false },\n  email: { type: String, regEx: SimpleSchema.RegEx.Email, optional: true }\n}]);\n\nexport const parcelSchema = new SimpleSchema({\n  length: { type: Number, decimal: true, min: 0.0001 },\n  width: { type: Number, decimal: true, min: 0.0001 },\n  height: { type: Number, decimal: true, min: 0.0001 },\n  distance_unit: { type: String, allowedValues: [\"cm\", \"in\", \"ft\", \"mm\", \"m\", \"yd\"] },\n  weight: { type: Number, decimal: true, min: 0.0001 },\n  mass_unit: { type: String, allowedValues: [\"g\", \"oz\", \"lb\", \"kg\"] },\n  template: { type: String, optional: true },\n  extra: { type: Object, optional: true },\n  metadata: { type: String, optional: true }\n});\n","import \"./rates\";\nimport \"./tracking\";\n","import { Meteor } from \"meteor/meteor\";\nimport { Shipping, Packages } from \"/lib/collections\";\nimport { Logger, Reaction, Hooks } from \"/server/api\";\n\n// callback ran on getShippingRates hook\nfunction getShippingRates(rates, cart) {\n  const shops = [];\n  const products = cart.items;\n\n  const pkgData = Packages.findOne({\n    name: \"reaction-shippo\",\n    shopId: Reaction.getShopId()\n  });\n\n  // must have cart items and package enabled to calculate shipping\n  if (!pkgData || !cart.items || pkgData.settings.shippo.enabled !== true) {\n    return rates;\n  }\n\n  // default selector is current shop\n  let selector = {\n    \"shopId\": Reaction.getShopId(),\n    \"provider.enabled\": true\n  };\n\n  // create an array of shops, allowing\n  // the cart to have products from multiple shops\n  for (const product of products) {\n    if (product.shopId) {\n      shops.push(product.shopId);\n    }\n  }\n  // if we have multiple shops in cart\n  if ((shops !== null ? shops.length : void 0) > 0) {\n    selector = {\n      \"shopId\": {\n        $in: shops\n      },\n      \"provider.enabled\": true\n    };\n  }\n\n  const shippingCollection = Shipping.find(selector);\n  const shippoDocs = {};\n  if (shippingCollection) {\n    shippingCollection.forEach(function (doc) {\n      // If provider is from Shippo, put it in an object to get rates dynamically(shippoApi) for all of them after.\n      if (doc.provider.shippoProvider) {\n        shippoDocs[doc.provider.shippoProvider.carrierAccountId] = doc;\n      }\n    });\n\n    //  Get shippingRates from Shippo\n    if (Object.keys(shippoDocs).length > 0) {\n      const shippoRates = Meteor.call(\"shippo/getShippingRatesForCart\", cart._id, shippoDocs);\n      rates.push(...shippoRates);\n    }\n  }\n\n  Logger.debug(\"Shippo onGetShippingRates\", rates);\n  return rates;\n}\n\n// run getShippingRates when the onGetShippingRates event runs\nHooks.Events.add(\"onGetShippingRates\", getShippingRates);\n","import { Meteor } from \"meteor/meteor\";\nimport { MethodHooks } from \"/server/api\";\n\nMethodHooks.before(\"shipping/status/refresh\", function (options) {\n  const orderId = options.arguments[0];\n  Meteor.call(\"shippo/confirmShippingMethodForOrder\",  orderId);\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./shippo\";\nimport fetchTrackingStatusForOrdersJob from \"./shippo\";\n\n// start \"shippo/fetchTrackingStatusForOrdersJob\"\nfetchTrackingStatusForOrdersJob();\n","import { Hooks, Logger, Reaction } from \"/server/api\";\nimport { Jobs, Packages } from \"/lib/collections\";\n\n// helper to fetch shippo config\nfunction getJobConfig() {\n  return Packages.findOne({\n    name: \"reaction-shippo\",\n    shopId: Reaction.getShopId()\n  }).settings;\n}\n\n// helper to get owner's UserId\nfunction getOwnerUserId() {\n  const owner = Meteor.users.findOne({\n    \"roles.__global_roles__\": \"owner\"\n  });\n  if (owner && typeof owner === \"object\") {\n    return owner._id;\n  }\n  return false;\n}\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  const config = getJobConfig();\n  const refreshPeriod = config.refreshPeriod;\n\n  if (!config.shippo.enabled || !refreshPeriod) {\n    return;\n  }\n  // there might be some validity to this being Logger.info.\n  Logger.debug(`Adding shippo/fetchTrackingStatusForOrders to JobControl. Refresh ${refreshPeriod}`);\n  new Job(Jobs, \"shippo/fetchTrackingStatusForOrdersJob\", {})\n    .priority(\"normal\")\n    .retry({\n      retries: 5,\n      wait: 60000,\n      backoff: \"exponential\" // delay by twice as long for each subsequent retry\n    })\n    .repeat({\n      schedule: Jobs.later.parse.text(refreshPeriod)\n    })\n    .save({\n      // Cancel any jobs of the same type,\n      // but only if this job repeats forever.\n      cancelRepeats: true\n    });\n});\n\nexport default function () {\n  const ownerId = getOwnerUserId();\n  if (ownerId) {\n    Jobs.processJobs(\n      \"shippo/fetchTrackingStatusForOrdersJob\",\n      {\n        pollInterval: 30 * 1000,\n        workTimeout: 180 * 1000\n      },\n      (job, callback) => {\n        // TODO review meteor runAsUser and add to project documentation\n        // As this is run by the Server and we don't have userId()/this.userId\n        // which \"shippo/fetchTrackingStatusForOrders\" need, we use dispatch:run-as-user\n        // An alternative way is https://forums.meteor.com/t/cant-set-logged-in-user-for-rest-calls/18656/3\n        Meteor.runAsUser(ownerId, ()=> {\n          Meteor.call(\"shippo/fetchTrackingStatusForOrders\", error => {\n            if (error) {\n              job.done(error.toString(), { repeatId: true });\n            } else {\n              const success = \"Shippo tracking status updated.\";\n              Logger.debug(success);\n              job.done(success, { repeatId: true });\n            }\n          });\n        });\n        callback();\n      }\n    );\n  }\n  return false;\n}\n","import { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Shipping } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport { shippingRoles } from \"../lib/roles\";\n\nexport const methods = {\n  /**\n   * shippo/carrier/update\n   * @summary update Shipping methods for a provider\n   * @param {String} provider provider object\n   * @return {Number} update result\n   */\n  \"shippo/carrier/update\": function (provider) {\n    check(provider, Object); // ShippingProvider\n    if (!Reaction.hasPermission(shippingRoles)) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const method = {};\n    method.provider = provider;\n    const flatten = require(\"flatten-obj\")();\n    const update = flatten(method);\n    return Shipping.update({\n      \"provider._id\": provider._id\n    }, {\n      $set: update\n    });\n  }\n};\n\nMeteor.methods(methods);\n","import \"./shippo\";\nimport \"./carriers\";\n","/* eslint camelcase: 0 */\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Reaction, Hooks } from \"/server/api\";\nimport { Packages, Accounts, Shops, Shipping, Cart, Orders } from \"/lib/collections\";\nimport { ShippoPackageConfig } from \"../../lib/collections/schemas\";\nimport { ShippoApi } from \"./shippoapi\";\nimport { shippingRoles } from \"../lib/roles\";\n\n// Creates an address (for sender or recipient) suitable for Shippo Api Calls given\n// a reaction address an email and a purpose(\"QUOTE\"|\"PURCHASE\")\nfunction createShippoAddress(reactionAddress, email, purpose) {\n  const shippoAddress = {\n    object_purpose: purpose,\n    name: reactionAddress.fullName,\n    street1: reactionAddress.address1,\n    street2: reactionAddress.address2 || \"\", // \"\" in order to be cleaned later by SimpleSchema.clean\n    city: reactionAddress.city,\n    company: reactionAddress.company || \"\",\n    state: reactionAddress.region,\n    zip: reactionAddress.postal,\n    country: reactionAddress.country,\n    phone: reactionAddress.phone,\n    email: email,\n    is_residential: !reactionAddress.isCommercial\n  };\n\n  return shippoAddress;\n}\n\n// Creates a parcel object suitable for Shippo Api Calls given\n// a reaction product's parcel and units of measure for mass and distance\nfunction createShippoParcel(reactionParcel, reactionMassUnit, reactionDistanceUnit) {\n  const shippoParcel = {\n    width: reactionParcel.width || \"\",\n    length: reactionParcel.length || \"\",\n    height: reactionParcel.height || \"\",\n    weight: reactionParcel.weight || \"\",\n    distance_unit: reactionDistanceUnit.toLowerCase(), // Propably we need to have for each shop a uom/baseuom for distance\n    mass_unit: reactionMassUnit.toLowerCase()\n  };\n\n  return shippoParcel;\n}\n\n// converts the Rates List fetched from the Shippo Api to Reaction Shipping Rates form\nfunction ratesParser(shippoRates, shippoDocs) {\n  return shippoRates.map(rate => {\n    const rateAmount = parseFloat(rate.amount);\n    // const methodLabel = `${rate.provider} - ${rate.servicelevel_name}`;\n    const reactionRate = {\n      carrier: rate.provider,\n      method: {\n        enabled: true,\n        label: rate.servicelevel_name,\n        rate: rateAmount,\n        handling: 0,\n        carrier: rate.provider,\n        settings: {\n          // carrierAccount: rate.carrier_account,\n          rateId: rate.object_id,\n          serviceLevelToken: rate.servicelevel_token\n        }\n      },\n      rate: rateAmount,\n      shopId: shippoDocs[rate.carrier_account].shopId\n    };\n\n    return reactionRate;\n  });\n}\n\n// Filters the carrier list and gets and parses only the ones that are activated in the Shippo Account\nfunction filterActiveCarriers(carrierList) {\n  const activeCarriers = [];\n  if (carrierList.results && carrierList.count) {\n    carrierList.results.forEach(carrier => {\n      if (carrier.active) {\n        activeCarriers.push({\n          carrier: carrier.carrier, // this is a property of the returned result with value the name of the carrier\n          carrierAccountId: carrier.object_id\n        });\n      }\n    });\n\n    return activeCarriers;\n  }\n}\n\n// usps_express to USPS EXPRESS .We need a better approach - use a suitable static map object\nfunction formatCarrierLabel(carrierName) {\n  return carrierName.replace(/_/g, \" \").toUpperCase();\n}\n\n// get Shippo's Api Key from the Shippo package with the supplied shopId or alternatively of the current shop's Id\nfunction getApiKey(shopId = Reaction.getShopId()) {\n  const { settings } = Packages.findOne({\n    name: \"reaction-shippo\",\n    shopId\n  });\n\n  return settings.apiKey;\n}\n\n// Adds Shippo carriers in Shipping Collection (one doc per carrier) for the current Shop\nfunction addShippoProviders(carriers, shopId = Reaction.getShopId()) {\n  let result = true;\n  carriers.forEach(carrier => {\n    const carrierName = carrier.carrier;\n    const carrierLabel = formatCarrierLabel(carrierName);\n    const currentResult = Shipping.insert({\n      name: `${carrierLabel}`, // check it later for a better name\n      methods: [],\n      provider: {\n        name: carrierName,\n        label: carrierLabel,\n        enabled: true,\n        shippoProvider: {\n          carrierAccountId: carrier.carrierAccountId\n        }\n      },\n      shopId\n    });\n    result = result && currentResult;\n  });\n\n  return result;\n}\n\n// Remove from Shipping Collection shop's Shippo Providers with carrier account Id in carriersIds\n// or all of them (if carriersIds is set to false)\nfunction removeShippoProviders(carriersIds, shopId = Reaction.getShopId()) {\n  if (carriersIds) {\n    return Shipping.remove({\n      shopId,\n      \"provider.shippoProvider.carrierAccountId\": { $in: carriersIds }\n    });\n  }\n\n  return Shipping.remove({\n    shopId,\n    \"provider.shippoProvider\": { $exists: true }\n  });\n}\n\n// After getting the current active Carriers of the Shippo Account removes\n// from the Shipping Collection the Shippo providers that are deactivated(don't exist in active carriers)\n// and inserts the newly active carriers in Shipping Collection as shippo providers.\n\nfunction updateShippoProviders(activeCarriers, shopId = Reaction.getShopId()) {\n  const currentShippoProviders = Shipping.find({\n    \"shopId\": shopId,\n    \"provider.shippoProvider\": { $exists: true }\n  }, {\n    fields: { \"provider.shippoProvider.carrierAccountId\": 1 }\n  });\n\n  // Ids of Shippo Carriers that exist currently as docs in Shipping Collection\n  const currentCarriersIds = currentShippoProviders.map(doc => doc.provider.shippoProvider.carrierAccountId);\n\n  const newActiveCarriers = [];\n  const unchangedActiveCarriersIds = [];\n  activeCarriers.forEach(carrier => {\n    const carrierId = carrier.carrierAccountId;\n    if (!currentCarriersIds.includes(carrierId)) {\n      newActiveCarriers.push(carrier);\n    } else {\n      unchangedActiveCarriersIds.push(carrierId);\n    }\n  });\n\n  const deactivatedCarriersIds = _.difference(currentCarriersIds, unchangedActiveCarriersIds);\n  if (deactivatedCarriersIds.length) {\n    removeShippoProviders(deactivatedCarriersIds, shopId);\n  }\n  if (newActiveCarriers.length) {\n    addShippoProviders(newActiveCarriers, shopId);\n  }\n\n  return true;\n}\n\nexport const methods = {\n  /**\n   * Updates the Api key(Live/Test Token) used for connection with the Shippo account.\n   * Also inserts(and deletes if already exist) docs in the Shipping collection each of the\n   * activated Carriers of the Shippo account.\n   * This method is intended to be used mainly by Autoform.\n   * @param {Object} modifier - The Autoform's modifier string\n   * @param {String} _id - The id of the Shippo package that gets updated\n   * @return {Object} result - The object returned.\n   * @return {String} {string(\"update\"|\"delete\")} result.type - The type of updating happened.\n   */\n  \"shippo/updateApiKey\"(modifier, _id) {\n    // Important server-side check for security and data integrity\n    check(modifier, ShippoPackageConfig);\n    check(_id, String);\n\n    // Make sure user has proper rights to this package\n    const { shopId } = Packages.findOne({ _id },\n                                        { field: { shopId: 1 } });\n    if (shopId && Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      // If user wants to delete existing key\n      if (modifier.hasOwnProperty(\"$unset\")) {\n        const customModifier = { $set: { \"settings.apiKey\": null } };\n        Packages.update(_id, customModifier);\n        // remove shop's existing Shippo Providers from Shipping Collection\n        removeShippoProviders(false, shopId);\n\n        return { type: \"delete\" };\n      }\n\n      const apiKey = modifier.$set[\"settings.apiKey\"];\n\n      // Tries to use the apiKey by fetching a list of the addresses of Shippo Account\n      // if not possible throws a relative Meteor Error (eg invalid_credentials)\n      ShippoApi.methods.getAddressList.call({ apiKey });\n      // if everything is ok proceed with the api key update\n      Packages.update(_id, modifier);\n      // remove shop's existing Shippo Providers from Shipping Collection\n      removeShippoProviders(false, shopId);\n\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({ apiKey }));\n      if (activeCarriers.length) {\n        addShippoProviders(activeCarriers, shopId);\n      }\n\n      return { type: \"update\" };\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the current active Shippo Carriers from the Shippo Account and updates the\n   * Shipping Collection by keeping only these as Shippo Providers of the shop.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n\n  \"shippo/fetchProviders\"() {\n    const shopId = Reaction.getShopId();\n\n    if (Roles.userIsInRole(this.userId, shippingRoles, shopId)) {\n      const apiKey = getApiKey(shopId);\n      if (!apiKey) {\n        return false;\n      }\n\n      const activeCarriers = filterActiveCarriers(ShippoApi.methods.getCarrierAccountsList.call({ apiKey }));\n      return updateShippoProviders(activeCarriers, shopId);\n    }\n\n    return false;\n  },\n\n  /**\n   * Fetches the tracking status of shipped orders from Shippo and updates the\n   * relevant orders' properties\n   * @param {String} orderId - optional orderId to get status of just one order.\n   * @return {Boolean} result - if the updating happened successfully or not.\n   * */\n  \"shippo/fetchTrackingStatusForOrders\"(orderId) {\n    check(orderId, Match.Optional(String));\n    const shopId = Reaction.getShopId();\n    let shippoOrders;\n    const apiKey = getApiKey(shopId);\n    if (!apiKey) {\n      return false;\n    }\n\n    if (orderId) {\n      // return a specific order\n      shippoOrders = Orders.find({\n        shopId,\n        orderId\n      });\n    } else {\n      // Find the orders of the shop that have shippo provider, tracking number, that are shipped\n      // but they are not yet delivered;\n      shippoOrders = Orders.find({\n        shopId,\n        \"shipping.0.shippo.transactionId\": { $exists: true },\n        \"shipping.0.tracking\": { $exists: true },\n        \"shipping.0.shipped\": true,\n        \"shipping.0.delivered\": { $ne: true }\n        // For now we don' t have logic for returned products\n      });\n    }\n\n\n    // no orders to update\n    if (!shippoOrders.count()) {\n      return true;\n    }\n\n    // For each order get from Shippo the transaction item ,check the tracking and if it has been updated\n    let updatingResult = true;\n    shippoOrders.forEach(order => {\n      const orderShipment = order.shipping[0];\n      const transactionId = orderShipment.shippo.transactionId;\n      const transaction = ShippoApi.methods.getTransaction.call({ apiKey, transactionId });\n\n      // For Testing:\n      // Comment First line of code, and uncomment following block to mock the updating of tracking status\n      // as Shippo's tracking status for test Shipments isn't getting updated.\n      const trackingStatus = transaction.tracking_status;\n      // const trackingStatus = {};\n      // if (transaction.object_state === \"VALID\") {\n      //   trackingStatus.status_date = (new Date).toString();\n      //   trackingStatus.status = (!orderShipment.shippo.trackingStatusStatus ? \"TRANSIT\" : \"DELIVERED\");\n      // }\n\n      if (trackingStatus &&\n        trackingStatus.status_date !== orderShipment.shippo.trackingStatusDate) {\n        // Shippo's tracking_status.status\tenum\tIndicates the high level status of the shipment:\n        // 'UNKNOWN', 'DELIVERED', 'TRANSIT', 'FAILURE', 'RETURNED'.\n        if (trackingStatus.status === \"DELIVERED\") {\n          Meteor.call(\"orders/shipmentDelivered\", order);\n        }\n\n        // A batch update might be better option. Unfortunately Reaction.import doesn't support\n        // .. Orders currently\n        const orderUpdating = Orders.update({\n          _id: order._id\n        }, {\n          $set: {\n            \"shipping.0.shippo.trackingStatusDate\": trackingStatus.status_date,\n            \"shipping.0.shippo.trackingStatusStatus\": trackingStatus.status\n          }\n        });\n        updatingResult = updatingResult && orderUpdating;\n      }\n    });\n\n    return updatingResult;\n  },\n\n  /**\n   * Returns the available Shippo Methods/Rates for a selected cart, in the same form shipping/getShippingRates\n   * returns them.\n   * @param {String} cartId - The id of the cart that rates are to be supplied.\n   * @param {Object} shippoDocs - Contains all the Enabled Shipping Objects with provider.shippoProvider property.\n   * Each property has as key the Shippo's carrierAccountId and as value the corresponding document of shipping\n   * collection.\n   * @return {Array} rates - The rates of the enabled and available Shippo carriers.\n   * */\n  \"shippo/getShippingRatesForCart\"(cartId, shippoDocs) {\n    check(cartId, String);\n    check(shippoDocs, Object);\n    const cart = Cart.findOne(cartId);\n    if (cart && cart.userId === this.userId) { // confirm user has the right\n      let shippoAddressTo;\n      let shippoParcel;\n      const purpose = \"PURCHASE\";\n\n      const shop = Shops.findOne({\n        _id: cart.shopId\n      }, {\n        field: {\n          addressBook: 1,\n          emails: 1,\n          unitsOfMeasure: { $elemMatch: { default: true } }\n        }\n      });\n\n      const apiKey = getApiKey(cart.shopId);\n      // If for a weird reason Shop hasn't a Shippo Api key anymore return no-rates.\n      if (!apiKey) {\n        return [];\n      }\n      // TODO create a shipping address book record for shop.\n      const shippoAddressFrom = createShippoAddress(shop.addressBook[0], shop.emails[0].address, purpose);\n      // product in the cart has to have parcel property with the dimensions\n      if (cart.items && cart.items[0] && cart.items[0].parcel) {\n        const unitOfMeasure = shop && shop.unitsOfMeasure && shop.unitsOfMeasure[0].uom || \"KG\";\n        // at the moment shops don't have a kind of unitOfMeasure for distance\n        // so we put CM...\n        shippoParcel = createShippoParcel(cart.items[0].parcel, unitOfMeasure, \"CM\");\n      } else {\n        return [];\n      }\n\n      const buyer = Accounts.findOne({\n        _id: this.userId\n      }, {\n        field: { emails: 1 }\n      });\n      // check that there is address available in cart\n      if (cart.shipping && cart.shipping[0] && cart.shipping[0].address) {\n        // TODO take a more elegant approach to guest checkout -> no email address\n        // add Logger.trace if this smells\n        let email = shop.emails[0].address || \"noreply@localhost\";\n        if (buyer.emails.length > 0) {\n          if (buyer.emails[0].address) {\n            email = buyer.emails[0].address;\n          }\n        }\n        shippoAddressTo = createShippoAddress(cart.shipping[0].address, email, purpose);\n      } else {\n        return [];\n      }\n      const carrierAccounts = Object.keys(shippoDocs);\n      const shippoShipment = ShippoApi.methods.createShipment.call({\n        shippoAddressFrom,\n        shippoAddressTo,\n        shippoParcel,\n        purpose,\n        carrierAccounts,\n        apiKey\n      });\n      const shippoRates = shippoShipment.rates_list;\n      const reactionRates = ratesParser(shippoRates, shippoDocs);\n\n      return reactionRates;\n    }\n\n    return false;\n  },\n\n  /**\n   * Confirms Shippo order based on buyer's choice at the time of purchase\n   * and supplies the order doc with the tracking and label infos\n   * @param {String} orderId - The id of the ordered that labels are purchased for\n   * @return {Boolean} result - True if procedure completed succesfully,otherwise false\n   */\n  \"shippo/confirmShippingMethodForOrder\"(orderId) {\n    check(orderId, String);\n    const order = Orders.findOne(orderId);\n    // Make sure user has permissions in the shop's order\n    if (Roles.userIsInRole(this.userId, shippingRoles, order.shopId)) {\n      const orderShipment = order.shipping[0];\n      // Here we done it for the first/unique Shipment only . in the near future it will be done for multiple ones\n      if (orderShipment && orderShipment.shipmentMethod && orderShipment.shipmentMethod.settings && orderShipment.shipmentMethod.settings.rateId) {\n        const apiKey = getApiKey(order.shopId);\n        // If for a weird reason Shop hasn't a Shippo Api key anymore you have to throw an error\n        // cause the Shippo label purchasing is not gonna happen.\n        if (!apiKey) {\n          throw new Meteor.Error(\"403\", \"Invalid Shippo Credentials\");\n        }\n        const rateId = orderShipment.shipmentMethod.settings.rateId;\n        // make the actual purchase\n        const transaction = ShippoApi.methods.createTransaction.call({ rateId, apiKey });\n        if (transaction) {\n          return Orders.update({\n            _id: orderId\n          }, {\n            $set: {\n              \"shipping.0.shippingLabelUrl\": transaction.label_url,\n              \"shipping.0.tracking\": transaction.tracking_number,\n              \"shipping.0.shippo.transactionId\": transaction.object_id,\n              \"shipping.0.shippo.trackingStatusDate\": null,\n              \"shipping.0.shippo.trackingStatusStatus\": null\n            }\n          });\n        }\n      }\n    }\n    return false;\n  }\n};\n\nMeteor.methods(methods);\n\nHooks.Events.add(\"onOrderPaymentCaptured\", methods[\"shippo/confirmShippingMethodForOrder\"]);\n","/* eslint camelcase: 0 */\nimport Shippo from \"shippo\";\nimport { Meteor } from \"meteor/meteor\";\nimport { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Logger } from \"/server/api\";\nimport { purchaseAddressSchema, parcelSchema } from \"../lib/shippoApiSchema\";\n\nexport const ShippoApi = {\n  methods: {}\n};\n\n\n/**\n * Retrieves the address objects stored in Shippo Account\n * @see https://goshippo.com/docs/reference#addresses\n * @param {Object} parameter - ValidatedMethod's parameter\n * @param {String} parameter.apiKey - The Test or Live Token required\n * for authentication by Shippo's api\n * @return {Object} addressList - compound object returned returned by Shippo\n * @return {Array} addressList.results - An array with the address objects\n * @return {Number} addressList.count - the count of the address objects.\n * */\nShippoApi.methods.getAddressList = new ValidatedMethod({\n  name: \"ShippoApi.methods.getAddressList\",\n  validate: new SimpleSchema({\n    apiKey: {\n      type: String\n    }\n  }).validator(),\n  run({ apiKey }) {\n    const shippoObj = new Shippo(apiKey);\n    shippoObj.set(\"version\", \"2016-10-25\");\n    const getAddressListFiber = Meteor.wrapAsync(shippoObj.address.list, shippoObj.address);\n    try {\n      const addressList = getAddressListFiber();\n\n      return addressList;\n    } catch (error) {\n      Logger.error(error.message);\n      throw new Meteor.Error(error.message);\n    }\n  }\n});\n\n\n/**\n * Retrieves all Shippo carriers from the Shippo Account\n * @see https://goshippo.com/docs/reference#carrier-accounts-list\n * @param {Object} parameter - ValidatedMethod's parameter\n * @param {String} parameter.apiKey - The Test or Live Token required\n * for authentication by Shippo's api\n * @return {Object} carrierAccountList - the compound object returned by Shippo\n * @return {Array} carrierAccountList.results - An array with the carrier accounts objects\n * @return {Number} carrierAccountList.count - the count of the carrier accounts objects.\n *\n */\nShippoApi.methods.getCarrierAccountsList = new ValidatedMethod({\n  name: \"ShippoApi.methods.getCarrierAccountsList\",\n  validate: new SimpleSchema({\n    apiKey: {\n      type: String\n    }\n  }).validator(),\n  run({ apiKey }) {\n    const shippoObj = new Shippo(apiKey);\n    shippoObj.set(\"version\", \"2016-10-25\");\n    let allCarriers = [];\n\n    // recursively fetch carriers because shippo returns paginated results\n    function fetchCarriers() {\n      try {\n        const response = Meteor.wrapAsync(shippoObj.carrieraccount.list, shippoObj.carrieraccount)();\n        allCarriers = allCarriers.concat(response.results);\n\n        if (!response.next) {\n          response.results = allCarriers;\n          return response;\n        }\n        // the Shippo module uses \"createFullPath\" to form the url for the request\n        // https://github.com/goshippo/shippo-node-client/blob/master/lib/Resource.js#L40-L48\n        // hence we're passing the next url in this way\n        shippoObj.carrieraccount.createFullPath = () => response.next;\n        return fetchCarriers();\n      } catch (error) {\n        Logger.error(error.message);\n        throw new Meteor.Error(error.message);\n      }\n    }\n\n    return fetchCarriers();\n  }\n});\n\n/**\n * Creates a Shippo's Shipment object for the given addresses and gets Rates for the particular shipment)\n * @see https://goshippo.com/docs/reference#shipments-create\n * @param {Object} parameter - ValidatedMethod's parameter\n * @param {Object} parameter.shippoAddressFrom - The address of the sender\n * @param {Object} parameter.shippoAddressTo - The address of the receiver\n * @param {Object} parameter.shippoParcel - The parcel dimensions's/weight\n * @param {String(\"QUOTE\"|\"PURCHASE\")} parameter.purpose  - The reason of the shipment(check prices/ purchase labels)\n * @param {String} parameter.apiKey - The Test or Live Token required\n * for authentication by Shippo's api\n * @return {Object} shipment - The compound shipment object returned by Shippo\n * @return {Array} shipment.rates_list - The available rate objects\n * */\nShippoApi.methods.createShipment = new ValidatedMethod({\n  name: \"ShippoApi.methods.createShipment\",\n  validate: new SimpleSchema({\n    shippoAddressFrom: { type: purchaseAddressSchema },\n    shippoAddressTo: { type: purchaseAddressSchema },\n    shippoParcel: { type: parcelSchema },\n    purpose: { type: String, allowedValues: [\"QUOTE\", \"PURCHASE\"] },\n    apiKey: { type: String },\n    carrierAccounts: { type: [String], optional: true }\n  }).validator(),\n  run({ shippoAddressFrom, shippoAddressTo, shippoParcel, purpose, apiKey, carrierAccounts }) {\n    const shippoObj = new Shippo(apiKey);\n    shippoObj.set(\"version\", \"2016-10-25\");\n\n    const createShipmentFiber = Meteor.wrapAsync(shippoObj.shipment.create, shippoObj.shipment);\n    try {\n      const shipment = createShipmentFiber({\n        object_purpose: purpose,\n        address_from: shippoAddressFrom,\n        address_to: shippoAddressTo,\n        parcel: shippoParcel,\n        carrier_accounts: carrierAccounts,\n        async: false\n      });\n\n      return shipment;\n    } catch (error) {\n      Logger.error(error.message);\n      throw new Meteor.Error(error.message);\n    }\n  }\n});\n\n/**\n * Makes the transaction (purchasing of a shipping label from a shipping provider for a specific service)\n * for the specific rateId and returns its Shipping Label ,Tracking number etc\n * @see https://goshippo.com/docs/reference#transactions-create\n * @param {Object} parameter - ValidatedMethod's parameter\n * @param {String} parameter.rateId - unique identifier of the chosen rate object\n * @param {String} parameter.apiKey - The Test or Live Token required\n * for authentication by Shippo's api\n * @return {Object} transaction - The compound transaction object returned by Shippo\n * */\nShippoApi.methods.createTransaction = new ValidatedMethod({\n  name: \"ShippoApi.methods.createTransaction\",\n  validate: new SimpleSchema({\n    rateId: { type: String },\n    apiKey: { type: String }\n  }).validator(),\n  run({ rateId, apiKey }) {\n    const shippoObj = new Shippo(apiKey);\n    shippoObj.set(\"version\", \"2016-10-25\");\n\n    const createTransactionFiber = Meteor.wrapAsync(shippoObj.transaction.create, shippoObj.transaction);\n    try {\n      const transaction = createTransactionFiber({\n        rate: rateId,\n        label_file_type: \"PDF\",\n        async: false\n      });\n\n      if (transaction.object_status !== \"SUCCESS\") {\n        const error = transaction.messages[0].text;\n        Logger.error(error);\n        throw new Meteor.Error(error);\n      }\n\n      return transaction;\n    } catch (error) {\n      Logger.debug(error.message);\n      throw new Meteor.Error(error.message);\n    }\n  }\n});\n\n/**\n * Retrieves transaction with transactionId of Shippo Account\n * @see https://goshippo.com/docs/reference#transactions-retrieve\n * @param {Object} parameter - ValidatedMethod's parameter\n * @param {String} parameter.transactionId - unique identifier of the transaction object\n * @param {String} parameter.apiKey - The Test or Live Token required\n * for authentication by Shippo's api\n * @return {Object} transaction - transaction object returned by Shippo\n * */\nShippoApi.methods.getTransaction = new ValidatedMethod({\n  name: \"ShippoApi.methods.getTransaction\",\n  validate: new SimpleSchema({\n    transactionId: { type: String },\n    apiKey: { type: String }\n  }).validator(),\n  run({ transactionId, apiKey }) {\n    const shippoObj = new Shippo(apiKey);\n    shippoObj.set(\"version\", \"2016-10-25\");\n\n    const retrieveTransactionFiber = Meteor.wrapAsync(shippoObj.transaction.retrieve, shippoObj.transaction);\n    try {\n      const transaction = retrieveTransactionFiber(transactionId);\n      return transaction;\n    } catch (error) {\n      Logger.error(error.message);\n      throw new Meteor.Error(error.message);\n    }\n  }\n});\n","import \"./methods\";\nimport \"./jobs\";\nimport \"./i18n\";\nimport \"./hooks\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Shippo\",\n  name: \"reaction-shippo\",\n  icon: \"fa fa-plane\",\n  autoEnable: true,\n  settings: {\n    shippo: {\n      enabled: false\n    },\n    // todo: move all settings in shippo subfield\n    apiKey: \"\",\n    refreshPeriod: \"every 2 hours\"\n  },\n  registry: [{\n    provides: \"dashboard\",\n    label: \"Shippo\",\n    description: \"Shippo service\",\n    icon: \"fa fa-plane\",\n    priority: 1,\n    container: \"connect\",\n    permissions: [{\n      label: \"Shippo\",\n      permission: \"dashboard/shippo\"\n    }]\n  }, {\n    label: \"Shippo\",\n    icon: \"fa fa-plane\",\n    name: \"shipping/settings/shippo\",\n    provides: \"shippingSettings\",\n    container: \"connection\",\n    template: \"shippoSettings\"\n  }\n// WIP:\n// TODO: Review custom shipping in checkout, are layout handling this requirement\n// For now we use Flat Rate's checkout template( which inherits its methods from coreCheckoutShipping\n// to show all shipping methods in the same panel.\n// .If we are gonna proceed with different panel per provider, we need to enable the 'provides:\"Shipping Method\"',\n// alter coreCheckoutShipping checkout.js and inherit from there (or write specific logic) for a shippo's\n// checkout template.\n//\n// provides: \"shippingMethod\",\n// name: \"shipping/methods/shippo\",\n// template: \"shippoCheckoutShipping\"\n// Not needed at the time cause the coreCheckoutShipping is enough(inherited from Flatrate)\n// }\n  ]\n});\n","/* eslint camelcase: 0 */\nimport { Meteor } from \"meteor/meteor\";\nimport { Packages } from \"/lib/collections\";\nimport Reaction from \"/lib/api\";\n\nfunction getSettings(settings, ref, valueName) {\n  if (settings !== null) {\n    return settings[valueName];\n  } else if (ref !== null) {\n    return ref[valueName];\n  }\n  return {};\n}\n\n// using global instance of Reaction\n// Paypal is a shared client/server stub\n// to provide normalized PayPal tooling\n\nexport const Express = {\n  expressCheckoutAccountOptions: function () {\n    const shopId = Reaction.getShopId();\n    const settings = Packages.findOne({\n      name: \"reaction-paypal\",\n      shopId: shopId,\n      enabled: true\n    }).settings;\n    let mode;\n\n    if ((settings !== null ? settings.express_mode : void 0) === true) {\n      mode = \"production\";\n    } else {\n      mode = \"sandbox\";\n    }\n    const ref = Meteor.settings.paypal;\n\n    const options = {\n      enabled: settings !== null ? settings.express.enabled : void 0,\n      mode: mode,\n      username: getSettings(settings, ref, \"username\"),\n      password: getSettings(settings, ref, \"password\"),\n      signature: getSettings(settings, ref, \"signature\"),\n      merchantId: getSettings(settings, ref, \"merchantId\"),\n      return_url: Reaction.getAbsoluteUrl(\"/paypal/done\"),\n      cancel_url: Reaction.getAbsoluteUrl(\"/paypal/cancel\")\n    };\n    if (options.mode === \"sandbox\") {\n      options.url = \"https://api-3t.sandbox.paypal.com/nvp\";\n    } else {\n      options.url = \"https://api-3t.paypal.com/nvp\";\n    }\n    return options;\n  },\n  config: function (options) {\n    this.accountOptions = options;\n  }\n};\n","import * as PayFlow from \"./payflow\";\nimport * as Express from \"./express\";\n\nexport const PayPal = Object.assign({},\n  Express.Express,\n  PayFlow.PayFlow\n);\n","/* eslint camelcase: 0 */\nimport { Meteor } from \"meteor/meteor\";\nimport { Packages } from \"/lib/collections\";\nimport Reaction from \"/lib/api\";\n\n// using global instance of Reaction\n// Paypal is a shared client/server stub\n// to provide normalized PayPal tooling\n\nexport const PayFlow = {\n  payflowAccountOptions: function () {\n    const settings = Packages.findOne({\n      name: \"reaction-paypal\",\n      shopId: Reaction.getShopId(),\n      enabled: true\n    }).settings;\n    let mode;\n    if ((settings !== null ? settings.payflow_mode : void 0) === true) {\n      mode = \"live\";\n    } else {\n      mode = \"sandbox\";\n    }\n    const ref = Meteor.settings.paypal;\n    const options = {\n      mode: mode,\n      enabled: getSettings(settings, ref, \"payflow_enabled\"),\n      client_id: getSettings(settings, ref, \"client_id\"),\n      client_secret: getSettings(settings, ref, \"client_secret\")\n    };\n    if (!options.client_id) {\n      throw new Meteor.Error(403, \"Invalid PayPal Credentials\");\n    }\n    return options;\n  },\n  authorize: function (cardInfo, paymentInfo, callback) {\n    Meteor.call(\"payflowpro/payment/submit\", \"authorize\", cardInfo, paymentInfo, callback);\n  },\n  capture: function (transactionId, amount, callback) {\n    const captureDetails = {\n      amount: {\n        currency: \"USD\", // todo should this be locale.currency\n        total: parseFloat(amount, 10)\n      },\n      is_final_capture: true\n    };\n    Meteor.call(\"payflowpro/payment/capture\", transactionId, captureDetails, callback);\n  },\n  config: function (options) {\n    this.accountOptions = options;\n  },\n  paymentObj: function () {\n    return {\n      intent: \"sale\",\n      payer: {\n        payment_method: \"credit_card\",\n        funding_instruments: []\n      },\n      transactions: []\n    };\n  },\n  parseCardData: function (data) {\n    return {\n      credit_card: {\n        type: data.type,\n        number: data.number,\n        first_name: data.first_name,\n        last_name: data.last_name,\n        cvv2: data.cvv2,\n        expire_month: data.expire_month,\n        expire_year: data.expire_year\n      }\n    };\n  },\n  parsePaymentData: function (data) {\n    return {\n      amount: {\n        total: parseFloat(data.total, 10),\n        currency: data.currency\n      }\n    };\n  }\n};\n\nfunction getSettings(settings, ref, valueName) {\n  if (settings !== null) {\n    return settings[valueName];\n  } else if (ref !== null) {\n    return ref[valueName];\n  }\n  return {};\n}\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import moment from \"moment\";\nimport _ from \"lodash\";\nimport accounting from \"accounting-js\";\nimport { HTTP } from \"meteor/http\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { PayPal } from \"../../lib/api\";\nimport { Shops, Cart, Packages } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\n\nconst nvpVersion = \"52.0\";\n\nexport const methods = {\n  /**\n   * Acquire the Token required for PayPal Express transactions\n   * https://developer.paypal.com/docs/classic/api/merchant/SetExpressCheckout_API_Operation_NVP/\n   * @param  {String} cartId Reference to the Cart object to be processed\n   * @return {String} PayPal Token\n   */\n  \"getExpressCheckoutToken\": function (cartId) {\n    check(cartId, String);\n    this.unblock();\n    const cart = Cart.findOne(cartId);\n    if (!cart) {\n      throw new Meteor.Error(\"Bad cart ID\");\n    }\n    const shop = Shops.findOne(cart.shopId);\n    if (!shop) {\n      throw new Meteor.Error(\"Bad shop ID\");\n    }\n    const amount = Number(cart.cartTotal());\n    const description = shop.name + \" Ref: \" + cartId;\n    const currency = shop.currency;\n    const options = PayPal.expressCheckoutAccountOptions();\n    let response;\n\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          SOLUTIONTYPE: \"Mark\",\n          VERSION: nvpVersion,\n          PAYMENTACTION: \"Authorization\",\n          AMT: amount,\n          RETURNURL: options.return_url,\n          CANCELURL: options.cancel_url,\n          DESC: description,\n          NOSHIPPING: 1,\n          ALLOWNOTE: 1,\n          CURRENCYCODE: currency,\n          METHOD: \"SetExpressCheckout\",\n          INVNUM: cartId,\n          CUSTOM: cartId + \"|\" + amount + \"|\" + currency\n        }\n      });\n    } catch (error) {\n      throw new Meteor.Error(error.message);\n    }\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"Bad response from PayPal\");\n    }\n    const parsedResponse = parseResponse(response);\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(\"ACK \" + parsedResponse.ACK + \": \" + parsedResponse.L_LONGMESSAGE0);\n    }\n    return parsedResponse.TOKEN;\n  },\n  /**\n   * Perform the PayPal Express payment application\n   * https://developer.paypal.com/docs/classic/api/merchant/DoExpressCheckoutPayment_API_Operation_NVP/\n   * @param  {String} cartId Reference to the cart we are checking out\n   * @param  {String} token The Token provided by PayPal for this transaction\n   * @param  {String} payerId Reference to the payer\n   * @return {Object} results from PayPal normalized\n   */\n  \"confirmPaymentAuthorization\": function (cartId, token, payerId) {\n    check(cartId, String);\n    check(token, String);\n    check(payerId, String);\n    this.unblock();\n    const cart = Cart.findOne(cartId);\n    if (!cart) {\n      throw new Meteor.Error(\"Bad cart ID\");\n    }\n    const amount = Number(cart.cartTotal());\n    const shop = Shops.findOne(cart.shopId);\n    const currency = shop.currency;\n    const options = PayPal.expressCheckoutAccountOptions();\n    const captureAtAuth = getSetting(cart.shopId, \"express_auth_and_capture\");\n    let paymentAction;\n    if (captureAtAuth) {\n      paymentAction = \"Sale\";\n    } else {\n      paymentAction = \"Authorization\";\n    }\n    let response;\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          VERSION: nvpVersion,\n          PAYMENTACTION: paymentAction,\n          AMT: amount,\n          METHOD: \"DoExpressCheckoutPayment\",\n          CURRENCYCODE: currency,\n          TOKEN: token,\n          PAYERID: payerId\n        }\n      });\n    } catch (error) {\n      throw new Meteor.Error(error.message);\n    }\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"Bad response from PayPal\");\n    }\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(\"ACK \" +\n        parsedResponse.ACK + \": \" +\n        parsedResponse.L_LONGMESSAGE0 + \":\" +\n        parsedResponse.L_ERRORCODE0);\n    }\n    return parsedResponse;\n  },\n\n  /**\n   * Return the settings for the PayPal Express payment Method\n   * @return {Object} Express Checkout settings\n   */\n  \"getExpressCheckoutSettings\": function () {\n    const settings = PayPal.expressCheckoutAccountOptions();\n    const expressCheckoutSettings = {\n      merchantId: settings.merchantId,\n      mode: settings.mode,\n      enabled: settings.enabled\n    };\n    return expressCheckoutSettings;\n  },\n\n  /**\n   * Capture an authorized PayPalExpress transaction\n   * https://developer.paypal.com/docs/classic/api/merchant/DoCapture_API_Operation_NVP/\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {Object} results from PayPal normalized\n   */\n  \"paypalexpress/payment/capture\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    this.unblock();\n    const options = PayPal.expressCheckoutAccountOptions();\n    const amount = accounting.toFixed(paymentMethod.amount, 2);\n    const authorizationId = paymentMethod.transactions[0].TRANSACTIONID;\n    const currencycode = paymentMethod.transactions[0].CURRENCYCODE;\n    let response;\n\n    // 100% discounts are not valid when using PayPal Express\n    // If discount is 100%, void authorization instead of applying discount\n    if (amount === accounting.toFixed(0, 2)) {\n      try {\n        response = HTTP.post(options.url, {\n          params: {\n            USER: options.username,\n            PWD: options.password,\n            SIGNATURE: options.signature,\n            VERSION: nvpVersion,\n            METHOD: \"DoVoid\",\n            AUTHORIZATIONID: authorizationId,\n            NOTE: \"Your order has been discounted 100%, and will appear as voided or canceled inside your payment account.\"\n          }\n        });\n      } catch (error) {\n        throw new Meteor.Error(error.message);\n      }\n    } else {\n      try {\n        response = HTTP.post(options.url, {\n          params: {\n            USER: options.username,\n            PWD: options.password,\n            SIGNATURE: options.signature,\n            VERSION: nvpVersion,\n            METHOD: \"DoCapture\",\n            AUTHORIZATIONID: authorizationId,\n            CURRENCYCODE: currencycode,\n            AMT: amount,\n            COMPLETETYPE: \"Complete\" // TODO: Allow for partial captures\n          }\n        });\n      } catch (error) {\n        throw new Meteor.Error(error.message);\n      }\n    }\n\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"Bad Response from PayPal during Capture\");\n    }\n\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(\"ACK \" + parsedResponse.ACK + \": \" + parsedResponse.L_LONGMESSAGE0);\n    }\n\n    const result = {\n      saved: true,\n      authorizationId: parsedResponse.AUTHORIZATIONID,\n      transactionId: parsedResponse.TRANSACTIONID,\n      currencycode: currencycode,\n      metadata: {},\n      rawTransaction: parsedResponse\n    };\n\n    return result;\n  },\n\n  /**\n   * Refund an order using the PayPay Express method\n   * https://developer.paypal.com/docs/classic/api/merchant/RefundTransaction_API_Operation_NVP/\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @param {Number} amount to be refunded\n   * @return {Object} Transaction results from PayPal normalized\n   */\n  \"paypalexpress/refund/create\": function (paymentMethod, amount) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n    this.unblock();\n\n    const options = PayPal.expressCheckoutAccountOptions();\n    const previousTransaction = _.last(paymentMethod.transactions);\n    const transactionId = previousTransaction.transactionId;\n    const currencycode = previousTransaction.currencycode;\n\n    let response;\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          VERSION: nvpVersion,\n          METHOD: \"RefundTransaction\",\n          TRANSACTIONID: transactionId,\n          REFUNDTYPE: \"Partial\",\n          AMT: amount,\n          CURRENCYCODE: currencycode\n        }\n      });\n    }  catch (error) {\n      Logger.debug(error, \"Failed paypalexpress/refund/create\");\n      throw new Meteor.Error(error.message);\n    }\n\n    if (!response || response.statusCode !== 200) {\n      Logger.debug(error, \"Bad Response from PayPal during Refund Creation\");\n      throw new Meteor.Error(\"Bad Response from PayPal during Refund Creation\");\n    }\n\n    const parsedResponse = parseResponse(response);\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(\"ACK \" + parsedResponse.ACK + \": \" + parsedResponse.L_LONGMESSAGE0);\n    }\n\n    const amountFormatted = {\n      total: amount,\n      currency: currencycode\n    };\n\n    const result = {\n      saved: true,\n      type: \"refund\",\n      created: new Date(),\n      transactionId: transactionId,\n      refundTransactionId: parsedResponse.REFUNDTRANSACTIONID,\n      grossRefundAmount: parsedResponse.GROSSREFUNDAMT,\n      netRefundAmount: parsedResponse.NETREFUNDAMT,\n      correlationId: parsedResponse.CORRELATIONID,\n      currencycode: parsedResponse.CURRENCYCODE,\n      amount: amountFormatted,\n      rawTransaction: parsedResponse\n    };\n    return result;\n  },\n  /**\n   * Query PayPal Express NVP API for Refund transactions\n   * Refunds returned here are listed in the dashboard\n   * https://developer.paypal.com/docs/classic/api/merchant/GetTransactionDetails_API_Operation_NVP/\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {array}  Refunds from PayPal query, normalized\n   */\n  \"paypalexpress/refund/list\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    this.unblock();\n\n    const options = PayPal.expressCheckoutAccountOptions();\n    const transactionId = paymentMethod.transactionId;\n    let response;\n\n    try {\n      response = HTTP.post(options.url, {\n        params: {\n          USER: options.username,\n          PWD: options.password,\n          SIGNATURE: options.signature,\n          VERSION: nvpVersion,\n          METHOD: \"TransactionSearch\",\n          STARTDATE: \"2013-08-24T05:38:48Z\",\n          TRANSACTIONID: transactionId,\n          TRANSACTIONCLASS: \"Refund\"\n        }\n      });\n    }  catch (error) {\n      throw new Meteor.Error(error.message);\n    }\n\n    if (!response || response.statusCode !== 200) {\n      throw new Meteor.Error(\"Bad Response from PayPal during refund list\");\n    }\n\n    const parsedResponse = parseResponse(response);\n\n    if (parsedResponse.ACK !== \"Success\") {\n      throw new Meteor.Error(\"ACK \" + parsedResponse.ACK + \": \" + parsedResponse.L_LONGMESSAGE0);\n    }\n    const result = parseRefundReponse(parsedResponse);\n    return result;\n  }\n\n};\n\n// internal helpers\nfunction parseResponse(response) {\n  const result = {};\n  const pieces = response.content.split(\"&\");\n  pieces.forEach(function (piece) {\n    const subpieces = piece.split(\"=\");\n    const decodedResult = result[subpieces[0]] = decodeURIComponent(subpieces[1]);\n    return decodedResult;\n  });\n  return result;\n}\n\n/**\n * Parse PayPal's 'unique' Transaction Query response to look for refunds\n * @param  {Object} response The response from PayPal\n * @return {Object} Refunds, normalized to an Array\n */\nfunction parseRefundReponse(response) {\n  const paypalArray = [];\n\n  for (let i = 0; i < 101; i++) {\n    const timeStampKey = \"L_TIMESTAMP\" + i;\n    const timestamp = response[timeStampKey];\n    const typeKey = \"L_TYPE\" + i;\n    const transactionType = response[typeKey];\n    const amountKey = \"L_AMT\" + i;\n    const amount = response[amountKey];\n    const currencyCodeKey = \"L_CURRENCYCODE\" + i;\n    const currencyCode = response[currencyCodeKey];\n\n    if (timestamp !== undefined && transactionType === \"Refund\") {\n      const responseObject = {\n        created: moment(timestamp).valueOf(),\n        type: \"refund\",\n        amount: Math.abs(Number(amount, 10)),\n        currency: currencyCode\n      };\n      paypalArray.push(responseObject);\n    }\n  }\n\n  return paypalArray;\n}\n\ngetSetting = function (shopId, parameter) {\n  const settings = Packages.findOne({\n    name: \"reaction-paypal\",\n    shopId: shopId,\n    enabled: true\n  }).settings;\n  return settings[parameter];\n};\n\n// export methods to Meteor\nMeteor.methods(methods);\n","import * as PayflowproMethods from \"./payflowproMethods\";\nimport { Meteor } from \"meteor/meteor\";\n\nMeteor.methods({\n  \"payflowpro/payment/submit\": PayflowproMethods.paymentSubmit,\n  \"payflowpro/payment/capture\": PayflowproMethods.paymentCapture,\n  \"payflowpro/refund/create\": PayflowproMethods.createRefund,\n  \"payflowpro/refund/list\": PayflowproMethods.listRefunds,\n  \"payflowpro/settings\": PayflowproMethods.getSettings\n});\n","import PayFlow from \"paypal-rest-sdk\"; // PayFlow is PayPal PayFlow lib\nimport moment from \"moment\";\nimport accounting from \"accounting-js\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { Shops } from \"/lib/collections\";\nimport { PayPal } from \"../../lib/api\"; // PayPal is the reaction api\n\nexport const PayflowproApi = {};\nPayflowproApi.apiCall = {};\n\n\nPayflowproApi.apiCall.paymentSubmit = function (paymentSubmitDetails) {\n  PayFlow.configure(PayPal.payflowAccountOptions());\n\n  const paymentObj = PayPal.paymentObj();\n  paymentObj.intent = paymentSubmitDetails.transactionType;\n  paymentObj.payer.funding_instruments.push(PayPal.parseCardData(paymentSubmitDetails.cardData));\n  paymentObj.transactions.push(PayPal.parsePaymentData(paymentSubmitDetails.paymentData));\n  const wrappedFunc = Meteor.wrapAsync(PayFlow.payment.create, PayFlow.payment);\n  let result;\n  try {\n    result = {\n      saved: true,\n      response: wrappedFunc(paymentObj)\n    };\n  } catch (error) {\n    Logger.warn(error);\n    result = {\n      saved: false,\n      error: error\n    };\n  }\n  return result;\n};\n\n\nPayflowproApi.apiCall.captureCharge = function (paymentCaptureDetails) {\n  PayFlow.configure(PayPal.payflowAccountOptions());\n\n  let result;\n  // TODO: This should be changed to some ReactionCore method\n  const shop = Shops.findOne(Reaction.getShopId());\n  const wrappedFunc = Meteor.wrapAsync(PayFlow.authorization.capture, PayFlow.authorization);\n  const wrappedFuncVoid = Meteor.wrapAsync(PayFlow.authorization.void, PayFlow.authorization);\n  const captureTotal = Math.round(parseFloat(paymentCaptureDetails.amount) * 100) / 100;\n  const captureDetails = {\n    amount: {\n      currency: shop.currency,\n      total: captureTotal\n    },\n    is_final_capture: true // eslint-disable-line camelcase\n  };\n  const capturedAmount = accounting.toFixed(captureDetails.amount.total, 2);\n\n  if (capturedAmount === accounting.toFixed(0, 2)) {\n    try {\n      const response = wrappedFuncVoid(paymentCaptureDetails.authorizationId, captureDetails);\n\n      result = {\n        saved: true,\n        metadata: {\n          parentPaymentId: response.parent_payment,\n          captureId: response.id\n        },\n        rawTransaction: response\n      };\n    } catch (error) {\n      Logger.warn(error);\n      result = {\n        saved: false,\n        error: error\n      };\n    }\n    return result;\n  }\n  try {\n    const response = wrappedFunc(paymentCaptureDetails.authorizationId, captureDetails);\n\n    result = {\n      saved: true,\n      metadata: {\n        parentPaymentId: response.parent_payment,\n        captureId: response.id\n      },\n      rawTransaction: response\n    };\n  } catch (error) {\n    Logger.warn(error);\n    result = {\n      saved: false,\n      error: error\n    };\n  }\n  return result;\n};\n\n\nPayflowproApi.apiCall.createRefund = function (refundDetails) {\n  PayFlow.configure(PayPal.payflowAccountOptions());\n\n  const createRefund = Meteor.wrapAsync(PayFlow.capture.refund, PayFlow.capture);\n  let result;\n\n  try {\n    Logger.debug(\"payflowpro/refund/create: paymentMethod.metadata.captureId\", refundDetails.captureId);\n    const response = createRefund(refundDetails.captureId, {\n      amount: {\n        total: refundDetails.amount,\n        currency: \"USD\"\n      }\n    });\n\n    result = {\n      saved: true,\n      type: \"refund\",\n      created: response.create_time,\n      amount: response.amount.total,\n      currency: response.amount.currency,\n      rawTransaction: response\n    };\n  } catch (error) {\n    result = {\n      saved: false,\n      error: error\n    };\n  }\n  return result;\n};\n\n\nPayflowproApi.apiCall.listRefunds = function (refundListDetails) {\n  PayFlow.configure(PayPal.payflowAccountOptions());\n\n  const listPayments = Meteor.wrapAsync(PayFlow.payment.get, PayFlow.payment);\n  let result = [];\n  // todo: review parentPaymentId vs authorizationId, are they both correct?\n  // added authorizationId without fully understanding the intent of parentPaymentId\n  // let authId = paymentMethod.metadata.parentPaymentId || paymentMethod.metadata.authorizationId;\n  const authId = refundListDetails.transactionId;\n\n  if (authId) {\n    Logger.debug(\"payflowpro/refund/list: paymentMethod.metadata.parentPaymentId\", authId);\n    try {\n      const response = listPayments(authId);\n\n      for (const transaction of response.transactions) {\n        for (const resource of transaction.related_resources) {\n          if (_.isObject(resource.refund)) {\n            if (resource.refund.state === \"completed\") {\n              result.push({\n                type: \"refund\",\n                created: moment(resource.refund.create_time).unix() * 1000,\n                amount: Math.abs(resource.refund.amount.total),\n                currency: resource.refund.amount.currency,\n                raw: response\n              });\n            }\n          }\n        }\n      }\n    } catch (error) {\n      Logger.warn(\"Failed payflowpro/refund/list\", error);\n      result = {\n        error: error\n      };\n    }\n  }\n  return result;\n};\n","import { PayflowproApi } from \"./payflowproApi\";\nimport { Logger } from \"/server/api\";\nimport { PaymentMethod } from \"/lib/collections/schemas\";\nimport { check } from \"meteor/check\";\nimport { PayPal } from \"../../lib/api\"; // PayPal is the reaction api\n\n\n/**\n * payflowpro/payment/submit\n * Create and Submit a PayPal PayFlow transaction\n * @param  {Object} transactionType transactionType\n * @param  {Object} cardData cardData object\n * @param  {Object} paymentData paymentData object\n * @return {Object} results from PayPal payment create\n */\nexport function paymentSubmit(transactionType, cardData, paymentData) {\n  check(transactionType, String);\n  check(cardData, Object);\n  check(paymentData, Object);\n\n  const paymentSubmitDetails = {\n    transactionType: transactionType,\n    cardData: cardData,\n    paymentData: paymentData\n  };\n\n  let result;\n\n  try {\n    const refundResult = PayflowproApi.apiCall.paymentSubmit(paymentSubmitDetails);\n    Logger.debug(refundResult);\n    result = refundResult;\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: `Cannot Submit Payment: ${error.message}`\n    };\n    Logger.fatal(\"PayPal PayFlow call failed, payment was not submitted\");\n  }\n\n  return result;\n}\n\n\n/**\n * payflowpro/payment/capture\n * Capture an authorized PayPal PayFlow transaction\n * @param  {Object} paymentMethod A PaymentMethod object\n * @return {Object} results from PayPal normalized\n */\nexport function paymentCapture(paymentMethod) {\n  check(paymentMethod, PaymentMethod);\n\n  const paymentCaptureDetails = {\n    authorizationId: paymentMethod.metadata.authorizationId,\n    amount: paymentMethod.amount\n  };\n\n  let result;\n\n  try {\n    const refundResult = PayflowproApi.apiCall.captureCharge(paymentCaptureDetails);\n    Logger.debug(refundResult);\n    result = refundResult;\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: `Cannot Capture Payment: ${error.message}`\n    };\n    Logger.fatal(\"PayPal PayFlow call failed, payment was not captured\");\n  }\n\n  return result;\n}\n\n\n/**\n * createRefund\n * Refund PayPal PayFlow payment\n * @param {Object} paymentMethod - Object containing everything about the transaction to be settled\n * @param {Number} amount - Amount to be refunded if not the entire amount\n * @return {Object} results - Object containing the results of the transaction\n */\nexport function createRefund(paymentMethod, amount) {\n  check(paymentMethod, PaymentMethod);\n  check(amount, Number);\n\n  const refundDetails = {\n    captureId: paymentMethod.metadata.captureId,\n    amount: amount\n  };\n\n  let result;\n\n  try {\n    const refundResult = PayflowproApi.apiCall.createRefund(refundDetails);\n    Logger.debug(refundResult);\n    result = refundResult;\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: `Cannot issue refund: ${error.message}`\n    };\n    Logger.fatal(\"PayPal PayFlow call failed, refund was not issued\");\n  }\n\n  return result;\n}\n\n\n/**\n * listRefunds\n * List all refunds for a PayPal PayFlow transaction\n * https://developers.braintreepayments.com/reference/request/transaction/find/node\n * @param {Object} paymentMethod - Object containing everything about the transaction to be settled\n * @return {Array} results - An array of refund objects for display in admin\n */\nexport function listRefunds(paymentMethod) {\n  check(paymentMethod, PaymentMethod);\n\n  const refundListDetails = {\n    transactionId: paymentMethod.metadata.transactionId\n  };\n\n  let result;\n\n  try {\n    const refundResult = PayflowproApi.apiCall.listRefunds(refundListDetails);\n    Logger.debug(refundResult);\n    result = refundResult;\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: `Cannot issue refund: ${error.message}`\n    };\n    Logger.fatal(\"PayPal PayFlow call failed, refund was not issued\");\n  }\n\n  return result;\n}\n\n\nexport function getSettings() {\n  const settings = PayPal.payflowAccountOptions();\n  const payflowSettings = {\n    mode: settings.mode,\n    enabled: settings.enabled\n  };\n  return payflowSettings;\n}\n","BrowserPolicy.content.allowEval();\nBrowserPolicy.content.allowOriginForAll(\"http://www.paypal.com\");\nBrowserPolicy.content.allowOriginForAll(\"http://www.paypalobjects.com\");\nBrowserPolicy.content.allowOriginForAll(\"https://www.sandbox.paypal.com\");\nBrowserPolicy.content.allowOriginForAll(\"https://www.paypal.com\");\nBrowserPolicy.content.allowOriginForAll(\"https://www.paypalobjects.com\");\nBrowserPolicy.content.allowOriginForAll(\"https://tracking.qa.paypal.com\");\nBrowserPolicy.content.allowOriginForAll(\"https://akamai.mathtag.com\");\n","import { Reaction, Hooks } from \"/server/api\";\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  Reaction.addRolesToDefaultRoleSet({\n    allShops: true,\n    roleSets: [\"defaultRoles\", \"defaultVisitorRole\"],\n    roles: [\"reaction-paypal/paypalDone\", \"reaction-paypal/paypalCancel\"]\n  });\n});\n","import \"./i18n\";\nimport \"./methods/express\";\nimport \"./methods/payflow\";\nimport \"./security/paypal\";\nimport \"./startup/startup\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"PayPal\",\n  name: \"reaction-paypal\",\n  icon: \"fa fa-paypal\",\n  autoEnable: true,\n  settings: {\n    express: {\n      enabled: false,\n      support: [\n        \"authorize\",\n        \"capture\",\n        \"refund\"\n      ]\n    },\n    payflow: {\n      enabled: false,\n      support: [\n        \"Authorize\",\n        \"Capture\",\n        \"Refund\"\n      ]\n    }\n  },\n  registry: [\n    {\n      label: \"PayPal Express\",\n      provides: \"paymentSettings\",\n      name: \"paypal/settings/express\",\n      icon: \"fa fa-paypal\",\n      template: \"paypalExpressSettings\"\n    }, {\n      label: \"PayPal PayFlow\",\n      provides: \"paymentSettings\",\n      name: \"paypal/settings/payflow\",\n      icon: \"fa fa-cc-paypal\",\n      template: \"paypalPayFlowSettings\"\n    }, {\n      route: \"/paypal/done\",\n      template: \"paypalDone\",\n      workflow: \"coreWorkflow\"\n    }, {\n      route: \"/paypal/cancel\",\n      template: \"paypalCancel\",\n      workflow: \"coreWorkflow\"\n    }, {\n      template: \"paypalCheckoutButton\",\n      label: \"Express\",\n      name: \"payment/method/express\",\n      provides: \"paymentMethod\",\n      icon: \"fa fa-paypal\",\n      priority: 1\n    }, {\n      template: \"paypalPayflowForm\",\n      label: \"Credit Card\",\n      name: \"payment/method/payflow\",\n      provides: \"paymentMethod\",\n      icon: \"fa fa-cc-paypal\"\n    }\n  ]\n});\n","\nexport default function blocks() {\n  return [\n\n    // Header block (Full Width)\n    {\n      type: \"block\",\n      columns: 12,\n      element: \"header\",\n      className: \"pdp header\",\n      permissions: [\"admin\"], // Permissions for staff\n      audience: [\"guest\", \"anonymous\"], // Permissions for customers\n      children: [\n        // Title\n        {\n          component: \"ProductField\",\n          // Example, you can set permissions components that are children of a block\n          permissions: [\"admin\"],\n          audience: [\"guest\", \"anonymous\"],\n          props: {\n            fieldName: \"title\",\n            fieldTitle: \"Title\",\n            element: \"h1\",\n            textFieldProps: {\n              i18nKeyPlaceholder: \"productDetailEdit.title\",\n              placeholder: \"Title\"\n            }\n          }\n        },\n\n        // PageTitle\n        {\n          component: \"ProductField\",\n          permissions: [\"admin\"],\n          audience: [\"guest\", \"anonymous\"],\n          props: {\n            // editable: this.editable,\n            fieldName: \"pageTitle\",\n            fieldTitle: \"SubTitle\",\n            element: \"h2\",\n            textFieldProps: {\n              i18nKeyPlaceholder: \"productDetailEdit.pageTitle\",\n              placeholder: \"Subtitle\"\n            }\n          }\n        }\n      ]\n    },\n\n    // Media block\n    // Contains\n    // - Medai Gallery\n    // - Tags\n    // - Details\n    {\n      type: \"block\",\n      columns: 6,\n      size: \"half\",\n      permissions: [\"admin\"],\n      audience: [\"guest\", \"anonymous\"],\n      style: {\n        \"@media  only screen and (max-width: 921px)\": {\n          minWidth: \"100%\",\n          maxWidth: \"100%\"\n        }\n      },\n      children: [\n        // Media Gallery\n        {\n          component: \"MediaGalleryContainer\"\n        },\n\n        // Tags\n        {\n          component: \"ProductTags\"\n        },\n\n        // Metadata\n        {\n          component: \"ProductMetadata\"\n        }\n      ]\n    },\n\n    // Variant block\n    {\n      type: \"block\",\n      columns: 6,\n      size: \"half\",\n      permissions: [\"admin\"],\n      audience: [\"guest\", \"anonymous\"],\n      style: {\n        \"@media  only screen and (max-width: 921px)\": {\n          minWidth: \"100%\",\n          maxWidth: \"100%\"\n        }\n      },\n      children: [\n        // Price /  Social Buttons split\n        {\n          axis: \"horizontal\",\n          align: \"center\",\n          type: \"block\",\n          size: \"static variable\",\n          permissions: [\"createProduct\"],\n          audience: [\"guest\", \"anonymous\"],\n          style: {\n            padding: 0\n          },\n          children: [\n            // Price Range\n            {\n              type: \"block\",\n              size: \"variable\",\n              style: {\n                padding: 0\n              },\n              children: [\n                {\n                  component: \"PriceRange\"\n                }\n              ]\n            },\n            // Social Buttons\n            {\n              type: \"block\",\n              size: \"static\",\n              justify: \"end\",\n              style: {\n                padding: 0\n              },\n              children: [\n                {\n                  component: \"SocialContainer\"\n                }\n              ]\n            }\n          ]\n        },\n\n        // Vendor\n        {\n          component: \"ProductField\",\n          props: {\n            fieldName: \"vendor\",\n            fieldTitle: \"Vendor\",\n            textFieldProps: {\n              i18nKeyPlaceholder: \"productDetailEdit.vendor\",\n              placeholder: \"Vendor\"\n            }\n          }\n        },\n        {\n          component: \"ProductField\",\n          props: {\n            fieldName: \"description\",\n            fieldTitle: \"Description\",\n            multiline: true,\n            textFieldProps: {\n              i18nKeyPlaceholder: \"productDetailEdit.description\",\n              placeholder: \"Description\"\n            }\n          }\n        },\n\n        // Variant List\n        {\n          component: \"VariantListContainer\"\n        },\n\n        // Divider\n        {\n          component: \"Divider\"\n        },\n\n        // Alerts for checkout\n        {\n          component: \"AlertContainer\",\n          props: {\n            placement: \"productDetail\"\n          }\n        },\n\n        // Add to cart button\n        {\n          component: \"AddToCartButton\",\n          props: {\n            style: {\n              paddingTop: 20\n            }\n          }\n        }\n\n      ]\n    }\n  ];\n}\n","\nexport default function twoColumn() {\n  return [\n    // Media block\n    // Contains\n    // - Media Gallery\n    // - Tags\n    // - Details\n    {\n      type: \"block\",\n      columns: 6,\n      size: \"half\",\n      permissions: [\"admin\"],\n      audience: [\"guest\", \"anonymous\"],\n      children: [\n        // Media Gallery\n        {\n          component: \"MediaGalleryContainer\"\n        },\n\n        // Tags\n        {\n          component: \"ProductTags\"\n        },\n\n        // Metadata\n        {\n          component: \"ProductMetadata\"\n        }\n      ]\n    },\n\n    // Product Details Block\n    // Contains\n    // - Title\n    // - Subtitle\n    // - Price\n    // - Social\n    // - Vendor\n    // - Description\n    // - Variants\n    // - Add to Cart button\n    {\n      type: \"block\",\n      columns: 6,\n      size: \"half\",\n      style: {\n        display: \"block\"\n      },\n      permissions: [\"admin\"],\n      audience: [\"guest\", \"anonymous\"],\n      children: [\n        // Header block (Full Width)\n        {\n          type: \"block\",\n          columns: 12,\n          element: \"header\",\n          className: \"pdp header\",\n          permissions: [\"admin\"], // Permissions for staff\n          audience: [\"guest\", \"anonymous\"], // Permissions for customers\n          children: [\n            // Title\n            {\n              component: \"ProductField\",\n              // Example, you can set permissions components that are children of a block\n              permissions: [\"admin\"],\n              audience: [\"guest\", \"anonymous\"],\n              props: {\n                fieldName: \"title\",\n                fieldTitle: \"Title\",\n                element: \"h1\",\n                textFieldProps: {\n                  i18nKeyPlaceholder: \"productDetailEdit.title\",\n                  placeholder: \"Title\"\n                }\n              }\n            },\n\n            // PageTitle\n            {\n              component: \"ProductField\",\n              permissions: [\"admin\"],\n              audience: [\"guest\", \"anonymous\"],\n              props: {\n                // editable: this.editable,\n                fieldName: \"pageTitle\",\n                fieldTitle: \"SubTitle\",\n                element: \"h2\",\n                textFieldProps: {\n                  i18nKeyPlaceholder: \"productDetailEdit.pageTitle\",\n                  placeholder: \"Subtitle\"\n                }\n              }\n            }\n          ]\n        },\n\n        // Price /  Social Buttons split\n        {\n          axis: \"horizontal\",\n          align: \"center\",\n          type: \"block\",\n          size: \"static variable\",\n          permissions: [\"createProduct\"],\n          audience: [\"guest\", \"anonymous\"],\n          style: {\n            padding: 0\n          },\n          children: [\n            // Price Range\n            {\n              type: \"block\",\n              size: \"variable\",\n              style: {\n                padding: 0\n              },\n              children: [\n                {\n                  component: \"PriceRange\"\n                }\n              ]\n            },\n            // Social Buttons\n            {\n              type: \"block\",\n              size: \"static\",\n              justify: \"end\",\n              style: {\n                padding: 0\n              },\n              children: [\n                {\n                  component: \"SocialContainer\"\n                }\n              ]\n            }\n          ]\n        },\n\n        // Vendor\n        {\n          component: \"ProductField\",\n          props: {\n            fieldName: \"vendor\",\n            fieldTitle: \"Vendor\",\n            textFieldProps: {\n              i18nKeyPlaceholder: \"productDetailEdit.vendor\",\n              placeholder: \"Vendor\"\n            }\n          }\n        },\n        {\n          component: \"ProductField\",\n          props: {\n            fieldName: \"description\",\n            fieldTitle: \"Description\",\n            multiline: true,\n            textFieldProps: {\n              i18nKeyPlaceholder: \"productDetailEdit.description\",\n              placeholder: \"Description\"\n            }\n          }\n        },\n\n        // Variant List\n        {\n          component: \"VariantListContainer\"\n        },\n\n        // Divider\n        {\n          component: \"Divider\"\n        },\n\n        // Alerts for checkout\n        {\n          component: \"AlertContainer\",\n          props: {\n            placement: \"productDetail\"\n          }\n        },\n\n        // Add to cart button\n        {\n          component: \"AddToCartButton\",\n          props: {\n            style: {\n              paddingTop: 20\n            }\n          }\n        }\n\n      ]\n    }\n  ];\n}\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import { Reaction } from \"/server/api\";\nimport SimpleLayout from \"../lib/layout/simple\";\nimport TwoColumnLayout from \"../lib/layout/twoColumn\";\nimport \"./i18n\";\n\nReaction.registerTemplate({\n  name: \"productDetailSimple\",\n  title: \"Product Detail Simple Layout\",\n  type: \"react\",\n  templateFor: [\"pdp\"],\n  permissions: [\"admin\", \"owner\"],\n  audience: [\"anonymous\", \"guest\"],\n  template: SimpleLayout()\n});\n\nReaction.registerTemplate({\n  name: \"productDetailTwoColumn\",\n  title: \"Product Detail Two Column Layout\",\n  type: \"react\",\n  templateFor: [\"pdp\"],\n  permissions: [\"admin\", \"owner\"],\n  audience: [\"anonymous\", \"guest\"],\n  template: TwoColumnLayout()\n});\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Product Detail Simple\",\n  name: \"product-detail-simple\",\n  icon: \"fa fa-cubes\",\n  autoEnable: true,\n  registry: [{\n    route: \"/product/:handle/:variantId?\",\n    name: \"product\",\n    template: \"productDetailSimple\",\n    workflow: \"coreProductWorkflow\"\n  }],\n  layout: [{\n    layout: \"coreLayout\",\n    workflow: \"coreProductWorkflow\",\n    collection: \"Products\",\n    theme: \"default\",\n    enabled: true,\n    structure: {\n      template: \"productDetailSimple\",\n      layoutHeader: \"layoutHeader\",\n      layoutFooter: \"\",\n      notFound: \"productNotFound\",\n      dashboardHeader: \"productDetailSimpleToolbar\",\n      dashboardControls: \"productDetailDashboardControls\",\n      dashboardHeaderControls: \"\",\n      adminControlsFooter: \"adminControlsFooter\"\n    }\n  }]\n});\n","export const shippingRoles = [\"admin\", \"owner\", \"shipping\", \"reaction-shippo\"];\n","import { check } from \"meteor/check\";\nimport { Shipping, Packages } from \"/lib/collections\";\nimport { Logger, Reaction, Hooks } from \"/server/api\";\nimport { Cart as CartSchema } from \"/lib/collections/schemas\";\n\n// callback ran on getShippingRates hook\nfunction getShippingRates(rates, cart) {\n  check(cart, CartSchema);\n  const shops = [];\n  const products = cart.items;\n\n  const pkgData = Packages.findOne({\n    name: \"reaction-shipping-rates\",\n    shopId: Reaction.getShopId()\n  });\n\n  if (!pkgData || !cart.items || pkgData.settings.flatRates.enabled !== true) {\n    return rates;\n  }\n\n  // default selector is current shop\n  let selector = {\n    \"shopId\": Reaction.getShopId(),\n    \"provider.enabled\": true\n  };\n\n  // create an array of shops, allowing\n  // the cart to have products from multiple shops\n  for (const product of products) {\n    if (product.shopId) {\n      shops.push(product.shopId);\n    }\n  }\n  // if we have multiple shops in cart\n  if ((shops !== null ? shops.length : void 0) > 0) {\n    selector = {\n      \"shopId\": {\n        $in: shops\n      },\n      \"provider.enabled\": true\n    };\n  }\n\n  const shippingCollection = Shipping.find(selector);\n  shippingCollection.forEach(function (doc) {\n    const _results = [];\n    for (const method of doc.methods) {\n      if (!method.enabled) {\n        continue;\n      }\n      if (!method.rate) {\n        method.rate = 0;\n      }\n      if (!method.handling) {\n        method.handling = 0;\n      }\n      // Store shipping provider here in order to have it available in shipmentMethod\n      // for cart and order usage\n      if (!method.carrier) {\n        method.carrier = doc.provider.label;\n      }\n      const rate = method.rate + method.handling;\n      _results.push(\n        rates.push({\n          carrier: doc.provider.label,\n          method: method,\n          rate: rate,\n          shopId: doc.shopId\n        })\n      );\n    }\n    return _results;\n  });\n\n  Logger.debug(\"Flat rate onGetShippingRates\", rates);\n  return rates;\n}\n// run getShippingRates when the onGetShippingRates event runs\nHooks.Events.add(\"onGetShippingRates\", getShippingRates);\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Shipping } from \"/lib/collections\";\nimport { ShippingMethod } from \"/lib/collections/schemas\";\nimport { Reaction } from \"/server/api\";\nimport { shippingRoles } from \"../lib/roles\";\n\nexport const methods = {\n  /**\n   * shipping/rates/add\n   * add new shipping flat rate methods\n   * @summary insert shipping method for a flat rate provider\n   * @param { Object } rate a valid ShippingMethod object\n   * @return { Number } insert result\n   */\n  \"shipping/rates/add\": function (rate) {\n    check(rate, {\n      _id: Match.Optional(String),\n      name: String,\n      label: String,\n      group: String,\n      cost: Match.Optional(Number),\n      handling: Match.Optional(Number),\n      rate: Number,\n      enabled: Boolean\n    });\n    if (!Reaction.hasPermission(shippingRoles)) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // a little trickery\n    // we passed in the providerId\n    // as _id, perhaps cleanup\n    let providerId;\n    if (rate._id) {\n      providerId = rate._id;\n    } else {\n      // There is no default provider, so add it\n      if (!Shipping.find({}).count()) {\n        const defaultProvider = Shipping.insert({\n          name: \"Default Shipping Provider\",\n          provider: {\n            name: \"flatRates\",\n            label: \"Flat Rate\"\n          }\n        });\n        providerId = defaultProvider;\n      } else {\n        throw new Meteor.Error(\"bad-provider-id\", \"No Provider ID provided when adding methods\");\n      }\n    }\n\n    rate._id = Random.id();\n    return Shipping.update({\n      _id: providerId\n    }, {\n      $addToSet: {\n        methods: rate\n      }\n    });\n  },\n\n  /**\n   * shipping/rates/update\n   * @summary update shipping rate methods\n   * @param { Object } method shipping method object\n   * @return { Number } update result\n   */\n  \"shipping/rates/update\": function (method) {\n    check(method, ShippingMethod);\n    if (!Reaction.hasPermission(shippingRoles)) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const methodId = method._id;\n\n    return Shipping.update({\n      \"methods._id\": methodId\n    }, {\n      $set: {\n        \"methods.$\": method\n      }\n    });\n  },\n\n  /**\n   * shipping/rates/delete\n   * @summary delete shipping rate method\n   * @param { String } rateId id of method to delete\n   * @return { Number } update result\n   */\n  \"shipping/rates/delete\": function (rateId) {\n    check(rateId, String);\n\n    if (!Reaction.hasPermission(shippingRoles)) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Shipping.update({\n      \"methods._id\": rateId\n    }, {\n      $pull: {\n        methods: { _id: rateId }\n      }\n    });\n  }\n};\n\nMeteor.methods(methods);\n","import \"./i18n\";\nimport \"./methods/rates\";\nimport \"./hooks/hooks\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Shipping Rates\",\n  name: \"reaction-shipping-rates\",\n  icon: \"fa fa-truck-o\",\n  autoEnable: true,\n  settings: {\n    name: \"Flat Rate Service\",\n    flatRates: {\n      enabled: false\n    }\n  },\n  registry: [\n    {\n      provides: \"dashboard\",\n      route: \"/shipping/rates\",\n      name: \"shipping\",\n      label: \"Shipping\",\n      description: \"Provide shipping rates\",\n      icon: \"fa fa-truck\",\n      priority: 1,\n      container: \"core\",\n      workflow: \"coreDashboardWorkflow\"\n    },\n    {\n      provides: \"shippingSettings\",\n      name: \"shipping/settings/flatRates\",\n      label: \"Flat Rate\",\n      description: \"Provide shipping rates\",\n      icon: \"fa fa-truck\",\n      template: \"shippingRatesSettings\"\n    },\n    {\n      template: \"flatRateCheckoutShipping\",\n      name: \"shipping/flatRates\",\n      provides: \"shippingMethod\"\n    }\n  ]\n});\n","// Tempalte paths relative to /private/email/templates\n// Templates registered in /imports/plugins/included/email-templates/server/index.js\n\n/*\n * Default email templates\n * Used when no other template is found\n */\nexport const coreDefaultTemplate = \"coreDefault\";\n\n\n/*\n * Account related email templates\n */\nexport const inviteShopMemberTemplate = \"accounts/inviteShopMember\";\nexport const resetPaswordTemplate = \"accounts/resetPassword\";\nexport const welcomeEmailTemplate = \"accounts/sendWelcomeEmail\";\n// TODO: Used by launchdock, I haven't been able to test efficiently\nexport const verifyEmailTemplate = \"accounts/verifyEmail\";\n\n\n/*\n * Order (coreOrder) related email templates\n */\nexport const coreOrderNewTemplate = \"orders/new\";\nexport const orderShipped = \"orders/shipped\";\nexport const orderRefunded = \"orders/refunded\";\n","import { Reaction } from \"/server/api\";\nimport * as TemplatePaths from \"../lib/paths.js\";\n\n/*\n * Default email templates\n * Used when no other template is found\n */\nReaction.registerTemplate({\n  title: \"Default\",\n  name: TemplatePaths.coreDefaultTemplate,\n  type: \"email\",\n  template: Reaction.Email.getTemplateFile(TemplatePaths.coreDefaultTemplate),\n  subject: \"A message from {{shop.name}}\"\n});\n\n\n/*\n * Account related email templates\n */\n\n/*\n * Accounts - Invite Shop member\n * When: Admin invites new member to shop\n */\nReaction.registerTemplate({\n  title: \"Accounts - Invite Shop Member\",\n  name: TemplatePaths.inviteShopMemberTemplate,\n  type: \"email\",\n  template: Reaction.Email.getTemplateFile(TemplatePaths.inviteShopMemberTemplate),\n  subject: \"You have been invited to join {{shop.name}}\"\n});\n\n/*\n * Accounts - Reset Password\n * When: User requests to reset their password\n */\nReaction.registerTemplate({\n  title: \"Accounts - Reset Password\",\n  name: TemplatePaths.resetPaswordTemplate,\n  type: \"email\",\n  template: Reaction.Email.getTemplateFile(TemplatePaths.resetPaswordTemplate),\n  subject: \"{{shop.name}}: Here's your password reset link\"\n});\n\n/*\n * Accounts - Welcome Email\n * When: New user signs up for an account\n */\nReaction.registerTemplate({\n  title: \"Accounts - Welcome Email\",\n  name: TemplatePaths.welcomeEmailTemplate,\n  type: \"email\",\n  template: Reaction.Email.getTemplateFile(TemplatePaths.welcomeEmailTemplate),\n  subject: \"You're In. Welcome to {{shop.name}}!\"\n});\n\n/*\n * Accounts - Verify Email\n * When: A user signs up through launchdock\n * TODO: Used by launchdock, I haven't been able to test efficiently\n */\nReaction.registerTemplate({\n  title: \"Accounts - Verify Account (via LaunchDock)\",\n  name: TemplatePaths.verifyEmailTemplate,\n  type: \"email\",\n  template: Reaction.Email.getTemplateFile(TemplatePaths.verifyEmailTemplate),\n  subject: \"{{shopName}}: Please verify your email address\"\n});\n\n\n/*\n * Order (coreOrder) related email templates\n */\n\n/*\n * Orders - New Order Place\n * When: A user completes the cart checkout flow and a new order is placed\n */\nReaction.registerTemplate({\n  title: \"Orders - New Order Placed\",\n  name: TemplatePaths.coreOrderNewTemplate,\n  type: \"email\",\n  template: Reaction.Email.getTemplateFile(TemplatePaths.coreOrderNewTemplate),\n  subject: \"Your order is confirmed - {{order._id}}\"\n});\n\n/*\n * Orders - Order Shipped\n * When: Admin completes the order flow and item is shipped\n * When: Admin resends shipment notification\n */\nReaction.registerTemplate({\n  title: \"Orders - Order Shipped\",\n  name: TemplatePaths.orderShipped,\n  type: \"email\",\n  template: Reaction.Email.getTemplateFile(TemplatePaths.orderShipped),\n  subject: \"{{shop.name}}: Your order has shipped - {{order._id}}\"\n});\n\n/*\n * Orders - Order Refunded\n * When: Admin completes the order flow and item is shipped\n * When: Admin resends shipment notification\n */\nReaction.registerTemplate({\n  title: \"Orders - Order Refunded\",\n  name: TemplatePaths.orderRefunded,\n  type: \"email\",\n  template: Reaction.Email.getTemplateFile(TemplatePaths.orderRefunded),\n  subject: \"{{shop.name}}: Confirmation of refund for {{order._id}}\"\n});\n","import * as Schemas from \"/lib/collections/schemas\";\n\nSchemas.LaunchdockPackageConfig = new SimpleSchema([\n  Schemas.PackageConfig, {\n    \"settings.ssl.domain\": {\n      type: String,\n      label: \"Custom Domain\"\n    },\n    \"settings.ssl.privateKey\": {\n      type: String,\n      label: \"SSL Private Key\"\n    },\n    \"settings.ssl.certificate\": {\n      type: String,\n      label: \"SSL Certificate\"\n    }\n  }\n]);\n","import { Meteor } from \"meteor/meteor\";\nimport { DDP } from \"meteor/ddp\";\n\nconst Launchdock = {\n  /*\n  * Create authenticated DDP connection to Launchdock\n  */\n  connect() {\n    let url;\n    let username;\n    let pw;\n\n    /*\n    * client login info\n    */\n    if (Meteor.isClient) {\n      const user = Meteor.user();\n\n      if (!user || !user.services || !user.services.launchdock) {\n        return null;\n      }\n\n      url = user.services.launchdock.url;\n      username = user.services.launchdock.username;\n      pw = user.services.launchdock.auth;\n    }\n\n    /*\n    * server login info\n    */\n    if (Meteor.isServer) {\n      url = process.env.LAUNCHDOCK_URL;\n      username = process.env.LAUNCHDOCK_USERNAME;\n      pw = process.env.LAUNCHDOCK_AUTH;\n    }\n\n    if (!url || !username || !pw) {\n      return null;\n    }\n\n    // create and return connection\n    const launchdock = DDP.connect(url);\n    DDP.loginWithPassword(launchdock, { username: username }, pw);\n\n    return launchdock;\n  }\n};\n\nexport default Launchdock;\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import { Meteor } from \"meteor/meteor\";\nimport { Hooks, Logger } from \"/server/api\";\n\n/**\n * Hook to setup default admin user with Launchdock credentials (if they exist)\n */\n\nHooks.Events.add(\"afterCreateDefaultAdminUser\", (user) => {\n  if (process.env.LAUNCHDOCK_USERID) {\n    Meteor.users.update({\n      _id: user._id\n    }, {\n      $set: {\n        \"services.launchdock.userId\": process.env.LAUNCHDOCK_USERID,\n        \"services.launchdock.username\": process.env.LAUNCHDOCK_USERNAME,\n        \"services.launchdock.auth\": process.env.LAUNCHDOCK_AUTH,\n        \"services.launchdock.url\": process.env.LAUNCHDOCK_URL,\n        \"services.launchdock.stackId\": process.env.LAUNCHDOCK_STACK_ID\n      }\n    }, (err) => {\n      if (err) {\n        Logger.error(err);\n      } else {\n        Logger.debug(\"Updated default admin with Launchdock account info.\");\n      }\n    });\n  }\n  return user;\n});\n","import \"../lib/collections\";\n\nimport \"./hooks\";\nimport \"./methods\";\nimport \"./publications\";\nimport \"./i18n\";\n","import { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Packages } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\nimport Launchdock from \"../lib/launchdock\";\n\nMeteor.methods({\n  /**\n   * Sets custom domain name, confirms SSL key/cert exists.\n   * @param  {Object} opts - custom SSL cert details\n   * @return {Boolean} - returns true on successful update\n   */\n  \"launchdock/setCustomSsl\"(opts) {\n    if (!Reaction.hasAdminAccess()) {\n      const err = \"Access denied\";\n      Logger.error(err);\n      throw new Meteor.Error(\"auth-error\", err);\n    }\n\n    if (!process.env.LAUNCHDOCK_USERID) {\n      const err = \"Launchdock credentials not found\";\n      Logger.error(err);\n      throw new Meteor.Error(\"launchdock-credential-error\", err);\n    }\n\n    check(opts, {\n      domain: String,\n      privateKey: String,\n      publicCert: String\n    });\n\n    this.unblock();\n\n    const ldConnect = Packages.findOne({\n      name: \"reaction-connect\"\n    });\n\n    // save everything locally\n    try {\n      Packages.update(ldConnect._id, {\n        $set: {\n          \"settings.ssl.domain\": opts.domain,\n          \"settings.ssl.privateKey\": opts.privateKey,\n          \"settings.ssl.certificate\": opts.publicCert\n        }\n      });\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(e);\n    }\n\n    // build args for method on Launchdock side\n    const stackId = process.env.LAUNCHDOCK_STACK_ID;\n    const ldArgs = {\n      name: opts.domain,\n      key: opts.privateKey,\n      cert: opts.publicCert\n    };\n\n    const launchdock = Launchdock.connect(ldUrl);\n\n    if (!launchdock) {\n      const err = \"Unable to connect to Launchdock\";\n      Logger.error(err);\n      throw new Meteor.Error(err);\n    }\n\n    const result = launchdock.call(\"rancher/updateStackSSLCert\", stackId, ldArgs);\n\n    launchdock.disconnect();\n\n    return result;\n  },\n\n\n  \"launchdock/getDefaultDomain\"() {\n    if (!Reaction.hasAdminAccess()) {\n      const err = \"Access denied\";\n      Logger.error(err);\n      throw new Meteor.Error(\"auth-error\", err);\n    }\n\n    return process.env.LAUNCHDOCK_DEFAULT_DOMAIN;\n  },\n\n\n  \"launchdock/getLoadBalancerEndpoint\"() {\n    if (!Reaction.hasAdminAccess()) {\n      const err = \"Access denied\";\n      Logger.error(err);\n      throw new Meteor.Error(\"auth-error\", err);\n    }\n\n    return process.env.LAUNCHDOCK_BALANCER_ENDPOINT;\n  }\n\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Roles } from \"meteor/alanning:roles\";\n\n\nMeteor.publish(\"launchdock-auth\", function () {\n  // only publish Launchdock credentials for logged in admin/owner\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"])) {\n    return Meteor.users.find({ _id: this.userId }, {\n      fields: {\n        \"services.launchdock.userId\": 1,\n        \"services.launchdock.username\": 1,\n        \"services.launchdock.auth\": 1,\n        \"services.launchdock.url\": 1,\n        \"services.launchdock.stackId\": 1\n      }\n    });\n  }\n  return this.ready();\n});\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Reaction Connect\",\n  name: \"reaction-connect\",\n  icon: \"fa fa-rocket\",\n  autoEnable: true,\n  settings: {\n    name: \"Connect\"\n  },\n  registry: [\n    {\n      provides: \"dashboard\",\n      label: \"Connect\",\n      name: \"reaction-connect\",\n      route: \"/dashboard/connect\",\n      description: \"Connect Reaction as a deployed service\",\n      icon: \"fa fa-rocket\",\n      priority: 1,\n      container: \"utilities\"\n    },\n    {\n      provides: \"settings\",\n      route: \"/dashboard/connect/settings\",\n      name: \"reaction-connect/settings\",\n      label: \"Reaction Connect\",\n      icon: \"fa fa-rocket\",\n      container: \"reaction-connect\",\n      template: \"connectSettings\"\n    }\n  ]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./policy\";\nimport \"./publications\";\nimport \"./security\";\nimport \"./i18n\";\n","import { BrowserPolicy } from \"meteor/browser-policy-common\";\n\nBrowserPolicy.content.allowOriginForAll(\"www.google-analytics.com\");\nBrowserPolicy.content.allowOriginForAll(\"*.doubleclick.net\");\nBrowserPolicy.content.allowOriginForAll(\"cdn.mxpnl.com\");\nBrowserPolicy.content.allowOriginForAll(\"cdn.segment.com\");\nBrowserPolicy.content.allowOriginForAll(\"*.facebook.com\");\nBrowserPolicy.content.allowOriginForAll(\"connect.facebook.net\");\nBrowserPolicy.content.allowOriginForAll(\"fonts.googleapis.com\");\nBrowserPolicy.content.allowOriginForAll(\"fonts.gstatic.com\");\n","import { AnalyticsEvents } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nMeteor.publish(\"AnalyticsEvents\", function () {\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  return AnalyticsEvents.find({\n    shopId: shopId\n  });\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { AnalyticsEvents } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\n\n\nMeteor.startup(() => {\n  let i = 0;\n\n  const handle = Meteor.setInterval(() => {\n    i++;\n    const shopId = Reaction.getShopId();\n\n    if (shopId) {\n      AnalyticsEvents.permit(\"insert\").ifLoggedIn().allowInClientCode();\n\n      AnalyticsEvents.permit([\"update\", \"remove\"]).ifHasRole({\n        role: [\"admin\", \"owner\"],\n        group: shopId\n      }).allowInClientCode();\n\n      return Meteor.clearInterval(handle);\n    }\n\n    if (i > 30) {\n      // stop checking and warn if the shopId isn't available within 30 secs\n      Meteor.clearInterval(handle);\n      Logger.warn(\"Error getting shopId for 'AnalyticsEvents.permit()'\");\n    }\n\n    return null;\n  }, 1000);\n});\n","/* eslint camelcase: 0 */\nimport { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  name: \"reaction-analytics\",\n  icon: \"fa fa-bar-chart-o\",\n  autoEnable: false,\n  settings: {\n    public: {\n      segmentio: {\n        enabled: false,\n        api_key: \"\"\n      },\n      googleAnalytics: {\n        enabled: false,\n        api_key: \"\"\n      },\n      mixpanel: {\n        enabled: false,\n        api_key: \"\"\n      }\n    }\n  },\n  registry: [{\n    provides: \"dashboard\",\n    label: \"Analytics\",\n    description: \"Analytics and tracking integrations\",\n    template: \"reactionAnalytics\",\n    icon: \"fa fa-bar-chart-o\",\n    priority: 3,\n    container: \"connect\",\n    permissions: [{\n      label: \"Reaction Analytics\",\n      permission: \"dashboard/analytics\"\n    }]\n  }, {\n    label: \"Analytics Settings\",\n    icon: \"fa fa-bar-chart-o\",\n    route: \"/dashboard/analytics/settings\",\n    provides: \"settings\",\n    container: \"dashboard\",\n    template: \"reactionAnalyticsSettings\"\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","/* eslint camelcase: 0 */\nimport { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Reaction Default Theme\",\n  name: \"reaction-default-theme\"\n});\n","import { Cart, Products, Orders } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\nimport { registerInventory } from \"../methods/inventory\";\n\n/**\n * Collection Hooks\n * transform collections based on events\n *\n * See: https://github.com/matb33/meteor-collection-hooks\n */\n\n/**\n * After cart update\n */\nCart.after.update((userId, cart, fieldNames, modifier) => {\n  // if we're adding a new product or variant to the cart\n  if (modifier.$addToSet) {\n    if (modifier.$addToSet.items) {\n      Logger.debug(\"after cart update, call inventory/addReserve\");\n      Meteor.call(\"inventory/addReserve\", cart.items);\n    }\n  }\n  // or we're adding more quantity\n  if (modifier.$inc) {\n    Logger.debug(\"after variant increment, call inventory/addReserve\");\n    Meteor.call(\"inventory/addReserve\", cart.items);\n  }\n});\n\n/**\n * Before cart update. When Item is removed from Cart, release the inventory reservation.\n */\nCart.before.update((userId, cart, fieldNames, modifier) => {\n  // removing  cart items, clear inventory reserve\n  if (modifier.$pull) {\n    if (modifier.$pull.items) {\n      Logger.debug(\"remove cart items, call inventory/clearReserve\");\n      Meteor.call(\"inventory/clearReserve\", cart.items);\n    }\n  }\n});\n\n/**\n * after variant were removed\n * @fires `inventory/remove` Method\n */\nProducts.after.remove((userId, doc) => {\n  if (doc.type === \"variant\") {\n    const variantItem = {\n      productId: doc.ancestors[0],\n      variantId: doc._id,\n      shopId: doc.shopId\n    };\n    Logger.debug(`remove inventory variants for variant: ${doc._id\n      }, call inventory/remove`);\n    Meteor.call(\"inventory/remove\", variantItem);\n  }\n});\n\n//\n// after product update\n//\nProducts.after.update((userId, doc, fieldNames, modifier) => {\n  // product update can't affect on inventory, so we don't manage this cases\n  // we should keep in mind that returning false within hook prevents other\n  // hooks to be run\n  if (doc.type !== \"variant\") return false;\n\n  // check if modifier is set and $pull and $push are undefined. This need\n  // because anyway on every create or delete operation we have additionally\n  // $set modifier because of auto-updating of `shopId` and `updateAt` schema\n  // properties\n  if ((modifier.$set || modifier.$inc) && !modifier.$pull && !modifier.$push) {\n    if (!modifier.$set) {\n      modifier.$set = {};\n    }\n    modifier.$set.updatedAt = new Date();\n    // triggers inventory adjustment\n    Meteor.call(\"inventory/adjust\", doc);\n  }\n});\n\n/**\n * after insert\n * @summary should fires on create new variants, on clones products/variants\n */\nProducts.after.insert((userId, doc) => {\n  if (doc.type !== \"variant\") {\n    return false;\n  }\n  registerInventory(doc);\n});\n\nfunction markInventoryShipped(doc) {\n  const order = Orders.findOne(doc._id);\n  const orderItems = order.items;\n  const cartItems = [];\n  for (const orderItem of orderItems) {\n    const cartItem = {\n      _id: orderItem.cartItemId || orderItem._id,\n      shopId: orderItem.shopId,\n      quantity: orderItem.quantity,\n      productId: orderItem.productId,\n      variants: orderItem.variants,\n      title: orderItem.title\n    };\n    cartItems.push(cartItem);\n  }\n  Meteor.call(\"inventory/shipped\", cartItems);\n}\n\nfunction markInventorySold(doc) {\n  const orderItems = doc.items;\n  const cartItems = [];\n  // If a cartItemId exists it's a legacy order and we use that\n  for (const orderItem of orderItems) {\n    const cartItem = {\n      _id: orderItem.cartItemId || orderItem._id,\n      shopId: orderItem.shopId,\n      quantity: orderItem.quantity,\n      productId: orderItem.productId,\n      variants: orderItem.variants,\n      title: orderItem.title\n    };\n    cartItems.push(cartItem);\n  }\n  Meteor.call(\"inventory/sold\", cartItems);\n}\n\nOrders.after.insert((userId, doc) => {\n  Logger.debug(\"Inventory module handling Order insert\");\n  markInventorySold(doc);\n});\n\nOrders.after.update((userId, doc, fieldnames, modifier) => {\n  Logger.debug(\"Inventory module handling Order update\");\n  if (modifier.$addToSet) {\n    if (modifier.$addToSet[\"workflow.workflow\"] === \"coreOrderWorkflow/completed\") {\n      markInventoryShipped(doc);\n    }\n  }\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Catalog } from \"/lib/api\";\nimport { Inventory } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * inventory/register\n * @summary check a product and update Inventory collection with inventory documents.\n * @param {Object} product - valid Schemas.Product object\n * @return {Number} - returns the total amount of new inventory created\n */\nexport function registerInventory(product) {\n  check(product, Match.OneOf(Schemas.ProductVariant, Schemas.Product));\n  let type;\n  switch (product.type) {\n    case \"variant\":\n      check(product, Schemas.ProductVariant);\n      type = \"variant\";\n      break;\n    default:\n      check(product, Schemas.Product);\n      type = \"simple\";\n  }\n  let totalNewInventory = 0;\n  const productId = type === \"variant\" ? product.ancestors[0] : product._id;\n  const variants = Catalog.getVariants(productId);\n\n  // we'll check each variant to see if it has been fully registered\n  for (const variant of variants) {\n    const inventory = Inventory.find({\n      productId: productId,\n      variantId: variant._id,\n      shopId: product.shopId\n    });\n    // we'll return this as well\n    const inventoryVariantCount = inventory.count();\n    // if the variant exists already we're remove from the inventoryVariants\n    // so that we don't process it as an insert\n    if (inventoryVariantCount < variant.inventoryQuantity) {\n      const newQty = variant.inventoryQuantity || 0;\n      let i = inventoryVariantCount + 1;\n\n      Logger.debug(\n        `inserting ${newQty - inventoryVariantCount\n          } new inventory items for ${variant._id}`\n      );\n\n      const batch = Inventory.\n      _collection.rawCollection().initializeUnorderedBulkOp();\n      while (i <= newQty) {\n        const id = Inventory._makeNewID();\n        batch.insert({\n          _id: id,\n          productId: productId,\n          variantId: variant._id,\n          shopId: product.shopId,\n          createdAt: new Date,\n          updatedAt: new Date,\n          workflow: { // we add this line because `batchInsert` doesn't know\n            status: \"new\" // about SimpleSchema, so `defaultValue` will not\n          }\n        });\n        i++;\n      }\n\n      // took from: http://guide.meteor.com/collections.html#bulk-data-changes\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n      const inventoryItem = execute();\n      const inserted = inventoryItem.nInserted;\n\n      if (!inserted) { // or maybe `inventory.length === 0`?\n        // throw new Meteor.Error(\"Inventory Anomaly Detected. Abort! Abort!\");\n        return totalNewInventory;\n      }\n      Logger.debug(`registered ${inserted}`);\n      totalNewInventory += inserted;\n    }\n  }\n  // returns the total amount of new inventory created\n  return totalNewInventory;\n}\n\nfunction adjustInventory(product) {\n  let type;\n  let results;\n  // adds or updates inventory collection with this product\n  switch (product.type) {\n    case \"variant\":\n      check(product, Schemas.ProductVariant);\n      type = \"variant\";\n      break;\n    default:\n      check(product, Schemas.Product);\n      type = \"simple\";\n  }\n  // user needs createProduct permission to adjust inventory\n  if (!Reaction.hasPermission(\"createProduct\")) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  }\n  // this.unblock();\n\n  // Quantity and variants of this product's variant inventory\n  if (type === \"variant\") {\n    const variant = {\n      _id: product._id,\n      qty: product.inventoryQuantity || 0\n    };\n\n    const inventory = Inventory.find({\n      productId: product.ancestors[0],\n      variantId: product._id\n    });\n    const itemCount = inventory.count();\n\n    if (itemCount !== variant.qty) {\n      if (itemCount < variant.qty) {\n        // we need to register some new variants to inventory\n        results = itemCount + Meteor.call(\"inventory/register\", product);\n      } else if (itemCount > variant.qty) {\n        // determine how many records to delete\n        const removeQty = itemCount - variant.qty;\n        // we're only going to delete records that are new\n        const removeInventory = Inventory.find({\n          \"variantId\": variant._id,\n          \"workflow.status\": \"new\"\n        }, {\n          sort: {\n            updatedAt: -1\n          },\n          limit: removeQty\n        }).fetch();\n\n        results = itemCount;\n        // delete latest inventory \"status:new\" records\n        for (const inventoryItem of removeInventory) {\n          results -= Meteor.call(\"inventory/remove\", inventoryItem);\n          // we could add handling for the case when aren't enough \"new\" items\n        }\n      }\n      Logger.debug(\n        `adjust variant ${variant._id} from ${itemCount} to ${results}`\n      );\n    }\n  }\n}\n\nMeteor.methods({\n  \"inventory/register\": function (product) {\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    registerInventory(product);\n  },\n  \"inventory/adjust\": function (product) { // TODO: this should be variant\n    check(product, Match.OneOf(Schemas.Product, Schemas.ProductVariant));\n    adjustInventory(product);\n  }\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Inventory } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n// TODO statusChanges DDP limiting Disabled for now, needs more testing.\n\n// // Define a rate limiting rule that matches update attempts by non-admin users\n// const addReserveRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"subscription\",\n//   method: \"Inventory\"\n// };\n//\n// // Define a rate limiting rule that matches backorder attempts by non-admin users\n// const addBackorderRule = {\n//   userId: function (userId) {\n//     return Roles.userIsInRole(userId, \"createProduct\", Reaction.getShopId());\n//   },\n//   type: \"method\",\n//   method: \"inventory/backorder\"\n// };\n//\n// // Add the rule, allowing up to 5 messages every 1000 milliseconds.\n// DDPRateLimiter.addRule(addReserveRule, 5, 1000);\n// DDPRateLimiter.addRule(addBackorderRule, 5, 1000);\n\n//\n// Inventory methods\n//\n\nMeteor.methods({\n  /**\n   * inventory/setStatus\n   * @summary sets status from one status to a new status. Defaults to \"new\" to \"reserved\"\n   * @param  {Array} cartItems array of objects of type Schemas.CartItems\n   * @param  {String} status optional - sets the inventory workflow status, defaults to \"reserved\"\n   * @param  {String} currentStatus - what is the current status to change \"from\"\n   * @param  {String} notFoundStatus - what to use if the status is not found\n   * @todo move this to bulkOp\n   * @return {Number} returns reservationCount\n   */\n  \"inventory/setStatus\": function (cartItems, status, currentStatus, notFoundStatus) {\n    check(cartItems, [Schemas.CartItem]);\n    check(status, Match.Optional(String));\n    check(currentStatus, Match.Optional(String));\n    check(notFoundStatus, Match.Optional(String));\n    this.unblock();\n\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n\n    // set defaults\n    const reservationStatus = status || \"reserved\"; // change status to options object\n    const defaultStatus = currentStatus || \"new\"; // default to the \"new\" status\n    const backorderStatus = notFoundStatus || \"backorder\"; // change status to options object\n    let reservationCount;\n    Logger.debug(`Moving Inventory items from ${defaultStatus} to ${reservationStatus}`);\n\n    // update inventory status for cartItems\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        productId: item.productId,\n        variantId: item.variants._id,\n        shopId: item.shopId,\n        orderItemId: item._id\n      });\n\n      // define a new reservation\n      const availableInventory = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"workflow.status\": defaultStatus\n      });\n\n      const totalRequiredQty = item.quantity;\n      const availableInventoryQty = availableInventory.count();\n      let existingReservationQty = existingReservations.count();\n\n      Logger.debug(\"totalRequiredQty\", totalRequiredQty);\n      Logger.debug(\"availableInventoryQty\", availableInventoryQty);\n\n      // if we don't have existing inventory we create backorders\n      if (totalRequiredQty > availableInventoryQty) {\n        // TODO put in a dashboard setting to allow backorder or altenate handler to be used\n        const backOrderQty = Number(totalRequiredQty - availableInventoryQty - existingReservationQty);\n        Logger.debug(`no inventory found, create ${backOrderQty} ${backorderStatus}`);\n        // define a new reservation\n        const reservation = {\n          productId: item.productId,\n          variantId: item.variants._id,\n          shopId: item.shopId,\n          orderItemId: item._id,\n          workflow: {\n            status: backorderStatus\n          }\n        };\n\n        Meteor.call(\"inventory/backorder\", reservation, backOrderQty);\n        existingReservationQty = backOrderQty;\n      }\n      // if we have inventory available, only create additional required reservations\n      Logger.debug(\"existingReservationQty\", existingReservationQty);\n      reservationCount = existingReservationQty;\n      let newReservedQty;\n      if (reservationStatus === \"reserved\" && defaultStatus === \"new\") {\n        newReservedQty = totalRequiredQty - existingReservationQty + 1;\n      } else {\n        // when moving from one \"reserved\" type status, we don't need to deal with existingReservationQty\n        newReservedQty = totalRequiredQty + 1;\n      }\n\n      let i = 1;\n      while (i < newReservedQty) {\n        // updated existing new inventory to be reserved\n        Logger.debug(\n          `updating reservation status ${i} of ${newReservedQty - 1}/${totalRequiredQty} items.`);\n        // we should be updating existing inventory here.\n        // backorder process created additional backorder inventory if there\n        // wasn't enough.\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"workflow.status\": defaultStatus\n        }, {\n          $set: {\n            \"orderItemId\": item._id,\n            \"workflow.status\": reservationStatus\n          }\n        });\n        reservationCount++;\n        i++;\n      }\n    }\n    Logger.debug(\n      `finished creating ${reservationCount} new ${reservationStatus} reservations`);\n    return reservationCount;\n  },\n  /**\n   * inventory/clearStatus\n   * @summary used to reset status on inventory item (defaults to \"new\")\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @param  {[type]} status optional reset workflow.status, defaults to \"new\"\n   * @param  {[type]} currentStatus optional matching workflow.status, defaults to \"reserved\"\n   * @return {undefined} undefined\n   */\n  \"inventory/clearStatus\": function (cartItems, status, currentStatus) {\n    check(cartItems, [Schemas.CartItem]);\n    check(status, Match.Optional(String)); // workflow status\n    check(currentStatus, Match.Optional(String));\n    this.unblock();\n\n    // // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\", \"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n\n    // optional workflow status or default to \"new\"\n    const newStatus = status || \"new\";\n    const oldStatus = currentStatus || \"reserved\";\n\n    // remove each cart item in inventory\n    for (const item of cartItems) {\n      // check of existing reserved inventory for this cart\n      const existingReservations = Inventory.find({\n        \"productId\": item.productId,\n        \"variantId\": item.variants._id,\n        \"shopId\": item.shopId,\n        \"orderItemId\": item._id,\n        \"workflow.status\": oldStatus\n      });\n      let i = existingReservations.count();\n      // reset existing cartItem reservations\n      while (i <= item.quantity) {\n        Inventory.update({\n          \"productId\": item.productId,\n          \"variantId\": item.variants._id,\n          \"shopId\": item.shopId,\n          \"orderItemId\": item._id,\n          \"workflow.status\": oldStatus\n        }, {\n          $set: {\n            \"orderItemId\": \"\", // clear order/cart\n            \"workflow.status\": newStatus // reset status\n          }\n        });\n        i++;\n      }\n    }\n    Logger.debug(\"inventory/clearReserve\", newStatus);\n  },\n  /**\n   * inventory/clearReserve\n   * @summary resets \"reserved\" items to \"new\"\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/clearReserve\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/clearStatus\", cartItems);\n  },\n  /**\n   * inventory/clearReserve\n   * converts new items to reserved, or backorders\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/addReserve\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems);\n  },\n  /**\n   * inventory/backorder\n   * @summary is used by the cart process to create a new Inventory\n   * backorder item, but this could be used for inserting any\n   * custom inventory.\n   *\n   * A note on DDP Limits.\n   * As these are wide open we defined some ddp limiting rules http://docs.meteor.com/#/full/ddpratelimiter\n   *\n   * @param {Object} reservation Schemas.Inventory\n   * @param {Number} backOrderQty number of backorder items to create\n   * @returns {Number} number of inserted backorder documents\n   */\n  \"inventory/backorder\": function (reservation, backOrderQty) {\n    check(reservation, Schemas.Inventory);\n    check(backOrderQty, Number);\n    this.unblock();\n\n    // this use case could happen then mergeCart is fires. We don't add anything\n    // or remove, just item owner changed. We need to add this check here\n    // because of bulk operation. It thows exception if nothing to operate.\n    if (backOrderQty === 0) {\n      return 0;\n    }\n\n    // TODO inventory/backorder need to look carefully and understand is it possible ho have a\n    // negative `backOrderQty` value here?\n\n    // check basic user permissions\n    // if (!Reaction.hasPermission([\"guest\",\"anonymous\"])) {\n    //   throw new Meteor.Error(403, \"Access Denied\");\n    // }\n\n    // set defaults\n    const newReservation = reservation;\n    if (!newReservation.workflow) {\n      newReservation.workflow = {\n        status: \"backorder\"\n      };\n    }\n\n    // insert backorder\n    let i = 0;\n    const batch = Inventory.rawCollection().initializeUnorderedBulkOp();\n    if (batch) {\n      while (i < backOrderQty) {\n        const id = Inventory._makeNewID();\n        batch.insert(Object.assign({ _id: id }, newReservation));\n        i++;\n      }\n\n      const execute = Meteor.wrapAsync(batch.execute, batch);\n      if (batch.length) {\n        const inventoryBackorder = execute();\n        const inserted = inventoryBackorder.nInserted;\n        Logger.debug(`created ${inserted} backorder records for product ${newReservation.productId}, variant ${newReservation.variantId}`);\n        return inserted;\n      }\n    }\n    //\n    // TODO implement a backup inventory/backorder method if bulk operations fail.\n    //\n    Logger.error(\"skipped bulk operations backorder updates.\");\n    return null;\n  },\n  //\n  // send low stock warnings\n  //\n  \"inventory/lowStock\": function (product) {\n    check(product, Schemas.Product);\n    //\n    // TODO implement inventory/lowstock calculations\n    // placeholder is here to give plugins a place to hook into\n    //\n    Logger.debug(\"inventory/lowStock\");\n  },\n  /**\n   * inventory/remove\n   * delete an inventory item permanently\n   * @param  {Object} inventoryItem object type Schemas.Inventory\n   * @return {String} return remove result\n   */\n  \"inventory/remove\": function (inventoryItem) {\n    check(inventoryItem, Schemas.Inventory);\n    // user needs createProduct permission to adjust inventory\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // this.unblock();\n    // todo add bulkOp here\n\n    Logger.debug(\"inventory/remove\", inventoryItem);\n    return Inventory.remove(inventoryItem);\n  },\n  /**\n   * inventory/shipped\n   * mark inventory as shipped\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/shipped\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"shipped\", \"sold\");\n  },\n  /**\n   * inventory/sold\n   * mark inventory as sold\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/sold\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"sold\", \"reserved\");\n  },\n  /**\n   * inventory/return\n   * mark inventory as returned\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/return\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/setStatus\", cartItems, \"return\");\n  },\n  /**\n   * inventory/returnToStock\n   * mark inventory as return and available for sale\n   * @param  {Array} cartItems array of objects Schemas.CartItem\n   * @return {undefined}\n   */\n  \"inventory/returnToStock\": function (cartItems) {\n    check(cartItems, [Schemas.CartItem]);\n    return Meteor.call(\"inventory/clearStatus\", cartItems, \"new\", \"return\");\n  }\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Inventory } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nMeteor.publish(\"Inventory\", function () {\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\", \"createProduct\"],\n    shopId)) {\n    return Inventory.find({\n      shopId: shopId\n    });\n  }\n  return this.ready();\n});\n","import { Hooks, Logger } from \"/server/api\";\nimport { Products, Inventory } from \"/lib/collections\";\nimport { registerInventory } from \"../methods/inventory\";\n\n// On first-time startup init the Inventory collection with entries for each product\nHooks.Events.add(\"afterCoreInit\", () => {\n  // If we already have any inventory record, skip\n  const inventory = Inventory.find().count();\n  if (!inventory) {\n    const products = Products.find().fetch();\n    for (const product of products) {\n      Logger.debug(`Registering product ${product.title}`);\n      registerInventory(product);\n    }\n  }\n});\n","import \"./methods/statusChanges\";\nimport \"./methods/inventory\";\n\nimport \"./publications/inventory\";\n\nimport \"./hooks/hooks\";\nimport \"./startup/init\";\nimport \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Inventory\",\n  name: \"reaction-inventory\",\n  icon: \"fa fa-building\",\n  autoEnable: true,\n  settings: {\n    name: \"Inventory\"\n  },\n  registry: [{\n    provides: \"dashboard\",\n    label: \"Inventory\",\n    description: \"Inventory utilities\",\n    icon: \"fa fa-building\",\n    priority: 1,\n    container: \"utilities\",\n    permissions: [{\n      label: \"Inventory\",\n      permission: \"dashboard/inventory\"\n    }]\n  }],\n  layout: [{\n    layout: \"coreLayout\",\n    workflow: \"coreInventoryWorkflow\",\n    collection: \"Inventory\",\n    theme: \"default\",\n    enabled: true\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import later from \"later\";\nimport moment from \"moment\";\nimport { Accounts, Cart, Jobs } from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\nimport { ServerSessions } from \"/server/publications/collections/sessions\";\n\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  Logger.debug(\"Adding Job removeStaleCart and Accounts to jobControl\");\n  const settings = Reaction.getShopSettings();\n  if (settings.cart) {\n    new Job(Jobs, \"cart/removeFromCart\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\" // delay by twice as long for each subsequent retry\n      })\n      .repeat({\n        schedule: later.parse.text(\"every day\")\n      })\n      .save({\n        cancelRepeats: true\n      });\n  } else {\n    Logger.warn(\"No cart cleanup schedule\");\n  }\n});\n\n/**\n * {Function} that fetches stale carts\n * @param {Object} olderThan older than date\n * @return {Object} stale carts\n */\nconst getstaleCarts = (olderThan) => {\n  return Cart.find({ updatedAt: { $lte: olderThan } }).fetch();\n};\n\nexport default () => {\n  const removeStaleCart = Jobs.processJobs(\"cart/removeFromCart\", {\n    pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n    workTimeout: 180 * 1000\n  }, (job, callback) => {\n    Logger.debug(\"Processing cart/removeFromCart\");\n    const settings = Reaction.getShopSettings();\n    if (settings.cart) {\n      const schedule = (settings.cart.cleanupDurationDays).match(/\\d/);// configurable in shop settings\n      const olderThan = moment().subtract(Number(schedule[0]), \"days\")._d;\n      const carts = getstaleCarts(olderThan);\n      carts.forEach(cart => {\n        const user = Accounts.findOne({ _id: cart.userId });\n        if (!user.emails.length) {\n          const removeCart = Cart.remove({ userId: user._id });\n          const removeAccount = Accounts.remove(\n            {\n              _id: cart.userId,\n              emails: []\n            }\n          );\n          const destroySession = ServerSessions.remove({ _id: cart.sessionId });\n          Meteor.users.remove({ _id: user._id, emails: [] }); // clears out anonymous user\n          if (removeCart && removeAccount && destroySession) {\n            const success = \"Stale anonymous user cart and account successfully cleaned\";\n            Logger.debug(success);\n            job.done(success, { repeatId: true });\n          }\n        } else {\n          Cart.remove({ userId: user._id });\n          const success = \"Stale user cart successfully cleaned\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n        }\n      });\n    } else {\n      Logger.warn(\"No cart cleanup schedule\");\n    }\n    callback();\n  });\n  Jobs.find({\n    type: \"cart/removeFromCart\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return removeStaleCart.trigger();\n    }\n  });\n};\n","import later from \"later\";\nimport moment from \"moment\";\nimport { Jobs } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\n\nHooks.Events.add(\"onJobServerStart\", () => {\n  Logger.debug(\"Adding Job jobControl/removeStaleJobs to JobControl\");\n\n  new Job(Jobs, \"jobControl/removeStaleJobs\", {})\n    .retry({\n      retries: 5,\n      wait: 60000,\n      backoff: \"exponential\"\n    })\n    .repeat({\n      schedule: later.parse.text(\"every day\")\n    })\n    .save({\n      cancelRepeats: true\n    });\n});\n\n\nexport default function () {\n  const removeStaleJobs = Jobs.processJobs(\"jobControl/removeStaleJobs\", {\n    pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n    workTimeout: 60 * 1000\n  }, (job, callback) => {\n    Logger.debug(\"Processing jobControl/removeStaleJobs...\");\n\n    // TODO: set this interval in the admin UI\n    const olderThan = moment().subtract(3, \"days\")._d;\n\n    const ids = Jobs.find({\n      type: {\n        $nin: [\"sendEmail\"]\n      },\n      status: {\n        $in: [\"cancelled\", \"completed\", \"failed\"]\n      },\n      updated: {\n        $lt: olderThan\n      }\n    }, {\n      fields: {\n        _id: 1\n      }\n    }).map((d) => d._id);\n\n    let success;\n    if (ids.length > 0) {\n      Jobs.removeJobs(ids);\n      success = `Removed ${ids.length} stale jobs`;\n      Logger.debug(success);\n    } else {\n      success = \"No eligible jobs to cleanup\";\n      Logger.debug(success);\n    }\n    job.done(success, { repeatId: true });\n    return callback();\n  });\n\n  Jobs.find({\n    type: \"jobControl/removeStaleJobs\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return removeStaleJobs.trigger();\n    }\n  });\n}\n","import later from \"later\";\nimport { Jobs } from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\n// While we don't necessarily need to wait for anything to add a job\n// in this case we need to have packages loaded so we can check for the OER API key\nHooks.Events.add(\"afterCoreInit\", () => {\n  const settings = Reaction.getShopSettings();\n  const exchangeConfig = settings.openexchangerates || {};\n\n  if (exchangeConfig.appId) {\n    const refreshPeriod = exchangeConfig.refreshPeriod || \"every 4 hours\";\n    Logger.debug(`Adding shop/fetchCurrencyRates to JobControl. Refresh ${refreshPeriod}`);\n    new Job(Jobs, \"shop/fetchCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\" // delay by twice as long for each subsequent retry\n      })\n      .repeat({\n        schedule: later.parse.text(refreshPeriod)\n      })\n      .save({\n        // Cancel any jobs of the same type,\n        // but only if this job repeats forever.\n        cancelRepeats: true\n      });\n  } else {\n    Logger.warn(\"OpenExchangeRates API not configured. Not adding fetchRates job\");\n  }\n});\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  const settings = Reaction.getShopSettings();\n  const exchangeConfig = settings.openexchangerates || {};\n\n  if (exchangeConfig.appId) {\n    Logger.debug(\"Adding shop/flushCurrencyRates to JobControl\");\n    // TODO: Add this as a configurable option\n    const refreshPeriod = \"Every 24 hours\";\n    new Job(Jobs, \"shop/flushCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\"\n      })\n      .repeat({\n        schedule: later.parse.text(refreshPeriod)\n      })\n      .save({\n        cancelRepeats: true\n      });\n  } else {\n    Logger.warn(\"OpenExchangeRates API not configured. Not adding flushRates job\");\n  }\n});\n\n\nexport default function () {\n  const fetchCurrencyRates = Jobs.processJobs(\"shop/fetchCurrencyRates\", {\n    pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n    workTimeout: 180 * 1000\n  }, (job, callback) => {\n    Meteor.call(\"shop/fetchCurrencyRate\", (error) => {\n      if (error) {\n        if (error.error === \"notConfigured\") {\n          Logger.error(error.message);\n          job.done(error.message, { repeatId: true });\n        } else {\n          job.done(error.toString(), { repeatId: true });\n        }\n      } else {\n        // we should always return \"completed\" job here, because errors are fine\n        // result for this task, so that's why we show message if error happens\n        // and return job.done();\n        // you can read more about job.repeat() here:\n        // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n        // -job-will-be-automatically-re-run-by-the-job-collection\n        const success = \"Latest exchange rates were fetched successfully.\";\n        Logger.debug(success);\n        job.done(success, { repeatId: true });\n      }\n    });\n    callback();\n  });\n\n  Jobs.find({\n    type: \"shop/fetchCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return fetchCurrencyRates.trigger();\n    }\n  });\n\n\n  const flushCurrencyRates = Jobs.processJobs(\n    \"shop/flushCurrencyRates\", {\n      pollInterval: 60 * 60 * 1000, // backup polling, see observer below\n      workTimeout: 180 * 1000\n    },\n    (job, callback) => {\n      Meteor.call(\"shop/flushCurrencyRate\", error => {\n        if (error) {\n          if (error.error === \"notExists\") {\n            Logger.error(error.message);\n            job.done(error.message, { repeatId: true });\n          } else {\n            // Logger.error(error.toString());\n            job.done(error.toString(), { repeatId: true });\n          }\n        } else {\n          // https://github.com/vsivsi/meteor-job-collection#set-how-many-times-this\n          // -job-will-be-automatically-re-run-by-the-job-collection\n          const success = \"Stale exchange rates were flushed.\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n        }\n      });\n      callback();\n    }\n  );\n\n  Jobs.find({\n    type: \"shop/flushCurrencyRates\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      return flushCurrencyRates.trigger();\n    }\n  });\n}\n","import \"./jobs/exchangerates\";\nimport \"./jobs/cleanup\";\nimport \"./jobs/cart\";\nimport cleanupJob from \"./jobs/cleanup\";\nimport fetchRateJobs from \"./jobs/exchangerates\";\nimport cartCleanupJob from \"./jobs/cart\";\nimport \"./i18n\";\n\ncleanupJob();\nfetchRateJobs();\ncartCleanupJob();\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Job Control\",\n  name: \"reaction-jobcontrol\",\n  icon: \"fa fa-vine\",\n  autoEnable: true\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Logger, MethodHooks, Reaction } from \"/server/api\";\n\nconst getAdminUserId = () => {\n  // TODO validate with multiple show owners\n  // switch to using getShopId for role lookup\n  const admin = Meteor.users.findOne({\n    \"roles.__global_roles__\": \"owner\"\n  });\n  if (admin && typeof admin === \"object\") {\n    return admin._id;\n  }\n  return false;\n};\n\nconst sendNotificationToAdmin = (adminId) => {\n  const type = \"forAdmin\";\n  const prefix = Reaction.getShopPrefix();\n  const url = `${prefix}/dashboard/orders`;\n  const sms = true;\n  // Sending notification to admin\n  Logger.debug(\"sending notification to admin\");\n  return Meteor.call(\"notification/send\", adminId, type, url, sms);\n};\n\nMethodHooks.after(\"cart/copyCartToOrder\", function (options) {\n  const userId = Meteor.userId();\n  const type = \"newOrder\";\n  const prefix = Reaction.getShopPrefix();\n  const url = `${prefix}/notifications`;\n  const sms = true;\n\n  // Send notification to user who made the order\n  Logger.debug(`sending notification to user: ${userId}`);\n  Meteor.call(\"notification/send\", userId, type, url, sms);\n\n  // Sending notification to admin\n  const adminId = getAdminUserId();\n  if (adminId) {\n    return sendNotificationToAdmin(adminId);\n  }\n  return options.result;\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./notifications.js\";\n","import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { Notifications, Packages } from \"/lib/collections\";\n\n/**\n * Reaction Notification methods\n */\nMeteor.methods({\n  /**\n  * notification/send\n  * @summary This send a notification to a user\n  * @param {String} userId - The user\n  * @param {String} type - The type of Notification\n  * @param {String} url - url link\n  * @param {Boolean} sms - sms enabled check.\n  * @param {String} details - details of the Notification\n  * @return {Object} returns result\n  */\n  \"notification/send\": function (userId, type, url, sms, details) {\n    check(userId, String);\n    check(type, String);\n    check(sms, Boolean);\n    check(details, Match.OptionalOrNull(String));\n    check(url, String);\n\n    const values = {};\n    const types = {\n      orderCancelled: \"Your order was canceled.\",\n      newOrder: \"Your order is being processed.\",\n      forAdmin: \"You have a new order.\",\n      orderDelivered: \"Your order has been delivered.\",\n      orderAccepted: \"Your order has been accepted.\",\n      orderShipped: \"Your order has been shipped.\"\n    };\n\n    if (userId && type && url) {\n      values.type = type;\n      values.to = userId;\n      values.url = url;\n      values.message = types[type];\n      values.hasDetails = false;\n      if (details) {\n        values.hasDetails = true;\n        values.details = details;\n      }\n    }\n\n    if (sms) {\n      const result = Packages.findOne({ name: \"reaction-sms\", shopId: Reaction.getShopId() });\n      if (result && result.enabled) {\n        Meteor.call(\"sms/send\", values.message, userId, Reaction.getShopId(), (error) => {\n          if (error) {\n            Logger.warn(\"Error: error occured while sending sms\", error);\n          }\n        });\n      } else {\n        Logger.debug(\"Sms is not enabled\");\n      }\n    }\n    Logger.debug(`Sending notification to ${userId}`);\n    return Notifications.insert(values);\n  },\n\n  /**\n   * notification/markOneAsRead\n   * @summary This marks all user's notification as ready\n   * @param {String} id - The notification id\n   * @return {Object} returns cursor\n   */\n  \"notification/markOneAsRead\": (id) => {\n    check(id, String);\n\n    return Notifications.update({ _id: id }, {\n      $set: {\n        status: \"read\"\n      }\n    });\n  },\n\n  /**\n   * notification/delete\n   * @summary This deletes a notification\n   * @param {String} id - The notification id\n   * @return {Object} return cursor\n   */\n  \"notification/delete\": (id) => {\n    check(id, String);\n\n    return Notifications.remove({ _id: id });\n  }\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Logger } from \"/server/api\";\nimport { Notifications } from \"/lib/collections\";\n\n/**\n * Notification list publication\n * @param {String} userId\n * @return {Object} return notification cursor\n */\nMeteor.publish(\"Notification\", function (userId) {\n  check(userId, Match.OptionalOrNull(String));\n\n  if (!userId) {\n    Logger.debug(\"Ingnoring null request on Notification Subscription\");\n    return this.ready();\n  }\n\n  const result = Notifications.find({ to: userId });\n\n  return result;\n});\n","import \"./publications/notifications\";\nimport \"./methods\";\nimport \"./hooks/notification\";\nimport \"./init.js\";\nimport \"./i18n\";\n","import { Reaction, Hooks, Logger } from \"/server/api\";\nimport { Shops } from \"/lib/collections\";\n\nfunction addRolesToVisitors() {\n    // Add the about permission to all default roles since it's available to all\n  Logger.debug(\"Adding notification route permissions to default roles\");\n  const shop = Shops.findOne(Reaction.getShopId());\n  Shops.update(shop._id, {\n    $addToSet: { defaultRoles: \"notifications\" }\n  });\n}\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  addRolesToVisitors();\n});\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Notifications\",\n  name: \"reaction-notification\",\n  icon: \"fa fa-bell\",\n  autoEnable: true,\n  registry: [{\n    label: \"Notifications\",\n    name: \"notifications\",\n    route: \"/notifications\",\n    workflow: \"coreWorkflow\",\n    permissions: [{\n      label: \"Notifications\",\n      permission: \"notifications\"\n    }],\n    template: \"notificationRoute\"\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","/* eslint camelcase: 0 */\n/* eslint quote-props: 0 */\n// meteor modules\nimport accounting from \"accounting-js\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Promise } from \"meteor/promise\";\n\nimport AuthNetAPI from \"@reactioncommerce/authorize-net\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { Packages } from \"/lib/collections\";\nimport { PaymentMethod } from \"/lib/collections/schemas\";\n\nfunction getAccountOptions() {\n  const settings = Packages.findOne({\n    name: \"reaction-auth-net\",\n    shopId: Reaction.getShopId(),\n    enabled: true\n  }).settings;\n  const ref = Meteor.settings.authnet;\n  const options = {\n    login: getSettings(settings, ref, \"api_id\"),\n    tran_key: getSettings(settings, ref, \"transaction_key\")\n  };\n\n  if (!options.login) {\n    throw new Meteor.Error(\"invalid-credentials\", \"Invalid Authnet Credentials\");\n  }\n  return options;\n}\n\nfunction getSettings(settings, ref, valueName) {\n  if (settings !== null) {\n    return settings[valueName];\n  } else if (ref !== null) {\n    return ref[valueName];\n  }\n  return undefined;\n}\n\nMeteor.methods({\n  authnetSubmit: function (transactionType = \"authorizeTransaction\", cardInfo, paymentInfo) {\n    check(transactionType, String);\n    check(cardInfo, {\n      cardNumber: ValidCardNumber,\n      expirationYear: ValidExpireYear,\n      expirationMonth: ValidExpireMonth,\n      cvv2: ValidCVV\n    });\n    check(paymentInfo, {\n      total: String,\n      currency: String\n    });\n\n    const order = {\n      amount: paymentInfo.total\n    };\n    const creditCard = {\n      creditCardNumber: cardInfo.cardNumber,\n      cvv2: cardInfo.cvv2,\n      expirationYear: cardInfo.expirationYear,\n      expirationMonth: cardInfo.expirationMonth\n    };\n    const authnetService = getAuthnetService(getAccountOptions());\n    const authnetTransactionFunc = authnetService[transactionType];\n    let authResult;\n    if (authnetTransactionFunc) {\n      try {\n        authResult = authnetTransactionFunc.call(authnetService,\n          order,\n          creditCard\n        );\n      } catch (error) {\n        Logger.fatal(error);\n      }\n    } else {\n      throw new Meteor.Error(\"403\", \"Invalid Transaction Type\");\n    }\n\n    const result =  Promise.await(authResult);\n    return result;\n  },\n\n  \"authnet/payment/capture\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    const {\n      transactionId,\n      amount\n    } = paymentMethod;\n\n    const authnetService = getAuthnetService(getAccountOptions());\n    const roundedAmount = parseFloat(amount.toFixed(2));\n    const capturedAmount = accounting.toFixed(amount, 2);\n    let result;\n    if (capturedAmount === accounting.toFixed(0, 2)) {\n      try {\n        const captureResult = voidTransaction(transactionId,\n          authnetService\n        );\n        if (captureResult.responseCode[0] === \"1\") {\n          result = {\n            saved: true,\n            response: captureResult\n          };\n        } else {\n          result = {\n            saved: false,\n            error: captureResult\n          };\n        }\n      } catch (error) {\n        Logger.fatal(error);\n        result = {\n          saved: false,\n          error: error\n        };\n      }\n      return result;\n    }\n    try {\n      const captureResult = priorAuthCaptureTransaction(transactionId,\n        roundedAmount,\n        authnetService\n      );\n      if (captureResult.responseCode[0] === \"1\") {\n        result = {\n          saved: true,\n          response: captureResult\n        };\n      } else {\n        result = {\n          saved: false,\n          error: captureResult\n        };\n      }\n    } catch (error) {\n      Logger.fatal(error);\n      result = {\n        saved: false,\n        error: error\n      };\n    }\n    return result;\n  },\n\n  \"authnet/refund/create\": function (paymentMethod, amount) {\n    check(paymentMethod, PaymentMethod);\n    check(amount, Number);\n    const result = {\n      saved: false,\n      error: \"Reaction does not yet support direct refund processing from Authorize.net. \" +\n      \"Please visit their web portal to perform this action. https://account.authorize.net/\"\n    };\n\n    return result;\n  },\n  \"authnet/refund/list\": function () {\n    check(arguments, [Match.Any]);\n    Meteor.Error(\"Not Implemented\", \"Authorize.net does not yet support retrieving a list of refunds.\");\n  }\n});\n\nfunction getAuthnetService(accountOptions) {\n  const {\n    login,\n    tran_key,\n    mode\n    } = accountOptions;\n\n  return new AuthNetAPI({\n    API_LOGIN_ID: login,\n    TRANSACTION_KEY: tran_key,\n    testMode: !mode\n  });\n}\n\nfunction priorAuthCaptureTransaction(transId, amount, service) {\n  const body = {\n    transactionType: \"priorAuthCaptureTransaction\",\n    amount: amount,\n    refTransId: transId\n  };\n  // This call returns a Promise to the cb so we need to use Promise.await\n  const transactionRequest = service.sendTransactionRequest.call(service, body, function (trans) {\n    return trans;\n  });\n  return Promise.await(transactionRequest);\n}\n\nfunction voidTransaction(transId, service) {\n  const body = {\n    transactionType: \"voidTransaction\",\n    refTransId: transId\n  };\n  // This call returns a Promise to the cb so we need to use Promise.await\n  const transactionRequest = service.sendTransactionRequest.call(service, body, function (trans) {\n    return trans;\n  });\n  return Promise.await(transactionRequest);\n}\n\nValidCardNumber = Match.Where(function (x) {\n  return /^[0-9]{14,16}$/.test(x);\n});\n\nValidExpireMonth = Match.Where(function (x) {\n  return /^[0-9]{1,2}$/.test(x);\n});\n\nValidExpireYear = Match.Where(function (x) {\n  return /^[0-9]{4}$/.test(x);\n});\n\nValidCVV = Match.Where(function (x) {\n  return /^[0-9]{3,4}$/.test(x);\n});\n","import \"./i18n\";\nimport \"./methods/authnet\";\n","/* eslint camelcase: 0 */\nimport { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Authorize.net\",\n  name: \"reaction-auth-net\",\n  icon: \"fa fa-credit-card\",\n  autoEnable: true,\n  settings: {\n    \"api_id\": \"\",\n    \"transaction_key\": \"\",\n    \"mode\": false,\n    \"authnet\": {\n      enabled: false\n    },\n    \"reaction-auth-net\": {\n      enabled: false,\n      support: [\n        \"Authorize\",\n        \"Capture\",\n        \"Refund\"\n      ]\n    }\n  },\n  registry: [\n    // Settings panel\n    {\n      provides: \"paymentSettings\",\n      label: \"Authorize.net\",\n      container: \"dashboard\",\n      template: \"authnetSettings\"\n    },\n\n    // Payment form for checkout\n    {\n      template: \"authnetPaymentForm\",\n      provides: \"paymentMethod\",\n      icon: \"fa fa-credit-card\"\n    }\n  ]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import * as BraintreeMethods from \"./braintreeMethods\";\nimport { Meteor } from \"meteor/meteor\";\n\nMeteor.methods({\n  \"braintreeSubmit\": BraintreeMethods.paymentSubmit,\n  \"braintree/payment/capture\": BraintreeMethods.paymentCapture,\n  \"braintree/refund/create\": BraintreeMethods.createRefund,\n  \"braintree/refund/list\": BraintreeMethods.listRefunds\n});\n","/* eslint camelcase: 0 */\n// meteor modules\nimport { Meteor } from \"meteor/meteor\";\n// reaction modules\nimport { Packages } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\nimport Future from \"fibers/future\";\nimport Braintree from \"braintree\";\nimport accounting from \"accounting-js\";\n\nexport const BraintreeApi = {};\nBraintreeApi.apiCall = {};\n\n\nfunction getPaymentObj() {\n  return {\n    amount: \"\",\n    options: { submitForSettlement: true }\n  };\n}\n\nfunction parseCardData(data) {\n  return {\n    cardholderName: data.name,\n    number: data.number,\n    expirationMonth: data.expirationMonth,\n    expirationYear: data.expirationYear,\n    cvv: data.cvv\n  };\n}\n\n\nfunction getSettings(settings, ref, valueName) {\n  if (settings !== null) {\n    return settings[valueName];\n  } else if (ref !== null) {\n    return ref[valueName];\n  }\n  return undefined;\n}\n\nfunction getAccountOptions() {\n  let environment;\n  const settings = Packages.findOne({\n    name: \"reaction-braintree\",\n    shopId: Reaction.getShopId(),\n    enabled: true\n  }).settings;\n  if (typeof settings !== \"undefined\" && settings !== null ? settings.mode : undefined === true) {\n    environment = \"production\";\n  } else {\n    environment = \"sandbox\";\n  }\n\n  const ref = Meteor.settings.braintree;\n  const options = {\n    environment: environment,\n    merchantId: getSettings(settings, ref, \"merchant_id\"),\n    publicKey: getSettings(settings, ref, \"public_key\"),\n    privateKey: getSettings(settings, ref, \"private_key\")\n  };\n  if (!options.merchantId) {\n    throw new Meteor.Error(\"invalid-credentials\", \"Invalid Braintree Credentials\");\n  }\n  return options;\n}\n\nfunction getGateway() {\n  const accountOptions = getAccountOptions();\n  if (accountOptions.environment === \"production\") {\n    accountOptions.environment = Braintree.Environment.Production;\n  } else {\n    accountOptions.environment = Braintree.Environment.Sandbox;\n  }\n  const gateway = Braintree.connect(accountOptions);\n  return gateway;\n}\n\ngetRefundDetails = function (refundId) {\n  check(refundId, String);\n  const gateway = getGateway();\n  const braintreeFind = Meteor.wrapAsync(gateway.transaction.find, gateway.transaction);\n  const findResults = braintreeFind(refundId);\n  return findResults;\n};\n\n\nBraintreeApi.apiCall.paymentSubmit = function (paymentSubmitDetails) {\n  const gateway = getGateway();\n  const paymentObj = getPaymentObj();\n  if (paymentSubmitDetails.transactionType === \"authorize\") {\n    paymentObj.options.submitForSettlement = false;\n  }\n  paymentObj.creditCard = parseCardData(paymentSubmitDetails.cardData);\n  paymentObj.amount = paymentSubmitDetails.paymentData.total;\n  const fut = new Future();\n  gateway.transaction.sale(paymentObj, Meteor.bindEnvironment(function (error, result) {\n    if (error) {\n      fut.return({\n        saved: false,\n        error: error\n      });\n    } else if (!result.success) {\n      fut.return({\n        saved: false,\n        response: result\n      });\n    } else {\n      fut.return({\n        saved: true,\n        response: result\n      });\n    }\n  }, function (error) {\n    Reaction.Events.warn(error);\n  }));\n\n  return fut.wait();\n};\n\n\nBraintreeApi.apiCall.captureCharge = function (paymentCaptureDetails) {\n  const transactionId = paymentCaptureDetails.transactionId;\n  const amount = accounting.toFixed(paymentCaptureDetails.amount, 2);\n  const gateway = getGateway();\n  const fut = new Future();\n\n  if (amount === accounting.toFixed(0, 2)) {\n    gateway.transaction.void(transactionId, function (error, result) {\n      if (error) {\n        fut.return({\n          saved: false,\n          error: error\n        });\n      } else {\n        fut.return({\n          saved: true,\n          response: result\n        });\n      }\n    }, function (e) {\n      Logger.warn(e);\n    });\n    return fut.wait();\n  }\n  gateway.transaction.submitForSettlement(transactionId, amount, Meteor.bindEnvironment(function (error, result) {\n    if (error) {\n      fut.return({\n        saved: false,\n        error: error\n      });\n    } else {\n      fut.return({\n        saved: true,\n        response: result\n      });\n    }\n  }, function (e) {\n    Logger.warn(e);\n  }));\n\n  return fut.wait();\n};\n\n\nBraintreeApi.apiCall.createRefund = function (refundDetails) {\n  const transactionId = refundDetails.transactionId;\n  const amount = refundDetails.amount;\n  const gateway = getGateway();\n  const fut = new Future();\n  gateway.transaction.refund(transactionId, amount, Meteor.bindEnvironment(function (error, result) {\n    if (error) {\n      fut.return({\n        saved: false,\n        error: error\n      });\n    } else if (!result.success) {\n      if (result.errors.errorCollections.transaction.validationErrors.base[0].code === \"91506\") {\n        fut.return({\n          saved: false,\n          error: \"Braintree does not allow refunds until transactions are settled. This can take up to 24 hours. Please try again later.\"\n        });\n      } else {\n        fut.return({\n          saved: false,\n          error: result.message\n        });\n      }\n    } else {\n      fut.return({\n        saved: true,\n        response: result\n      });\n    }\n  }, function (e) {\n    Logger.fatal(e);\n  }));\n  return fut.wait();\n};\n\n\nBraintreeApi.apiCall.listRefunds = function (refundListDetails) {\n  const transactionId = refundListDetails.transactionId;\n  const gateway = getGateway();\n  const braintreeFind = Meteor.wrapAsync(gateway.transaction.find, gateway.transaction);\n  const findResults = braintreeFind(transactionId);\n  const result = [];\n  if (findResults.refundIds.length > 0) {\n    for (const refund of findResults.refundIds) {\n      const refundDetails = getRefundDetails(refund);\n      result.push({\n        type: \"refund\",\n        amount: parseFloat(refundDetails.amount),\n        created: moment(refundDetails.createdAt).unix() * 1000,\n        currency: refundDetails.currencyIsoCode,\n        raw: refundDetails\n      });\n    }\n  }\n\n  return result;\n};\n","import { BraintreeApi } from \"./braintreeApi\";\nimport { Logger } from \"/server/api\";\nimport { PaymentMethod } from \"/lib/collections/schemas\";\n\n/**\n * braintreeSubmit\n * Authorize, or authorize and capture payments from Braintree\n * https://developers.braintreepayments.com/reference/request/transaction/sale/node\n * @param {String} transactionType - either authorize or capture\n * @param {Object} cardData - Object containing everything about the Credit card to be submitted\n * @param {Object} paymentData - Object containing everything about the transaction to be settled\n * @return {Object} results - Object containing the results of the transaction\n */\nexport function paymentSubmit(transactionType, cardData, paymentData) {\n  check(transactionType, String);\n  check(cardData, {\n    name: String,\n    number: String,\n    expirationMonth: String,\n    expirationYear: String,\n    cvv2: String,\n    type: String\n  });\n  check(paymentData, {\n    total: String,\n    currency: String\n  });\n\n  const paymentSubmitDetails = {\n    transactionType: transactionType,\n    cardData: cardData,\n    paymentData: paymentData\n  };\n\n  let result;\n\n  try {\n    const paymentSubmitResult = BraintreeApi.apiCall.paymentSubmit(paymentSubmitDetails);\n    Logger.debug(paymentSubmitResult);\n    result = paymentSubmitResult;\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: `Cannot Submit Payment: ${error.message}`\n    };\n    Logger.fatal(\"Braintree call failed, payment was not submitted\");\n  }\n\n  return result;\n}\n\n\n/**\n * paymentCapture\n * Capture payments from Braintree\n * https://developers.braintreepayments.com/reference/request/transaction/submit-for-settlement/node\n * @param {Object} paymentMethod - Object containing everything about the transaction to be settled\n * @return {Object} results - Object containing the results of the transaction\n */\nexport function paymentCapture(paymentMethod) {\n  check(paymentMethod, PaymentMethod);\n\n  const paymentCaptureDetails = {\n    transactionId: paymentMethod.transactionId,\n    amount: paymentMethod.amount\n  };\n\n  let result;\n\n  try {\n    const paymentCaptureResult = BraintreeApi.apiCall.captureCharge(paymentCaptureDetails);\n    Logger.debug(paymentCaptureResult);\n    result = paymentCaptureResult;\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: `Cannot Capture Payment: ${error.message}`\n    };\n    Logger.fatal(\"Braintree call failed, payment was not captured\");\n  }\n\n  return result;\n}\n\n\n/**\n * createRefund\n * Refund BrainTree payment\n * https://developers.braintreepayments.com/reference/request/transaction/refund/node\n * @param {Object} paymentMethod - Object containing everything about the transaction to be settled\n * @param {Number} amount - Amount to be refunded if not the entire amount\n * @return {Object} results - Object containing the results of the transaction\n */\nexport function createRefund(paymentMethod, amount) {\n  check(paymentMethod, PaymentMethod);\n  check(amount, Number);\n\n  const refundDetails = {\n    transactionId: paymentMethod.transactionId,\n    amount: amount\n  };\n\n  let result;\n\n  try {\n    const refundResult = BraintreeApi.apiCall.createRefund(refundDetails);\n    Logger.debug(refundResult);\n    result = refundResult;\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: `Cannot issue refund: ${error.message}`\n    };\n    Logger.fatal(\"Braintree call failed, refund was not issued\");\n  }\n\n  return result;\n}\n\n\n/**\n * listRefunds\n * List all refunds for a transaction\n * https://developers.braintreepayments.com/reference/request/transaction/find/node\n * @param {Object} paymentMethod - Object containing everything about the transaction to be settled\n * @return {Array} results - An array of refund objects for display in admin\n */\nexport function listRefunds(paymentMethod) {\n  check(paymentMethod, Object);\n\n  const refundListDetails = {\n    transactionId: paymentMethod.transactionId\n  };\n\n  let result;\n\n  try {\n    const refundListResult = BraintreeApi.apiCall.listRefunds(refundListDetails);\n    Logger.debug(refundListResult);\n    result = refundListResult;\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: `Cannot list refunds: ${error.message}`\n    };\n    Logger.fatal(\"Braintree call failed, refunds not listed\");\n  }\n\n  return result;\n}\n","import \"./i18n\";\nimport \"./methods/braintree\";\n\nexport * from \"./methods/braintree\";\n","/* eslint camelcase: 0 */\nimport { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"BrainTree\",\n  icon: \"fa fa-credit-card\",\n  autoEnable: true,\n  name: \"reaction-braintree\", // usually same as meteor package\n  settings: // private package settings config (blackbox)\n  {\n    \"mode\": false,\n    \"merchant_id\": \"\",\n    \"public_key\": \"\",\n    \"private_key\": \"\",\n    \"reaction-braintree\": {\n      enabled: false,\n      support: [\n        \"Authorize\",\n        \"Capture\",\n        \"Refund\"\n      ]\n    }\n  },\n  registry: [\n    {\n      label: \"Braintree\",\n      provides: \"paymentSettings\",\n      container: \"dashboard\",\n      template: \"braintreeSettings\"\n    },\n    // configures template for checkout\n    // paymentMethod dynamic template\n    {\n      template: \"braintreePaymentForm\",\n      provides: \"paymentMethod\",\n      icon: \"fa fa-credit-card\"\n    }\n  ]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import accounting from \"accounting-js\";\n/* eslint camelcase: 0 */\n// meteor modules\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\n// reaction modules\nimport { Reaction, Logger } from \"/server/api\";\nimport { StripeApi } from \"./stripeapi\";\n\nfunction luhnValid(x) {\n  return [...x].reverse().reduce((sum, c, i) => {\n    let d = parseInt(c, 10);\n    if (i % 2 !== 0) { d *= 2; }\n    if (d > 9) { d -= 9; }\n    return sum + d;\n  }, 0) % 10 === 0;\n}\n\nconst ValidCardNumber = Match.Where(function (x) {\n  return /^[0-9]{13,16}$/.test(x) && luhnValid(x);\n});\n\nconst ValidExpireMonth = Match.Where(function (x) {\n  return /^[0-9]{1,2}$/.test(x);\n});\n\nconst ValidExpireYear = Match.Where(function (x) {\n  return /^[0-9]{4}$/.test(x);\n});\n\nconst ValidCVV = Match.Where(function (x) {\n  return /^[0-9]{3,4}$/.test(x);\n});\n\nfunction parseCardData(data) {\n  return {\n    number: data.number,\n    name: data.name,\n    cvc: data.cvv2,\n    exp_month: data.expire_month,\n    exp_year: data.expire_year\n  };\n}\n\n// Stripe uses a \"Decimal-less\" format so 10.00 becomes 1000\nfunction formatForStripe(amount) {\n  return Math.round(amount * 100);\n}\nfunction unformatFromStripe(amount) {\n  return (amount / 100);\n}\n\nfunction stripeCaptureCharge(paymentMethod) {\n  let result;\n  const captureDetails = {\n    amount: formatForStripe(paymentMethod.amount)\n  };\n\n  try {\n    const captureResult = StripeApi.methods.captureCharge.call({\n      transactionId: paymentMethod.transactionId,\n      captureDetails: captureDetails\n    });\n    if (captureResult.status === \"succeeded\") {\n      result = {\n        saved: true,\n        response: captureResult\n      };\n    } else {\n      result = {\n        saved: false,\n        response: captureResult\n      };\n    }\n  } catch (error) {\n    Logger.error(error);\n    result = {\n      saved: false,\n      error: error\n    };\n    return { error, result };\n  }\n  return result;\n}\n\n\nMeteor.methods({\n  \"stripeSubmit\": function (transactionType, cardData, paymentData) {\n    check(transactionType, String);\n    check(cardData, {\n      name: String,\n      number: ValidCardNumber,\n      expire_month: ValidExpireMonth,\n      expire_year: ValidExpireYear,\n      cvv2: ValidCVV,\n      type: String\n    });\n    check(paymentData, {\n      total: String,\n      currency: String\n    });\n\n    const chargeObj = {\n      amount: \"\",\n      currency: \"\",\n      card: {},\n      capture: true\n    };\n\n    if (transactionType === \"authorize\") {\n      chargeObj.capture = false;\n    }\n    chargeObj.card = parseCardData(cardData);\n    chargeObj.amount = formatForStripe(paymentData.total);\n    chargeObj.currency = paymentData.currency;\n    let result;\n    let chargeResult;\n\n    try {\n      chargeResult = StripeApi.methods.createCharge.call({ chargeObj });\n      if (chargeResult && chargeResult.status === \"succeeded\") {\n        result = {\n          saved: true,\n          response: chargeResult\n        };\n      } else {\n        Logger.debug(\"Stripe Call succeeded but charge failed\");\n        result = {\n          saved: false,\n          error: chargeResult.error.message\n        };\n      }\n      return result;\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"error\", e.message);\n    }\n  },\n\n  /**\n   * Capture a Stripe charge\n   * @see https://stripe.com/docs/api#capture_charge\n   * @param  {Object} paymentMethod A PaymentMethod object\n   * @return {Object} results from Stripe normalized\n   */\n  \"stripe/payment/capture\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    // let result;\n    const captureDetails = {\n      amount: formatForStripe(paymentMethod.amount)\n    };\n\n    // 100% discounts are not valid when using Stripe\n    // If discount is 100%, capture 100% and then refund 100% of transaction\n    if (captureDetails.amount === accounting.unformat(0)) {\n      const voidedAmount = unformatFromStripe(paymentMethod.transactions[0].amount);\n      stripeCaptureCharge(paymentMethod);\n\n      return Meteor.call(\"stripe/refund/create\", paymentMethod, voidedAmount);\n    }\n    return stripeCaptureCharge(paymentMethod);\n  },\n\n  /**\n   * Issue a refund against a previously captured transaction\n   * @see https://stripe.com/docs/api#refunds\n   * @param  {Object} paymentMethod object\n   * @param  {Number} amount to be refunded\n   * @param  {String} reason refund was issued (currently unused by client)\n   * @return {Object} result\n   */\n  \"stripe/refund/create\": function (paymentMethod, amount, reason = \"requested_by_customer\") {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n    check(reason, String);\n\n    const refundDetails = {\n      charge: paymentMethod.transactionId,\n      amount: formatForStripe(amount),\n      reason\n    };\n\n    let result;\n    try {\n      const refundResult = StripeApi.methods.createRefund.call({ refundDetails });\n      Logger.debug(refundResult);\n      if (refundResult && refundResult.object === \"refund\") {\n        result = {\n          saved: true,\n          response: refundResult\n        };\n      } else {\n        result = {\n          saved: false,\n          response: refundResult\n        };\n        Logger.warn(\"Stripe call succeeded but refund not issued\");\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = {\n        saved: false,\n        error: `Cannot issue refund: ${error.message}`\n      };\n      Logger.fatal(\"Stripe call failed, refund was not issued\");\n    }\n    return result;\n  },\n\n  /**\n   * List refunds\n   * @param  {Object} paymentMethod object\n   * @return {Object} result\n   */\n  \"stripe/refund/list\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    let result;\n    try {\n      const refunds = StripeApi.methods.listRefunds.call({ transactionId: paymentMethod.transactionId });\n      result = [];\n      for (const refund of refunds.data) {\n        result.push({\n          type: refund.object,\n          amount: refund.amount / 100,\n          created: refund.created * 1000,\n          currency: refund.currency,\n          raw: refund\n        });\n      }\n    } catch (error) {\n      Logger.error(error);\n      result = { error };\n    }\n    return result;\n  }\n});\n","/* eslint camelcase: 0 */\nimport _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Packages } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\n\nexport const StripeApi = {};\nStripeApi.methods = {};\n\n\nexport const cardSchema = new SimpleSchema({\n  number: { type: String },\n  name: { type: String },\n  cvc: { type: String },\n  exp_month: { type: String },\n  exp_year: { type: String }\n});\n\nexport const chargeObjectSchema = new SimpleSchema({\n  amount: { type: Number },\n  currency: { type: String },\n  card: { type: cardSchema },\n  capture: { type: Boolean }\n});\n\nexport const captureDetailsSchema = new SimpleSchema({\n  amount: { type: Number }\n});\n\nexport const refundDetailsSchema = new SimpleSchema({\n  charge: { type: String },\n  amount: { type: Number },\n  metadata: { type: String, optional: true },\n  reason: { type: String }\n});\n\n// These are errors on the user side that we just want to pass back up to the user\nconst expectedErrors = [\n  \"card_declined\",\n  \"incorrect_cvc\",\n  \"expired_card\",\n  \"incorrect_number\"\n];\n\nStripeApi.methods.getApiKey = new ValidatedMethod({\n  name: \"StripeApi.methods.getApiKey\",\n  validate: null,\n  run() {\n    const settings = Packages.findOne({\n      name: \"reaction-stripe\",\n      shopId: Reaction.getShopId()\n    }).settings;\n    if (!settings.api_key) {\n      throw new Meteor.Error(\"403\", \"Invalid Stripe Credentials\");\n    }\n    return settings.api_key;\n  }\n});\n\n\nStripeApi.methods.createCharge = new ValidatedMethod({\n  name: \"StripeApi.methods.createCharge\",\n  validate: new SimpleSchema({\n    chargeObj: { type: chargeObjectSchema },\n    apiKey: { type: String, optional: true }\n  }).validator(),\n  run({ chargeObj, apiKey }) {\n    let stripe;\n    if (!apiKey) {\n      const dynamicApiKey = StripeApi.methods.getApiKey.call();\n      stripe = require(\"stripe\")(dynamicApiKey);\n    } else {\n      stripe = require(\"stripe\")(apiKey);\n    }\n    try {\n      const chargePromise = stripe.charges.create(chargeObj);\n      const promiseResult = Promise.await(chargePromise);\n      return promiseResult;\n    } catch (e) {\n      // Handle \"expected\" errors differently\n      if (e.rawType === \"card_error\" && _.includes(expectedErrors, e.code)) {\n        Logger.debug(\"Error from Stripe is expected, not throwing\");\n        return { error: e, result: null };\n      }\n      Logger.error(\"Received unexpected error code: \" + e.code);\n      Logger.error(e);\n      return { error: e, result: null };\n    }\n  }\n});\n\nStripeApi.methods.captureCharge = new ValidatedMethod({\n  name: \"StripeApi.methods.captureCharge\",\n  validate: new SimpleSchema({\n    transactionId: { type: String },\n    captureDetails: { type: captureDetailsSchema },\n    apiKey: { type: String, optional: true }\n  }).validator(),\n  run({ transactionId, captureDetails, apiKey })  {\n    let stripe;\n    if (!apiKey) {\n      const dynamicApiKey = StripeApi.methods.getApiKey.call();\n      stripe = require(\"stripe\")(dynamicApiKey);\n    } else {\n      stripe = require(\"stripe\")(apiKey);\n    }\n    const capturePromise = stripe.charges.capture(transactionId, captureDetails);\n    const captureResults = Promise.await(capturePromise);\n    return captureResults;\n  }\n});\n\nStripeApi.methods.createRefund = new ValidatedMethod({\n  name: \"StripeApi.methods.createRefund\",\n  validate: new SimpleSchema({\n    refundDetails: { type: refundDetailsSchema },\n    apiKey: { type: String, optional: true }\n  }).validator(),\n  run({ refundDetails, apiKey }) {\n    let stripe;\n    if (!apiKey) {\n      const dynamicApiKey = StripeApi.methods.getApiKey.call();\n      stripe = require(\"stripe\")(dynamicApiKey);\n    } else {\n      stripe = require(\"stripe\")(apiKey);\n    }\n    const refundPromise = stripe.refunds.create({ charge: refundDetails.charge, amount: refundDetails.amount });\n    const refundResults = Promise.await(refundPromise);\n    return refundResults;\n  }\n});\n\nStripeApi.methods.listRefunds = new ValidatedMethod({\n  name: \"StripeApi.methods.listRefunds\",\n  validate: new SimpleSchema({\n    transactionId: { type: String },\n    apiKey: { type: String, optional: true }\n  }).validator(),\n  run({ transactionId, apiKey }) {\n    let stripe;\n    if (!apiKey) {\n      const dynamicApiKey = StripeApi.methods.getApiKey.call();\n      stripe = require(\"stripe\")(dynamicApiKey);\n    } else {\n      stripe = require(\"stripe\")(apiKey);\n    }\n    const refundListPromise = stripe.refunds.list({ charge: transactionId });\n    const refundListResults = Promise.await(refundListPromise);\n    return refundListResults;\n  }\n});\n","import \"./i18n\";\nimport \"./methods/stripe\";\n\nexport * from \"./methods/stripeapi\";\n","/* eslint camelcase: 0 */\nimport { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Stripe\",\n  name: \"reaction-stripe\",\n  icon: \"fa fa-cc-stripe\",\n  autoEnable: true,\n  settings: {\n    \"mode\": false,\n    \"api_key\": \"\",\n    \"reaction-stripe\": {\n      enabled: false,\n      support: [\n        \"Authorize\",\n        \"Capture\",\n        \"Refund\"\n      ]\n    }\n  },\n  registry: [\n    // Settings panel\n    {\n      label: \"Stripe\",\n      provides: \"paymentSettings\",\n      container: \"dashboard\",\n      template: \"stripeSettings\"\n    },\n\n    // Payment form for checkout\n    {\n      template: \"stripePaymentForm\",\n      provides: \"paymentMethod\",\n      icon: \"fa fa-cc-stripe\"\n    }\n  ]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Product Admin\",\n  name: \"reaction-product-admin\",\n  autoEnable: true\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import  \"./populateTaxCodes.js\";\n","import { Meteor } from \"meteor/meteor\";\nimport { TaxCodes } from \"/imports/plugins/core/taxes/lib/collections\";\n\nconst taxCodes = {};\n\n/*\n * taxes/insertTaxCodes\n * @summary populate TaxCodes collection\n * @param {String} shopID - current shop's id\n * @param {Object} code - tax code object to insert into TaxCodes collection\n * @param {String} providerName - tax code provider\n * @return {} undefined\n */\ntaxCodes.populateTaxCodes = function (shopId, code, providerName) {\n  check(shopId, String);\n  check(code, Object);\n  check(providerName, String);\n\n  try {\n    TaxCodes.insert({\n      id: code.id,\n      shopId: shopId,\n      taxCode: code.taxCode || code.id,\n      taxCodeProvider: providerName,\n      ssuta: code.isSSTCertified,\n      title: code.title || \"\",\n      label: code.description || code.label,\n      parent: code.parentTaxCode || code.parent,\n      children: code.children || []\n    });\n  } catch (err) {\n    throw new Meteor.Error(\"Error populating TaxCodes collection\", err);\n  }\n};\n\nMeteor.methods({\n  \"taxes/insertTaxCodes\": taxCodes.populateTaxCodes\n});\n","import \"./i18n\";\nimport \"./methods\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Products\",\n  name: \"reaction-product-variant\",\n  icon: \"fa fa-cubes\",\n  autoEnable: true,\n  registry: [{\n    route: \"/tag/:slug?\",\n    name: \"tag\",\n    template: \"products\",\n    workflow: \"coreProductWorkflow\"\n  }, {\n    route: \"/products/createProduct\",\n    name: \"createProduct\",\n    label: \"Add Product\",\n    icon: \"fa fa-plus\",\n    template: \"productDetail\",\n    provides: \"shortcut\",\n    container: \"addItem\",\n    priority: 1,\n    permissions: [{\n      label: \"Create Product\",\n      permission: \"createProduct\"\n    }]\n  }],\n  layout: [{\n    layout: \"coreLayout\",\n    workflow: \"coreProductWorkflow\",\n    collection: \"Products\",\n    theme: \"default\",\n    enabled: true,\n    structure: {\n      template: \"productDetail\",\n      layoutHeader: \"layoutHeader\",\n      layoutFooter: \"\",\n      notFound: \"productNotFound\",\n      dashboardHeader: \"productDetailSimpleToolbar\",\n      dashboardControls: \"productDetailDashboardControls\",\n      dashboardHeaderControls: \"\",\n      adminControlsFooter: \"adminControlsFooter\"\n    }\n  }, {\n    layout: \"coreLayout\",\n    workflow: \"coreProductGridWorkflow\",\n    collection: \"Products\",\n    theme: \"default\",\n    enabled: true,\n    structure: {\n      template: \"products\",\n      layoutHeader: \"layoutHeader\",\n      layoutFooter: \"\",\n      notFound: \"productNotFound\",\n      dashboardHeader: \"gridPublishControls\",\n      dashboardControls: \"productDetailDashboardControls\",\n      dashboardHeaderControls: \"\",\n      adminControlsFooter: \"adminControlsFooter\"\n    }\n  }]\n});\n","import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Products, ProductSearch, Orders, OrderSearch, Accounts, AccountSearch } from \"/lib/collections\";\nimport { getSearchParameters,\n  buildProductSearchRecord, buildOrderSearchRecord, buildAccountSearchRecord } from \"../methods/searchcollections\";\nimport { Logger } from \"/server/api\";\n\nAccounts.after.insert((userId, doc) => {\n  if (AccountSearch && !Meteor.isAppTest) {\n    buildAccountSearchRecord(doc._id);\n  }\n});\n\nAccounts.after.remove((userId, doc) => {\n  if (AccountSearch && !Meteor.isAppTest) {\n    AccountSearch.remove(doc._id);\n  }\n});\n\nAccounts.after.update((userId, doc) => {\n  if (AccountSearch && !Meteor.isAppTest) {\n    const accountId = doc._id;\n    AccountSearch.remove(accountId);\n    buildAccountSearchRecord(accountId);\n  }\n});\n\n\nOrders.after.remove((userId, doc) => {\n  if (OrderSearch && !Meteor.isAppTest) {\n    OrderSearch.remove(doc._id);\n  }\n});\n\nOrders.after.insert((userId, doc) => {\n  if (OrderSearch && !Meteor.isAppTest) {\n    const orderId = doc._id;\n    buildOrderSearchRecord(orderId);\n  }\n});\n\nOrders.after.update((userId, doc) => {\n  if (OrderSearch && !Meteor.isAppTest) {\n    const orderId = doc._id;\n    OrderSearch.remove(orderId);\n    buildOrderSearchRecord(orderId);\n  }\n});\n\n/**\n * if product is removed, remove product search record\n */\nProducts.after.remove((userId, doc) => {\n  if (ProductSearch && !Meteor.isAppTest && doc.type === \"simple\") {\n    const productId = doc._id;\n    ProductSearch.remove(productId);\n    Logger.debug(`Removed product ${productId} from ProductSearch collection`);\n  }\n});\n\n//\n// after product update rebuild product search record\n//\nProducts.after.update((userId, doc, fieldNames) => {\n  if (ProductSearch && !Meteor.isAppTest && doc.type === \"simple\") {\n    const productId = doc._id;\n    const { fieldSet } = getSearchParameters();\n    const modifiedFields = _.intersection(fieldSet, fieldNames);\n    if (modifiedFields.length) {\n      Logger.debug(`Rewriting search record for ${doc.title}`);\n      ProductSearch.remove(productId);\n      if (!doc.isDeleted) { // do not create record if product was archived\n        buildProductSearchRecord(productId);\n      }\n    } else {\n      Logger.debug(\"No watched fields modified, skipping\");\n    }\n  }\n});\n\n/**\n * after insert\n * @summary should fires on create new variants, on clones products/variants\n */\nProducts.after.insert((userId, doc) => {\n  if (ProductSearch && !Meteor.isAppTest && doc.type === \"simple\") {\n    const productId = doc._id;\n    buildProductSearchRecord(productId);\n    Logger.debug(`Added product ${productId} to ProductSearch`);\n  }\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import { Meteor } from \"meteor/meteor\";\nimport { Jobs, ProductSearch, Orders, OrderSearch, AccountSearch } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\nimport { buildProductSearch, buildOrderSearch, buildAccountSearch,\n  rebuildProductSearchIndex, buildEmptyProductSearch } from \"../methods/\";\n\n\nfunction addBuildProductSearchCollection() {\n  const productSearchCount = ProductSearch.find({}).count();\n  if (!productSearchCount) {\n    Logger.debug(\"No ProductSearch records found. Adding build ProductSearch Collection to jobs\");\n    new Job(Jobs, \"product/buildSearchCollection\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\"\n      })\n      .save({\n        cancelRepeats: true\n      });\n  } else {\n    Logger.debug(\"ProductSearch collection already exists, not building\");\n  }\n}\n\nfunction addBuildOrderSearchCollection() {\n  const orderSearchCount = OrderSearch.find({}).count();\n  const orderCount = Orders.find({}).count();\n  if (!orderSearchCount && orderCount) {\n    Logger.debug(\"No OrderSearch records found. Adding build OrderSearch Collection to jobs\");\n    new Job(Jobs, \"order/buildSearchCollection\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\"\n      })\n      .save({\n        cancelRepeats: true\n      });\n  } else {\n    Logger.debug(\"OrderSearch collection already exists (or no orders), not building\");\n  }\n}\n\nfunction addBuildAccountSearchCollection() {\n  const accountSearchCount = AccountSearch.find({}).count();\n  if (!accountSearchCount) {\n    Logger.debug(\"No AccountSearch records found. Adding build AccountSearch Collection to jobs\");\n    new Job(Jobs, \"account/buildSearchCollection\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\"\n      })\n      .save({\n        cancelRepeats: true\n      });\n  } else {\n    Logger.debug(\"AccountSearch collection already exists, not building\");\n  }\n}\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  if (!Meteor.isAppTest) {\n    buildEmptyProductSearch();\n    addBuildProductSearchCollection();\n    addBuildOrderSearchCollection();\n    addBuildAccountSearchCollection();\n  }\n});\n\n\nexport default function () {\n  Jobs.processJobs(\"product/buildSearchCollection\",\n    {\n      pollInterval: 30 * 1000,\n      workTimeout: 180 * 1000\n    },\n    (job, callback) => {\n      Logger.debug(\"(re)build ProductSearch collection running\");\n      buildProductSearch(function (error) {\n        if (error) {\n          job.done(error.toString(), { repeatId: true });\n          callback();\n        } else {\n          const success = \"ProductSearch collection (re)built successfully.\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n          callback();\n        }\n      });\n    }\n  );\n\n  Jobs.processJobs(\"product/buildSearchIndex\",\n    {\n      pollInterval: 30 * 1000,\n      workTimeout: 180 * 1000\n    },\n    (job, callback) => {\n      Logger.debug(\"(re)build ProductSearch index running\");\n      rebuildProductSearchIndex(function (error) {\n        if (error) {\n          job.done(error.toString(), { repeatId: true });\n          callback();\n        } else {\n          const success = \"ProductSearch Index (re)built successfully.\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n          callback();\n        }\n      });\n    }\n  );\n\n  Jobs.processJobs(\"order/buildSearchCollection\",\n    {\n      pollInterval: 30 * 1000,\n      workTimeout: 180 * 1000\n    },\n    (job, callback) => {\n      Logger.debug(\"(re)build OrderSearch index running\");\n      buildOrderSearch(function (error) {\n        if (error) {\n          job.done(error.toString(), { repeatId: true });\n          callback();\n        } else {\n          const success = \"OrderSearch collection (re)built successfully.\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n          callback();\n        }\n      });\n    }\n  );\n\n  Jobs.processJobs(\"account/buildSearchCollection\",\n    {\n      pollInterval: 30 * 1000,\n      workTimeout: 180 * 1000\n    },\n    (job, callback) => {\n      Logger.debug(\"(re)build AccountSearch index running\");\n      buildAccountSearch(function (error) {\n        if (error) {\n          job.done(error.toString(), { repeatId: true });\n          callback();\n        } else {\n          const success = \"AccountSearch collection (re)built successfully.\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n          callback();\n        }\n      });\n    }\n  );\n}\n","import \"./buildSearchCollections\";\n\nexport * from \"./buildSearchCollections\";\n","import { Reaction } from \"/server/api\";\nimport { Packages } from \"/lib/collections\";\n\nconst utils = {\n  getPackageSettings: function () {\n    const searchPackage = Packages.findOne({\n      shopId: Reaction.getShopId(),\n      name: \"reaction-search\"\n    });\n    return searchPackage.settings;\n  }\n};\n\nexport default utils;\n","import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Job } from \"meteor/vsivsi:job-collection\";\nimport { Packages, Jobs } from \"/lib/collections\";\nimport { CorePackageConfig } from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n\nfunction fieldsChanged(changedFields, fieldType = \"includes\") {\n  for (const field of changedFields) {\n    if (field.indexOf(fieldType) !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction weightsChanged(changedFields) {\n  return fieldsChanged(changedFields, \"weights\");\n}\n\nMeteor.methods({\n  \"search/updateSearchSettings\": function (modifier, _id) {\n    check(modifier, Match.Optional(CorePackageConfig));\n    check(_id, String);\n    const currentSettings = Packages.findOne(_id);\n    const newSettingsArray = _.keys(modifier.$set);\n    const changedSettings = [];\n    for (const setting of newSettingsArray) {\n      const currentSetting = _.get(currentSettings, setting);\n      if (currentSetting !== modifier.$set[setting]) {\n        changedSettings.push(setting);\n      }\n    }\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    let rebuildJob;\n    if (fieldsChanged(changedSettings)) {\n      Logger.debug(\"Fields have changed, we need to rebuild the ProductSearch Collection\");\n      // fields have changed, we need to rebuild entire Product Search Collection\n      rebuildJob = new Job(Jobs, \"product/buildSearchCollection\", {})\n        .priority(\"normal\")\n        .retry({\n          retries: 5,\n          wait: 60000,\n          backoff: \"exponential\" // delay by twice as long for each subsequent retry\n        })\n        .save({\n          // Cancel any jobs of the same type,\n          // but only if this job repeats forever.\n          cancelRepeats: true\n        });\n    } else if (weightsChanged(changedSettings)) {\n      // only weights have changed, we only need to build the index\n      Logger.debug(\"Weights have changed, we need to rebuild the ProductSearch index\");\n      rebuildJob = new Job(Jobs, \"product/buildSearchIndex\", {})\n        .priority(\"normal\")\n        .retry({\n          retries: 5,\n          wait: 60000,\n          backoff: \"exponential\"\n        })\n        .save({\n          // Cancel any jobs of the same type,\n          // but only if this job repeats forever.\n          cancelRepeats: true\n        });\n    }\n    Packages.update(_id, modifier);\n    return rebuildJob;\n  }\n});\n","import \"./searchcollections\";\nimport \"./formHandler\";\n\nexport * from \"./searchcollections\";\n","/* eslint camelcase: 0 */\nimport _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { ProductSearch, OrderSearch, AccountSearch, Orders, Products, Accounts, Shops } from \"/lib/collections\";\nimport utils from \"./common\";\nimport { transformations } from \"./transformations\";\n\n\nconst requiredFields = {};\nrequiredFields.products = [\"_id\", \"hashtags\", \"shopId\", \"handle\", \"price\", \"isVisible\", \"isSoldOut\", \"isLowQuantity\", \"isBackorder\"];\nrequiredFields.orders = [\"_id\", \"shopId\", \"shippingName\", \"shippingPhone\", \"billingName\", \"userEmails\",\n  \"shippingAddress\", \"billingAddress\", \"shippingStatus\", \"billingStatus\", \"orderTotal\", \"orderDate\"];\nrequiredFields.accounts = [\"_id\", \"shopId\", \"emails\", \"profile\"];\n\n// https://docs.mongodb.com/manual/reference/text-search-languages/#text-search-languages\n// MongoDb supports a subset of languages for analysis of the text data which includes\n// things like stop words and stems. With this language support the quality of the search matches\n// and weighting increases, however without this search will still work and delivery good results.\n// We currently support the languages which are supported by Mongo by default but more languages\n// are available through custom configuration.\nconst supportedLanguages = [\"da\", \"nl\", \"en\", \"fi\", \"fr\", \"de\", \"hu\", \"it\", \"nb\", \"pt\", \"ro\", \"ru\", \"es\", \"sv\", \"tr\"];\n\n\nfunction filterFields(customFields) {\n  const fieldNames = [];\n  const fieldKeys = _.keys(customFields);\n  for (const fieldKey of fieldKeys) {\n    if (customFields[fieldKey]) {\n      fieldNames.push(fieldKey);\n    }\n  }\n  return fieldNames;\n}\n\n// get the weights for all enabled fields\nfunction getScores(customFields, settings, collection = \"products\") {\n  const weightObject = {};\n  for (const weight of _.keys(settings[collection].weights)) {\n    if (_.includes(customFields, weight)) {\n      weightObject[weight] = settings[collection].weights[weight];\n    }\n  }\n  return weightObject;\n}\n\nfunction getSearchLanguage() {\n  const shopId = Reaction.getShopId();\n  const shopLanguage = Shops.findOne(shopId).language;\n  if (_.includes(supportedLanguages, shopLanguage)) {\n    return { default_language: shopLanguage };\n  }\n  return { default_language: \"en\" };\n}\n\nexport function getSearchParameters(collection = \"products\") {\n  const settings = utils.getPackageSettings();\n  const customFields = filterFields(settings[collection].includes);\n  const fieldSet = requiredFields[collection].concat(customFields);\n  const weightObject = getScores(customFields, settings);\n  return { fieldSet: fieldSet, weightObject: weightObject, customFields: customFields };\n}\n\nexport function buildProductSearchRecord(productId) {\n  const product = Products.findOne(productId);\n  if (product.type === \"simple\") {\n    const { fieldSet } = getSearchParameters();\n    const productRecord = {};\n    for (const field of fieldSet) {\n      if (transformations.products[field]) {\n        productRecord[field] = transformations.products[field](product[field]);\n      } else {\n        productRecord[field] = product[field];\n      }\n    }\n    const productSearchRecord = ProductSearch.insert(productRecord);\n    ensureProductSearchIndex();\n    return productSearchRecord;\n  }\n  return undefined;\n}\n\nexport function buildProductSearch(cb) {\n  check(cb, Match.Optional(Function));\n  Logger.debug(\"Start (re)Building ProductSearch Collection\");\n  ProductSearch.remove({});\n  const { fieldSet, weightObject, customFields } = getSearchParameters();\n  const products = Products.find({ type: \"simple\" }).fetch();\n  for (const product of products) {\n    const productRecord = {};\n    for (const field of fieldSet) {\n      if (transformations.products[field]) {\n        productRecord[field] = transformations.products[field](product[field]);\n      } else {\n        productRecord[field] = product[field];\n      }\n    }\n    ProductSearch.insert(productRecord);\n  }\n  const indexObject = {};\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.dropIndexes(\"*\");\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage());\n  if (cb) {\n    cb();\n  }\n}\n\n// we build this immediately on startup so that search will not throw an error\nexport function buildEmptyProductSearch() {\n  const { weightObject, customFields } = getSearchParameters();\n  const indexObject = {};\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.dropIndexes(\"*\");\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage());\n}\n\nexport function rebuildProductSearchIndex(cb) {\n  check(cb, Match.Optional(Function));\n  const { customFields, weightObject } = getSearchParameters();\n  const indexObject = {};\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.dropIndexes(\"*\");\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage());\n  if (cb) {\n    cb();\n  }\n}\n\n// this only creates the index if it doesn't already exist, `ensureIndex` is deprecated\nexport function ensureProductSearchIndex() {\n  const { customFields, weightObject } = getSearchParameters();\n  const indexObject = {};\n  for (const field of customFields) {\n    indexObject[field] = \"text\";\n  }\n  const rawProductSearchCollection = ProductSearch.rawCollection();\n  rawProductSearchCollection.createIndex(indexObject, weightObject, getSearchLanguage());\n}\n\nexport function buildOrderSearchRecord(orderId) {\n  const order = Orders.findOne(orderId);\n  const user = Meteor.users.findOne(order.userId);\n  const userEmails = [];\n  if (user) {\n    for (const email of user.emails) {\n      userEmails.push(email.address);\n    }\n  }\n  const orderSearch = {};\n  for (const field of requiredFields.orders) {\n    if (transformations.orders[field]) {\n      orderSearch[field] = transformations.orders[field](order[field]);\n    } else {\n      orderSearch[field] = order[field];\n    }\n  }\n  orderSearch.billingName = order.billing[0].address.fullName;\n  orderSearch.billingPhone = _.replace(order.billing[0].address.phone, /\\D/g, \"\");\n  orderSearch.shippingName = order.shipping[0].address.fullName;\n  orderSearch.shippingPhone = _.replace(order.shipping[0].address.phone, /\\D/g, \"\");\n  orderSearch.billingAddress = {\n    address: order.billing[0].address.address1,\n    postal: order.billing[0].address.postal,\n    city: order.billing[0].address.city,\n    region: order.billing[0].address.region,\n    country: order.billing[0].address.country\n  };\n  orderSearch.shippingAddress = {\n    address: order.shipping[0].address.address1,\n    postal: order.shipping[0].address.postal,\n    city: order.shipping[0].address.city,\n    region: order.shipping[0].address.region,\n    country: order.shipping[0].address.country\n  };\n  orderSearch.userEmails = userEmails;\n  orderSearch.orderTotal = order.billing[0].invoice.total;\n  orderSearch.orderDate = moment(order.createdAt).format(\"YYYY/MM/DD\");\n  orderSearch.billingStatus = order.billing[0].paymentMethod.status;\n  if (order.shipping[0].shipped) {\n    orderSearch.shippingStatus = \"Shipped\";\n  } else if (order.shipping[0].packed) {\n    orderSearch.shippingStatus = \"Packed\";\n  } else {\n    orderSearch.shippingStatus = \"New\";\n  }\n  OrderSearch.insert(orderSearch);\n}\n\nexport function buildOrderSearch(cb) {\n  check(cb, Match.Optional(Function));\n  const orders = Orders.find({}).fetch();\n  for (const order of orders) {\n    buildOrderSearchRecord(order._id);\n  }\n  const rawOrderSearchCollection = OrderSearch.rawCollection();\n  rawOrderSearchCollection.dropIndexes(\"*\");\n  rawOrderSearchCollection.createIndex({ shopId: 1, shippingName: 1, billingName: 1, userEmails: 1 });\n  if (cb) {\n    cb();\n  }\n}\n\n\nexport function buildAccountSearch(cb) {\n  check(cb, Match.Optional(Function));\n  AccountSearch.remove({});\n  const accounts = Accounts.find({}).fetch();\n  for (const account of accounts) {\n    buildAccountSearchRecord(account._id);\n  }\n  const rawAccountSearchCollection = AccountSearch.rawCollection();\n  rawAccountSearchCollection.dropIndexes(\"*\");\n  rawAccountSearchCollection.createIndex({ shopId: 1, emails: 1 });\n  if (cb) {\n    cb();\n  }\n}\n\nexport function buildAccountSearchRecord(accountId) {\n  Logger.debug(\"building account search record\");\n  check(accountId, String);\n  const account = Accounts.findOne(accountId);\n  // let's ignore anonymous accounts\n  if (account.emails.length) {\n    const accountSearch = {};\n    for (const field of requiredFields.accounts) {\n      if (transformations.accounts[field]) {\n        accountSearch[field] = transformations.accounts[field](account[field]);\n      } else {\n        accountSearch[field] = account[field];\n      }\n    }\n    AccountSearch.insert(accountSearch);\n    const rawAccountSearchCollection = AccountSearch.rawCollection();\n    rawAccountSearchCollection.createIndex({ shopId: 1, emails: 1 });\n  }\n}\n","import _ from \"lodash\";\n\nexport const transformations = {};\ntransformations.products = {};\ntransformations.accounts = {};\ntransformations.orders = {};\n\ntransformations.products.metafields = function (fieldData) {\n  const values = [];\n  if (fieldData) {\n    for (const field of fieldData) {\n      values.push(field.value);\n    }\n  }\n  return values;\n};\n\ntransformations.accounts.emails = function (fieldData) {\n  const values = [];\n  if (fieldData) {\n    for (const email of fieldData) {\n      values.push(email.address);\n    }\n  }\n  return values;\n};\n\ntransformations.accounts.profile = function (fieldData) {\n  let profileObject;\n  if (fieldData && fieldData.addressBook && fieldData.addressBook[0] && fieldData.addressBook[0].fullName) {\n    profileObject = {\n      firstName: _.split(fieldData.addressBook[0].fullName, \" \")[0],\n      lastName: _.split(fieldData.addressBook[0].fullName, \" \")[1],\n      phone: _.replace(fieldData.addressBook[0].phone, /\\D/g, \"\")\n    };\n  }\n  return profileObject;\n};\n","import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { ProductSearch, OrderSearch, AccountSearch } from \"/lib/collections\";\n\nconst supportedCollections = [\"products\", \"orders\", \"accounts\"];\n\nfunction getProductFindTerm(searchTerm, searchTags, userId) {\n  const shopId = Reaction.getShopId();\n  const findTerm = {\n    shopId: shopId,\n    $text: { $search: searchTerm }\n  };\n  if (searchTags.length) {\n    findTerm.hashtags = { $all: searchTags };\n  }\n  if (!Roles.userIsInRole(userId, [\"admin\", \"owner\"], shopId)) {\n    findTerm.isVisible = true;\n  }\n  return findTerm;\n}\n\nexport const getResults = {};\n\ngetResults.products = function (searchTerm, facets, maxResults, userId) {\n  const searchTags = facets || [];\n  const findTerm = getProductFindTerm(searchTerm, searchTags, userId);\n  const productResults = ProductSearch.find(findTerm,\n    {\n      fields: {\n        score: { $meta: \"textScore\" },\n        title: 1,\n        hashtags: 1,\n        description: 1,\n        handle: 1,\n        price: 1,\n        isSoldOut: 1,\n        isLowQuantity: 1,\n        isBackorder: 1\n      },\n      sort: { score: { $meta: \"textScore\" } },\n      limit: maxResults\n    }\n  );\n  return productResults;\n};\n\ngetResults.orders = function (searchTerm, facets, maxResults, userId) {\n  let orderResults;\n  const searchPhone = _.replace(searchTerm, /\\D/g, \"\");\n  const shopId = Reaction.getShopId();\n  const findTerm = {\n    $and: [\n      { shopId: shopId },\n      { $or: [\n        { _id: searchTerm },\n        { userEmails: {\n          $regex: searchTerm,\n          $options: \"i\"\n        } },\n        { shippingName: {\n          $regex: searchTerm,\n          $options: \"i\"\n        } },\n        { billingName: {\n          $regex: searchTerm,\n          $options: \"i\"\n        } },\n        { billingPhone: {\n          $regex: \"^\" + searchPhone + \"$\",\n          $options: \"i\"\n        } },\n        { shippingPhone: {\n          $regex: \"^\" + searchPhone + \"$\",\n          $options: \"i\"\n        } }\n      ] }\n    ] };\n  if (Reaction.hasPermission(\"orders\", userId)) {\n    orderResults = OrderSearch.find(findTerm, { limit: maxResults });\n    Logger.debug(`Found ${orderResults.count()} orders searching for ${searchTerm}`);\n  }\n  return orderResults;\n};\n\ngetResults.accounts = function (searchTerm, facets, maxResults, userId) {\n  let accountResults;\n  const shopId = Reaction.getShopId();\n  const searchPhone = _.replace(searchTerm, /\\D/g, \"\");\n  if (Reaction.hasPermission(\"reaction-accounts\", userId)) {\n    const findTerm = {\n      $and: [\n        { shopId: shopId },\n        { $or: [\n          { emails: {\n            $regex: searchTerm,\n            $options: \"i\"\n          } },\n          { \"profile.firstName\": {\n            $regex: \"^\" + searchTerm + \"$\",\n            $options: \"i\"\n          } },\n          { \"profile.lastName\": {\n            $regex: \"^\" + searchTerm + \"$\",\n            $options: \"i\"\n          } },\n          { \"profile.phone\": {\n            $regex: \"^\" + searchPhone + \"$\",\n            $options: \"i\"\n          } }\n        ] }\n      ] };\n    accountResults = AccountSearch.find(findTerm, {\n      limit: maxResults\n    });\n    Logger.debug(`Found ${accountResults.count()} accounts searching for ${searchTerm}`);\n  }\n  return accountResults;\n};\n\nMeteor.publish(\"SearchResults\", function (collection, searchTerm, facets, maxResults = 99) {\n  check(collection, String);\n  check(collection, Match.Where((coll) => {\n    return _.includes(supportedCollections, coll);\n  }));\n  check(searchTerm, Match.Optional(String));\n  check(facets, Match.OneOf(Array, undefined));\n  Logger.debug(`Returning search results on ${collection}. SearchTerm: |${searchTerm}|. Facets: |${facets}|.`);\n  if (!searchTerm) {\n    return this.ready();\n  }\n  return getResults[collection](searchTerm, facets, maxResults, this.userId);\n});\n","import \"./publications/searchresults\";\nimport \"./hooks/search\";\nimport \"./jobs\";\nimport buildSearchCollectionJob from \"./jobs/buildSearchCollections\";\nimport \"./i18n\";\n\nexport * from \"./publications/searchresults\";\n\nbuildSearchCollectionJob();\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Search\",\n  name: \"reaction-search\",\n  icon: \"fa fa-search\",\n  autoEnable: true,\n  settings: {\n    products: {\n      includes: {\n        title: true,\n        description: true,\n        pageTitle: false,\n        metafields: true,\n        vendor: true\n      },\n      weights: {\n        title: 10,\n        description: 5,\n        pageTitle: 3,\n        metafields: 1,\n        vendor: 4\n      }\n    }\n  },\n  registry: [\n    // Dashboard card\n    {\n      provides: \"dashboard\",\n      label: \"Search\",\n      description: \"Search\",\n      icon: \"fa fa-search\",\n      priority: 2,\n      container: \"core\"\n    },\n    // Settings Panel\n    {\n      label: \"Search Settings\",\n      icon: \"fa fa-search\",\n      route: \"/dashboard/search\",\n      provides: \"settings\",\n      container: \"dashboard\",\n      template: \"searchSettings\"\n    }\n  ]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./sms\";\n","import Twilio from \"twilio\";\nimport Nexmo from \"nexmo\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Sms, Accounts } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\n\n\n/**\n * Sms Methods\n */\nMeteor.methods({\n  /**\n   * sms/saveSettings\n   * @summary This save the sms provider settings\n   * @param {Object} settings - settings\n   * @return {object} returns result\n   */\n  \"sms/saveSettings\": (settings) => {\n    check(settings, Object);\n    settings.shopId = Reaction.getShopId();\n\n    const smsDetails = Sms.find().count();\n    if (smsDetails >= 1) {\n      return Sms.update({ shopId: Reaction.getShopId() }, {\n        $set: settings\n      });\n    }\n    return Sms.insert(settings);\n  },\n\n  /**\n   * sms/send\n   * @summary This send the sms to the user\n   * @param {String} message - The message to send\n   * @param {String} userId - The user to receive the message\n   * @param {String} shopId - The currenct shopId\n   * @return {object} returns result\n   */\n  \"sms/send\": (message, userId, shopId) => {\n    check(message, String);\n    check(userId, String);\n    check(shopId, String);\n\n    const user = Accounts.findOne();\n    const addressBook = user.profile.addressBook;\n    let phone = false;\n    // check for addressBook phone\n    if (user && addressBook) {\n      if (addressBook[0].phone) {\n        phone = addressBook[0].phone;\n      }\n    }\n\n    if (phone) {\n      const smsSettings = Sms.findOne();\n\n      if (smsSettings) {\n        const { apiKey, apiToken, smsPhone, smsProvider } = smsSettings;\n        if (smsProvider === \"twilio\") {\n          Logger.debug(\"choose twilio\");\n          const client = new Twilio(apiKey, apiToken);\n\n          client.sendMessage({\n            to: phone,\n            from: smsPhone,\n            body: message\n          }, (err) => {\n            if (err) {\n              return Logger.error(err);\n            }\n          });\n          return;\n        }\n        if (smsProvider === \"nexmo\") {\n          Logger.debug(\"choose nexmo\");\n          const client = new Nexmo({\n            apiKey,\n            apiSecret: apiToken\n          });\n          client.message.sendSms(smsPhone, phone, message, {}, (err) => {\n            if (err) {\n              return Logger.error(err);\n            }\n          });\n        }\n      }\n    }\n  }\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { Sms } from \"/lib/collections\";\n\n/**\n * Sms publication\n * @return {Object} return sms cursor\n */\nMeteor.publish(\"SmsSettings\", function () {\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    Logger.warn(\"Ignoring null request on Sms Subscription\");\n    return this.ready();\n  }\n\n  const result = Sms.find({ shopId });\n\n  return result;\n});\n","import \"./publications/smsPublication\";\nimport \"./methods\";\nimport \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"SMS\",\n  name: \"reaction-sms\",\n  icon: \"fa fa-mobile\",\n  autoEnable: true,\n  settings: {\n    name: \"SMS\"\n  },\n  registry: [{\n    provides: \"dashboard\",\n    label: \"SMS\",\n    description: \"Notifications\",\n    icon: \"fa fa-mobile fa-2x\",\n    priority: 3,\n    container: \"core\",\n    workflow: \"coreDashboardWorkflow\"\n  }, {\n    label: \"SMS Settings\",\n    icon: \"fa fa-mobile\",\n    route: \"/dashboard/sms\",\n    provides: \"settings\",\n    container: \"dashboard\",\n    template: \"smsSettings\"\n  }]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./policy\";\nimport \"./i18n\";\nimport \"./methods\";\n","import { check, Match } from \"meteor/check\";\nimport { Packages } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nexport function updateSocialSetting(provider, field, value) {\n  check(provider, String);\n  check(field, String);\n  check(value, Match.OneOf(String, Boolean));\n\n  if (!Reaction.hasPermission([\"reaction-social\"])) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  }\n\n  return Packages.update({\n    name: \"reaction-social\",\n    shopId: Reaction.getShopId()\n  }, {\n    $set: {\n      [`settings.public.apps.${provider}.${field}`]: value\n    }\n  });\n}\n\nexport function updateSocialSettings(values) {\n  check(values, Match.OneOf(Object, String, Boolean, Number, null, undefined));\n\n  if (!Reaction.hasPermission([\"reaction-social\"])) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  }\n\n  return Packages.update({\n    name: \"reaction-social\",\n    shopId: Reaction.getShopId()\n  }, {\n    $set: {\n      settings: values\n    }\n  });\n}\n\nMeteor.methods({\n  \"reaction-social/updateSocialSetting\": updateSocialSetting,\n  \"reaction-social/updateSocialSettings\": updateSocialSettings\n});\n","import { BrowserPolicy } from \"meteor/browser-policy-common\";\n/*\n * set browser policies\n */\nBrowserPolicy.content.allowOriginForAll(\"*.facebook.com\");\n\nBrowserPolicy.content.allowOriginForAll(\"connect.facebook.net\");\n","import { Reaction } from \"/server/api\";\n\nconst DefaultSocialApp = {\n  profilePage: \"\",\n  enabled: false\n};\n\nReaction.registerPackage({\n  label: \"Social\",\n  name: \"reaction-social\",\n  icon: \"fa fa-share-alt\",\n  autoEnable: true,\n  settings: {\n    public: {\n      autoInit: true,\n      apps: {\n        facebook: _.extend({\n          appId: \"\",\n          version: \"v2.1\"\n        }, DefaultSocialApp),\n        twitter: _.extend({\n          username: \"\"\n        }, DefaultSocialApp),\n        googleplus: _.extend({}, DefaultSocialApp),\n        pinterest: _.extend({}, DefaultSocialApp)\n      },\n      appsOrder: [\"facebook\", \"twitter\", \"pinterest\", \"googleplus\"],\n      iconOnly: true,\n      faSize: \"fa-2x\",\n      faClass: \"square\",\n      targetWindow: \"_self\"\n    }\n  },\n  registry: [{\n    provides: \"dashboard\",\n    label: \"Social\",\n    description: \"Social Channel configuration\",\n    icon: \"fa fa-share-alt\",\n    priority: 2,\n    container: \"connect\",\n    permissions: [{\n      label: \"Social\",\n      permission: \"dashboard/social\"\n    }]\n  }, {\n    label: \"Social Settings\",\n    icon: \"fa fa-share-alt\",\n    route: \"/dashboard/social\",\n    provides: \"settings\",\n    container: \"dashboard\",\n    template: \"socialSettings\"\n  }, {\n    template: \"reactionSocial\",\n    provides: \"social\"\n  }]\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Logger, MethodHooks } from \"/server/api\";\nimport { Cart, Orders } from \"/lib/collections\";\nimport taxCalc from \"../methods/taxCalc\";\n\nfunction linesToTaxes(lines) {\n  const taxes = lines.map((line) => {\n    return {\n      lineNumber: line.lineNumber,\n      discountAmount: line.discountAmount,\n      taxable: line.isItemTaxable,\n      tax: line.tax,\n      taxableAmount: line.taxableAmount,\n      taxCode: line.taxCode,\n      details: line.details\n    };\n  });\n  return taxes;\n}\n\n\nMethodHooks.after(\"taxes/calculate\", (options) => {\n  const cartId = options.arguments[0];\n  const cartToCalc = Cart.findOne(cartId);\n  const pkg = taxCalc.getPackageData();\n\n  Logger.debug(\"Avalara triggered on taxes/calculate for cartId:\", cartId);\n  // console.log(pkg, \"package in hook\");\n  if (pkg && pkg.settings.avalara.enabled && pkg.settings.avalara.performTaxCalculation) {\n    taxCalc.estimateCart(cartToCalc, function (result) {\n      // we don't use totalTax, that just tells us we have a valid tax calculation\n      if (result && result.totalTax && typeof result.totalTax === \"number\" && result.lines) {\n        const taxes = linesToTaxes(result.lines);\n        const taxAmount = taxes.reduce((totalTaxes, tax) => totalTaxes + tax.tax, 0);\n        const taxRate = taxAmount / taxCalc.calcTaxable(cartToCalc);\n        Meteor.call(\"taxes/setRate\", cartId, taxRate, taxes);\n      }\n    });\n  }\n  return options;\n});\n\nMethodHooks.after(\"cart/copyCartToOrder\", (options) => {\n  const pkg = taxCalc.getPackageData();\n  if (pkg && pkg.settings.avalara.enabled && pkg.settings.avalara.performTaxCalculation) {\n    const cartId = options.arguments[0];\n    const order = Orders.findOne({ cartId: cartId });\n    taxCalc.recordOrder(order, function (result) {\n      if (result) {\n        Logger.info(`Order ${order._id} recorded with Avalara`);\n      }\n    });\n  }\n  return options;\n});\n\nMethodHooks.after(\"orders/refunds/create\", (options) => {\n  const pkg = taxCalc.getPackageData();\n  if (pkg && pkg.settings.avalara.enabled && pkg.settings.avalara.performTaxCalculation) {\n    const orderId = options.arguments[0];\n    const order = Orders.findOne(orderId);\n    const refundAmount = options.arguments[2];\n    taxCalc.reportRefund(order, refundAmount, function (result) {\n      if (result) {\n        Logger.info(`Refund for order ${order._id} recorded with Avalara`);\n      }\n    });\n  }\n  return options;\n});\n","import \"./hooks\";\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import moment from \"moment\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Jobs, Logs } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\nimport taxCalc from \"../methods/taxCalc\";\n\n\n/**\n * @summary Remove logs older than the configured number of days\n * @param {Function} callback - function to call when process complete\n * @returns {Number} results of remmoval query\n */\nfunction cleanupAvalaraJobs(callback) {\n  const pkgData = taxCalc.getPackageData();\n  if (pkgData && pkgData.settings.avalara.enabled) {\n    const saveDuration = pkgData.settings.avalara.logRetentionDuration;\n    const olderThan = moment().subtract(saveDuration, \"days\");\n    const result = Logs.remove({\n      date: {\n        $lt: olderThan\n      }\n    });\n    Logger.debug(`Removed ${result} Avalara log records`);\n  }\n  callback();\n}\n\n\nHooks.Events.add(\"afterCoreInit\", () => {\n  if (!Meteor.isAppTest) {\n    Logger.debug(\"Adding Avalara log cleanup job and removing existing\");\n    // Renove all previous jobs\n    Jobs.remove({ type: \"logs/removeOldAvalaraLogs\" });\n    new Job(Jobs, \"logs/removeOldAvalaraLogs\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\"\n      })\n      .save({\n        cancelRepeats: true\n      });\n  }\n});\n\n\nexport default function () {\n  Jobs.processJobs(\"logs/removeOldAvalaraLogs\",\n    {\n      pollInterval: 30 * 1000,\n      workTimeout: 180 * 1000\n    },\n    (job, callback) => {\n      Logger.debug(\"Avalara log cleanup running\");\n      cleanupAvalaraJobs(function (error) {\n        if (error) {\n          job.done(error.toString(), { repeatId: true });\n          callback();\n        } else {\n          const success = \"Avalara Log Cleanup ran successfully\";\n          Logger.debug(success);\n          job.done(success, { repeatId: true });\n          callback();\n        }\n      });\n    }\n  );\n}\n","import bunyan from \"bunyan\";\nimport { Logs } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nconst level = \"INFO\";\n\nclass BunyanMongo {\n\n  levelToName = {\n    10: \"trace\",\n    20: \"debug\",\n    30: \"info\",\n    40: \"warn\",\n    50: \"error\",\n    60: \"fatal\"\n  };\n\n  write = Meteor.bindEnvironment((logData) => {\n    const avalog = {\n      logType: \"avalara\",\n      shopId: Reaction.getShopId(),\n      data: logData,\n      level: this.levelToName[logData.level]\n    };\n    Logs.insert(avalog);\n  });\n}\n\nconst streams = [\n  {\n    type: \"raw\",\n    stream: new BunyanMongo()\n  }\n];\n\n\nconst Avalogger = bunyan.createLogger({\n  level,\n  name: \"Avalara\",\n  streams\n});\n\nexport default Avalogger;\n","import _ from \"lodash\";\nimport accounting from \"accounting-js\";\nimport os from \"os\";\nimport moment from \"moment\";\nimport { Meteor } from \"meteor/meteor\";\nimport { HTTP } from \"meteor/http\";\nimport { check } from \"meteor/check\";\nimport { Packages, Shops, Accounts } from \"/lib/collections\";\nimport { TaxCodes } from \"/imports/plugins/core/taxes/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\nimport Avalogger from \"./avalogger\";\n\nconst countriesWithRegions = [\"US\", \"CA\", \"DE\", \"AU\"];\nconst requiredFields = [\"username\", \"password\", \"apiLoginId\", \"companyCode\", \"shippingTaxCode\"];\nconst taxCalc = {};\n\ntaxCalc.getPackageData = function () {\n  const pkgData = Packages.findOne({\n    name: \"taxes-avalara\",\n    shopId: Reaction.getShopId(),\n    enabled: true\n  });\n  return pkgData;\n};\n\n// Private methods\n\n/**\n * @summary Get the root URL for REST calls\n * @returns {String} Base url\n */\nfunction getUrl() {\n  const packageData = taxCalc.getPackageData();\n  const { productionMode } = packageData.settings.avalara;\n  let baseUrl;\n  if (!productionMode) {\n    baseUrl = \"https://sandbox-rest.avatax.com/api/v2/\";\n  } else {\n    baseUrl = \"https://rest.avatax.com\";\n  }\n  return baseUrl;\n}\n\n/**\n * @summary Verify that we have all required configuration data before attempting to use the API\n * @param {Object} packageData - Package data retrieved from the database\n * @returns {boolean} - isValid Is the current configuration valid\n */\nfunction checkConfiguration(packageData = taxCalc.getPackageData()) {\n  let isValid = true;\n  const settings = _.get(packageData, \"settings.avalara\", {});\n  for (const field of requiredFields) {\n    if (!settings[field]) {\n      const msg = `The Avalara package cannot function unless ${field} is configured`;\n      Logger.warn(msg);\n      Avalogger.error({ error: msg });\n      isValid = false;\n    }\n  }\n  if (!isValid) {\n    throw new Meteor.Error(\"The Avalara package is not configured correctly. Cannot continue\");\n  }\n  return isValid;\n}\n\n/**\n * @summary Get the auth info to authenticate to REST API\n * @param {Object} packageData - Optionally pass in packageData if we already have it\n * @returns {String} Username/Password string\n */\nfunction getAuthData(packageData = taxCalc.getPackageData()) {\n  if (checkConfiguration(packageData)) {\n    const settings = _.get(packageData, \"settings.avalara\", {});\n    const { username, password } = settings;\n    const auth = `${username}:${password}`;\n    return auth;\n  }\n}\n\n/**\n * @summary Get exempt tax settings to pass to REST API\n * @param {String} userId id of user to find settings\n * @returns {Object} containing exemptCode and customerUsageType\n */\nfunction getTaxSettings(userId) {\n  return _.get(Accounts.findOne({ _id: userId }), \"taxSettings\");\n}\n\n/**\n * @summary function to get HTTP data and pass in extra Avalara-specific headers\n * @param {String} requestUrl - The URL to make the request to\n * @param {Object} options - An object of other options\n * @param {Boolean} testCredentials - determines skipping of configuration check\n * @returns {Object} Response from call\n */\nfunction avaGet(requestUrl, options = {}, testCredentials = true) {\n  const logObject = {};\n  const pkgData = taxCalc.getPackageData();\n\n  if (testCredentials) {\n    if (!checkConfiguration(pkgData)) {\n      return undefined;\n    }\n  }\n\n  const appVersion = Reaction.getAppVersion();\n  const meteorVersion = _.split(Meteor.release, \"@\")[1];\n  const machineName = os.hostname();\n  const avaClient = `Reaction; ${appVersion}; Meteor HTTP; ${meteorVersion}; ${machineName}`;\n  const headers = {\n    headers: {\n      \"X-Avalara-Client\": avaClient,\n      \"X-Avalara-UID\": \"a0o33000004K8g3\"\n    }\n  };\n  const auth = options.auth || getAuthData();\n  const timeout = { timeout: options.timeout || pkgData.settings.avalara.requestTimeout };\n  const allOptions = Object.assign({}, options, headers, { auth }, timeout);\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.request = allOptions;\n  }\n\n  try {\n    result = HTTP.get(requestUrl, allOptions);\n  } catch (error) {\n    result = error;\n    Logger.error(`Encountered error while calling Avalara API endpoint ${requestUrl}`);\n    Logger.error(error);\n    logObject.error = error;\n    Avalogger.error(logObject);\n  }\n\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.duration = _.get(result, \"headers.serverDuration\");\n    logObject.result = result.data;\n    Avalogger.info(logObject);\n  }\n\n  return result;\n}\n\n\n/**\n * @summary to POST HTTP data and pass in extra Avalara-specific headers\n * @param {String} requestUrl - The URL to make the request to\n * @param {Object} options - An object of others options, usually data\n * @returns {Object} Response from call\n */\nfunction avaPost(requestUrl, options) {\n  const logObject = {};\n  const pkgData = taxCalc.getPackageData();\n  const appVersion = Reaction.getAppVersion();\n  const meteorVersion = _.split(Meteor.release, \"@\")[1];\n  const machineName = os.hostname();\n  const avaClient = `Reaction; ${appVersion}; Meteor HTTP; ${meteorVersion}; ${machineName}`;\n  const headers = {\n    headers: {\n      \"X-Avalara-Client\": avaClient,\n      \"X-Avalara-UID\": \"a0o33000004K8g3\"\n    }\n  };\n  const auth = { auth: getAuthData() };\n  const timeout = { timeout: pkgData.settings.avalara.requestTimeout };\n  const allOptions = Object.assign({}, options, headers, auth, timeout);\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.request = allOptions;\n  }\n\n  let result;\n\n  try {\n    result = HTTP.post(requestUrl, allOptions);\n  } catch (error) {\n    Logger.error(`Encountered error while calling API at ${requestUrl}`);\n    Logger.error(error);\n    logObject.error = error;\n    // whether logging is enabled or not we log out errors\n    Avalogger.error(logObject);\n    result = {};\n  }\n\n  if (pkgData.settings.avalara.enableLogging) {\n    logObject.duration = _.get(result, \"headers.serverDuration\");\n    logObject.result = result.data;\n    Avalogger.info(logObject);\n  }\n\n  return result;\n}\n\n/**\n * @summary Gets the full list of Avalara-supported entity use codes.\n * @returns {Object[]} API response\n */\ntaxCalc.getEntityCodes = function () {\n  if (checkConfiguration()) {\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}definitions/entityusecodes`;\n    const result = avaGet(requestUrl);\n\n    if (result && result.code === \"ETIMEDOUT\") {\n      throw new Meteor.Error(\"Request timed out while populating entity codes.\");\n    }\n\n    return _.get(result, \"data.value\", []);\n  }\n  throw new Meteor.Error(\"bad-configuration\", \"Avalara package is enabled, but is not properly configured\");\n};\n\n// API Methods\n\n/**\n * @summary Calculate the taxable subtotal for a cart\n * @param {Cart} cart - Cart to calculate subtotal for\n * @returns {Number} Taxable subtotal\n */\ntaxCalc.calcTaxable = function (cart) {\n  let subTotal = 0;\n  for (const item of cart.items) {\n    if (item.variants.taxable) {\n      subTotal += (item.variants.price * item.quantity);\n    }\n  }\n  return subTotal;\n};\n\n/**\n * @summary Validate a particular address\n * @param {Object} address Address to validate\n * @returns {Object} The validated result\n */\ntaxCalc.validateAddress = function (address) {\n  check(address, Object);\n\n  const packageData = taxCalc.getPackageData();\n  const { countryList } = packageData.settings.addressValidation;\n\n  if (!_.includes(countryList, address.country)) {\n    // if this is a country selected for validation, proceed\n    // else use current address as response\n    return { validatedAddress: address, errors: [] };\n  }\n\n  let messages;\n  let validatedAddress = \"\"; // set default as falsy value\n  const errors = [];\n  const addressToValidate  = {\n    line1: address.address1,\n    city: address.city,\n    postalCode: address.postal,\n    country: address.country\n  };\n\n  if (_.includes(countriesWithRegions, address.country)) {\n    // if this is a country with regions, pass in region\n    addressToValidate.region = address.region;\n  }\n  if (address.line2) {\n    addressToValidate.line2 = address.address2;\n  }\n  const baseUrl = getUrl();\n  const requestUrl = `${baseUrl}addresses/resolve`;\n  const result = avaPost(requestUrl, { data: addressToValidate });\n  let content;\n\n  try {\n    content = JSON.parse(result.content);\n  } catch (error) {\n    content = result.content;\n  }\n  if (content && content.messages) {\n    messages = content.messages;\n  }\n  if (messages) {\n    for (const message of messages) {\n      errors.push({ summary: message.summary, details: message.details });\n    }\n  }\n\n  if (result && result.data && result.data.validatedAddresses.length !== 0) {\n    const resultAddress = result.data.validatedAddresses[0];\n    validatedAddress = {\n      address1: resultAddress.line1,\n      city: resultAddress.city,\n      region: resultAddress.region,\n      postal: resultAddress.postalCode,\n      country: resultAddress.country\n    };\n    if (result.data.address.line2) {\n      validatedAddress.addresss2 = resultAddress.line2;\n    }\n  }\n  return { validatedAddress, errors };\n};\n\n/**\n * @summary Tests supplied Avalara credentials by calling company endpoint\n * @param {Object} credentials callback Callback function for asynchronous execution\n * @param {Boolean} testCredentials To be set as false so avaGet skips config check\n * @returns {Object} Object containing \"statusCode\" on success, empty response on error\n */\ntaxCalc.testCredentials = function (credentials, testCredentials = false) {\n  check(credentials, Object);\n\n  const baseUrl = getUrl();\n  const auth = `${credentials.username}:${credentials.password}`;\n  const requestUrl = `${baseUrl}companies/${credentials.companyCode}/transactions`;\n  const result = avaGet(requestUrl, { auth, timeout: credentials.requestTimeout }, testCredentials);\n\n  if (result && result.code === \"ETIMEDOUT\") {\n    throw new Meteor.Error(\"Request Timed out. Increase your timeout settings\");\n  }\n\n  if (result.statusCode === 200) {\n    if (TaxCodes.find({}).count() === 0) {\n      Meteor.call(\"avalara/getTaxCodes\", (error, res) => {\n        if (error) {\n          if (typeof error === \"object\") {\n            Meteor.call(\"logging/logError\", \"avalara\",  error);\n          } else {\n            Meteor.call(\"logging/logError\", \"avalara\",  { error });\n          }\n        } else if (res && Array.isArray(res)) {\n          res.forEach(function (code) {\n            Meteor.call(\"taxes/insertTaxCodes\", Reaction.getShopId(), code, \"taxes-avalara\", (err) => {\n              if (err) {\n                throw new Meteor.Error(\"Error populating TaxCodes collection\", err);\n              }\n            });\n          });\n        }\n      });\n    }\n  }\n\n  return { statusCode: result.statusCode };\n};\n\n/**\n * @summary get Avalara Tax Codes\n * @returns {Array} An array of Tax code objects\n */\ntaxCalc.getTaxCodes = function () {\n  if (checkConfiguration()) {\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}definitions/taxcodes`;\n    const result = avaGet(requestUrl);\n    return _.get(result, \"data.value\", []);\n  }\n  throw new Meteor.Error(\"bad-configuration\", \"Avalara Tax package is enabled but not properly configured\");\n};\n\n/**\n * @summary Translate RC cart into format for submission\n * @param {Object} cart RC cart to send for tax estimate\n * @returns {Object} SalesOrder in Avalara format\n */\nfunction cartToSalesOrder(cart) {\n  const pkgData = taxCalc.getPackageData();\n  const { companyCode, shippingTaxCode } = pkgData.settings.avalara;\n  const company = Shops.findOne(Reaction.getShopId());\n  const companyShipping = _.filter(company.addressBook, (o) => o.isShippingDefault)[0];\n  const currencyCode = company.currency;\n  const cartShipping = cart.cartShipping();\n  const cartDate = moment(cart.createdAt).format();\n  let lineItems = [];\n  if (cart.items) {\n    lineItems = cart.items.map((item) => {\n      if (item.variants.taxable) {\n        return {\n          number: item._id,\n          itemCode: item.productId,\n          quantity: item.quantity,\n          amount: item.variants.price * item.quantity,\n          description: item.taxDescription || item.title,\n          taxCode: item.variants.taxCode\n        };\n      }\n    });\n    if (cartShipping) {\n      lineItems.push({\n        number: \"shipping\",\n        itemCode: \"shipping\",\n        quantity: 1,\n        amount: cartShipping,\n        description: \"Shipping\",\n        taxCode: shippingTaxCode\n      });\n    }\n  }\n\n  const salesOrder = {\n    companyCode: companyCode,\n    type: \"SalesOrder\",\n    customerCode: cart.userId,\n    date: cartDate,\n    currencyCode: currencyCode,\n    addresses: {\n      ShipFrom: {\n        line1: companyShipping.address1,\n        line2: companyShipping.address2,\n        city: companyShipping.city,\n        region: companyShipping.region,\n        country: companyShipping.country,\n        postalCode: companyShipping.postal\n      },\n      ShipTo: {\n        line1: cart.shipping[0].address.address1,\n        line2: cart.shipping[0].address.address2 || \"\",\n        city: cart.shipping[0].address.city,\n        region: cart.shipping[0].address.region,\n        country: cart.shipping[0].address.country || \"US\"\n      }\n    },\n    lines: lineItems\n  };\n\n  // current \"coupon code\" discount are based at the cart level, and every iten has it's\n  // discounted property set to true.\n  if (cart.discount)  {\n    salesOrder.discount = accounting.toFixed(cart.discount, 2);\n    for (const line of salesOrder.lines) {\n      if (line.itemCode !== \"shipping\") {\n        line.discounted = true;\n      }\n    }\n  }\n  return salesOrder;\n}\n\n/**\n * @summary Submit cart for tax calculation\n * @param {Cart} cart Cart object for estimation\n * @param {Function} callback callback when using async version\n * @returns {Object} result Result of SalesOrder call\n */\ntaxCalc.estimateCart = function (cart, callback) {\n  check(cart, Reaction.Schemas.Cart);\n  check(callback, Function);\n\n  if (cart.items && cart.shipping && cart.shipping[0].address) {\n    const salesOrder = Object.assign({}, cartToSalesOrder(cart), getTaxSettings(cart.userId));\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}transactions/create`;\n    const result = avaPost(requestUrl, { data: salesOrder });\n    return callback(result.data);\n  }\n};\n\n/**\n * @summary Translate RC order into format for final submission\n * @param {Object} order RC order to send for tax reporting\n * @returns {Object} SalesOrder in Avalara format\n */\nfunction orderToSalesInvoice(order) {\n  let documentType;\n  const pkgData = taxCalc.getPackageData();\n  const { companyCode, shippingTaxCode, commitDocuments } = pkgData.settings.avalara;\n  if (commitDocuments) {\n    documentType = \"SalesInvoice\";\n  } else {\n    documentType = \"SalesOrder\";\n  }\n  const company = Shops.findOne(Reaction.getShopId());\n  const companyShipping = _.filter(company.addressBook, (o) => o.isShippingDefault)[0];\n  const currencyCode = company.currency;\n  const orderShipping = order.orderShipping();\n  const orderDate = moment(order.createdAt).format();\n  const lineItems = order.items.map((item) => {\n    if (item.variants.taxable) {\n      return {\n        number: item._id,\n        itemCode: item.productId,\n        quantity: item.quantity,\n        amount: item.variants.price * item.quantity,\n        description: item.taxDescription || item.title,\n        taxCode: item.variants.taxCode\n      };\n    }\n  });\n  if (orderShipping) {\n    lineItems.push({\n      number: \"shipping\",\n      itemCode: \"shipping\",\n      quantity: 1,\n      amount: orderShipping,\n      description: \"Shipping\",\n      taxCode: shippingTaxCode\n    });\n  }\n\n  const salesInvoice = {\n    companyCode: companyCode,\n    type: documentType,\n    commit: commitDocuments,\n    code: order._id,\n    customerCode: order.userId,\n    date: orderDate,\n    currencyCode: currencyCode,\n    addresses: {\n      ShipFrom: {\n        line1: companyShipping.address1,\n        line2: companyShipping.address2,\n        city: companyShipping.city,\n        region: companyShipping.region,\n        country: companyShipping.country,\n        postalCode: companyShipping.postal\n      },\n      ShipTo: {\n        line1: order.shipping[0].address.address1,\n        line2: order.shipping[0].address.address2 || \"\",\n        city: order.shipping[0].address.city,\n        region: order.shipping[0].address.region,\n        country: order.shipping[0].address.country || \"US\"\n      }\n    },\n    lines: lineItems\n  };\n\n  if (order.discount)  {\n    salesInvoice.discount = accounting.toFixed(order.discount, 2);\n    for (const line of salesInvoice.lines) {\n      if (line.itemCode !== \"shipping\") {\n        line.discounted = true;\n      }\n    }\n  }\n  return salesInvoice;\n}\n\n/**\n * @summary Submit order for tax reporting\n * @param {Order} order Order object for submission\n * @param {Function} callback callback when using async version\n * @returns {Object} result Result of SalesInvoice call\n */\ntaxCalc.recordOrder = function (order, callback) {\n  check(callback, Function);\n  // unlike the other functions, we expect this to always be called asynchronously\n  if (order && order.shipping && order.shipping[0].address) {\n    const salesOrder = Object.assign({}, orderToSalesInvoice(order), getTaxSettings(order.userId));\n    const baseUrl = getUrl();\n    const requestUrl = `${baseUrl}transactions/create`;\n    try {\n      const result = avaPost(requestUrl, { data: salesOrder });\n      return callback(result.data);\n    } catch (error) {\n      Logger.error(\"Encountered error while recording order to Avalara\");\n      Logger.error(error);\n    }\n  }\n};\n\n/**\n * @summary Report refund to Avalara\n * @param {Order} order - The original order the refund was against\n * @param {Number} refundAmount - Amount to be refunded\n * @param {Function} callback - Callback\n * @returns {Object} Results from transaction call\n */\ntaxCalc.reportRefund = function (order, refundAmount, callback) {\n  check(refundAmount, Number);\n  check(callback, Function);\n  const pkgData = taxCalc.getPackageData();\n  const { companyCode } = pkgData.settings.avalara;\n  const company = Shops.findOne(Reaction.getShopId());\n  const companyShipping = _.filter(company.addressBook, (o) => o.isShippingDefault)[0];\n  const currencyCode = company.currency;\n  const baseUrl = getUrl();\n  const requestUrl = `${baseUrl}transactions/create`;\n  const returnAmount = refundAmount * -1;\n  const orderDate = moment(order.createdAt).format();\n  const refundDate = moment().format();\n  const refundReference = `${order.cartId}:${refundDate}`;\n  const  lineItems = {\n    number: \"01\",\n    quantity: 1,\n    amount: returnAmount,\n    description: \"refund\"\n  };\n  const returnInvoice = {\n    companyCode: companyCode,\n    type: \"ReturnInvoice\",\n    code: refundReference,\n    commit: true,\n    customerCode: order._id,\n    taxDate: orderDate,\n    date: refundDate,\n    currencyCode: currencyCode,\n    addresses: {\n      ShipFrom: {\n        line1: companyShipping.address1,\n        line2: companyShipping.address2,\n        city: companyShipping.city,\n        region: companyShipping.region,\n        country: companyShipping.country,\n        postalCode: companyShipping.postal\n      },\n      ShipTo: {\n        line1: order.shipping[0].address.address1,\n        line2: order.shipping[0].address.address2 || \"\",\n        city: order.shipping[0].address.city,\n        region: order.shipping[0].address.region,\n        country: order.shipping[0].address.country || \"US\"\n      }\n    },\n    lines: [lineItems]\n  };\n\n\n  const result = avaPost(requestUrl, { data: returnInvoice });\n  return callback(result.data);\n};\n\nexport default taxCalc;\n\nMeteor.methods({\n  \"avalara/addressValidation\": taxCalc.validateAddress,\n  \"avalara/getTaxCodes\": taxCalc.getTaxCodes,\n  \"avalara/testCredentials\": taxCalc.testCredentials,\n  \"avalara/getEntityCodes\": taxCalc.getEntityCodes\n});\n","import \"./hooks\";\nimport \"./i18n\";\nimport \"./jobs/cleanup\";\nimport cleanupAvalogs from \"./jobs/cleanup\";\n\ncleanupAvalogs();\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Avalara\",\n  name: \"taxes-avalara\",\n  icon: \"fa fa-university\",\n  autoEnable: true,\n  settings: {\n    avalara: {\n      enabled: false,\n      apiLoginId: \"\",\n      username: \"\",\n      password: \"\",\n      mode: false,\n      commitDocuments: true,\n      performTaxCalculation: true,\n      enableLogging: false,\n      requestTimeout: 3000,\n      logRetentionDuration: 30\n    },\n    addressValidation: {\n      enabled: true,\n      addressValidationMethod: \"avalara/addressValidation\"\n    },\n    taxCodes: {\n      getTaxCodeMethod: \"avalara/getTaxCodes\"\n    }\n  },\n  registry: [\n    {\n      label: \"Avalara\",\n      name: \"taxes/settings/avalara\",\n      provides: \"taxSettings\",\n      template: \"avalaraSettings\"\n    },\n    {\n      label: \"Avalara Address Validation\",\n      name: \"taxes/addressValidation/avalara\",\n      provides: \"addressValidation\"\n    },\n    {\n      label: \"Avalara Tax Calculation\",\n      provides: \"taxMethod\",\n      name: \"taxes/calculation/avalara\"\n    },\n    {\n      label: \"Avalara Tax Codes\",\n      provides: \"taxCodes\",\n      name: \"taxes/taxcodes/avalara\"\n    }\n  ]\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { HTTP } from \"meteor/http\";\nimport { Logger, MethodHooks } from \"/server/api\";\nimport { Shops, Cart, Packages } from \"/lib/collections\";\n\n//\n// this entire method will run after the core/taxes\n// plugin runs the taxes/calculate method\n// it overrwites any previous tax calculation\n// tax methods precendence is determined by\n// load order of plugins\n//\nMethodHooks.after(\"taxes/calculate\", function (options) {\n  const result = options.result || {};\n  let origin = {};\n\n  const cartId = options.arguments[0];\n  const cartToCalc = Cart.findOne(cartId);\n  if (cartToCalc) {\n    const shopId = cartToCalc.shopId;\n    const shop = Shops.findOne(shopId);\n    const pkg = Packages.findOne({\n      name: \"taxes-taxcloud\",\n      shopId: shopId,\n      enabled: true\n    });\n\n    // check if package is configured\n    if (shop && pkg && pkg.settings.taxcloud) {\n      const apiKey = pkg.settings.taxcloud.apiKey;\n      const apiLoginId = pkg.settings.taxcloud.apiLoginId;\n\n      // get shop address\n      // this will need some refactoring\n      // for multi-vendor/shop orders\n      if (shop.addressBook) {\n        const shopAddress = shop.addressBook[0];\n        origin =  {\n          Address1: shopAddress.address1,\n          City: shopAddress.city,\n          State: shopAddress.region,\n          Zip5: shopAddress.postal\n        };\n      }\n\n      // check if plugin is enabled and this calculation method is enabled\n      if (pkg && pkg.enabled === true && pkg.settings.taxcloud.enabled === true) {\n        if (!apiKey || !apiLoginId) {\n          Logger.warn(\"TaxCloud API Key is required.\");\n        }\n        if (typeof cartToCalc.shipping !== \"undefined\" && cartToCalc.items) {\n          const shippingAddress = cartToCalc.shipping[0].address;\n\n          if (shippingAddress) {\n            Logger.debug(\"TaxCloud triggered on taxes/calculate for cartId:\", cartId);\n            const url = \"https://api.taxcloud.net/1.0/TaxCloud/Lookup\";\n            const cartItems = [];\n            const destination = {\n              Address1: shippingAddress.address1,\n              City: shippingAddress.city,\n              State: shippingAddress.region,\n              Zip5: shippingAddress.postal\n            };\n\n            // format cart items to TaxCloud structure\n            let index = 0;\n            for (const items of cartToCalc.items) {\n              // only processs taxable products\n              if (items.variants.taxable === true) {\n                const item = {\n                  Index: index,\n                  ItemID: items.variants._id,\n                  TIC: \"00000\",\n                  Price: items.variants.price,\n                  Qty: items.quantity\n                };\n                index ++;\n                cartItems.push(item);\n              }\n            }\n\n            // request object\n            const request = {\n              headers: {\n                \"accept\": \"application/json\",\n                \"content-type\": \"application/json\"\n              },\n              data: {\n                apiKey: apiKey,\n                apiLoginId: apiLoginId,\n                customerID: cartToCalc.userId,\n                cartItems: cartItems,\n                origin: origin,\n                destination: destination,\n                cartID: cartId,\n                deliveredBySeller: false\n              }\n            };\n\n            HTTP.post(url, request, function (error, response) {\n              let taxRate = 0;\n              // ResponseType 3 is a successful call.\n              if (!error && response.data.ResponseType === 3) {\n                let totalTax = 0;\n                for (const item of response.data.CartItemsResponse) {\n                  totalTax += item.TaxAmount;\n                }\n                // don't run this calculation if there isn't tax.\n                if (totalTax > 0) {\n                  taxRate = (totalTax / cartToCalc.cartSubTotal());\n                }\n                // we should consider if we want percentage and dollar\n                // as this is assuming that subTotal actually contains everything\n                // taxable\n                Meteor.call(\"taxes/setRate\", cartId, taxRate, response.CartItemsResponse);\n              } else {\n                let errMsg = \"Unable to access service. Check credentials.\";\n                if (response && response.data.Messages[0].Message) {\n                  errMsg = response.data.Messages[0].Message;\n                }\n                Logger.warn(\"Error fetching tax rate from TaxCloud:\", errMsg);\n              }\n            });\n          }\n        }\n      }\n    }\n  }\n  // Default return value is the return value of previous call in method chain\n  // or an empty object if there's no result yet.\n  return result;\n});\n","import \"./hooks\";\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./methods\";\n","import { Meteor } from \"meteor/meteor\";\nimport { HTTP } from \"meteor/http\";\n\nMeteor.methods({\n  /**\n   * We're using https://taxcloud.net\n   * just to get an intial import data set\n   * this service doesn't require taxcloud id\n   * but other services need authorization\n   * use TAXCODE_SRC  to override source url\n   * @returns {Array} An array of Tax code objects\n   */\n  \"taxcloud/getTaxCodes\": function () {\n    const taxCodeArray = [];\n    const TAXCODE_SRC = \"https://taxcloud.net/tic/?format=json\";\n    const taxCodes = HTTP.get(TAXCODE_SRC);\n\n    if (taxCodes) {\n      taxCodes.data.tic_list.forEach(function (code) {\n        if (code.tic.children) {\n          code.tic.children.forEach(function (child) {\n            taxCodeArray.push(child.tic);\n          });\n        }\n        taxCodeArray.push(code.tic);\n      });\n      return taxCodeArray;\n    }\n    throw new Meteor.Error(\"Error getting tax codes\");\n  }\n});\n","import \"./hooks\";\nimport \"./i18n\";\n\n// TODO decide if we want to use tax codes\n// these imports was start a job to import TaxCloud taxCodes\n\nimport \"./methods\";\n// import \"./jobs\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Taxes\",\n  name: \"taxes-taxcloud\",\n  icon: \"fa fa-university\",\n  autoEnable: true,\n  settings: {\n    taxcloud: {\n      enabled: false,\n      apiLoginId: \"\",\n      apiKey: \"\",\n      refreshPeriod: \"every 7 days\",\n      taxCodeUrl: \"https://taxcloud.net/tic/?format=json\"\n    },\n    taxCodes: {\n      getTaxCodeMethod: \"taxcloud/getTaxCodes\"\n    }\n  },\n  registry: [\n    {\n      label: \"TaxCloud\",\n      name: \"taxes/settings/taxcloud\",\n      provides: \"taxSettings\",\n      template: \"taxCloudSettings\"\n    },\n    {\n      label: \"TaxCloud Tax Codes\",\n      provides: \"taxCodes\",\n      name: \"taxes/taxcodes/taxcloud\"\n    }\n  ]\n});\n","import { Reaction, Logger, MethodHooks } from \"/server/api\";\nimport { Packages } from \"/lib/collections\";\n\n// // Meteor.after to call after\nMethodHooks.after(\"taxes/calculate\", function (options) {\n  const result = options.result || {};\n  const pkg = Packages.findOne({\n    name: \"taxes-taxjar\",\n    shopId: Reaction.getShopId(),\n    enabled: true\n  });\n\n  // check if plugin is enabled and this calculation method is enabled\n  if (pkg && pkg && pkg.enabled === true && pkg.settings.taxjar.enabled === true) {\n    Logger.warn(\"TaxJar triggered on taxes/calculate for cartId:\", options.arguments[0]);\n  }\n\n  // Default return value is the return value of previous call in method chain\n  // or an empty object if there's no result yet.\n  return result;\n});\n","import \"./hooks\";\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./hooks\";\nimport \"./i18n\";\n","import { loadTranslations } from \"/server/startup/i18n\";\n\n// import ar from \"./ar.json\";\n// import bg from \"./bg.json\";\n// import de from \"./de.json\";\n// import el from \"./el.json\";\nimport en from \"./en.json\";\n// import es from \"./es.json\";\n// import fr from \"./fr.json\";\n// import he from \"./he.json\";\n// import hr from \"./hr.json\";\n// import it from \"./it.json\";\n// import my from \"./my.json\";\n// import nb from \"./nb.json\";\n// import nl from \"./nl.json\";\n// import pl from \"./pl.json\";\n// import pt from \"./pt.json\";\n// import ro from \"./ro.json\";\n// import ru from \"./ru.json\";\n// import sl from \"./sl.json\";\n// import sv from \"./sv.json\";\n// import tr from \"./tr.json\";\n// import vi from \"./vi.json\";\n// import zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([en]);\n// loadTranslations([ar, bg, de, el, en, es, fr, he, hr, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","import \"./i18n\";\n","import { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"Search UI\",\n  name: \"reaction-ui-search\",\n  icon: \"fa fa-search\",\n  autoEnable: true,\n  registry: [\n    {\n      name: \"Search Modal\",\n      provides: \"ui-search\",\n      template: \"searchModal\"\n    }\n  ]\n});\n","import { loadTranslations } from \"/server/startup/i18n\";\n\nimport ar from \"./ar.json\";\nimport bg from \"./bg.json\";\nimport cs from \"./cs.json\";\nimport de from \"./de.json\";\nimport el from \"./el.json\";\nimport en from \"./en.json\";\nimport es from \"./es.json\";\nimport fr from \"./fr.json\";\nimport he from \"./he.json\";\nimport hr from \"./hr.json\";\nimport hu from \"./hu.json\";\nimport it from \"./it.json\";\nimport my from \"./my.json\";\nimport nb from \"./nb.json\";\nimport nl from \"./nl.json\";\nimport pl from \"./pl.json\";\nimport pt from \"./pt.json\";\nimport ro from \"./ro.json\";\nimport ru from \"./ru.json\";\nimport sl from \"./sl.json\";\nimport sv from \"./sv.json\";\nimport tr from \"./tr.json\";\nimport vi from \"./vi.json\";\nimport zh from \"./zh.json\";\n\n//\n// we want all the files in individual\n// imports for easier handling by\n// automated translation software\n//\nloadTranslations([ar, bg, cs, de, el, en, es, fr, he, hr, hu, it, my, nb, nl, pl, pt, ro, ru, sl, sv, tr, vi, zh]);\n","/* eslint camelcase: 0 */\n// meteor modules\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\n// reaction modules\nimport { Reaction, Logger } from \"/server/api\";\nimport { ExampleApi } from \"./exampleapi\";\n\nfunction luhnValid(x) {\n  return [...x].reverse().reduce((sum, c, i) => {\n    let d = parseInt(c, 10);\n    if (i % 2 !== 0) { d *= 2; }\n    if (d > 9) { d -= 9; }\n    return sum + d;\n  }, 0) % 10 === 0;\n}\n\nconst ValidCardNumber = Match.Where(function (x) {\n  return /^[0-9]{13,16}$/.test(x) && luhnValid(x);\n});\n\nconst ValidExpireMonth = Match.Where(function (x) {\n  return /^[0-9]{1,2}$/.test(x);\n});\n\nconst ValidExpireYear = Match.Where(function (x) {\n  return /^[0-9]{4}$/.test(x);\n});\n\nconst ValidCVV = Match.Where(function (x) {\n  return /^[0-9]{3,4}$/.test(x);\n});\n\n// function chargeObj() {\n//   return {\n//     amount: \"\",\n//     currency: \"\",\n//     card: {},\n//     capture: true\n//   };\n// }\n\n// function parseCardData(data) {\n//   return {\n//     number: data.number,\n//     name: data.name,\n//     cvc: data.cvv2,\n//     expireMonth: data.expire_month,\n//     expireYear: data.expire_year\n//   };\n// }\n\n\nMeteor.methods({\n  /**\n   * Submit a card for Authorization\n   * @param  {Object} transactionType authorize or capture\n   * @param  {Object} cardData card Details\n   * @param  {Object} paymentData The details of the Payment Needed\n   * @return {Object} results normalized\n   */\n  \"exampleSubmit\": function (transactionType, cardData, paymentData) {\n    check(transactionType, String);\n    check(cardData, {\n      name: String,\n      number: ValidCardNumber,\n      expireMonth: ValidExpireMonth,\n      expireYear: ValidExpireYear,\n      cvv2: ValidCVV,\n      type: String\n    });\n\n    check(paymentData, {\n      total: String,\n      currency: String\n    });\n    const total = parseFloat(paymentData.total);\n    let result;\n    try {\n      const transaction = ExampleApi.methods.authorize.call({\n        transactionType: transactionType,\n        cardData: cardData,\n        paymentData: paymentData\n      });\n\n      result = {\n        saved: true,\n        status: \"created\",\n        currency: paymentData.currency,\n        amount: total,\n        transactionId: transaction.id,\n        response: {\n          amount: total,\n          transactionId: transaction.id,\n          currency: paymentData.currency\n        }\n      };\n    } catch (error) {\n      Logger.warn(error);\n      result = {\n        saved: false,\n        error: error\n      };\n    }\n    return result;\n  },\n\n  /**\n   * Capture a Charge\n   * @param {Object} paymentData Object containing data about the transaction to capture\n   * @return {Object} results normalized\n   */\n  \"example/payment/capture\": function (paymentData) {\n    check(paymentData, Reaction.Schemas.PaymentMethod);\n    const authorizationId = paymentData.transactionId;\n    const amount = paymentData.amount;\n    const response = ExampleApi.methods.capture.call({\n      authorizationId: authorizationId,\n      amount: amount\n    });\n    const result = {\n      saved: true,\n      response: response\n    };\n    return result;\n  },\n\n  /**\n   * Create a refund\n   * @param  {Object} paymentMethod object\n   * @param  {Number} amount The amount to be refunded\n   * @return {Object} result\n   */\n  \"example/refund/create\": function (paymentMethod, amount) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n    const { transactionId } = paymentMethod;\n    const response = ExampleApi.methods.refund.call({\n      transactionId: transactionId,\n      amount: amount\n    });\n    const results = {\n      saved: true,\n      response: response\n    };\n    return results;\n  },\n\n  /**\n   * List refunds\n   * @param  {Object} paymentMethod Object containing the pertinant data\n   * @return {Object} result\n   */\n  \"example/refund/list\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    const { transactionId } = paymentMethod;\n    const response = ExampleApi.methods.refunds.call({\n      transactionId: transactionId\n    });\n    const result = [];\n    for (const refund of response.refunds) {\n      result.push(refund);\n    }\n\n    // The results retured from the GenericAPI just so happen to look like exactly what the dashboard\n    // wants. The return package should ba an array of objects that look like this\n    // {\n    //   type: \"refund\",\n    //   amount: Number,\n    //   created: Number: Epoch Time,\n    //   currency: String,\n    //   raw: Object\n    // }\n    const emptyResult = [];\n    return emptyResult;\n  }\n});\n","\n// You should not implement ThirdPartyAPI. It is supposed to represent your third party API\n// And is called so that it can be stubbed out for testing. This would be a library\n// like Stripe or Authorize.net usually just included with a NPM.require\n\nThirdPartyAPI = {\n  authorize: function (transactionType, cardData, paymentData) {\n    if (transactionType === \"authorize\") {\n      const results = {\n        success: true,\n        id: Random.id(),\n        cardNumber: cardData.number.slice(-4),\n        amount: paymentData.total,\n        currency: \"USD\"\n      };\n      return results;\n    };\n    console.log(\"Authorized\");\n    return {\n      success: false\n    };\n  },\n  capture: function (authorizationId, amount) {\n    console.log(\"Authorized\");\n    return {\n      authorizationId: authorizationId,\n      amount: amount,\n      success: true\n    };\n  },\n  refund: function (transactionId, amount) {\n    return {\n      sucess: true,\n      transactionId: transactionId,\n      amount: amount\n    };\n  },\n  listRefunds: function (transactionId) {\n    return {\n      transactionId: transactionId,\n      refunds: [\n        {\n          type: \"refund\",\n          amount: 3.99,\n          created: 1454034562000,\n          currency: \"usd\",\n          raw: {}\n        }\n      ]\n    };\n  }\n};\n\n// This is the \"wrapper\" functions you should write in order to make your code more\n// testable. You can either mirror the API calls or normalize them to the authorize/capture/refund/refunds\n// that Reaction is expecting\nexport const ExampleApi = {};\nExampleApi.methods = {};\n\nexport const cardSchema = new SimpleSchema({\n  number: { type: String },\n  name: { type: String },\n  cvv2: { type: String },\n  expireMonth: { type: String },\n  expireYear: { type: String },\n  type: { type: String }\n});\n\npaymentDataSchema = new SimpleSchema({\n  total: { type: String },\n  currency: { type: String }\n});\n\n\nExampleApi.methods.authorize = new ValidatedMethod({\n  name: \"ExampleApi.methods.authorize\",\n  validate: new SimpleSchema({\n    transactionType: { type: String },\n    cardData: { type: cardSchema },\n    paymentData: { type: paymentDataSchema }\n  }).validator(),\n  run({ transactionType, cardData, paymentData }) {\n    const results = ThirdPartyAPI.authorize(transactionType, cardData, paymentData);\n    return results;\n  }\n});\n\n\nExampleApi.methods.capture = new ValidatedMethod({\n  name: \"ExampleApi.methods.capture\",\n  validate: new SimpleSchema({\n    authorizationId: { type: String },\n    amount: { type: Number, decimal: true }\n  }).validator(),\n  run(args) {\n    const transactionId = args.authorizationId;\n    const amount = args.amount;\n    const results = ThirdPartyAPI.capture(transactionId, amount);\n    return results;\n  }\n});\n\n\nExampleApi.methods.refund = new ValidatedMethod({\n  name: \"ExampleApi.methods.refund\",\n  validate: new SimpleSchema({\n    transactionId: { type: String },\n    amount: { type: Number, decimal: true  }\n  }).validator(),\n  run(args) {\n    const transactionId = args.transactionId;\n    const amount = args.amount;\n    const results = ThirdPartyAPI.refund(transactionId, amount);\n    return results;\n  }\n});\n\n\nExampleApi.methods.refunds = new ValidatedMethod({\n  name: \"ExampleApi.methods.refunds\",\n  validate: new SimpleSchema({\n    transactionId: { type: String }\n  }).validator(),\n  run(args) {\n    const { transactionId } = args;\n    const results = ThirdPartyAPI.listRefunds(transactionId);\n    return results;\n  }\n});\n","import \"./methods/example\";\nimport \"./i18n\";\n\nexport * from \"./methods/exampleapi\";\n","/* eslint camelcase: 0 */\nimport { Reaction } from \"/server/api\";\n\nReaction.registerPackage({\n  label: \"ExamplePayment\",\n  name: \"example-paymentmethod\",\n  icon: \"fa fa-credit-card-alt\",\n  autoEnable: true,\n  settings: {\n    \"mode\": false,\n    \"apiKey\": \"\",\n    \"example\": {\n      enabled: false\n    },\n    \"example-paymentmethod\": {\n      enabled: false,\n      support: [\n        \"Authorize\",\n        \"Capture\",\n        \"Refund\"\n      ]\n    }\n  },\n  registry: [\n    // Settings panel\n    {\n      label: \"Example Payment\", // this key (minus spaces) is used for translations\n      provides: \"paymentSettings\",\n      container: \"dashboard\",\n      template: \"exampleSettings\"\n    },\n\n    // Payment form for checkout\n    {\n      template: \"examplePaymentForm\",\n      provides: \"paymentMethod\",\n      icon: \"fa fa-credit-card-alt\"\n    }\n  ]\n});\n","import { DocHead } from \"meteor/kadira:dochead\";\nimport { ReactionProduct } from \"/lib/api\";\nimport { Shops } from \"/lib/collections\";\nimport { getShopId } from \"/lib/api\";\n\n/**\n * MetaData\n * populates title and meta tags for routes\n * init accepts Router.current() context\n */\nexport const MetaData = {\n  init(context) {\n    const params = context.params;\n    const product = ReactionProduct.selectedProduct();\n    const shop = Shops.findOne(getShopId());\n    const meta = [];\n    let title = \"\";\n    const keywords = [];\n\n    // case helper\n    const titleCase = (param) => {\n      return param.charAt(0).toUpperCase() + param.substring(1);\n    };\n\n    // populate meta from shop\n    if (shop) {\n      //\n      // shop defaults\n      //\n      if (shop && shop.description) {\n        DocHead.addMeta({\n          name: \"description\",\n          content: shop.description.substring(0, 160)\n        });\n      }\n      if (shop && shop.keywords) {\n        DocHead.addMeta({\n          name: \"keywords\",\n          content: shop.keywords.toString()\n        });\n      }\n\n      //\n      // set title defaults\n      //\n      MetaData.name = shop.name;\n      // product title default\n      if (params && params.handle) {\n        if (product && product.title) {\n          title = titleCase(product.title);\n        } else {\n          title = titleCase(params.handle);\n        }\n        // tag slugs\n      } else if (params && params.slug) {\n        title = titleCase(params.slug);\n        // fallback to route name\n      } else if (context.route && context.route.name) {\n        const route = context.route;\n        const routeName = route.name;\n        // default index to Shop Name\n        if (routeName === \"index\") {\n          title = titleCase(shop.name);\n          // check for meta in package route\n        } else if (route.options.meta && route.options.meta.title) {\n          title = titleCase(route.options.meta.title);\n        } else {\n          // default routes to route's name\n          title = titleCase(routeName);\n        }\n      }\n\n      //\n      //  product details\n      //\n      if (params && params.handle && product) {\n        // discard defaults\n        DocHead.removeDocHeadAddedTags();\n\n        if (product.description) {\n          DocHead.addMeta({\n            name: \"description\",\n            content: product.description.substring(0, 160)\n          });\n        }\n\n        if (product && product.metafields) {\n          for (const key of product.metafields) {\n            keywords.push(key.value);\n          }\n        }\n\n        if (keywords) {\n          DocHead.addMeta({\n            name: \"keywords\",\n            content: keywords.toString()\n          });\n        }\n      }\n\n      // set site defaults\n      DocHead.setTitle(title);\n      MetaData.title = title;\n      MetaData.meta = meta;\n      return meta;\n    } // end shop\n  } // end update\n};\n","import { Meteor } from \"meteor/meteor\";\n\nconst validationMethods = {\n  /**\n   * Username validation\n   * @summary Determins if a username meets the minimum requirement of 3 characters\n   * @param  {String} username Username to validate\n   * @return {Boolean|Object} true if valid, error object if invalid\n   */\n  username(username) {\n    check(username, Match.OptionalOrNull(String));\n\n    // Valid\n    if (username.length >= 3) {\n      return true;\n    }\n\n    // Invalid\n    return {\n      error: \"INVALID_USERNAME\",\n      reason: \"Username must be at least 3 characters long\",\n      i18nKeyReason: \"accountsUI.error.usernameMinLength\"\n    };\n  },\n\n  /**\n   * Email validation\n   * @summary Validates both required and optional email addresses.\n   * @param  {String} email Email address to validate\n   * @param  {Boolean} optional If set to true, validation will pass if email is blank\n   * @return {Boolean|Object} Returns true if valid; Returns an error object if invalid\n   */\n  email(email, optional) {\n    check(email, Match.OptionalOrNull(String));\n    check(optional, Match.OptionalOrNull(Boolean));\n\n    const processedEmail = email.trim();\n\n    // Valid\n    if (optional === true && processedEmail.length === 0) {\n      return true;\n    } else if (processedEmail.indexOf(\"@\") !== -1) {\n      return true;\n    }\n\n    // Invalid\n    return {\n      error: \"INVALID_EMAIL\",\n      reason: \"Email address is invalid\",\n      i18nKeyReason: \"accountsUI.error.invalidEmail\"\n    };\n  },\n\n  /**\n   * Password validation\n   * Passwords may be validated 2 ways.\n   * \"exists\" (options.validationLevel = \"exists\") - Password must not be blank. Thats is the only rule. Used to validate a sign in.\n   * undefined (options.validationLevel = undefined) - Password must meet the lenght and other criteria to validate. Used for validating a new sign up.\n   * @param  {String} password Password to validate\n   * @param  {Object} options Options to apply to the password validator\n   * @param  {String} options.validationLevel \"exists\" | undefined (default)\n   * @return {Boolean|[{error: String, reason: String}]} true if valid | Error object otherwise\n   */\n  password(password, options) {\n    check(password, Match.OptionalOrNull(String));\n    check(options, Match.OptionalOrNull(Object));\n\n    const passwordOptions = options || {};\n    const errors = [];\n\n    // Only check if a password has been entered at all.\n    // This is usefull for the login forms\n    if (passwordOptions.validationLevel === \"exists\") {\n      if (password.length > 0) {\n        return true;\n      }\n\n      errors.push({\n        error: \"INVALID_PASSWORD\",\n        reason: \"Password is required\",\n        i18nKeyReason: \"accountsUI.error.passwordRequired\"\n      });\n    } else {\n      // Validate the password on some rules\n      // This is useful for cases where a password needs to be created or updated.\n      if (password.length < 6) {\n        errors.push({\n          error: \"INVALID_PASSWORD\",\n          reason: \"Password must be at least 6 characters long.\",\n          i18nKeyReason: \"accountsUI.error.passwordMustBeAtLeast6CharactersLong\"\n        });\n      }\n    }\n\n    if (errors.length) {\n      return errors;\n    }\n\n    // Otherwise the password is valid\n    return true;\n  }\n};\n\n// Export object globally\nLoginFormValidation = validationMethods;\n\n// Register validation methods as meteor methods\nMeteor.methods({\n  \"accounts/validation/username\": validationMethods.username,\n  \"accounts/validation/email\": validationMethods.email,\n  \"accounts/validation/password\": validationMethods.password\n});\n\n","import { Products } from \"/lib/collections\";\nimport { applyProductRevision } from \"/lib/api/products\";\n\nexport default Catalog = {\n  /**\n   * setProduct\n   * @summary method to set default/parameterized product variant\n   * @param {String} currentProductId - set current productId\n   * @param {String} currentVariantId - set current variantId\n   * @return {undefined} return nothing, sets in session\n   */\n  setProduct(currentProductId, currentVariantId) {\n    let productId = currentProductId;\n    const variantId = currentVariantId;\n    if (!productId.match(/^[A-Za-z0-9]{17}$/)) {\n      const product = Products.findOne({\n        handle: productId.toLowerCase()\n      });\n      if (product) {\n        productId = product._id;\n      }\n    }\n    setCurrentProduct(productId);\n    setCurrentVariant(variantId);\n  },\n\n  /**\n   * getProductPriceRange\n   * @summary get price range of a product\n   * if no only one price available, return it\n   * otherwise return a string range\n   * @todo remove string return and replace with object\n   * @todo move all this methods this to export function after 1.3\n   * @param {String} [productId] - current product _id\n   * @return {Object} range, min, max\n   */\n  getProductPriceRange(productId) {\n    const product = applyProductRevision(Products.findOne(productId));\n    if (!product) {\n      return \"\";\n    }\n    const variants = this.getTopVariants(product._id);\n    // if we have variants we have a price range.\n    // this processing will default on the server\n    const visibileVariant = variants.filter(variant => variant.isVisible === true);\n\n    if (visibileVariant.length > 0) {\n      const variantPrices = [];\n      variants.forEach(variant => {\n        if (variant.isVisible === true) {\n          const range = this.getVariantPriceRange(variant._id);\n          if (typeof range === \"string\") {\n            const firstPrice = parseFloat(range.substr(0, range.indexOf(\" \")));\n            const lastPrice = parseFloat(range.substr(range.lastIndexOf(\" \") + 1));\n            variantPrices.push(firstPrice, lastPrice);\n          } else {\n            variantPrices.push(range);\n          }\n        } else {\n          variantPrices.push(0, 0);\n        }\n      });\n      const priceMin = _.min(variantPrices);\n      const priceMax = _.max(variantPrices);\n      let priceRange = `${priceMin} - ${priceMax}`;\n      // if we don't have a range\n      if (priceMin === priceMax) {\n        priceRange = priceMin.toString();\n      }\n      const priceObject = {\n        range: priceRange,\n        min: priceMin,\n        max: priceMax\n      };\n      return priceObject;\n    }\n    // if we have no variants subscribed to (client)\n    // we'll get the price object previously from the product\n    return product.price;\n  },\n\n  /**\n   * getVariantPriceRange\n   * @summary get price range of a variant if it has child options.\n   * if no child options, return main price value\n   * @todo remove string return and replace with object\n   * @param {String} [variantId] - current variant _Id\n   * @return {String} formatted price or price range\n   */\n  getVariantPriceRange(variantId) {\n    const children = this.getVariants(variantId);\n    const visibleChildren = children.filter(child => child.isVisible);\n\n    switch (visibleChildren.length) {\n      case 0:\n        const topVariant = applyProductRevision(Products.findOne(variantId));\n        // topVariant could be undefined when we removing last top variant\n        return topVariant && topVariant.price;\n      case 1:\n        return visibleChildren[0].price;\n      default:\n        let priceMin = Number.POSITIVE_INFINITY;\n        let priceMax = Number.NEGATIVE_INFINITY;\n\n        children.map(child => {\n          if (child.isVisible === true) {\n            if (child.price < priceMin) {\n              priceMin = child.price;\n            }\n            if (child.price > priceMax) {\n              priceMax = child.price;\n            }\n          }\n        });\n\n        if (priceMin === priceMax) {\n          // TODO check impact on i18n/formatPrice from moving return to string\n          return priceMin.toString();\n        }\n        return `${priceMin} - ${priceMax}`;\n    }\n  },\n\n  /**\n   * getVariantQuantity\n   * @description calculate a sum of descendants `inventoryQuantity`\n   * @param {Object} variant - top-level variant\n   * @return {Number} summary of options quantity\n   */\n  getVariantQuantity(variant) {\n    const options = this.getVariants(variant._id);\n    if (options && options.length) {\n      return options.reduce((sum, option) =>\n      sum + option.inventoryQuantity || 0, 0);\n    }\n    return variant.inventoryQuantity || 0;\n  },\n\n  /**\n   * @method getPublishedOrRevision\n   * @description return top product revision if available\n   * @param {Object} product product or variant document\n   * @return {Object} product document\n   */\n  getPublishedOrRevision(product) {\n    return applyProductRevision(product);\n  },\n\n  /**\n   * @method getVariants\n   * @description Get all parent variants\n   * @summary could be useful for products and for top level variants\n   * @param {String} [id] - product _id\n   * @param {String} [type] - type of variant\n   * @return {Array} Parent variants or empty array\n   */\n  getVariants(id, type) {\n    return Products.find({\n      ancestors: { $in: [id] },\n      type: type || \"variant\"\n    }).map(this.getPublishedOrRevision);\n  },\n\n  /**\n   * @method getTopVariants\n   * @description Get only product top level variants\n   * @param {String} [id] - product _id\n   * @return {Array} Product top level variants or empty array\n   */\n  getTopVariants(id) {\n    return Products.find({\n      ancestors: [id],\n      type: \"variant\"\n    }).map(this.getPublishedOrRevision);\n  }\n};\n","/**\n * Wrapper around react-komposer v2 to provide some backwars compatability\n * for features from v1.\n */\nimport { compose } from \"react-komposer\";\nimport React from \"react\";\nexport * from \"react-komposer\";\n\n/**\n * getTrackerLoader creates a Meteor Tracker to watch dep updates from\n * passed in reactiveMapper funtion\n * @param  {Function} reactiveMapper data fetching function to bind to a tracker\n * @return {Function} composed function\n */\nfunction getTrackerLoader(reactiveMapper) {\n  return (props, onData, env) => {\n    let trackerCleanup = null;\n    const handler = Tracker.nonreactive(() => {\n      return Tracker.autorun(() => {\n        // assign the custom clean-up function.\n        trackerCleanup = reactiveMapper(props, onData, env);\n      });\n    });\n\n    return () => {\n      if (typeof trackerCleanup === \"function\") trackerCleanup();\n      return handler.stop();\n    };\n  };\n}\n\n/**\n * Re-implementation of composeWithTracker from v1.x\n * @param {Function} reactiveMapper data fetching function to bind to a tracker\n * @param {React.Component} LoadingComponent react component for a custom loading screen\n * @return {Function} composed function\n */\nexport function composeWithTracker(reactiveMapper, LoadingComponent) {\n  const options = {};\n\n  if (typeof LoadingComponent === \"undefined\") {\n    options.loadingHandler = () => { // eslint-disable-line react/display-name\n      return (\n        <LoadingComponent />\n      );\n    };\n  }\n\n  return compose(getTrackerLoader(reactiveMapper), options);\n}\n","/*\n * Copy store data, copied from Meteor CollectionsFS\n * https://github.com/CollectionFS/Meteor-CollectionFS/blob/master/packages/file/fsFile-server.js#L225\n */\nfunction _copyStoreData(fileObj, storeName, sourceKey, callback) {\n  if (!fileObj.isMounted()) {\n    throw new Error(\"Cannot copy store data for a file that is not associated with a collection\");\n  }\n\n  const storage = fileObj.collection.storesLookup[storeName];\n  if (!storage) {\n    throw new Error(storeName + \" is not a valid store name\");\n  }\n\n  // We want to prevent beforeWrite and transformWrite from running, so\n  // we interact directly with the store.\n  const destinationKey = storage.adapter.fileKey(fileObj);\n  const readStream = storage.adapter.createReadStreamForFileKey(sourceKey);\n  const writeStream = storage.adapter.createWriteStreamForFileKey(destinationKey);\n\n  writeStream.once(\"stored\", function (result) {\n    callback(null, result.fileKey);\n  });\n\n  writeStream.once(\"error\", function (error) {\n    callback(error);\n  });\n\n  readStream.pipe(writeStream);\n}\nconst copyStoreData = Meteor.wrapAsync(_copyStoreData);\n\n/*\n * Modified from Meteor CollectionsFS\n * https://github.com/CollectionFS/Meteor-CollectionFS/blob/master/packages/file/fsFile-server.js#L126\n */\nexport function copyFile(fileObj, newMetaData) {\n  const self = fileObj;\n\n  if (!self.isMounted()) {\n    throw new Error(\"Cannot copy a file that is not associated with a collection\");\n  }\n\n  // Get the file record\n  const fileRecord = self.collection.files.findOne({ _id: self._id }, { transform: null }) || {};\n\n  if (newMetaData) {\n    const oldMetaData = fileRecord.metadata || {};\n\n    fileRecord.metadata = {\n      ...oldMetaData,\n      ...newMetaData\n    };\n  }\n\n  // Remove _id and copy keys from the file record\n  delete fileRecord._id;\n\n  // Insert directly; we don't have access to \"original\" in this case\n  const newId = self.collection.files.direct.insert(fileRecord);\n\n  const newFile = self.collection.findOne(newId);\n\n  // Copy underlying files in the stores\n  let mod;\n  let oldKey;\n  for (const name in newFile.copies) {\n    if (newFile.copies.hasOwnProperty(name)) {\n      oldKey = newFile.copies[name].key;\n      if (oldKey) {\n        // We need to ask the adapter for the true oldKey because\n        // right now gridfs does some extra stuff.\n        // TODO GridFS should probably set the full key object\n        // (with _id and filename) into `copies.key`\n        // so that copies.key can be passed directly to\n        // createReadStreamForFileKey\n        const sourceFileStorage = self.collection.storesLookup[name];\n        if (!sourceFileStorage) {\n          throw new Error(name + \" is not a valid store name\");\n        }\n        oldKey = sourceFileStorage.adapter.fileKey(self);\n        // delete so that new fileKey will be generated in copyStoreData\n        delete newFile.copies[name].key;\n        mod = mod || {};\n        mod[\"copies.\" + name + \".key\"] = copyStoreData(newFile, name, oldKey);\n      }\n    }\n  }\n  // Update keys in the filerecord\n  if (mod) {\n    self.collection.files.direct.update({\n      _id: newId\n    }, {\n      $set: mod\n    });\n  }\n\n  return newFile;\n}\n","import url from \"url\";\nimport { slugify } from \"transliteration\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Router } from \"/imports/plugins/core/router/lib\";\nimport { Shops } from \"/lib/collections\";\n\n/**\n * getShopId\n * @return {String} returns current shopId\n */\nexport function getShopId() {\n  const domain = url.parse(Meteor.absoluteUrl()).hostname;\n\n  const shop = Shops.find({ domains: { $in: [domain] } }, {\n    limit: 1\n  }).fetch()[0];\n\n  return !!shop ? shop._id : null;\n}\n\n\n/**\n * getShopName\n * @return {String} returns current shop name\n */\nexport function getShopName() {\n  const domain = url.parse(Meteor.absoluteUrl()).hostname;\n\n  const shop = Shops.find({ domains: { $in: [domain] } }, {\n    limit: 1\n  }).fetch()[0];\n\n  return !!shop ? shop.name : null;\n}\n\n/**\n * getShopPrefix\n * @param {String} leading - Default \"/\", prefix, the prefix with a leading shash\n * @return {String} returns shop url prefix\n */\nexport function getShopPrefix(leading = \"/\") {\n  return leading + getSlug(getShopName().toLowerCase());\n}\n\n/**\n * getAbsoluteUrl\n * @param {String} path - path to append to absolute Url, path should be prefixed with / if necessary\n * @return {String} returns absolute url (shop prefix + path)\n */\nexport function getAbsoluteUrl(path) {\n  const prefix = getShopPrefix(\"\");\n  return Meteor.absoluteUrl(`${prefix}${path}`);\n}\n\n/**\n * getCurrentTag\n * @return {String} returns current tag\n */\nexport function getCurrentTag() {\n  if (Router.getRouteName() === \"tag\") {\n    return Router.current().params.slug;\n  }\n  return null;\n}\n\n\n/**\n * getSlug - return a slugified string using \"slugify\" from transliteration\n * https://www.npmjs.com/package/transliteration\n * @param  {String} slugString - string to slugify\n * @return {String} slugified string\n */\nexport function getSlug(slugString) {\n  return slugString ? slugify(slugString) : \"\";\n}\n\n/**\n * toCamelCase helper for i18n\n * @summary special toCamelCase for converting a string to camelCase for use with i18n keys\n * @param {String} needscamels String to be camel cased.\n * @return {String} camelCased string\n */\nexport function toCamelCase(needscamels) {\n  let s;\n  s = needscamels.replace(/([^a-zA-Z0-9_\\- ])|^[_0-9]+/g, \"\").trim().toLowerCase();\n  s = s.replace(/([ -]+)([a-zA-Z0-9])/g, function (a, b, c) {\n    return c.toUpperCase();\n  });\n  s = s.replace(/([0-9]+)([a-zA-Z])/g, function (a, b, c) {\n    return b + c.toUpperCase();\n  });\n  return s;\n}\n\n/**\n * translateRegistry\n * @summary adds i18n strings to registry object\n * @param {Object} registry registry object\n * @param {Object} [app] complete package object\n * @return {Object} with updated registry\n */\nexport function translateRegistry(registry, app) {\n  let registryLabel = \"\";\n  let i18nKey = \"\";\n  // first we check the default place for a label\n  if (registry.label) {\n    registryLabel = toCamelCase(registry.label);\n    i18nKey = `admin.${registry.provides}.${registryLabel}`;\n    // and if we don\"t find it, we are trying to look at first\n    // registry entry\n  } else if (app && app.registry && app.registry.length &&\n    app.registry[0].label) {\n    registryLabel = toCamelCase(app.registry[0].label);\n    i18nKey = `admin.${app.registry[0].provides}.${registryLabel}`;\n  }\n  registry.i18nKeyLabel = `${i18nKey}Label`;\n  registry.i18nKeyDescription = `${i18nKey}Description`;\n  registry.i18nKeyPlaceholder = `${i18nKey}Placeholder`;\n  registry.i18nKeyTooltip = `${i18nKey}Tooltip`;\n  registry.i18nKeyTitle = `${i18nKey}Title`;\n  // return registry object with added i18n keys\n  return registry;\n}\n\n/**\n * Simple is object check.\n * @param {Object} item item to check if is an object\n * @returns {boolean} return true if object\n */\nexport function isObject(item) {\n  return (item && typeof item === \"object\" && !Array.isArray(item) && item !== null);\n}\n\n/**\n * Helper for Deep merge two objects.\n * @param {Object} target deep merge into this object\n * @param {Object} source merge this object\n * @returns {Object} return deep merged object\n */\nexport function mergeDeep(target, source) {\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, { [key]: {} });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    });\n  }\n  return target;\n}\n","export { default as Catalog } from \"./catalog\";\nexport { default as ReactionProduct } from \"./products\";\nexport { PropTypes } from \"./prop-types\";\nexport * from \"./helpers\";\nexport * from \"./files\";\n","import { Match } from \"meteor/check\";\n\n/**\n * Match.OptionalOrNull\n * See Meteor Match methods\n * @param {String} pattern - match pattern\n * @return {Boolean} matches - void, null, or pattern\n */\nMatch.OptionalOrNull = function (pattern) {\n  return Match.OneOf(void 0, null, pattern);\n};\n\n/**\n * Match.OrderHookOption\n * See Meteor Match methods\n * @return {Boolean} matches - void, null, or pattern\n */\nMatch.OrderHookOptions = function () {\n  return Match.OneOf(Object);\n};\n","import i18next from \"i18next\";\nimport orderBy from \"lodash/orderBy\";\nimport { Meteor } from \"meteor/meteor\";\nimport { ReactiveDict } from \"meteor/reactive-dict\";\nimport { Router } from \"/imports/plugins/core/router/lib\";\nimport { getCurrentTag, getShopName } from \"/lib/api\";\nimport { Products, Revisions } from \"/lib/collections\";\nimport Catalog from \"./catalog\";\nimport { MetaData } from \"/lib/api/router/metadata\";\n\n// ReactionProduct is only intended to be used on the client, but it's placed\n// in common code because of it is imported by the Products schema\n\n/**\n *  currentProduct\n *  @summary Reactive current product dependency, ensuring reactive products, without session\n *  @todo this is a messy class implementation, normalize it.\n *  @description\n *  products:\n\n */\nconst ReactionProduct = new ReactiveDict(\"currentProduct\");\n\nexport function applyProductRevision(product) {\n  if (product) {\n    if (product.__revisions && product.__revisions.length) {\n      const cleanProduct = Object.assign({}, product);\n      delete cleanProduct.__revisions;\n      let revisedProduct;\n      // check for product revisions and set that as the current product\n      for (const revision of product.__revisions) {\n        if (!revision.parentDocument) {\n          revisedProduct = product.__revisions[0].documentData;\n        }\n      }\n\n      // if there are no revision to product (image and/or tag only) just set the original product as the product\n      if (!revisedProduct) {\n        revisedProduct = cleanProduct;\n      }\n      return Object.assign({},\n        revisedProduct,\n        {\n          __published: cleanProduct,\n          __draft: product.__revisions[0]\n        }\n      );\n    }\n    return product;\n  }\n\n  return null;\n}\n\nReactionProduct.sortProducts = (products, tag) => {\n  let sorted = [];\n\n  sorted = orderBy(products,\n    // Sort by postion for tag\n    (product) => {\n      return product.positions && product.positions[tag] && product.positions[tag].position;\n    },\n    // Then by creation date for tag\n    (product) => {\n      return product.positions && product.positions[tag] && product.positions[tag].createdAt;\n    },\n    // Finally sort by creation date\n    \"createdAt\"\n  );\n\n  return sorted;\n};\n\n/**\n * setCurrentVariant\n * @param {String} variantId - set current variantId\n * @return {undefined}\n */\nReactionProduct.setCurrentVariant = (variantId) => {\n  if (variantId === null) {\n    ReactionProduct.set(\"variantId\", null);\n    ReactionProduct.set(\"variantId\", ReactionProduct.selectedVariantId());\n  }\n  if (!variantId) {\n    return;\n  }\n  const currentId = ReactionProduct.selectedVariantId();\n  if (currentId === variantId) {\n    return;\n  }\n  ReactionProduct.set(\"variantId\", variantId);\n};\n\n/**\n * ReactionProduct.setProduct\n * this will be deprecated in favor of template.instance data.\n *\n * @summary method to set default/parameterized product variant\n * @param {String} currentProductId - set current productId\n * @param {String} currentVariantId - set current variantId\n * @return {Object} product object\n */\nReactionProduct.setProduct = (currentProductId, currentVariantId) => {\n  let productId = currentProductId || Router.getParam(\"handle\");\n  let variantId = currentVariantId || Router.getParam(\"variantId\");\n\n  // Find the current product\n  const product = Products.findOne({\n    $or: [\n      { handle: productId.toLowerCase() }, // Try the handle (slug) lowercased\n      { handle: productId }, // Otherwise try the handle (slug) untouched\n      { _id: productId } // Last attempt, try the product id\n    ]\n  });\n\n  productId = product && product._id;\n\n  if (product) {\n    // set the default variant\n    // as the default.\n    if (!variantId) {\n      const variants = ReactionProduct.getTopVariants(productId);\n      variantId = Array.isArray(variants) && variants.length &&\n        variants[0]._id || null;\n    }\n    // set in our reactive dictionary\n    ReactionProduct.set(\"productId\", productId);\n    ReactionProduct.set(\"variantId\", variantId);\n  }\n\n  // Update the meta data when a product is selected\n  MetaData.init(Router.current());\n\n  return applyProductRevision(product);\n};\n\n/**\n * selectedProductId\n * @summary get the currently active/requested product\n * @return {String} currently selected product id\n */\nReactionProduct.selectedProductId = () => ReactionProduct.get(\"productId\");\n\n/**\n * selectedVariantId\n * @summary get the currently active/requested variant\n * @return {String} currently selected variant id\n */\nReactionProduct.selectedVariantId = () => {\n  let id = ReactionProduct.get(\"variantId\");\n  if (id !== null) {\n    return id;\n  }\n  const variants = ReactionProduct.getVariants();\n\n  if (!(variants.length > 0)) {\n    return [];\n  }\n\n  id = variants[0]._id;\n  // ReactionProduct.set(\"variantId\", id);\n  return id;\n};\n\n/**\n * selectedVariant\n * @summary get the currently active/requested variant object\n * @return {Object} currently selected variant object\n */\nReactionProduct.selectedVariant = function () {\n  const id = ReactionProduct.selectedVariantId();\n  if (typeof id === \"string\") {\n    return applyProductRevision(Products.findOne(id));\n  }\n  return [];\n};\n\n/**\n * selectedProduct\n * @summary get the currently active/requested product object\n * @return {Object|undefined} currently selected product cursor\n */\nReactionProduct.selectedProduct = function () {\n  const id = ReactionProduct.selectedProductId();\n  if (typeof id === \"string\") {\n    return applyProductRevision(Products.findOne(id));\n  }\n  return undefined;\n};\n\n/**\n * checkChildVariants\n * @summary return number of child variants for a parent\n * @param {String} parentVariantId - parentVariantId\n * @return {Number} count of childVariants for this parentVariantId\n */\nReactionProduct.checkChildVariants = function (parentVariantId) {\n  const childVariants = ReactionProduct.getVariants(parentVariantId);\n  return childVariants.length ? childVariants.length : 0;\n};\n\n/**\n * checkInventoryVariants\n * @summary return number of inventory variants for a parent\n * @param {String} parentVariantId - parentVariantId\n * @todo could be combined with checkChildVariants in one method\n * @todo inventoryVariants are deprecated. remove this.\n * @return {Number} count of inventory variants for this parentVariantId\n */\nReactionProduct.checkInventoryVariants = function (parentVariantId) {\n  const inventoryVariants = ReactionProduct.getVariants(parentVariantId, \"inventory\");\n  return inventoryVariants.length ? inventoryVariants.length : 0;\n};\n\n/**\n * getVariantPriceRange\n * @summary get price range of a variant if it has child options.\n * if no child options, return main price value\n * @todo remove string return and replace with object\n * @param {String} [id] - current variant _Id\n * @return {String} formatted price or price range\n */\nReactionProduct.getVariantPriceRange = id => Catalog.\n  getVariantPriceRange(id || ReactionProduct.selectedVariant()._id);\n\n/**\n * getProductPriceRange\n * @summary get price range of a product\n * if no only one price available, return it\n * otherwise return a string range\n * @todo remove string return and replace with object\n * @param {String} [id] - current product _id\n * @return {String} formatted price or price range\n */\nReactionProduct.getProductPriceRange = id => Catalog.\n  getProductPriceRange(id || ReactionProduct.selectedProductId());\n\n/**\n * getVariantQuantity\n * @description middleware method which calls the same named common method.\n * @todo maybe we could remove this after 1.3. But for now I like how it looks.\n * @param {Object} doc - variant object\n * @return {Number} summary of options quantity or top-level variant\n * inventoryQuantity\n */\nReactionProduct.getVariantQuantity = doc => Catalog.getVariantQuantity(doc);\n\n/**\n * @method getVariants\n * @description Get all parent variants\n * @summary could be useful for products and for top level variants\n * @param {String} [id] - product _id\n * @param {String} [type] - type of variant\n * @return {Array} Parent variants or empty array\n */\nReactionProduct.getVariants = (id, type) => {\n  return Catalog.getVariants(id || ReactionProduct.selectedProductId(), type);\n};\n\n/**\n * @method getTopVariants\n * @description Get only product top level variants\n * @param {String} [id] - product _id\n * @return {Array} Product top level variants or empty array\n */\nReactionProduct.getTopVariants = id => {\n  return Catalog.getTopVariants(id || ReactionProduct.selectedProductId());\n};\n\n/**\n * getTag\n * @summary This needed for naming `positions` object. Method could return `tag`\n * route name or shop name as default name.\n * @return {String} tag name or shop name\n */\nReactionProduct.getTag = () => {\n  return getCurrentTag() || getShopName().toLowerCase();\n};\n\n/**\n * getProductsByTag\n * @summary method to return tag specific product\n * @param {String} tag - tag string\n * @return {Object} - return products collection cursor filtered by tag\n */\nReactionProduct.getProductsByTag = function (tag) {\n  let hashtags;\n  let newRelatedTags;\n  let relatedTag;\n  let relatedTags;\n  const selector = {};\n\n  if (tag) {\n    hashtags = [];\n    relatedTags = [tag];\n    while (relatedTags.length) {\n      newRelatedTags = [];\n      for (relatedTag of relatedTags) {\n        if (hashtags.indexOf(relatedTag._id) === -1) {\n          hashtags.push(relatedTag._id);\n        }\n      }\n      relatedTags = newRelatedTags;\n    }\n    selector.hashtags = {\n      $in: hashtags\n    };\n  }\n  const cursor = Products.find(selector);\n  return cursor;\n};\n\n/**\n * publishProduct\n * @summary product publishing and alert\n * @param {Object} productOrArray - product Object\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\nReactionProduct.publishProduct = function (productOrArray) {\n  const products = !_.isArray(productOrArray) ? [productOrArray] : productOrArray;\n  /* eslint no-loop-func: 1 */\n  //\n  // TODO review process for publishing arrays of product\n  //\n  for (const product of products) {\n    Meteor.call(\"products/publishProduct\", product._id, (error, result) => {  // eslint-disable-line no-loop-func\n      if (error) {\n        Alerts.add(error, \"danger\", {\n          placement: \"productGridItem\",\n          id: product._id\n        });\n        throw new Meteor.Error(\"error publishing product\", error);\n      }\n      const alertSettings = {\n        placement: \"productGridItem\",\n        id: product._id,\n        autoHide: true,\n        dismissable: false\n      };\n      if (result) {\n        Alerts.add(i18next.t(\"productDetail.publishProductVisible\", { product: product.title }), \"success\", alertSettings);\n      } else {\n        Alerts.add(i18next.t(\"productDetail.publishProductHidden\", { product: product.title }), \"warning\", alertSettings);\n      }\n    });\n  }\n};\n\n/**\n * publishProduct\n * @summary product publishing and alert\n * @param {Object} productOrArray - product Object\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\nReactionProduct.toggleVisibility = function (productOrArray) {\n  const products = !_.isArray(productOrArray) ? [productOrArray] : productOrArray;\n  for (const product of products) {\n    Meteor.call(\"products/toggleVisibility\", product._id, (error, result) => { // eslint-disable-line no-loop-func\n      if (error) {\n        Alerts.add(error, \"danger\", {\n          placement: \"productGridItem\",\n          id: product._id\n        });\n        throw new Meteor.Error(\"error publishing product\", error);\n      }\n      const alertSettings = {\n        placement: \"productGridItem\",\n        id: product._id,\n        autoHide: true,\n        dismissable: false\n      };\n      if (result) {\n        Alerts.add(i18next.t(\"productDetail.publishProductVisible\", { product: product.title }), \"success\", alertSettings);\n      } else {\n        Alerts.add(i18next.t(\"productDetail.publishProductHidden\", { product: product.title }), \"warning\", alertSettings);\n      }\n    });\n  }\n};\n\n\n/**\n * cloneProduct\n * @summary product cloning and alert\n * @param {Object|Array} productOrArray - if this method calls from productGrid\n * it receives and array with product _id or _ids, but if it calls from PDP, when\n * it receive a `Object` with _id. It needed to determine the source of call.\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\nReactionProduct.cloneProduct = function (productOrArray) {\n  const products = !Array.isArray(productOrArray) ? [productOrArray] : productOrArray;\n\n  return Meteor.call(\"products/cloneProduct\", products, function (error, result) {\n    if (error) {\n      Alerts.add(error, \"danger\", { placement: \"productGridItem\" });\n      throw new Meteor.Error(\"error cloning product\", error);\n    }\n    if (result) {\n      if (products.length === 1) {\n        Alerts.add(i18next.t(\"productDetail.clonedAlert\", { product: products[0].title }), \"success\", {\n          placement: \"productGridItem\",\n          id: products[0]._id,\n          autoHide: true,\n          dismissable: false\n        });\n      } else {\n        Alerts.add(i18next.t(\"productDetail.clonedAlert_plural\", { product: i18next.t(\"productDetail.theSelectedProducts\"), count: 0 }),\n          \"success\", {\n            placement: \"productGridItem\",\n            id: products[0]._id,\n            autoHide: true,\n            dismissable: false\n          }\n        );\n      }\n    }\n    // this statement allow us to redirect to a new clone PDP if clone action\n    // was fired within PDP, not within productGrid.\n    if (!Array.isArray(productOrArray)) {\n      Router.go(\"product\", {\n        handle: result[0]\n      });\n    }\n  });\n};\n\n/**\n * archiveProduct\n * @summary confirm to archive product\n * @param {Object} productOrArray - product Object\n * @returns {undefined} - returns nothing, and alerts, happen here\n */\nReactionProduct.archiveProduct = function (productOrArray) {\n  const products = !_.isArray(productOrArray) ? [productOrArray] : productOrArray;\n  const productIds = _.map(products, product => typeof product === \"string\" ? product : product._id);\n  let confirmTitle;\n  // we have to use so difficult logic with `length` check because of some\n  // languages, which have different phrase forms for each of cases.\n  // we are using i18next `plural` functionality here.\n  // @see: http://i18next.com/translate/pluralSimple\n  if (products.length === 1) {\n    confirmTitle = i18next.t(\"productDetailEdit.archiveThisProduct\");\n  } else {\n    confirmTitle = i18next.t(\"productDetailEdit.archiveSelectedProducts\");\n  }\n\n  Alerts.alert({\n    title: confirmTitle,\n    type: \"warning\",\n    showCancelButton: true,\n    confirmButtonText: \"Archive\"\n  }, (isConfirm) => {\n    if (isConfirm) {\n      Meteor.call(\"products/archiveProduct\", productIds, function (error, result) {\n        let title;\n        if (error) {\n          title = products.length === 1 ?\n            products[0].title || i18next.t(\"productDetail.archiveErrorTheProduct\") :\n            i18next.t(\"productDetail.theSelectedProducts\");\n          Alerts.toast(i18next.t(\"productDetail.productArchiveError\", { product: title }), \"error\");\n          throw new Meteor.Error(\"Error archiving \" + title, error);\n        }\n        if (result) {\n          Router.go(\"/\");\n          if (products.length === 1) {\n            title = products[0].title || i18next.t(\"productDetail.theProduct\");\n            Alerts.toast(i18next.t(\"productDetail.archivedAlert\", { product: title }), \"info\");\n          } else {\n            title = i18next.t(\"productDetail.theSelectedProducts\");\n            Alerts.toast(i18next.t(\"productDetail.archivedAlert_plural\", { product: title, count: 0 }), \"info\");\n          }\n        }\n      });\n    }\n  });\n};\n\nReactionProduct.isAncestorDeleted = function (product, includeSelf) {\n  const productIds = [\n    ...product.ancestors // Avoid mutations\n  ];\n\n  if (includeSelf) {\n    productIds.push(product._id);\n  }\n\n  // Verify there are no deleted ancestors,\n  // Variants cannot be restored if their parent product / variant is deleted\n  const archivedCount = Revisions.find({\n    \"documentId\": { $in: productIds },\n    \"documentData.isDeleted\": true,\n    \"workflow.status\": {\n      $nin: [\n        \"revision/published\"\n      ]\n    }\n  }).count();\n\n  if (archivedCount > 0) {\n    return true;\n  }\n\n  return false;\n};\n\nexport default ReactionProduct;\n","import _ from \"lodash\";\nimport * as Schemas from \"/lib/collections/schemas\";\n\nconst TagSchema = Schemas.Tag.newContext();\n\nexport const PropTypes = {};\n\n/**\n * React Component propType validator for a single Tag\n * @param  {Object} props An object containing all props passed into the component\n * @param  {String} propName Name of prop to validate\n * @return {Error|undefined} returns an error if validation us unseccessful\n */\nPropTypes.Tag = (props, propName) => {\n  check(props, Object);\n  check(propName, String);\n\n  if (_.isEmpty(props[propName]) === false) {\n    if (TagSchema.validate(props[propName]) === false) {\n      return new Error(\"Tag must be of type: Schemas.Tag\");\n    }\n  }\n};\n\n/**\n * React Component propType validator for an array of Tags\n * @param  {Object} props An object containing all props passed into the component\n * @param  {String} propName Name of prop to validate\n * @return {Error|undefined} returns an error if validation us unseccessful\n */\nPropTypes.arrayOfTags = (props, propName) => {\n  check(props, Object);\n  check(propName, String);\n\n  if (_.isEmpty(props[propName]) === false && _.isArray(props[propName])) {\n    const valid = _.every(props[propName], (tag) => {\n      return TagSchema.validate(tag);\n    });\n\n    if (valid === false) {\n      return new Error(\"Objects in array must be of type: Schemas.Tag\");\n    }\n  }\n};\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { shopIdAutoValue } from \"./helpers\";\nimport { Address } from \"./address\";\nimport { Metafield } from \"./metafield\";\n\n/**\n * Accounts Schemas\n */\n\nconst TaxSettings = new SimpleSchema({\n  exemptionNo: {\n    type: String,\n    optional: true\n  },\n  customerUsageType: {\n    type: String,\n    optional: true\n  }\n});\n\nexport const Profile = new SimpleSchema({\n  addressBook: {\n    type: [Address],\n    optional: true\n  },\n  name: {\n    type: String,\n    optional: true\n  },\n  picture: {\n    type: String,\n    optional: true\n  }\n});\n\nexport const Email = new SimpleSchema({\n  provides: {\n    type: String,\n    defaultValue: \"default\",\n    optional: true\n  },\n  address: {\n    type: String,\n    regEx: SimpleSchema.RegEx.Email\n  },\n  verified: {\n    type: Boolean,\n    defaultValue: false,\n    optional: true\n  }\n});\n\n/**\n * Reaction Schemas Accounts\n */\n\nexport const Accounts = new SimpleSchema({\n  userId: {\n    type: String,\n    regEx: SimpleSchema.RegEx.Id,\n    index: 1,\n    label: \"Accounts ShopId\"\n  },\n  sessions: {\n    type: [String],\n    optional: true,\n    index: 1\n  },\n  shopId: {\n    type: String,\n    autoValue: shopIdAutoValue,\n    regEx: SimpleSchema.RegEx.Id,\n    index: 1\n  },\n  emails: {\n    type: [Email],\n    optional: true\n  },\n  acceptsMarketing: {\n    type: Boolean,\n    defaultValue: false,\n    optional: true\n  },\n  state: {\n    type: String,\n    defaultValue: \"new\",\n    optional: true\n  },\n  taxSettings: {\n    type: TaxSettings,\n    optional: true\n  },\n  note: {\n    type: String,\n    optional: true\n  },\n  profile: {\n    type: Profile,\n    optional: true\n  },\n  metafields: {\n    type: [Metafield],\n    optional: true\n  },\n  createdAt: {\n    type: Date,\n    autoValue() {\n      if (this.isInsert) {\n        return new Date;\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date\n        };\n      }\n    }\n  },\n  updatedAt: {\n    type: Date,\n    autoValue() {\n      if (this.isUpdate) {\n        return {\n          $set: new Date\n        };\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date\n        };\n      }\n    },\n    optional: true\n  }\n});\n","import { Random } from \"meteor/random\";\nimport { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Metafield } from \"./metafield\";\n\n/**\n* Reaction Schemas Address\n*/\n\nexport const Address = new SimpleSchema({\n  _id: {\n    type: String,\n    defaultValue: Random.id(),\n    optional: true\n  },\n  fullName: {\n    type: String,\n    label: \"Full name\"\n  },\n  address1: {\n    label: \"Address 1\",\n    type: String\n  },\n  address2: {\n    label: \"Address 2\",\n    type: String,\n    optional: true\n  },\n  city: {\n    type: String,\n    label: \"City\"\n  },\n  company: {\n    type: String,\n    label: \"Company\",\n    optional: true\n  },\n  phone: {\n    type: String,\n    label: \"Phone\"\n  },\n  region: {\n    label: \"State/Province/Region\",\n    type: String\n  },\n  postal: {\n    label: \"ZIP/Postal Code\",\n    type: String\n  },\n  country: {\n    type: String,\n    label: \"Country\"\n  },\n  isCommercial: {\n    label: \"This is a commercial address.\",\n    type: Boolean\n  },\n  isBillingDefault: {\n    label: \"Make this your default billing address?\",\n    type: Boolean\n  },\n  isShippingDefault: {\n    label: \"Make this your default shipping address?\",\n    type: Boolean\n  },\n  metafields: {\n    type: [Metafield],\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Roles } from \"meteor/alanning:roles\";\nimport { getShopId } from \"/lib/api\";\nimport { PackageConfig } from \"./registry\";\nimport { shopIdAutoValue } from \"./helpers\";\n\nexport const AnalyticsEvents = new SimpleSchema({\n  \"eventType\": {\n    type: String\n  },\n  \"category\": {\n    type: String,\n    optional: true\n  },\n  \"action\": {\n    type: String,\n    optional: true\n  },\n  \"label\": {\n    type: String,\n    optional: true\n  },\n  \"value\": {\n    type: String,\n    optional: true\n  },\n  \"user\": {\n    type: Object,\n    optional: true\n  },\n  \"user.id\": {\n    type: String,\n    regEx: SimpleSchema.RegEx.Id,\n    optional: true,\n    autoValue: function () {\n      return Meteor.userId();\n    }\n  },\n  \"user.isAnonymous\": {\n    type: Boolean,\n    optional: true,\n    autoValue: function () {\n      return Roles.userIsInRole(Meteor.user(), \"anonymous\", getShopId());\n    }\n  },\n  \"shopId\": {\n    type: String,\n    regEx: SimpleSchema.RegEx.Id,\n    autoValue: shopIdAutoValue,\n    label: \"AnalyticsEvents shopId\"\n  },\n  \"createdAt\": {\n    type: Date,\n    autoValue: function () {\n      return new Date;\n    }\n  },\n  // Any additional data\n  \"data\": {\n    type: Object,\n    blackbox: true,\n    optional: true\n  }\n});\n\n/*\n *   Analytics\n *   api_key: \"UA-XXXXX-X\" (this is your tracking ID)\n */\n\nexport const ReactionAnalyticsPackageConfig = new SimpleSchema([\n  PackageConfig, {\n    \"settings.public.segmentio.enabled\": {\n      type: Boolean,\n      label: \"Enabled\"\n    },\n    \"settings.public.segmentio.api_key\": {\n      type: String,\n      label: \"Segment Write Key\",\n      optional: true\n    },\n    \"settings.public.googleAnalytics.enabled\": {\n      type: Boolean,\n      label: \"Enabled\"\n    },\n    \"settings.public.googleAnalytics.api_key\": {\n      type: String,\n      label: \"Google Analytics Tracking ID\",\n      optional: true\n    },\n    \"settings.public.mixpanel.enabled\": {\n      type: Boolean,\n      label: \"Enabled\"\n    },\n    \"settings.public.mixpanel.api_key\": {\n      type: String,\n      label: \"Mixpanel Token\",\n      optional: true\n    }\n  }\n]);\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\nexport const Assets = new SimpleSchema({\n  type: {\n    type: String\n  },\n  name: {\n    type: String,\n    optional: true\n  },\n  /**\n   * namespace for i18n. This allows to load translation for custom plugins\n   */\n  ns: {\n    type: String,\n    optional: true\n  },\n  path: {\n    type: String,\n    optional: true\n  },\n  content: {\n    type: String,\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { shopIdAutoValue } from \"./helpers\";\nimport { Payment } from \"./payments\";\nimport { ProductVariant } from \"./products\";\nimport { Shipment, ShippingParcel } from \"./shipping\";\nimport { Workflow } from \"./workflow\";\n\n/**\n * CartItem Schema\n */\n\nexport const CartItem = new SimpleSchema({\n  _id: {\n    type: String\n  },\n  productId: {\n    type: String,\n    index: 1\n  },\n  shopId: {\n    type: String,\n    autoValue: shopIdAutoValue,\n    index: 1,\n    label: \"Cart Item shopId\",\n    optional: true\n  },\n  quantity: {\n    label: \"Quantity\",\n    type: Number,\n    min: 0\n  },\n  variants: {\n    type: ProductVariant\n  },\n  title: {\n    type: String,\n    label: \"CartItem Title\"\n  },\n  type: {\n    label: \"Product Type\",\n    type: String,\n    optional: true\n  },\n  parcel: { // Currently the parcel is in the simple product schema, so we need to include it here as well. Maybe it should go in productvariant\n    type: ShippingParcel,\n    optional: true\n  },\n  cartItemId: { // Seems strange here but has to be here since we share schemas between cart and order\n    type: String,\n    optional: true\n  }\n});\n\n/**\n * CartItem Schema\n * used in check by inventory/addReserve method\n */\n\nexport const CartItems = new SimpleSchema({\n  items: {\n    type: [CartItem],\n    optional: true\n  }\n});\n\n/**\n * Cart Schema\n */\n\nexport const Cart = new SimpleSchema({\n  _id: { // required for check of users' carts\n    type: String,\n    optional: true\n  },\n  shopId: {\n    type: String,\n    autoValue: shopIdAutoValue,\n    index: 1,\n    label: \"Cart ShopId\"\n  },\n  userId: {\n    type: String,\n    unique: true,\n    autoValue: function () {\n      if (this.isInsert || this.isUpdate) {\n        if (!this.isFromTrustedCode) {\n          return this.userId;\n        }\n      } else {\n        this.unset();\n      }\n    }\n  },\n  sessionId: {\n    type: String,\n    index: 1\n  },\n  email: {\n    type: String,\n    optional: true,\n    index: 1,\n    regEx: SimpleSchema.RegEx.Email\n  },\n  items: {\n    type: [CartItem],\n    optional: true\n  },\n  shipping: {\n    type: [Shipment],\n    optional: true,\n    blackbox: true\n  },\n  billing: {\n    type: [Payment],\n    optional: true,\n    blackbox: true\n  },\n  tax: {\n    type: Number,\n    decimal: true,\n    optional: true\n  },\n  taxes: {\n    type: [Object],\n    optional: true,\n    blackbox: true\n  },\n  discount: {\n    type: Number,\n    decimal: true,\n    optional: true\n  },\n  workflow: {\n    type: Workflow,\n    optional: true\n  },\n  createdAt: {\n    type: Date,\n    autoValue: function () {\n      if (this.isInsert) {\n        return new Date;\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date\n        };\n      }\n    },\n    denyUpdate: true\n  },\n  updatedAt: {\n    type: Date,\n    autoValue: function () {\n      if (this.isUpdate) {\n        return {\n          $set: new Date\n        };\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date\n        };\n      }\n    },\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\nexport const Emails = new SimpleSchema({\n  to: {\n    type: String\n  },\n\n  from: {\n    type: String\n  },\n\n  subject: {\n    type: String\n  },\n\n  text: {\n    type: String,\n    optional: true\n  },\n\n  html: {\n    type: String,\n    optional: true\n  },\n\n  userId: {\n    type: String,\n    optional: true\n  },\n\n  jobId: {\n    type: String,\n    index: true\n  },\n\n  type: {\n    type: String,\n    optional: true\n  },\n\n  status: {\n    type: String\n  },\n\n  createdAt: {\n    type: Date,\n    autoValue() {\n      if (this.isInsert) {\n        return new Date();\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date()\n        };\n      }\n      return this.unset();\n    }\n  },\n\n  updatedAt: {\n    type: Date,\n    autoValue() {\n      if (this.isUpdate) {\n        return new Date();\n      }\n      return this.unset();\n    },\n    denyInsert: true,\n    optional: true\n  }\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Random } from \"meteor/random\";\nimport { getShopId } from \"/lib/api\";\n\n/**\n * shopIdAutoValue\n * @summary used for schema injection autoValue\n * @example autoValue: shopIdAutoValue\n * @return {String} returns current shopId\n */\nexport function shopIdAutoValue() {\n  // we should always have a shopId\n  if (this.isSet && Meteor.isServer) {\n    return this.value;\n  } else if (Meteor.isServer && !this.isUpdate || Meteor.isClient && this.isInsert) {\n    return getShopId();\n  }\n  return this.unset();\n}\n\n/**\n * schemaIdAutoValue\n * @summary used for schema injection autoValue\n * @example autoValue: schemaIdAutoValue\n * @return {String} returns randomId\n */\nexport function schemaIdAutoValue() {\n  if (this.isSet && Meteor.isServer) {\n    return this.value;\n  } else if (Meteor.isServer && this.operator !== \"$pull\" ||\n    Meteor.isClient && this.isInsert) {\n    return Random.id();\n  }\n  return this.unset();\n}\n","export * from \"./accounts\";\nexport * from \"./address\";\nexport * from \"./analytics\";\nexport * from \"./assets\";\nexport * from \"./cart\";\nexport * from \"./emails\";\nexport * from \"./inventory\";\nexport * from \"./layouts\";\nexport * from \"./logs\";\nexport * from \"./metafield\";\nexport * from \"./notifications\";\nexport * from \"./orders\";\nexport * from \"./payments\";\nexport * from \"./products\";\nexport * from \"./registry\";\nexport * from \"./revisions\";\nexport * from \"./shipping\";\nexport * from \"./shops\";\nexport * from \"./sms\";\nexport * from \"./social\";\nexport * from \"./tags\";\nexport * from \"./templates\";\nexport * from \"./themes\";\nexport * from \"./translations\";\nexport * from \"./workflow\";\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { shopIdAutoValue } from \"./helpers\";\nimport { Document, Notes } from \"./orders\";\nimport { Metafield } from \"./metafield\";\nimport { Workflow } from \"./workflow\";\n\nexport const Inventory = new SimpleSchema({\n  _id: {\n    type: String,\n    optional: true // inserted by mongo, we need it for schema validation\n  },\n  shopId: {\n    type: String,\n    autoValue: shopIdAutoValue,\n    index: 1,\n    label: \"Inventory ShopId\"\n  },\n  productId: {\n    type: String,\n    index: true\n  },\n  variantId: {\n    type: String,\n    index: true\n  },\n  orderItemId: {\n    type: String,\n    index: true,\n    optional: true\n  },\n  workflow: {\n    type: Workflow,\n    optional: true\n  },\n  sku: {\n    label: \"sku\",\n    type: String,\n    optional: true\n  },\n  metafields: {\n    type: [Metafield],\n    optional: true\n  },\n  documents: {\n    type: [Document],\n    optional: true\n  },\n  notes: {\n    type: [Notes],\n    optional: true\n  },\n  createdAt: {\n    type: Date,\n    optional: true, // schema validation failing in method with this required. should be considered temporary.\n    autoValue: function () {\n      if (this.isInsert || this.isUpdate && !this.isSet) {\n        return new Date;\n      }\n      this.unset();\n    }\n  },\n  updatedAt: {\n    type: Date,\n    autoValue: function () {\n      return new Date;\n    },\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\n/**\n * @summary Layout Schema\n * Layout are used by the Shops and Packages schemas.\n * They are used to defin both the template layout on the site,\n * as well as the workflow components that will be used in each\n * layout block.\n *\n *  \"layout\": \"coreLayout\",\n *  \"workflow\": \"coreWorkflow\",\n *  \"theme\": \"default\",\n *  \"enabled\": true,\n *  \"structure\": {\n *   \"template\": \"products\",\n *   \"layoutHeader\": \"layoutHeader\",\n *   \"layoutFooter\": \"layoutFooter\",\n *   \"notFound\": \"notFound\",\n *   \"dashboardControls\": \"dashboardControls\",\n *   \"adminControlsFooter\": \"adminControlsFooter\"\n */\n\nexport const LayoutStructure = new SimpleSchema({\n  template: {\n    type: String,\n    optional: true,\n    index: true\n  },\n  layoutHeader: {\n    type: String,\n    optional: true,\n    index: true\n  },\n  layoutFooter: {\n    type: String,\n    optional: true,\n    index: true\n  },\n  notFound: {\n    type: String,\n    optional: true,\n    index: true\n  },\n  dashboardHeader: {\n    type: String,\n    optional: true,\n    index: true\n  },\n  dashboardControls: {\n    type: String,\n    optional: true,\n    index: true\n  },\n  dashboardHeaderControls: {\n    type: String,\n    optional: true,\n    index: true\n  },\n  adminControlsFooter: {\n    type: String,\n    optional: true,\n    index: true\n  }\n});\n\nexport const Layout = new SimpleSchema({\n  layout: {\n    type: String,\n    optional: true,\n    index: true\n  },\n  workflow: {\n    type: String,\n    optional: true\n  },\n  template: {\n    type: String,\n    optional: true\n  },\n  collection: {\n    type: String,\n    optional: true\n  },\n  theme: {\n    type: String,\n    optional: true\n  },\n  enabled: {\n    type: Boolean,\n    defaultValue: true\n  },\n  status: {\n    type: String,\n    optional: true\n  },\n  label: {\n    type: String,\n    optional: true\n  },\n  container: {\n    type: String,\n    optional: true\n  },\n  audience: {\n    type: [String],\n    optional: true\n  },\n  structure: {\n    type: LayoutStructure,\n    optional: true\n  },\n  priority: {\n    type: Number,\n    optional: true,\n    defaultValue: 999\n  },\n  position: {\n    type: Number,\n    optional: true,\n    defaultValue: 1\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\nexport const Logs = new SimpleSchema({\n\n  logType: {\n    type: String\n  },\n  shopId: {\n    type: String\n  },\n  level: {\n    type: String,\n    defaultValue: \"info\",\n    allowedValues: [\"trace\", \"debug\", \"info\", \"warn\", \"error\", \"fatal\"]\n  },\n  source: {\n    type: String,\n    defaultValue: \"server\",\n    allowedValues: [\"client\", \"server\"]\n  },\n  handled: {\n    type: Boolean,\n    defaultValue: false\n  },\n  data: {\n    type: Object,\n    blackbox: true\n  },\n  date: {\n    type: Date,\n    autoValue() { return new Date(); }\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\n/**\n * Metafield Schema\n */\n\nexport const Metafield = new SimpleSchema({\n  key: {\n    type: String,\n    max: 30,\n    optional: true\n  },\n  namespace: {\n    type: String,\n    max: 20,\n    optional: true\n  },\n  scope: {\n    type: String,\n    optional: true\n  },\n  value: {\n    type: String,\n    optional: true\n  },\n  valueType: {\n    type: String,\n    optional: true\n  },\n  description: {\n    type: String,\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\n\nexport const Notification = new SimpleSchema({\n  message: {\n    type: String,\n    optional: false\n  },\n  /**\n   * Type              Message(This would be the corresponding message)\n   * ----------------| -----------------------------------------------\n   * orderCancelled  | \"Your order was canceled.\"\n   * forAdmin:       | \"You have a new order.\"\n   * newOrder:       | \"Your order is being processed.\"\n   * orderDelivered: | \"Your order has been delivered.\"\n   * orderAccepted:  | \"Your order has been accepted.\"\n   * orderShipped:   | \"Your order has been shipped.\"\n   */\n  type: {\n    type: String,\n    optional: false\n  },\n  url: {\n    type: String,\n    optional: false\n  },\n  to: {\n    type: String,\n    optional: false\n  },\n  hasDetails: {\n    type: Boolean,\n    optional: false\n  },\n  details: {\n    type: String,\n    optional: true\n  },\n  status: {\n    type: String,\n    optional: false,\n    defaultValue: \"unread\"\n  },\n  timeSent: {\n    type: Date,\n    optional: false,\n    autoValue: function () {\n      if (this.isInsert) {\n        return new Date();\n      } else if (this.isUpsert) {\n        return { $setOnInsert: new Date() };\n      }\n      this.unset();\n    }\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Workflow } from \"./workflow\";\n\n/**\n * Order Document Schema\n */\n\nexport const Document = new SimpleSchema({\n  docId: {\n    type: String\n  },\n  docType: {\n    type: String,\n    optional: true\n  }\n});\n\n/**\n * Order History Schema\n */\n\nexport const History = new SimpleSchema({\n  event: {\n    type: String\n  },\n  value: {\n    type: String\n  },\n  userId: {\n    type: String\n  },\n  updatedAt: {\n    type: Date\n  }\n});\n\n/**\n * Order Notes Schema\n */\n\nexport const Notes = new SimpleSchema({\n  content: {\n    type: String\n  },\n  userId: {\n    type: String\n  },\n  updatedAt: {\n    type: Date\n  }\n});\n\n/**\n * OrderItems Schema\n * merges with Cart and Order to create Orders collection\n */\nexport const OrderItem = new SimpleSchema({\n  additionalField: {\n    type: String,\n    optional: true\n  },\n  workflow: {\n    type: Workflow,\n    optional: true\n  },\n  history: {\n    type: [History],\n    optional: true\n  },\n  documents: {\n    type: [Document],\n    optional: true\n  }\n});\n\n\n/**\n * OrderTransaction Schema\n * order transactions tie shipping, billing, and inventory transactions\n */\nexport const OrderTransaction = new SimpleSchema({\n  itemId: {\n    type: String,\n    optional: true\n  },\n  paymentId: {\n    type: String,\n    optional: true\n  },\n  shipmentId: {\n    type: String,\n    optional: true\n  },\n  inventoryId: {\n    type: String,\n    optional: true\n  },\n  createdAt: {\n    type: Date,\n    autoValue: function () {\n      if (this.isUpdate && !this.isSet) {\n        return new Date;\n      }\n      this.unset();\n    },\n    denyUpdate: true\n  }\n});\n\n/**\n * Order Schema\n */\nexport const Order = new SimpleSchema({\n  userId: {\n    type: String,\n    unique: false\n  },\n  cartId: {\n    type: String,\n    optional: true\n  },\n  history: {\n    type: [History],\n    optional: true\n  },\n  documents: {\n    type: [Document],\n    optional: true\n  },\n  notes: {\n    type: [Notes],\n    optional: true\n  },\n  items: {\n    type: [OrderItem],\n    optional: true\n  },\n  transactions: {\n    type: [OrderTransaction],\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { schemaIdAutoValue } from \"./helpers\";\nimport { Address } from \"./address\";\nimport { Workflow } from \"./workflow\";\n\n/**\n * PaymentMethod Schema\n */\n\nexport const PaymentMethod = new SimpleSchema({\n  processor: {\n    type: String\n  },\n  paymentPackageId: {\n    type: String\n  },\n  paymentSettingsKey: {\n    type: String\n  },\n  storedCard: {\n    type: String,\n    optional: true\n  },\n  method: {\n    type: String,\n    allowedValues: [\"credit\", \"debit\", \"shipping-credit\"],\n    optional: true\n  },\n  transactionId: {\n    type: String\n  },\n  metadata: {\n    type: Object,\n    optional: true,\n    blackbox: true\n  },\n  workflow: {\n    type: Workflow,\n    optional: true\n  },\n  status: {\n    type: String\n  },\n  mode: {\n    type: String,\n    allowedValues: [\"authorize\", \"capture\", \"refund\", \"cancel\", \"void\"]\n  },\n  createdAt: {\n    type: Date,\n    autoValue: function () {\n      if (this.isInsert) {\n        return new Date;\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date\n        };\n      }\n    },\n    denyUpdate: true\n  },\n  updatedAt: {\n    type: Date,\n    optional: true\n  },\n  authorization: {\n    type: String,\n    optional: true\n  },\n  amount: {\n    type: Number,\n    decimal: true,\n    optional: true\n  },\n  currency: {\n    type: String,\n    optional: true\n  },\n  transactions: {\n    type: [Object],\n    optional: true,\n    blackbox: true\n  }\n});\n\n/**\n * Invoice Schema\n */\n\nexport const Invoice = new SimpleSchema({\n  transaction: {\n    type: String,\n    optional: true\n  },\n  shipping: {\n    type: Number,\n    decimal: true,\n    optional: true\n  },\n  taxes: {\n    type: Number,\n    decimal: true,\n    optional: true\n  },\n  subtotal: {\n    type: Number,\n    decimal: true\n  },\n  discounts: {\n    type: Number,\n    decimal: true,\n    optional: true\n  },\n  total: {\n    type: Number,\n    decimal: true\n  }\n});\n\n/**\n * Currency Schema\n */\n\nexport const Currency = new SimpleSchema({\n  userCurrency: {\n    type: String,\n    optional: true\n  },\n  exchangeRate: {\n    type: Number,\n    decimal: true,\n    optional: true\n  }\n});\n\n/**\n * Payment Schema\n */\n\nexport const Payment = new SimpleSchema({\n  _id: {\n    type: String,\n    label: \"Payment Id\",\n    autoValue: schemaIdAutoValue\n  },\n  address: {\n    type: Address,\n    optional: true\n  },\n  paymentMethod: {\n    type: PaymentMethod,\n    optional: true\n  },\n  invoice: {\n    type: Invoice,\n    optional: true\n  },\n  currency: {\n    type: Currency,\n    optional: true,\n    defaultValue: \"USD\"\n  }\n});\n\nexport const Refund = new SimpleSchema({\n  type: {\n    type: String\n  },\n  amount: {\n    type: Number,\n    decimal: true\n  },\n  created: {\n    type: Number\n  },\n  currency: {\n    type: String\n  },\n  raw: {\n    type: Object,\n    optional: true,\n    blackbox: true\n  }\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Random } from \"meteor/random\";\nimport { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { ReactionProduct, getSlug } from \"/lib/api\";\nimport { shopIdAutoValue } from \"./helpers\";\nimport { Metafield } from \"./metafield\";\nimport { ShippingParcel } from \"./shipping\";\nimport { Workflow } from \"./workflow\";\n\n\n/**\n * VariantMedia Schema\n */\nexport const VariantMedia = new SimpleSchema({\n  mediaId: {\n    type: String,\n    optional: true\n  },\n  priority: {\n    type: Number,\n    optional: true\n  },\n  metafields: {\n    type: [Metafield],\n    optional: true\n  },\n  updatedAt: {\n    type: Date,\n    optional: true\n  },\n  createdAt: {\n    type: Date,\n    autoValue: function () {\n      if (this.isInsert) {\n        return new Date;\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date\n        };\n      }\n    },\n    denyUpdate: true\n  }\n});\n\n/**\n * ProductPosition Schema\n */\nexport const ProductPosition = new SimpleSchema({\n  tag: {\n    type: String,\n    optional: true\n  },\n  position: {\n    type: Number,\n    optional: true\n  },\n  pinned: {\n    type: Boolean,\n    optional: true\n  },\n  weight: {\n    type: Number,\n    optional: true,\n    defaultValue: 0,\n    min: 0,\n    max: 3\n  },\n  updatedAt: {\n    type: Date\n  }\n});\n\n/**\n * ProductVariant Schema\n */\nexport const ProductVariant = new SimpleSchema({\n  _id: {\n    type: String,\n    label: \"Variant ID\"\n  },\n  ancestors: {\n    type: [String],\n    defaultValue: []\n  },\n  // since implementing of flattened model this property is used for keeping\n  // array index. This is needed for moving variants through list (drag'n'drop)\n  index: {\n    label: \"Variant position number in list\",\n    type: Number,\n    optional: true\n  },\n  isVisible: {\n    type: Boolean,\n    index: 1,\n    defaultValue: false\n  },\n  isDeleted: {\n    type: Boolean,\n    index: 1,\n    defaultValue: false\n  },\n  barcode: {\n    label: \"Barcode\",\n    type: String,\n    optional: true,\n    custom: function () {\n      if (Meteor.isClient) {\n        if (this.siblingField(\"type\").value === \"inventory\" && !this.value) {\n          return \"required\";\n        }\n      }\n    }\n  },\n  compareAtPrice: {\n    label: \"MSRP\",\n    type: Number,\n    optional: true,\n    decimal: true,\n    min: 0,\n    defaultValue: 0.00\n  },\n  fulfillmentService: {\n    label: \"Fulfillment service\",\n    type: String,\n    optional: true\n  },\n  weight: {\n    label: \"Weight\",\n    type: Number,\n    min: 0,\n    optional: true,\n    defaultValue: 0,\n    custom: function () {\n      if (Meteor.isClient) {\n        if (!(this.siblingField(\"type\").value === \"inventory\" || this.value ||\n          this.value === 0)) {\n          return \"required\";\n        }\n      }\n    }\n  },\n  length: {\n    label: \"Length\",\n    type: Number,\n    min: 0,\n    optional: true,\n    defaultValue: 0\n  },\n  width: {\n    label: \"Width\",\n    type: Number,\n    min: 0,\n    optional: true,\n    defaultValue: 0\n  },\n  height: {\n    label: \"Height\",\n    type: Number,\n    min: 0,\n    optional: true,\n    defaultValue: 0\n  },\n  inventoryManagement: {\n    type: Boolean,\n    label: \"Inventory Tracking\",\n    optional: true,\n    defaultValue: true,\n    custom: function () {\n      if (Meteor.isClient) {\n        if (!(this.siblingField(\"type\").value === \"inventory\" || this.value ||\n          this.value === false)) {\n          return \"required\";\n        }\n      }\n    }\n  },\n  // this represents an ability to sell item without keeping it on stock. In\n  // other words if it is disabled, then you can sell item even if it is not in\n  // stock.\n  inventoryPolicy: {\n    type: Boolean,\n    label: \"Deny when out of stock\",\n    optional: true,\n    defaultValue: false,\n    custom: function () {\n      if (Meteor.isClient) {\n        if (!(this.siblingField(\"type\").value === \"inventory\" || this.value ||\n          this.value === false)) {\n          return \"required\";\n        }\n      }\n    }\n  },\n  lowInventoryWarningThreshold: {\n    type: Number,\n    label: \"Warn at\",\n    min: 0,\n    optional: true,\n    defaultValue: 0\n  },\n  inventoryQuantity: {\n    type: Number,\n    label: \"Quantity\",\n    optional: true,\n    defaultValue: 0,\n    min: 0,\n    custom: function () {\n      if (Meteor.isClient) {\n        if (this.siblingField(\"type\").value !== \"inventory\") {\n          if (ReactionProduct.checkChildVariants(this.docId) === 0 && !this.value) {\n            return \"required\";\n          }\n        }\n      }\n    }\n  },\n  minOrderQuantity: {\n    label: \"Minimum order quantity\",\n    type: Number,\n    optional: true\n  },\n  // Denormalized field: Indicates when at least one of variants\n  // `inventoryQuantity` are lower then their `lowInventoryWarningThreshold`.\n  // This is some kind of marketing course.\n  isLowQuantity: {\n    label: \"Indicates that the product quantity is too low\",\n    type: Boolean,\n    optional: true\n  },\n  // Denormalized field: Indicates when all variants `inventoryQuantity` is zero\n  isSoldOut: {\n    label: \"Indicates when the product quantity is zero\",\n    type: Boolean,\n    optional: true\n  },\n  price: {\n    label: \"Price\",\n    type: Number,\n    decimal: true,\n    defaultValue: 0.00,\n    min: 0\n  },\n  shopId: {\n    type: String,\n    autoValue: shopIdAutoValue,\n    index: 1,\n    label: \"Variant ShopId\"\n  },\n  sku: {\n    label: \"SKU\",\n    type: String,\n    optional: true\n  },\n  type: {\n    label: \"Type\",\n    type: String,\n    defaultValue: \"variant\"\n  },\n  taxable: {\n    label: \"Taxable\",\n    type: Boolean,\n    defaultValue: true,\n    optional: true\n  },\n  taxCode: {\n    label: \"Tax Code\",\n    type: String,\n    defaultValue: \"0000\",\n    optional: true\n  },\n  taxDescription: {\n    type: String,\n    optional: true,\n    label: \"Tax Description\"\n  },\n  // Label for customers\n  title: {\n    label: \"Label\",\n    type: String,\n    defaultValue: \"\"\n  },\n  // Option internal name\n  optionTitle: {\n    label: \"Option\",\n    type: String,\n    optional: true,\n    defaultValue: \"Untitled Option\"\n  },\n  metafields: {\n    type: [Metafield],\n    optional: true\n  },\n  createdAt: {\n    label: \"Created at\",\n    type: Date,\n    optional: true\n  },\n  updatedAt: {\n    label: \"Updated at\",\n    type: Date,\n    optional: true\n  },\n  workflow: {\n    type: Workflow,\n    optional: true\n  },\n  originCountry: {\n    type: String,\n    optional: true\n  }\n});\n\nexport const PriceRange = new SimpleSchema({\n  range: {\n    type: String,\n    defaultValue: \"0.00\"\n  },\n  min: {\n    type: Number,\n    decimal: true,\n    defaultValue: 0,\n    optional: true\n  },\n  max: {\n    type: Number,\n    decimal: true,\n    defaultValue: 0,\n    optional: true\n  }\n});\n\n/**\n * Product Schema\n */\nexport const Product = new SimpleSchema({\n  _id: {\n    type: String,\n    label: \"Product Id\"\n  },\n  ancestors: {\n    type: [String],\n    defaultValue: []\n  },\n  shopId: {\n    type: String,\n    autoValue: shopIdAutoValue,\n    index: 1,\n    label: \"Product ShopId\"\n  },\n  title: {\n    type: String,\n    defaultValue: \"\",\n    label: \"Product Title\"\n  },\n  pageTitle: {\n    type: String,\n    optional: true\n  },\n  description: {\n    type: String,\n    optional: true\n  },\n  originCountry: {\n    type: String,\n    optional: true\n  },\n  type: {\n    label: \"Type\",\n    type: String,\n    defaultValue: \"simple\"\n  },\n  vendor: {\n    type: String,\n    optional: true\n  },\n  metafields: {\n    type: [Metafield],\n    optional: true\n  },\n  positions: {\n    type: Object, // ProductPosition\n    blackbox: true,\n    optional: true\n  },\n  // Denormalized field: object with range string, min and max\n  price: {\n    label: \"Price\",\n    type: PriceRange\n  },\n  // Denormalized field: Indicates when at least one of variants\n  // `inventoryQuantity` are lower then their `lowInventoryWarningThreshold`.\n  // This is some kind of marketing course.\n  isLowQuantity: {\n    label: \"Indicates that the product quantity is too low\",\n    type: Boolean,\n    optional: true\n  },\n  // Denormalized field: Indicates when all variants `inventoryQuantity` is zero\n  isSoldOut: {\n    label: \"Indicates when the product quantity is zero\",\n    type: Boolean,\n    optional: true\n  },\n  // Denormalized field. It is `true` if product not in stock, but customers\n  // anyway could order it.\n  isBackorder: {\n    label: \"Indicates when the seller has allowed the sale of product which\" +\n    \" is not in stock\",\n    type: Boolean,\n    optional: true\n  },\n  requiresShipping: {\n    label: \"Require a shipping address\",\n    type: Boolean,\n    defaultValue: true,\n    optional: true\n  },\n  parcel: {\n    type: ShippingParcel,\n    optional: true\n  },\n  hashtags: {\n    type: [String],\n    optional: true,\n    index: 1\n  },\n  twitterMsg: {\n    type: String,\n    optional: true,\n    max: 140\n  },\n  facebookMsg: {\n    type: String,\n    optional: true,\n    max: 255\n  },\n  googleplusMsg: {\n    type: String,\n    optional: true,\n    max: 255\n  },\n  pinterestMsg: {\n    type: String,\n    optional: true,\n    max: 255\n  },\n  metaDescription: {\n    type: String,\n    optional: true\n  },\n  handle: {\n    type: String,\n    optional: true,\n    index: 1,\n    autoValue: function () {\n      let slug = getSlug(this.value);\n\n      if (!slug && this.siblingField(\"title\").value) {\n        slug = getSlug(this.siblingField(\"title\").value);\n      } else if (!slug) {\n        slug = this.siblingField(\"_id\").value || Random.id();\n      }\n      if (this.isInsert) {\n        return slug;\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: slug\n        };\n      }\n    }\n  },\n  isDeleted: {\n    type: Boolean,\n    index: 1,\n    defaultValue: false\n  },\n  isVisible: {\n    type: Boolean,\n    index: 1,\n    defaultValue: false\n  },\n  template: {\n    label: \"Template\",\n    type: String,\n    defaultValue: \"productDetailSimple\"\n  },\n  createdAt: {\n    type: Date,\n    autoValue: function () {\n      if (this.isInsert) {\n        return new Date;\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date\n        };\n      }\n    }\n  },\n  updatedAt: {\n    type: Date,\n    autoValue: function () {\n      return new Date;\n    },\n    optional: true\n  },\n  publishedAt: {\n    type: Date,\n    optional: true\n  },\n  publishedScope: {\n    type: String,\n    optional: true\n  },\n  workflow: {\n    type: Workflow,\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Layout } from \"./layouts\";\n\n/**\n * Permissions Schema\n */\n\nexport const Permissions = new SimpleSchema({\n  permission: {\n    type: String\n  },\n  label: {\n    type: String\n  }\n});\n\n/**\n * Permissions Registry\n * the registry entries in the Package registry\n */\n\nexport const Registry = new SimpleSchema({\n  provides: {\n    type: String,\n    index: true\n  },\n  route: {\n    type: String,\n    optional: true,\n    index: true\n  },\n  name: {\n    type: String,\n    label: \"Registry Name\",\n    index: true\n  },\n  template: {\n    type: String,\n    optional: true\n  },\n  workflow: {\n    type: String,\n    optional: true\n  },\n  layout: {\n    type: String,\n    optional: true\n  },\n  triggersEnter: {\n    label: \"Trigger on Entry\",\n    type: [String],\n    optional: true\n  },\n  triggersExit: {\n    label: \"Trigger on Exit\",\n    type: [String],\n    optional: true\n  },\n  options: {\n    label: \"Routing Options\",\n    type: Object,\n    optional: true\n  },\n  description: {\n    type: String,\n    optional: true\n  },\n  icon: {\n    type: String,\n    optional: true\n  },\n  label: {\n    type: String,\n    optional: true\n  },\n  container: {\n    type: String,\n    optional: true\n  },\n  priority: {\n    type: Number,\n    optional: true\n  },\n  enabled: {\n    type: Boolean,\n    optional: true\n  },\n  permissions: {\n    type: [Permissions],\n    optional: true\n  },\n  audience: {\n    type: [String],\n    optional: true,\n    label: \"Audience\"\n  },\n  meta: {\n    label: \"Meta\",\n    type: Object,\n    optional: true,\n    blackbox: true\n  }\n});\n\n\n/**\n * PackageConfig Schema\n */\nexport const PackageConfig = new SimpleSchema({\n  shopId: {\n    type: String,\n    index: 1,\n    // see: https://github.com/reactioncommerce/reaction/issues/646#issuecomment-169351842\n    // autoValue: shopIdAutoValue,\n    label: \"PackageConfig ShopId\",\n    optional: true\n  },\n  name: {\n    type: String,\n    index: 1\n  },\n  enabled: {\n    type: Boolean,\n    defaultValue: true\n  },\n  icon: {\n    type: String,\n    optional: true\n  },\n  settings: {\n    type: Object,\n    optional: true,\n    blackbox: true\n  },\n  registry: {\n    type: [Registry],\n    optional: true\n  },\n  layout: {\n    type: [Layout],\n    optional: true\n  }\n});\n\n/**\n * CorePackageConfig Schema\n * Core Reaction Settings\n */\n\nexport const CorePackageConfig = new SimpleSchema([\n  PackageConfig, {\n    \"settings.mail\": {\n      type: Object,\n      optional: true,\n      label: \"Mail Settings\"\n    },\n    \"settings.mail.user\": {\n      type: String,\n      label: \"Username\"\n    },\n    \"settings.mail.password\": {\n      type: String,\n      label: \"Password\"\n    },\n    \"settings.mail.host\": {\n      type: String,\n      label: \"Host\"\n    },\n    \"settings.mail.port\": {\n      type: String,\n      label: \"Port\"\n    },\n    \"settings.openexchangerates.appId\": {\n      type: String,\n      label: \"Open Exchange Rates App Id\"\n    },\n    \"settings.openexchangerates.refreshPeriod\": {\n      type: String,\n      label: \"Open Exchange Rates refresh period\",\n      defaultValue: \"every 1 hour\"\n    },\n    \"settings.google.clientId\": {\n      type: String,\n      label: \"Google Client Id\",\n      defaultValue: null\n    },\n    \"settings.google.apiKey\": {\n      type: String,\n      label: \"Google Api Key\",\n      defaultValue: null\n    },\n    \"settings.public\": {\n      type: Object,\n      optional: true\n    },\n    \"settings.public.allowGuestCheckout\": {\n      type: Boolean,\n      label: \"Allow Guest Checkout\"\n    },\n    \"settings.cart.cleanupDurationDays\": {\n      type: String,\n      label: \"Cleanup Schedule\",\n      defaultValue: \"older than 3 days\"\n    }\n  }\n]);\n","import { Workflow } from \"./workflow\";\n\n\nexport const Revisions = new SimpleSchema({\n  _id: {\n    type: String,\n    label: \"Revision Id\"\n  },\n\n  // status: {\n  //   type: String,\n  //   label: \"Revision Status\"\n  // },\n\n  workflow: {\n    type: Workflow,\n    optional: false\n  },\n\n  documentId: {\n    type: String,\n    label: \"Reference Document Id\"\n  },\n\n  documentType: {\n    type: String,\n    label: \"Document Type\",\n    defaultValue: \"product\",\n    allowedValues: [\"product\", \"image\", \"tag\"]\n  },\n\n  parentDocument: {\n    type: String,\n    optional: true\n  },\n\n  documentData: {\n    type: \"object\",\n    blackbox: true\n  },\n\n  changeType: {\n    type: String,\n    optional: true,\n    allowedValues: [\"insert\", \"update\", \"remove\"]\n  },\n\n  diff: {\n    type: [Object],\n    blackbox: true,\n    optional: true\n  },\n\n  createdAt: {\n    type: Date,\n    autoValue: function () {\n      if (this.isInsert) {\n        return new Date;\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date\n        };\n      }\n    }\n  },\n\n  updatedAt: {\n    type: Date,\n    autoValue: function () {\n      return new Date;\n    },\n    optional: true\n  },\n\n  publishAt: {\n    type: Date,\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { shopIdAutoValue, schemaIdAutoValue } from \"./helpers\";\nimport { Address } from \"./address\";\nimport { Invoice } from \"./payments\";\nimport { PackageConfig } from \"./registry\";\nimport { Workflow } from \"./workflow\";\n\n/**\n * ShippoShippingMethod Schema\n * TODO move shippo related schema to shippo module\n * This will only exist in ShippingMethods Inside Cart/Order and not DB shipping Collection\n * as Shippo Methods are Dynamic.\n */\n\nexport const ShippoShippingMethod = new SimpleSchema({\n  serviceLevelToken: {\n    type: String,\n    optional: true\n  },\n  rateId: {\n    type: String,\n    optional: true\n  }\n});\n\n/**\n * ShippingMethod Schema\n */\n\nexport const ShippingMethod = new SimpleSchema({\n  \"_id\": {\n    type: String,\n    label: \"Shipment Method Id\",\n    autoValue: schemaIdAutoValue\n  },\n  \"name\": {\n    type: String,\n    label: \"Method Name\"\n  },\n  \"label\": {\n    type: String,\n    label: \"Public Label\"\n  },\n  \"group\": {\n    type: String,\n    label: \"Group\",\n    allowedValues: [\"Ground\", \"Priority\", \"One Day\", \"Free\"]\n  },\n  \"cost\": {\n    type: Number,\n    label: \"Cost\",\n    decimal: true,\n    optional: true\n  },\n  \"handling\": {\n    type: Number,\n    label: \"Handling\",\n    optional: true,\n    decimal: true,\n    defaultValue: 0,\n    min: 0\n  },\n  \"rate\": {\n    type: Number,\n    label: \"Rate\",\n    decimal: true,\n    min: 0\n  },\n  \"enabled\": {\n    type: Boolean,\n    label: \"Enabled\",\n    defaultValue: false\n  },\n  \"validRanges\": {\n    type: Array,\n    optional: true,\n    label: \"Matching Cart Ranges\"\n  },\n  \"validRanges.$\": {\n    type: Object,\n    optional: true\n  },\n  \"validRanges.$.begin\": {\n    type: Number,\n    decimal: true,\n    label: \"Begin\",\n    optional: true\n  },\n  \"validRanges.$.end\": {\n    type: Number,\n    decimal: true,\n    label: \"End\",\n    optional: true\n  },\n  \"validLocales\": {\n    type: Array,\n    optional: true,\n    label: \"Matching Locales\"\n  },\n  \"validLocales.$\": {\n    type: Object,\n    optional: true\n  },\n  \"validLocales.$.origination\": {\n    type: String,\n    label: \"From\",\n    optional: true\n  },\n  \"validLocales.$.destination\": {\n    type: String,\n    label: \"To\",\n    optional: true\n  },\n  \"validLocales.$.deliveryBegin\": {\n    type: Number,\n    label: \"Shipping Est.\",\n    optional: true\n  },\n  \"validLocales.$.deliveryEnd\": {\n    type: Number,\n    label: \"Delivery Est.\",\n    optional: true\n  },\n  \"carrier\": {     // kind of denormalizing, useful for having it in shipmentMethod( cart & order)\n    type: String,  // Alternatively we can make an extra Schema:ShipmentMethod, that inherits\n    optional: true // ShippingMethod and add the optional carrier field\n  },\n  \"settings\": {\n    type: ShippoShippingMethod,\n    optional: true\n  }\n});\n\n/**\n * ShipmentQuote Schema\n */\n\nexport const ShipmentQuote = new SimpleSchema({\n  carrier: {\n    type: String\n  },\n  method: {\n    type: ShippingMethod\n  },\n  rate: {\n    type: Number,\n    decimal: true,\n    defaultValue: \"0.00\"\n  }\n});\n\n// populate with order.items that are added to a shipment\nexport const ShipmentItem = new SimpleSchema({\n  _id: {\n    type: String,\n    label: \"Shipment Line Item\",\n    optional: true,\n    autoValue: schemaIdAutoValue\n  },\n  productId: {\n    type: String,\n    index: 1\n  },\n  shopId: {\n    type: String,\n    index: 1,\n    label: \"Shipment Item ShopId\",\n    optional: true\n  },\n  quantity: {\n    label: \"Quantity\",\n    type: Number,\n    min: 0\n  },\n  variantId: {\n    type: String\n  }\n});\n\n/**\n * ShippingParcel Schema\n */\n\nexport const ShippingParcel = new SimpleSchema({\n  containers: {\n    type: String,\n    optional: true\n  },\n  length: {\n    type: Number,\n    optional: true\n  },\n  width: {\n    type: Number,\n    optional: true\n  },\n  height: {\n    type: Number,\n    optional: true\n  },\n  weight: {\n    type: Number,\n    optional: true\n  }\n});\n\n/**\n * ShippoShipment Schema\n * Specific properties of Shipment for use with Shippo. We don't use\n */\n\nexport const ShippoShipment = new SimpleSchema({\n  transactionId: {\n    type: String,\n    optional: true\n  },\n  trackingStatusStatus: { // cause tracking_status.status\n    type: String,\n    optional: true\n  },\n  trackingStatusDate: {\n    type: String,\n    optional: true\n  }\n});\n\n\n/**\n * Shipment Schema\n * used for cart/order shipment tracking\n */\n\nexport const Shipment = new SimpleSchema({\n  _id: {\n    type: String,\n    label: \"Shipment Id\",\n    autoValue: schemaIdAutoValue\n  },\n  paymentId: {\n    type: String,\n    label: \"Payment Id\",\n    optional: true\n  },\n  address: {\n    type: Address,\n    optional: true\n  },\n  shipmentMethod: {\n    type: ShippingMethod,\n    optional: true\n  },\n  shipmentQuotes: {\n    type: [ShipmentQuote],\n    optional: true\n  },\n  tracking: {\n    type: String,\n    optional: true\n  },\n  parcel: {\n    type: ShippingParcel,\n    optional: true\n  },\n  items: {\n    type: [ShipmentItem],\n    optional: true\n  },\n  workflow: {\n    type: Workflow,\n    optional: true\n  },\n  packed: {\n    type: Boolean,\n    optional: true,\n    defaultValue: false\n  },\n  shipped: {\n    type: Boolean,\n    optional: true,\n    defaultValue: false\n  },\n  delivered: {\n    type: Boolean,\n    optional: true,\n    defaultValue: false\n  },\n  invoice: {\n    type: Invoice,\n    optional: true\n  },\n  transactions: {\n    type: [Object],\n    optional: true,\n    blackbox: true\n  }, // For printable Shipping label\n  shippingLabelUrl: {\n    type: String,\n    optional: true\n  }, // For Customs printable label\n  customsLabelUrl: {\n    type: String,\n    optional: true\n  }, // shippo specific properties\n  shippo: {\n    type: ShippoShipment,\n    optional: true\n  }\n});\n\n/**\n * ShippoShippingProvider Schema\n * Specific  properties for use with Shippo. We don't use\n * ShippingProvider service* fields because Shippo is on level\n * higher service than simple carrier's ,e.g Fedex api.\n */\n\nexport const ShippoShippingProvider = new SimpleSchema({\n  carrierAccountId: {\n    type: String,\n    optional: true\n  }\n});\n\n/**\n * ShippingProvider Schema\n */\n\nexport const ShippingProvider = new SimpleSchema({\n  _id: {\n    type: String,\n    label: \"Provider Id\",\n    optional: true,\n    autoValue: schemaIdAutoValue\n  },\n  name: {\n    type: String,\n    label: \"Service Code\",\n    optional: true\n  },\n  label: {\n    type: String,\n    label: \"Public Label\"\n  },\n  enabled: {\n    type: Boolean,\n    defaultValue: true\n  },\n  serviceAuth: {\n    type: String,\n    label: \"Auth\",\n    optional: true\n  },\n  serviceSecret: {\n    type: String,\n    label: \"Secret\",\n    optional: true\n  },\n  serviceUrl: {\n    type: String,\n    label: \"Service URL\",\n    optional: true\n  },\n  shippoProvider: {\n    type: ShippoShippingProvider,\n    optional: true\n  }\n});\n\n/**\n * Shipping Schema\n */\n\nexport const Shipping = new SimpleSchema({\n  _id: {\n    type: String,\n    label: \"Service Id\",\n    optional: true\n  },\n  shopId: {\n    type: String,\n    index: 1,\n    autoValue: shopIdAutoValue,\n    label: \"Shipping ShopId\"\n  },\n  name: {\n    type: String,\n    label: \"Service Name\",\n    optional: true,\n    index: 1\n  },\n  provider: {\n    type: ShippingProvider,\n    label: \"Shipping Provider\"\n  },\n  methods: {\n    type: [ShippingMethod],\n    optional: true,\n    label: \"Shipping Methods\"\n  },\n  shipmentQuotes: {\n    type: [ShipmentQuote],\n    optional: true,\n    label: \"Quoted Methods\"\n  }\n});\n\n/**\n * Shipping Package Schema\n */\nexport const ShippingPackageConfig = new SimpleSchema([\n  PackageConfig, {\n    \"settings.name\": {\n      type: String,\n      defaultValue: \"Flat Rate Service\"\n    }\n  }\n]);\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { Email } from \"./accounts\";\nimport { Address } from \"./address\";\nimport { Layout } from \"./layouts\";\nimport { Metafield } from \"./metafield\";\n\n/**\n * CustomEmailSettings Schema\n */\nexport const CustomEmailSettings = new SimpleSchema({\n  service: {\n    type: String,\n    optional: true\n  },\n  username: {\n    type: String,\n    optional: true\n  },\n  password: {\n    type: String,\n    optional: true\n  },\n  host: {\n    type: String,\n    optional: true\n  },\n  port: {\n    type: Number,\n    optional: true\n  }\n});\n\n/**\n * Currency Schema\n */\nexport const Currency = new SimpleSchema({\n  symbol: {\n    type: String,\n    defaultValue: \"$\"\n  },\n  format: {\n    type: String,\n    defaultValue: \"%s%v\"\n  },\n  scale: {\n    type: Number,\n    defaultValue: 2,\n    optional: true\n  },\n  decimal: {\n    type: String,\n    defaultValue: \".\",\n    optional: true\n  },\n  thousand: {\n    type: String,\n    defaultValue: \",\",\n    optional: true\n  },\n  rate: {\n    type: Number,\n    optional: true\n  }\n});\n\n/**\n * Locale Schema\n */\nexport const Locale = new SimpleSchema({\n  continents: {\n    type: Object,\n    blackbox: true\n  },\n  countries: {\n    type: Object,\n    blackbox: true\n  }\n});\n\n/**\n * Languages Schema\n */\n\nexport const Languages = new SimpleSchema({\n  label: {\n    type: String\n  },\n  i18n: {\n    type: String\n  },\n  enabled: {\n    type: Boolean,\n    defaultValue: true\n  }\n});\n\n/**\n * ShopTheme Schema\n */\nexport const ShopTheme = new SimpleSchema({\n  themeId: {\n    type: String\n  },\n  styles: {\n    type: String,\n    optional: true\n  }\n});\n\n/**\n * Shop Theme Schema\n */\nexport const BrandAsset = new SimpleSchema({\n  mediaId: {\n    type: String,\n    optional: true\n  },\n  type: {\n    type: String,\n    optional: true\n  }\n});\n\n/**\n * Shop Schema\n */\nexport const Shop = new SimpleSchema({\n  \"_id\": {\n    type: String,\n    optional: true\n  },\n  \"status\": {\n    type: String,\n    defaultValue: \"active\"\n  },\n  \"name\": {\n    type: String,\n    index: 1\n  },\n  \"description\": {\n    type: String,\n    optional: true\n  },\n  \"keywords\": {\n    type: String,\n    optional: true\n  },\n  \"addressBook\": {\n    type: [Address],\n    optional: true\n  },\n  \"domains\": {\n    type: [String],\n    defaultValue: [\"localhost\"],\n    index: 1\n  },\n  \"emails\": {\n    type: [Email],\n    optional: true\n  },\n  \"defaultPaymentMethod\": {\n    label: \"Default Payment Method\",\n    type: String,\n    defaultValue: \"none\"\n  },\n  \"currency\": {\n    label: \"Base Currency\",\n    type: String,\n    defaultValue: \"USD\"\n  },\n  \"currencies\": {\n    type: Object, // Schemas.Currency\n    blackbox: true,\n    optional: true\n  },\n  \"locales\": {\n    type: Locale\n  },\n  \"language\": {\n    label: \"Base Language\",\n    type: String,\n    defaultValue: \"en\"\n  },\n  \"languages\": {\n    type: [Languages],\n    optional: true\n  },\n  \"public\": {\n    type: String,\n    optional: true\n  },\n  \"timezone\": {\n    label: \"Timezone\",\n    type: String,\n    defaultValue: \"US/Pacific\"\n  },\n  \"baseUOM\": {\n    type: String,\n    optional: true,\n    defaultValue: \"OZ\",\n    label: \"Base Unit of Measure\"\n  },\n  \"unitsOfMeasure\": {\n    type: [Object]\n  },\n  \"unitsOfMeasure.$.uom\": {\n    type: String,\n    defaultValue: \"OZ\"\n  },\n  \"unitsOfMeasure.$.label\": {\n    type: String,\n    defaultValue: \"Ounces\"\n  },\n  \"unitsOfMeasure.$.default\": {\n    type: Boolean,\n    defaultValue: false\n  },\n  \"metafields\": {\n    type: [Metafield],\n    optional: true\n  },\n  \"defaultVisitorRole\": {\n    type: [String],\n    defaultValue: [\"anonymous\", \"guest\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"]\n  },\n  \"defaultRoles\": {\n    type: [String],\n    defaultValue: [\"guest\", \"account/profile\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"]\n  },\n  \"layout\": {\n    type: [Layout],\n    optional: true\n  },\n  \"theme\": {\n    type: ShopTheme,\n    optional: true\n  },\n  \"brandAssets\": {\n    type: [BrandAsset],\n    optional: true\n  },\n  \"appVersion\": {\n    type: String,\n    optional: true\n  },\n  \"createdAt\": {\n    type: Date,\n    autoValue: function () {\n      if (this.isInsert) {\n        return new Date();\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date()\n        };\n      }\n      this.unset();\n    },\n    denyUpdate: true,\n    optional: true\n  },\n  \"updatedAt\": {\n    type: Date,\n    autoValue: function () {\n      if (this.isUpdate) {\n        return new Date;\n      }\n    },\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\nexport const Sms  = new SimpleSchema({\n  apiKey: {\n    type: String,\n    optional: true\n  },\n  apiToken: {\n    type: String,\n    optional: true\n  },\n  shopId: {\n    type: String,\n    optional: true\n  },\n  smsPhone: {\n    type: String,\n    optional: true\n  },\n  smsProvider: {\n    type: String,\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { PackageConfig } from \"./registry\";\n\n/*\n * Settings for Social Package\n */\nexport const SocialProvider = new SimpleSchema({\n  profilePage: {\n    type: String,\n    regEx: SimpleSchema.RegEx.Url,\n    label: \"Profile Page\",\n    optional: true\n  },\n  enabled: {\n    type: Boolean,\n    label: \"Enabled\",\n    defaultValue: false,\n    optional: true\n  }\n});\n\nexport const SocialPackageConfig = new SimpleSchema([\n  PackageConfig, {\n    \"settings.public\": {\n      type: Object,\n      optional: true\n    },\n    \"settings.public.apps\": {\n      type: Object,\n      label: \"Social Settings\",\n      optional: true\n    },\n    \"settings.public.apps.facebook\": {\n      type: SocialProvider,\n      optional: true\n    },\n    \"settings.public.apps.facebook.appId\": {\n      type: String,\n      regEx: /\\d+/,\n      label: \"App Id\",\n      optional: true\n    },\n    \"settings.public.apps.facebook.appSecret\": {\n      type: String,\n      regEx: /[\\da-z]+/,\n      label: \"App Secret\",\n      optional: true\n    },\n    \"settings.public.apps.twitter\": {\n      type: SocialProvider,\n      optional: true\n    },\n    \"settings.public.apps.twitter.username\": {\n      type: String,\n      label: \"Username\",\n      optional: true\n    },\n    \"settings.public.apps.pinterest\": {\n      type: SocialProvider,\n      optional: true\n    },\n    \"settings.public.apps.googleplus\": {\n      type: SocialProvider,\n      label: \"Google+\",\n      optional: true\n    }\n  }\n]);\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { shopIdAutoValue } from \"./helpers\";\n\n/**\n * Tag Schema\n */\n\nexport const Tag = new SimpleSchema({\n  _id: {\n    type: String,\n    optional: true\n  },\n  name: {\n    type: String,\n    index: 1\n  },\n  slug: {\n    type: String\n  },\n  position: {\n    type: Number,\n    optional: true\n  },\n  relatedTagIds: {\n    type: [String],\n    optional: true,\n    index: 1\n  },\n  isDeleted: {\n    type: Boolean,\n    defaultValue: false\n  },\n  isTopLevel: {\n    type: Boolean\n  },\n  shopId: {\n    type: String,\n    index: 1,\n    autoValue: shopIdAutoValue,\n    label: \"Tag shopId\"\n  },\n  createdAt: {\n    type: Date,\n    autoValue: function () {\n      if (this.isInsert) {\n        return new Date;\n      } else if (this.isUpsert) {\n        return {\n          $setOnInsert: new Date\n        };\n      }\n    }\n  },\n  updatedAt: {\n    type: Date\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { shopIdAutoValue } from \"./helpers\";\n\nconst sharedFields = {\n  shopId: {\n    type: String,\n    index: 1,\n    autoValue: shopIdAutoValue,\n    label: \"Template ShopId\"\n  },\n  name: {\n    type: String\n  },\n  priority: {\n    type: Number,\n    optional: true,\n    defaultValue: 1\n  },\n  enabled: {\n    type: Boolean,\n    defaultValue: true\n  },\n  route: {\n    type: String,\n    optional: true\n  },\n  // permissions: {\n  //   type: [String],\n  //   optional: true\n  // },\n  // audience: {\n  //   type: [String],\n  //   optional: true\n  // },\n  type: {\n    type: String,\n    defaultValue: \"template\"\n  },\n\n  provides: {\n    type: String,\n    defaultValue: \"template\"\n  },\n  block: {\n    type: String,\n    optional: true\n  },\n  defaultData: {\n    type: Object,\n    blackbox: true,\n    optional: true\n  },\n  parser: {\n    type: String\n  },\n  language: {\n    type: String,\n    optional: true,\n    defaultValue: \"en\"\n  },\n  source: {\n    type: String,\n    optional: true\n  }\n};\n\nexport const ReactLayout = new SimpleSchema({\n  ...sharedFields,\n  templateFor: {\n    type: [String],\n    optional: true\n  },\n  template: {\n    type: [Object],\n    optional: true,\n    blackbox: true\n  }\n});\n\nexport const Template = new SimpleSchema({\n  ...sharedFields,\n  template: {\n    type: String,\n    optional: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\n/**\n * @summary Themes Schema\n * Schema for themes used in reaction-layout\n */\n\nexport const Themes = new SimpleSchema({\n  name: {\n    type: String,\n    index: true\n  },\n\n  author: {\n    type: String,\n    optional: true\n  },\n\n  layout: {\n    type: String,\n    optional: true,\n    defaultValue: \"coreLayout\"\n  },\n\n  url: {\n    type: String,\n    optional: true\n  },\n\n  components: {\n    type: [Object],\n    optional: true,\n    blackbox: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\nimport { shopIdAutoValue } from \"./helpers\";\n\n/*\n* translations schema\n* mostly just a blackbox for now\n* someday maybe we'll validate the entire schema\n* since ui editing for these values are likely\n*/\n\nexport const Translation = new SimpleSchema({\n  shopId: {\n    type: String,\n    index: 1,\n    autoValue: shopIdAutoValue,\n    label: \"Translation ShopId\"\n  },\n  language: {\n    type: String\n  },\n  i18n: {\n    type: String,\n    index: 1\n  },\n  ns: {\n    type: String,\n    label: \"Namespace\"\n  },\n  translation: {\n    type: Object,\n    blackbox: true\n  }\n});\n","import { SimpleSchema } from \"meteor/aldeed:simple-schema\";\n\n/**\n * workflow schema for attaching to collection where\n * PackageWorkflow is controlling view flow\n * Shop defaultWorkflow is defined in Shop\n */\n\nexport const Workflow = new SimpleSchema({\n  status: {\n    type: String,\n    defaultValue: \"new\",\n    index: 1\n  },\n  workflow: {\n    type: [String],\n    optional: true\n  }\n});\n","import accounting from \"accounting-js\";\n\n/**\n * getSummary\n * @summary iterates over cart items with computations\n * @param {Array} items - cart.items array\n * @param {Array} prop - path to item property represented by array\n * @param {Array} [prop2] - path to another item property represented by array\n * @return {Number} - computations result\n */\nfunction getSummary(items, prop, prop2) {\n  try {\n    if (Array.isArray(items)) {\n      return items.reduce((sum, item) => {\n        if (prop2) {\n          // S + a * b, where b could be b1 or b2\n          return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] :\n            item[prop2[0]][prop2[1]]);\n        }\n        // S + b, where b could be b1 or b2\n        return sum + (prop.length === 1 ? item[prop[0]] :\n          item[prop[0]][prop[1]]);\n      }, 0);\n    }\n  } catch (e) {\n    // If data not prepared we should send a number to avoid exception with\n    // `toFixed`. This could happens if user stuck on `completed` checkout stage\n    // by some reason.\n    return 0;\n  }\n  return 0;\n}\n\n/**\n * Reaction transform collections\n *\n * transform methods used to return cart calculated values\n * cartCount, cartSubTotal, cartShipping, cartTaxes, cartTotal\n * are calculated by a transformation on the collection\n * and are available to use in template as cart.xxx\n * in template: {{cart.cartCount}}\n * in code: Cart.findOne().cartTotal()\n */\nexport const cartTransform = {\n  cartCount() {\n    return getSummary(this.items, [\"quantity\"]);\n  },\n  cartShipping() {\n    // loop through the cart.shipping, sum shipments.\n    const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"]);\n    const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"]);\n    const shipping = handling + rate || 0;\n    return accounting.toFixed(shipping, 2);\n  },\n  cartSubTotal() {\n    const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"]);\n    return accounting.toFixed(subTotal, 2);\n  },\n  cartTaxes() {\n    // taxes are calculated in a Cart.after.update hooks\n    // the tax value stored with the cart is the effective tax rate\n    // calculated by line items\n    // in the imports/core/taxes plugin\n    const tax = this.tax || 0;\n    const subTotal = parseFloat(this.cartSubTotal());\n    const taxTotal = subTotal * tax;\n    return accounting.toFixed(taxTotal, 2);\n  },\n  cartDiscounts() {\n    const discount = this.discount || 0;\n    return accounting.toFixed(discount, 2);\n  },\n  cartTotal() {\n    const subTotal = parseFloat(this.cartSubTotal());\n    const shipping = parseFloat(this.cartShipping());\n    const taxes = parseFloat(this.cartTaxes());\n    const discount = parseFloat(this.cartDiscounts());\n    const discountTotal = Math.max(0, subTotal - discount);\n    const total = discountTotal + shipping + taxes;\n    return accounting.toFixed(total, 2);\n  }\n};\n","import accounting from \"accounting-js\";\n\n\n// TODO: This is a duplicate of the cart transform with just the names changed.\n// This should be factored to be just one file for both\n\n/**\n * getSummary\n * @summary iterates over order items with computations\n * @param {Array} items - order.items array\n * @param {Array} prop - path to item property represented by array\n * @param {Array} [prop2] - path to another item property represented by array\n * @return {Number} - computations result\n */\nfunction getSummary(items, prop, prop2) {\n  try {\n    if (Array.isArray(items)) {\n      return items.reduce((sum, item) => {\n        if (prop2) {\n          // S + a * b, where b could be b1 or b2\n          return sum + item[prop[0]] * (prop2.length === 1 ? item[prop2[0]] :\n              item[prop2[0]][prop2[1]]);\n        }\n        // S + b, where b could be b1 or b2\n        return sum + (prop.length === 1 ? item[prop[0]] :\n            item[prop[0]][prop[1]]);\n      }, 0);\n    }\n  } catch (e) {\n    // If data not prepared we should send a number to avoid exception with\n    // `toFixed`. This could happens if user stuck on `completed` checkout stage\n    // by some reason.\n    return 0;\n  }\n  return 0;\n}\n\n/**\n * Reaction transform collections\n *\n * transform methods used to return order calculated values\n * orderCount, orderSubTotal, orderShipping, orderTaxes, orderTotal\n * are calculated by a transformation on the collection\n * and are available to use in template as order.xxx\n * in template: {{order.orderCount}}\n * in code: order.findOne().orderTotal()\n */\nexport const orderTransform = {\n  orderCount() {\n    return getSummary(this.items, [\"quantity\"]);\n  },\n  orderShipping() {\n    // loop through the order.shipping, sum shipments.\n    const rate = getSummary(this.shipping, [\"shipmentMethod\", \"rate\"]);\n    const handling = getSummary(this.shipping, [\"shipmentMethod\", \"handling\"]);\n    const shipping = handling + rate || 0;\n    return accounting.toFixed(shipping, 2);\n  },\n  orderSubTotal() {\n    const subTotal = getSummary(this.items, [\"quantity\"], [\"variants\", \"price\"]);\n    return accounting.toFixed(subTotal, 2);\n  },\n  orderTaxes() {\n    // taxes are calculated in a order.after.update hooks\n    // the tax value stored with the order is the effective tax rate\n    // calculated by line items\n    // in the imports/core/taxes plugin\n    const tax = this.tax || 0;\n    const subTotal = parseFloat(this.orderSubTotal());\n    const taxTotal = subTotal * tax;\n    return accounting.toFixed(taxTotal, 2);\n  },\n  orderDiscounts() {\n    const discount = this.discount || 0;\n    return accounting.toFixed(discount, 2);\n  },\n  orderTotal() {\n    const subTotal = parseFloat(this.orderSubTotal());\n    const shipping = parseFloat(this.orderShipping());\n    const taxes = parseFloat(this.orderTaxes());\n    const discount = parseFloat(this.orderDiscounts());\n    const discountTotal = Math.max(0, subTotal - discount);\n    const total = discountTotal + shipping + taxes;\n    return accounting.toFixed(total, 2);\n  },\n  itemCount() {\n    let count = 0;\n    if (Array.isArray(this.items)) {\n      for (const item of this.items) {\n        count += item.quantity;\n      }\n    }\n    return count;\n  }\n};\n\n","/**\n * core collectionsFS configurations\n */\nFS.HTTP.setBaseUrl(\"/assets\");\nFS.HTTP.setHeadersForGet([\n  [\"Cache-Control\", \"public, max-age=31536000\"]\n]);\n\n/**\n * Define CollectionFS collection\n * See: https://github.com/CollectionFS/Meteor-CollectionFS\n * chunkSize: 1024*1024*2; <- CFS default // 256k is default GridFS chunk size, but performs terribly\n */\n\nexport const Media = new FS.Collection(\"Media\", {\n  stores: [\n    new FS.Store.GridFS(\"image\", {\n      chunkSize: 1 * 1024 * 1024\n    }), new FS.Store.GridFS(\"large\", {\n      chunkSize: 1 * 1024 * 1024,\n      transformWrite: function (fileObj, readStream, writeStream) {\n        if (gm.isAvailable) {\n          gm(readStream, fileObj.name).resize(\"1000\", \"1000\").stream()\n            .pipe(writeStream);\n        } else {\n          readStream.pipe(writeStream);\n        }\n      }\n    }), new FS.Store.GridFS(\"medium\", {\n      chunkSize: 1 * 1024 * 1024,\n      transformWrite: function (fileObj, readStream, writeStream) {\n        if (gm.isAvailable) {\n          gm(readStream, fileObj.name).resize(\"600\", \"600\").stream().pipe(\n            writeStream);\n        } else {\n          readStream.pipe(writeStream);\n        }\n      }\n    }), new FS.Store.GridFS(\"small\", {\n      chunkSize: 1 * 1024 * 1024,\n      transformWrite: function (fileObj, readStream, writeStream) {\n        if (gm.isAvailable) {\n          gm(readStream).resize(\"235\", \"235\" + \"^\").gravity(\"Center\")\n            .extent(\"235\", \"235\").stream(\"PNG\").pipe(writeStream);\n        } else {\n          readStream.pipe(writeStream);\n        }\n      }\n    }), new FS.Store.GridFS(\"thumbnail\", {\n      chunkSize: 1 * 1024 * 1024,\n      transformWrite: function (fileObj, readStream, writeStream) {\n        if (gm.isAvailable) {\n          gm(readStream).resize(\"100\", \"100\" + \"^\").gravity(\"Center\")\n            .extent(\"100\", \"100\").stream(\"PNG\").pipe(writeStream);\n        } else {\n          readStream.pipe(writeStream);\n        }\n      }\n    })\n  ],\n  filter: {\n    allow: {\n      contentTypes: [\"image/*\"]\n    }\n  }\n});\n","import { Mongo } from \"meteor/mongo\";\nimport * as Schemas from \"./schemas\";\nimport { cartTransform } from \"./transform/cart\";\nimport { orderTransform } from \"./transform/order\";\n\n/**\n*\n* Reaction Core Collections\n*\n*/\n\n/**\n * Accounts Collection\n */\nexport const Accounts = new Mongo.Collection(\"Accounts\");\n\nAccounts.attachSchema(Schemas.Accounts);\n\n\n/*\n *  AnalyticsEvents Collection\n *  Store the Analytics Events in a Collection\n */\nexport const AnalyticsEvents = new Mongo.Collection(\"AnalyticsEvents\");\n\nAnalyticsEvents.attachSchema(Schemas.AnalyticsEvents);\n\n\n/**\n *  Assets Collection\n *  Store file asset paths or contents in a Collection\n */\nexport const Assets = new Mongo.Collection(\"Assets\");\n\nAssets.attachSchema(Schemas.Assets);\n\n\n/**\n* Cart Collection\n*/\nexport const Cart = new Mongo.Collection(\"Cart\", {\n  transform(cart) {\n    const newInstance = Object.create(cartTransform);\n    return _.extend(newInstance, cart);\n  }\n});\n\nCart.attachSchema(Schemas.Cart);\n\n\n/**\n* Emails Collection\n*/\nexport const Emails = new Mongo.Collection(\"Emails\");\n\nEmails.attachSchema(Schemas.Emails);\n\n\n/**\n* Inventory Collection\n*/\nexport const Inventory = new Mongo.Collection(\"Inventory\");\n\nInventory.attachSchema(Schemas.Inventory);\n\n\n/**\n* Orders Collection\n*/\nexport const Orders = new Mongo.Collection(\"Orders\", {\n  transform(order) {\n    const newInstance = Object.create(orderTransform);\n    return _.extend(newInstance, order);\n  }\n});\n\nOrders.attachSchema([\n  Schemas.Cart,\n  Schemas.Order,\n  Schemas.OrderItem\n]);\n\n\n/**\n* Packages Collection\n*/\nexport const Packages = new Mongo.Collection(\"Packages\");\n\nPackages.attachSchema(Schemas.PackageConfig);\n\n\n/**\n* Products Collection\n*/\nexport const Products = new Mongo.Collection(\"Products\");\n\nProducts.attachSchema(Schemas.Product, { selector: { type: \"simple\" } });\nProducts.attachSchema(Schemas.ProductVariant, { selector: { type: \"variant\" } });\n\n/**\n* Revisions Collection\n*/\nexport const Revisions = new Mongo.Collection(\"Revisions\");\n\nRevisions.attachSchema(Schemas.Revisions);\n\n/**\n* Shipping Collection\n*/\nexport const Shipping = new Mongo.Collection(\"Shipping\");\n\nShipping.attachSchema(Schemas.Shipping);\n\n\n/**\n* Shops Collection\n*/\nexport const Shops = new Mongo.Collection(\"Shops\");\n\nShops.attachSchema(Schemas.Shop);\n\n\n/**\n* Tags Collection\n*/\nexport const Tags = new Mongo.Collection(\"Tags\");\n\nTags.attachSchema(Schemas.Tag);\n\n\n/**\n* Templates Collection\n*/\nexport const Templates = new Mongo.Collection(\"Templates\");\n\nTemplates.attachSchema(Schemas.Templates, { selector: { type: \"template\" } });\nTemplates.attachSchema(Schemas.ReactLayout, { selector: { type: \"react\" } });\n\n/**\n* Themes Collection\n*/\nexport const Themes = new Mongo.Collection(\"Themes\");\n\nThemes.attachSchema(Schemas.Themes);\n\n\n/**\n* Translations Collection\n*/\nexport const Translations = new Mongo.Collection(\"Translations\");\n\nTranslations.attachSchema(Schemas.Translation);\n\n/**\n * Notifications Collection\n */\nexport const Notifications = new Mongo.Collection(\"Notifications\");\n\nNotifications.attachSchema(Schemas.Notification);\n\n\n/**\n * Sms Collection\n */\nexport const Sms = new Mongo.Collection(\"Sms\");\n\nSms.attachSchema(Schemas.Sms);\n\n\n/**\n * Logs Collection\n */\nexport const Logs = new Mongo.Collection(\"Logs\");\n\nLogs.attachSchema(Schemas.Logs);\n","export * from \"./collections\";\nexport * from \"./search\";\nexport { Media } from \"./collectionFS\";\nexport { Jobs } from \"./jobs\";\n","import { JobCollection } from \"meteor/vsivsi:job-collection\";\n\n/**\n * Jobs Collection\n */\nexport const Jobs = new JobCollection(\"Jobs\", {\n  noCollectionSuffix: true\n});\n","import { Mongo } from \"meteor/mongo\";\n\nexport const ProductSearch = new Mongo.Collection(\"ProductSearch\");\nexport const OrderSearch = new Mongo.Collection(\"OrderSearch\");\nexport const AccountSearch = new Mongo.Collection(\"AccountSearch\");\n","\n// Template literal for html strings.\nexport function html(strings) {\n  return strings.raw[0];\n}\n","export const getTagIds = (state) => {\n  if (Array.isArray(state.tags)) {\n    return state.tags.map(tag => tag._id);\n  }\n\n  return [];\n};\n","export const getVariantIds = (variants) => Array.isArray(variants) && variants.map(variant => variant._id);\n","export * from \"./password\";\n","import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Accounts } from \"meteor/accounts-base\";\nimport { SSR } from \"meteor/meteorhacks:ssr\";\nimport { Media, Shops } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\n\n\n/**\n * Send an email with a link that the user can use to reset their password.\n * @param {String} userId - The id of the user to send email to.\n * @param {String} [optionalEmail] Address to send the email to.\n *                 This address must be in the user's `emails` list.\n *                 Defaults to the first email in the list.\n * @return {Job} - returns a sendEmail Job instance\n */\nexport function sendResetPasswordEmail(userId, optionalEmail) {\n  // Make sure the user exists, and email is one of their addresses.\n  const user = Meteor.users.findOne(userId);\n\n  if (!user) {\n    Logger.error(\"sendResetPasswordEmail - User not found\");\n    throw new Meteor.Error(\"user-not-found\", \"User not found\");\n  }\n\n  let email = optionalEmail;\n\n  // pick the first email if we weren't passed an email.\n  if (!optionalEmail && user.emails && user.emails[0]) {\n    email = user.emails[0].address;\n  }\n\n  // make sure we have a valid email\n  if (!email || !_.includes(_.map(user.emails || [], \"address\"), email)) {\n    Logger.error(\"sendResetPasswordEmail - Email not found\");\n    throw new Meteor.Error(\"email-not-found\", \"Email not found\");\n  }\n\n  // Create token for password reset\n  const token = Random.secret();\n  const when = new Date();\n  const tokenObj = { token, email, when };\n\n  Meteor.users.update(userId, {\n    $set: {\n      \"services.password.reset\": tokenObj\n    }\n  });\n\n  Meteor._ensure(user, \"services\", \"password\").reset = tokenObj;\n\n  // Get shop data for email display\n  const shop = Shops.findOne(Reaction.getShopId());\n\n  // Get shop logo, if available. If not, use default logo from file-system\n  let emailLogo;\n  if (Array.isArray(shop.brandAssets)) {\n    const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n    const mediaId = Media.findOne(brandAsset.mediaId);\n    emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n  } else {\n    emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n  }\n\n  const dataForEmail = {\n    // Shop Data\n    shop: shop,\n    contactEmail: shop.emails[0].address,\n    homepage: Meteor.absoluteUrl(),\n    emailLogo: emailLogo,\n    copyrightDate: moment().format(\"YYYY\"),\n    legalName: shop.addressBook[0].company,\n    physicalAddress: {\n      address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n      city: shop.addressBook[0].city,\n      region: shop.addressBook[0].region,\n      postal: shop.addressBook[0].postal\n    },\n    shopName: shop.name,\n    socialLinks: {\n      display: true,\n      facebook: {\n        display: true,\n        icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n        link: \"https://www.facebook.com\"\n      },\n      googlePlus: {\n        display: true,\n        icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n        link: \"https://plus.google.com\"\n      },\n      twitter: {\n        display: true,\n        icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n        link: \"https://www.twitter.com\"\n      }\n    },\n    // Account Data\n    passwordResetUrl: Accounts.urls.resetPassword(token),\n    user: user\n  };\n\n  // Compile Email with SSR\n  const tpl = \"accounts/resetPassword\";\n  const subject = \"accounts/resetPassword/subject\";\n  SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n  SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n  return Reaction.Email.send({\n    to: email,\n    from: Reaction.getShopEmail(),\n    subject: SSR.render(subject, dataForEmail),\n    html: SSR.render(tpl, dataForEmail)\n  });\n}\n\n\n/**\n * Send an email with a link the user can use verify their email address.\n * @param {String} userId - The id of the user to send email to.\n * @param {String} [email] Optional. Address to send the email to.\n *                 This address must be in the user's emails list.\n *                 Defaults to the first unverified email in the list.\n * @return {Job} - returns a sendEmail Job instance\n */\nexport function sendVerificationEmail(userId, email) {\n  // Make sure the user exists, and email is one of their addresses.\n  const user = Meteor.users.findOne(userId);\n\n  if (!user) {\n    Logger.error(\"sendVerificationEmail - User not found\");\n    throw new Meteor.Error(\"user-not-found\", \"User not found\");\n  }\n\n  let address = email;\n\n  // pick the first unverified address if no address provided.\n  if (!email) {\n    const unverifiedEmail = _.find(user.emails || [], (e) => !e.verified) || {};\n\n    address = unverifiedEmail.address;\n\n    if (!address) {\n      const msg = \"No unverified email addresses found.\";\n      Logger.error(msg);\n      throw new Meteor.Error(\"no-unverified-address\", msg);\n    }\n  }\n\n  // make sure we have a valid address\n  if (!address || !_.includes(_.map(user.emails || [], \"address\"), address)) {\n    const msg = \"Email not found for user\";\n    Logger.error(msg);\n    throw new Meteor.Error(\"email-not-found\", msg);\n  }\n\n  const token = Random.secret();\n  const when = new Date();\n  const tokenObj = { token, address, when };\n\n  Meteor.users.update({ _id: userId }, {\n    $push: {\n      \"services.email.verificationTokens\": tokenObj\n    }\n  });\n\n  const shopName = Reaction.getShopName();\n  const url = Accounts.urls.verifyEmail(token);\n\n  const dataForEmail = {\n    // Reaction Information\n    contactEmail: \"hello@reactioncommerce.com\",\n    homepage: Meteor.absoluteUrl(),\n    emailLogo: Meteor.absoluteUrl() + \"resources/placeholder.gif\",\n    copyrightDate: moment().format(\"YYYY\"),\n    legalName: \"Reaction Commerce\",\n    physicalAddress: {\n      address: \"2110 Main Street, Suite 207\",\n      city: \"Santa Monica\",\n      region: \"CA\",\n      postal: \"90405\"\n    },\n    shopName: shopName,\n    socialLinks: {\n      facebook: {\n        link: \"https://www.facebook.com/reactioncommerce\"\n      },\n      github: {\n        link: \"https://github.com/reactioncommerce/reaction\"\n      },\n      instagram: {\n        link: \"https://instagram.com/reactioncommerce\"\n      },\n      twitter: {\n        link: \"https://www.twitter.com/getreaction\"\n      }\n    },\n    confirmationUrl: url,\n    userEmailAddress: address\n  };\n\n  if (!Reaction.Email.getMailUrl()) {\n    Logger.warn(`\n\n  ***************************************************\n          IMPORTANT! EMAIL VERIFICATION LINK\n\n           Email sending is not configured.\n\n  Go to the following URL to verify email: ${address}\n\n  ${url}\n  ***************************************************\n\n    `);\n  }\n\n  const tpl = \"accounts/verifyEmail\";\n  const subject = \"accounts/verifyEmail/subject\";\n\n  SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n  SSR.compileTemplate(subject, Reaction.Email.getSubject(subject));\n\n  return Reaction.Email.send({\n    to: address,\n    from: Reaction.getShopEmail(),\n    subject: SSR.render(subject, dataForEmail),\n    html: SSR.render(tpl, dataForEmail)\n  });\n}\n","import nodemailer from \"nodemailer\";\nimport getServiceConfig from \"nodemailer-wellknown\";\nimport url from \"url\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Reaction, Logger } from \"/server/api\";\n\n\n/**\n * getMailUrl - get the smtp URL for sending emails\n * There are 3 possible ways to set the email configuration and\n * the first value found will be used.\n * The priority order is:\n *   1. MAIL_URL environment variable\n *   2. Meteor settings (MAIL_URL key)\n *   3. Core shop settings from the database\n * @return {String} returns an SMTP url if one of the settings have been set\n */\nexport function getMailUrl() {\n  const shopSettings = Reaction.getShopSettings();\n\n  let shopMail;\n\n  if (shopSettings) {\n    shopMail = shopSettings.mail || {};\n  }\n\n  // get all possible mail settings\n  const processUrl = process.env.MAIL_URL;\n  const settingsUrl = Meteor.settings.MAIL_URL;\n  const { service, user, password, host, port } = shopMail;\n\n  let mailString;\n\n  // create a mail url from well-known provider settings (if they exist)\n  // https://github.com/nodemailer/nodemailer-wellknown\n  if (service && service !== \"custom\" && user && password) {\n    const conf = getServiceConfig(service);\n\n    if (conf) {\n      // account for local test providers like Maildev\n      if (!conf.host) {\n        mailString = `smtp://localhost:${conf.port}`;\n      } else {\n        mailString = `smtp://${encodeURIComponent(user)}:${password}@${conf.host}:${conf.port}`;\n      }\n    }\n  }\n\n  // create a mail url from custom provider settings (if they exist)\n  if ((!service || service === \"custom\") && user && password && host && port) {\n    mailString = `smtp://${encodeURIComponent(user)}:${password}@${host}:${port}`;\n  }\n\n  // create the final url from the available options\n  const mailUrl = processUrl || settingsUrl || mailString;\n\n  if (!mailUrl) {\n    Logger.warn(\"Reaction.Email.getMailUrl() - no email provider configured\");\n    return null;\n  }\n\n  return mailUrl;\n}\n\n\n/**\n * getMailConfig - get the email sending config for Nodemailer\n * @return {{host: String, port: Number, secure: Boolean, auth: Object, logger: Boolean}} returns a config object\n */\nexport function getMailConfig() {\n  const processUrl = process.env.MAIL_URL;\n  const settingsUrl = Meteor.settings.MAIL_URL;\n\n  const mailString = processUrl || settingsUrl;\n\n  // if MAIL_URL or Meteor settings have been used,\n  // parse the URL and create a config object\n  if (mailString) {\n    // parse the url\n    const parsedUrl = url.parse(mailString);\n    const creds = parsedUrl.auth.split(\":\");\n    parsedUrl.port = Number(parsedUrl.port);\n\n    Logger.debug(`Using ${parsedUrl.hostname} to send email`);\n\n    // create a nodemailer config from the SMTP url string\n    return {\n      host: parsedUrl.hostname,\n      port: parsedUrl.port,\n      // since the port is casted to number above\n      secure: parsedUrl.port === 465,\n      auth: {\n        user: creds[0],\n        pass: creds[1]\n      },\n      logger: process.env.EMAIL_DEBUG === \"true\"\n    };\n  }\n\n  // check for mail settings in the database\n  const shopSettings = Reaction.getShopSettings();\n\n  let shopMail;\n\n  if (shopSettings) {\n    shopMail = shopSettings.mail || {};\n  }\n\n  const { service, user, password, host, port } = shopMail;\n\n  // if a service provider preset was chosen, return a Nodemailer config for it\n  // https://github.com/nodemailer/nodemailer-wellknown\n  if (service && service !== \"custom\" && user && password) {\n    Logger.debug(`Using ${service} to send email`);\n\n    // get the config from nodemailer-wellknown\n    const conf = getServiceConfig(service);\n\n    // account for local test providers like Maildev with no auth\n    if (!conf.host) {\n      return conf;\n    }\n\n    // add the credentials to the config\n    conf.auth = { user, pass: password };\n\n    return conf;\n  }\n\n  // if a custom config was chosen and all necessary fields exist in the database,\n  // return the custom Nodemailer config\n  if ((!service || service === \"custom\") && user && password && host && port) {\n    Logger.debug(`Using ${host} to send email`);\n\n    return {\n      host,\n      port,\n      secure: port === 465,\n      auth: { user, pass: password },\n      logger: process.env.EMAIL_DEBUG === \"true\"\n    };\n  }\n\n  // else, return the direct mail config and a warning\n  Logger.warn(`\n    Mail service not configured. Attempting to use direct sending option.\n    The mail may send, but messages are far more likely go to the user's spam folder.\n    Please configure an SMTP mail sending provider.\n  `);\n\n  return {\n    direct: true,\n    logger: process.env.EMAIL_DEBUG === \"true\"\n  };\n}\n\n\n/**\n * Verify a transporter configuration works\n * https://github.com/nodemailer/nodemailer#verify-smtp-connection-configuration\n * @param {Object} config - a Nodemailer transporter config object\n * @param {Function} callback - optional callback with standard error/result args\n * @return {Promise} returns a Promise if no callback is provided\n */\nexport function verifyConfig(config, callback) {\n  const transporter = nodemailer.createTransport(config);\n  return transporter.verify(callback);\n}\n","import { Meteor } from \"meteor/meteor\";\nimport { Job } from \"meteor/vsivsi:job-collection\";\nimport { Jobs, Templates } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\n\n\n/**\n * Reaction.Email.send()\n * (Job API doc) https://github.com/vsivsi/meteor-job-collection/#user-content-job-api\n * @param  {Object} options - object containing to/from/subject/html String keys\n * @return {Boolean} returns job object\n */\nexport function send(options) {\n  return new Job(Jobs, \"sendEmail\", options)\n    .retry({\n      retries: 5,\n      wait: 3 * 60000\n    }).save();\n}\n\n\n/**\n * Reaction.Email.getSubject() - Returns a subject source for SSR consumption\n * layout must be defined + template\n * @param {String} template name of the template in either Layouts or fs\n * @returns {Object} returns source\n */\nexport function getSubject(template) {\n  if (typeof template !== \"string\") {\n    const msg = \"Reaction.Email.getSubject() requires a template name\";\n    Logger.error(msg);\n    throw new Meteor.Error(\"no-template-name\", msg);\n  }\n\n  // set default\n  const language = Reaction.getShopLanguage();\n\n  // check database for a matching template\n  const tmpl = Templates.findOne({\n    name: template,\n    language\n  });\n\n  // use that template if found\n  if (tmpl && tmpl.template) {\n    return tmpl.subject;\n  }\n  return \"A message from {{shop.name}}\";\n}\n\n/**\n * Reaction.Email.getTemplate() - Returns a template source for SSR consumption\n * layout must be defined + template\n * @param {String} template name of the template in either Layouts or fs\n * @returns {Object} returns source\n */\nexport function getTemplate(template) {\n  if (typeof template !== \"string\") {\n    const msg = \"Reaction.Email.getTemplate() requires a template name\";\n    Logger.error(msg);\n    throw new Meteor.Error(\"no-template-name\", msg);\n  }\n\n  // set default\n  const language = Reaction.getShopLanguage();\n\n  // check database for a matching template\n  const tmpl = Templates.findOne({\n    name: template,\n    language\n  });\n\n  // use that template if found\n  if (tmpl && tmpl.template) {\n    return tmpl.template;\n  }\n\n  // otherwise, use the default template from the filesystem\n  return getTemplateFile(template);\n}\n\n/**\n * Reaction.Email.getTemplateFile\n * @param  {String} file name of the template on file system\n * @return {String} returns source\n */\nexport function getTemplateFile(file) {\n  if (typeof file !== \"string\") {\n    const msg = \"Reaction.Email.getTemplateFile() requires a template name\";\n    Logger.error(msg);\n    throw new Meteor.Error(\"no-template-name\", msg);\n  }\n\n  try {\n    return Assets.getText(`email/templates/${file}.html`);\n  } catch (e) {\n    Logger.warn(`Template not found: ${file}. Falling back to coreDefault.html`);\n    return Assets.getText(\"email/templates/coreDefault.html\");\n  }\n}\n","export * from \"./config\";\nexport * from \"./email\";\n","import { check, Match } from \"meteor/check\";\nimport { Shops } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\n\n\n/**\n * Add roles to the Shops.defaultRoles array\n * Options:\n * allShops: add supplied roles to all shops, defaults to false\n * roles: Array of roles to add to default roles set\n * shops: Array of shopIds that should be added to set\n * roleSets: Rolesets to add roles to, Options: [\"defaultRoles\", \"defaultVisitorRole\", \"defaultSellerRoles\"]\n * TODO: Review and eliminate rolesets other than \"default\"\n * @param {Object} options - See above for details\n * @returns {Number} result of Shops.update method (number of documents updated)\n */\nexport function addRolesToDefaultRoleSet(options = { allShops: false, roles: [], shops: [], roleSets: [\"defaultRoles\"] }) {\n  check(options.roles, [String]);\n  check(options.allShops, Match.Maybe(Boolean));\n  check(options.shops, Match.Maybe([String]));\n  check(options.roleSets, Match.Maybe([String]));\n\n  const { allShops, roles, shops, roleSets } = options;\n  const query = {};\n  const update = {};\n\n  if (!allShops) {\n    // if we're not updating all shops, we should only update the shops passed in.\n    query._id = {\n      $in: shops || []\n    };\n  }\n\n  roleSets.forEach((roleSet) => {\n    // We should add each role to each roleSet passed in.\n    update[roleSet] = { $each: roles };\n  });\n\n  if (allShops) {\n    Logger.debug(`Adding roles ${roles} to roleSets  ${roleSets} for all shops`);\n  } else {\n    Logger.debug(`Adding roles: ${roles} to roleSets: ${roleSets} for shops: ${shops}`);\n  }\n\n  return Shops.update(query, { $addToSet: update }, { multi: true });\n}\n","import { Roles } from \"meteor/alanning:roles\";\nimport { Logger } from \"/server/api\";\n\n/**\n * getRouteName\n * assemble route name to be standard\n * this is duplicate that exists in Reaction.Router\n * however this is to avoid a dependency in core\n * on the router\n * prefix/package name + registry name or route\n * @param  {[type]} packageName  [package name]\n * @param  {[type]} registryItem [registry object]\n * @return {String}              [route name]\n */\nfunction getRouteName(packageName, registryItem) {\n  let routeName;\n  if (packageName && registryItem) {\n    if (registryItem.name) {\n      routeName = registryItem.name;\n    } else if (registryItem.template) {\n      routeName = `${packageName}/${registryItem.template}`;\n    } else {\n      routeName = `${packageName}`;\n    }\n    // dont include params in the name\n    routeName = routeName.split(\":\")[0];\n    return routeName;\n  }\n  return null;\n}\n\n\n/**\n * assignOwnerRoles\n * populate roles with all the packages and their permissions\n * this is the main way that roles are inserted and created for\n * admin user.\n * we assign all package roles to each owner account for each shopId\n * we assign only basic GLOBAL_GROUP rights\n *\n * @param  {String} shopId - shopId\n * @param  {String} pkgName - Package name\n * @param  {String} registry - registry object\n * @return {undefined}\n */\n\nexport function assignOwnerRoles(shopId, pkgName, registry) {\n  const defaultRoles = [\"owner\", \"admin\", \"createProduct\", \"guest\", pkgName];\n  const globalRoles = defaultRoles;\n\n  if (registry) {\n      // for each registry item define and push roles\n    for (const registryItem of registry) {\n      // packages don't need to define specific permission routes.,\n      // the routeName will be used as default roleName for each route.\n      // todo: check dependency on this.\n      const roleName = getRouteName(pkgName, registryItem);\n      if (roleName) {\n        defaultRoles.push(roleName);\n      }\n\n      // Get all defined permissions, add them to an array\n      // define permissions if you need to check custom permission\n      if (registryItem.permissions) {\n        for (const permission of registryItem.permissions) {\n          defaultRoles.push(permission.permission);\n        }\n      }\n    }\n  } else {\n    Logger.debug(`No routes loaded for ${pkgName}`);\n  }\n  // only unique roles\n  const defaultOwnerRoles = _.uniq(defaultRoles);\n  // get existing shop owners to add new roles to\n  const owners = [];\n  const shopOwners = Roles.getUsersInRole(defaultOwnerRoles).fetch();\n  // just a nice warning. something is misconfigured.\n  if (!shopOwners) {\n    Logger.warn(\"Cannot assign roles without existing owner users.\");\n    return;\n  }\n  // assign this package permission to each existing owner.\n  for (const account of shopOwners) {\n    owners.push(account._id);\n  }\n  // we don't use accounts/addUserPermissions here because we may not yet have permissions\n  Roles.addUsersToRoles(owners, defaultOwnerRoles, shopId);\n\n  // the reaction owner has permissions to all sites by default\n  Roles.addUsersToRoles(owners, globalRoles, Roles.GLOBAL_GROUP);\n\n  Logger.debug(`Owner permissions added for ${pkgName}`);\n}\n","import url from \"url\";\nimport packageJson from \"/package.json\";\nimport { merge, uniqWith } from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { EJSON } from \"meteor/ejson\";\nimport { Jobs, Packages, Shops } from \"/lib/collections\";\nimport { Hooks, Logger } from \"/server/api\";\nimport ProcessJobs from \"/server/jobs\";\nimport { getRegistryDomain } from \"./setDomain\";\nimport { registerTemplate } from \"./templates\";\nimport { sendVerificationEmail } from \"./accounts\";\nimport { getMailUrl } from \"./email/config\";\n\n\nexport default {\n\n  init() {\n    // make sure the default shop has been created before going further\n    while (!this.getShopId()) {\n      Logger.warn(\"No shopId, waiting one second...\");\n      Meteor._sleepForMs(1000);\n    }\n\n    // run onCoreInit hooks\n    Hooks.Events.run(\"onCoreInit\");\n\n    // start job server\n    Jobs.startJobServer(() => {\n      Logger.info(\"JobServer started\");\n      ProcessJobs();\n      Hooks.Events.run(\"onJobServerStart\");\n    });\n    if (process.env.VERBOSE_JOBS) {\n      Jobs.setLogStream(process.stdout);\n    }\n\n    this.loadPackages();\n    // process imports from packages and any hooked imports\n    this.Import.flush();\n    // timing is important, packages are rqd for initial permissions configuration.\n    if (!Meteor.isAppTest) {\n      this.createDefaultAdminUser();\n    }\n    this.setAppVersion();\n    // hook after init finished\n    Hooks.Events.run(\"afterCoreInit\");\n\n    Logger.debug(\"Reaction.init() has run\");\n\n    return true;\n  },\n\n  Packages: {},\n\n  registerPackage(packageInfo) {\n    const registeredPackage = this.Packages[packageInfo.name] = packageInfo;\n    return registeredPackage;\n  },\n\n  /**\n   * registerTemplate\n   * registers Templates into the Tempaltes Collection\n   * @return {function} Registers template\n   */\n  registerTemplate: registerTemplate,\n\n  /**\n   * hasPermission - server\n   * server permissions checks\n   * hasPermission exists on both the server and the client.\n   * @param {String | Array} checkPermissions -String or Array of permissions if empty, defaults to \"admin, owner\"\n   * @param {String} userId - userId, defaults to Meteor.userId()\n   * @param {String} checkGroup group - default to shopId\n   * @return {Boolean} Boolean - true if has permission\n   */\n  hasPermission(checkPermissions, userId = Meteor.userId(), checkGroup = this.getShopId()) {\n    // check(checkPermissions, Match.OneOf(String, Array)); check(userId, String); check(checkGroup,\n    // Match.Optional(String));\n\n    let permissions;\n    // default group to the shop or global if shop isn't defined for some reason.\n    if (checkGroup !== undefined && typeof checkGroup === \"string\") {\n      group = checkGroup;\n    } else {\n      group = this.getShopId() || Roles.GLOBAL_GROUP;\n    }\n\n    // permissions can be either a string or an array we'll force it into an array and use that\n    if (checkPermissions === undefined) {\n      permissions = [\"owner\"];\n    } else if (typeof checkPermissions === \"string\") {\n      permissions = [checkPermissions];\n    } else {\n      permissions = checkPermissions;\n    }\n\n    // if the user has admin, owner permissions we'll always check if those roles are enough\n    permissions.push(\"owner\");\n    permissions = _.uniq(permissions);\n\n    // return if user has permissions in the group\n    if (Roles.userIsInRole(userId, permissions, group)) {\n      return true;\n    }\n\n    // global roles check\n    const sellerShopPermissions = Roles.getGroupsForUser(userId, \"admin\");\n\n    // we're looking for seller permissions.\n    if (sellerShopPermissions) {\n      // loop through shops roles and check permissions\n      for (const key in sellerShopPermissions) {\n        if (key) {\n          const shop = sellerShopPermissions[key];\n          if (Roles.userIsInRole(userId, permissions, shop)) {\n            return true;\n          }\n        }\n      }\n    }\n    // no specific permissions found returning false\n    return false;\n  },\n\n  hasOwnerAccess() {\n    return this.hasPermission([\"owner\"]);\n  },\n\n  hasAdminAccess() {\n    return this.hasPermission([\"owner\", \"admin\"]);\n  },\n\n  hasDashboardAccess() {\n    return this.hasPermission([\"owner\", \"admin\", \"dashboard\"]);\n  },\n\n  getSellerShopId() {\n    return Roles.getGroupsForUser(this.userId, \"admin\");\n  },\n\n  configureMailUrl() {\n    // maintained for legacy support\n    Logger.warn(\"Reaction.configureMailUrl() is deprecated. Please use Reaction.Email.getMailUrl() instead\");\n    return getMailUrl();\n  },\n\n  getCurrentShopCursor() {\n    const domain = this.getDomain();\n    const cursor = Shops.find({\n      domains: domain\n    }, { limit: 1 });\n    if (!cursor.count()) {\n      Logger.debug(domain, \"Add a domain entry to shops for \");\n    }\n    return cursor;\n  },\n\n  getCurrentShop() {\n    const currentShopCursor = this.getCurrentShopCursor();\n    // also, we could check in such a way: `currentShopCursor instanceof Object` but not instanceof something.Cursor\n    if (typeof currentShopCursor === \"object\") {\n      return currentShopCursor.fetch()[0];\n    }\n    return null;\n  },\n\n  getShopId() {\n    const domain = this.getDomain();\n    const shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        _id: 1\n      }\n    }).fetch()[0];\n    return shop && shop._id;\n  },\n\n  getDomain() {\n    return url.parse(Meteor.absoluteUrl()).hostname;\n  },\n\n  getShopName() {\n    const domain = this.getDomain();\n    const shop = Shops.find({\n      domains: domain\n    }, {\n      limit: 1,\n      fields: {\n        name: 1\n      }\n    }).fetch()[0];\n    return shop && shop.name;\n  },\n\n  getShopPrefix() {\n    return \"/\" + this.getSlug(this.getShopName().toLowerCase());\n  },\n\n  getShopEmail() {\n    const shop = Shops.find({\n      _id: this.getShopId()\n    }, {\n      limit: 1,\n      fields: {\n        emails: 1\n      }\n    }).fetch()[0];\n    return shop && shop.emails && shop.emails[0].address;\n  },\n\n  getShopSettings(name = \"core\") {\n    const settings = Packages.findOne({ name: name, shopId: this.getShopId() }) || {};\n    return settings.settings || {};\n  },\n\n  getShopCurrency() {\n    const shop = Shops.findOne({\n      _id: this.getShopId()\n    });\n\n    return shop && shop.currency || \"USD\";\n  },\n\n  getShopLanguage() {\n    const { language } = Shops.findOne({\n      _id: this.getShopId()\n    }, {\n      fields: {\n        language: 1\n      } }\n    );\n    return language;\n  },\n\n  getPackageSettings(name) {\n    return Packages.findOne({ packageName: name, shopId: this.getShopId() }) || null;\n  },\n\n  getAppVersion() {\n    return Shops.findOne().appVersion;\n  },\n\n  /**\n   * createDefaultAdminUser\n   * @summary Method that creates default admin user\n   * Settings load precendence:\n   *  1. settings in meteor.settings\n   *  2. environment variables\n   * @returns {String} return userId\n   */\n  createDefaultAdminUser() {\n    const domain = getRegistryDomain();\n    const env = process.env;\n    const defaultAdminRoles = [\"owner\", \"admin\", \"guest\", \"account/profile\"];\n    let options = {};\n    let configureEnv = false;\n    let accountId;\n\n    const shopId = this.getShopId();\n\n    // if an admin user has already been created, we'll exit\n    if (Roles.getUsersInRole(\"owner\", shopId).count() !== 0) {\n      Logger.debug(\"Not creating default admin user, already exists\");\n      return \"\"; // this default admin has already been created for this shop.\n    }\n\n    // run hooks on options object before creating user (the options object must be returned from all callbacks)\n    options = Hooks.Events.run(\"beforeCreateDefaultAdminUser\", options);\n\n    //\n    // process Meteor settings and env variables for initial user config if ENV variables are set, these always override\n    // \"settings.json\" this is to allow for testing environments. where we don't want to use users configured in a settings\n    // file.\n    //\n    if (env.REACTION_EMAIL && env.REACTION_USER && env.REACTION_AUTH) {\n      configureEnv = true;\n    }\n\n    // defaults use either env or generated\n    options.email = env.REACTION_EMAIL || Random.id(8).toLowerCase() + \"@\" + domain;\n    options.username = env.REACTION_USER || \"Admin\"; // username\n    options.password = env.REACTION_AUTH || Random.secret(8);\n\n    // but we can override with provided `meteor --settings`\n    if (Meteor.settings && !configureEnv) {\n      if (Meteor.settings.reaction) {\n        options.username = Meteor.settings.reaction.REACTION_USER || \"Admin\";\n        options.password = Meteor.settings.reaction.REACTION_AUTH || Random.secret(8);\n        options.email = Meteor.settings.reaction.REACTION_EMAIL || Random.id(8).toLowerCase() + \"@\" + domain;\n        Logger.info(\"Using meteor --settings to create admin user\");\n      }\n    }\n\n    // set the default shop email to the default admin email\n    Shops.update(shopId, {\n      $addToSet: {\n        emails: {\n          address: options.email,\n          verified: true\n        },\n        domains: Meteor.settings.ROOT_URL\n      }\n    });\n\n    //\n    // create the new admin user\n    //\n\n    // we're checking again to see if this user was created but not specifically for this shop.\n    if (Meteor.users.find({ \"emails.address\": options.email }).count() === 0) {\n      accountId = Accounts.createUser(options);\n    } else {\n      // this should only occur when existing admin creates a new shop\n      accountId = Meteor.users.findOne({ \"emails.address\": options.email })._id;\n    }\n\n    //\n    // send verification email\n    //\n\n    // we dont need to validate admin user in development\n    if (process.env.NODE_ENV === \"development\") {\n      Meteor.users.update({\n        \"_id\": accountId,\n        \"emails.address\": options.email\n      }, {\n        $set: {\n          \"emails.$.verified\": true\n        }\n      });\n    } else {\n      // send verification email to admin\n      sendVerificationEmail(accountId);\n    }\n\n    //\n    // Set Default Roles\n    //\n\n    // we don't use accounts/addUserPermissions here because we may not yet have permissions\n    Roles.setUserRoles(accountId, _.uniq(defaultAdminRoles), shopId);\n    // // the reaction owner has permissions to all sites by default\n    Roles.setUserRoles(accountId, _.uniq(defaultAdminRoles), Roles.GLOBAL_GROUP);\n    // initialize package permissions we don't need to do any further permission configuration it is taken care of in the\n    // assignOwnerRoles\n    const packages = Packages.find().fetch();\n    for (const pkg of packages) {\n      this.assignOwnerRoles(shopId, pkg.name, pkg.registry);\n    }\n\n    //\n    //  notify user that admin was created account email should print on console\n    //\n\n    Logger.warn(`\\n *********************************\n        \\n  IMPORTANT! DEFAULT ADMIN INFO\n        \\n  EMAIL/LOGIN: ${options.email}\n        \\n  PASSWORD: ${options.password}\n        \\n ********************************* \\n\\n`);\n\n    // run hooks on new user object\n    const user = Meteor.users.findOne(accountId);\n    Hooks.Events.run(\"afterCreateDefaultAdminUser\", user);\n    return accountId;\n  },\n\n  /**\n   *  loadPackages\n   *  insert Reaction packages into registry\n   *  we check to see if the number of packages have changed against current data\n   *  if there is a change, we'll either insert or upsert package registry\n   *  into the Packages collection\n   *  import is processed on hook in init()\n   *  @return {String} returns insert result\n   */\n  loadPackages() {\n    const packages = Packages.find().fetch();\n\n    let registryFixtureData;\n\n    if (process.env.REACTION_REGISTRY) {\n      // check the environment for the registry fixture data first\n      registryFixtureData = process.env.REACTION_REGISTRY;\n      Logger.info(\"Loaded REACTION_REGISTRY environment variable for registry fixture import\");\n    } else {\n      // or attempt to load reaction.json fixture data\n      try {\n        registryFixtureData = Assets.getText(\"settings/reaction.json\");\n        Logger.info(\"Loaded \\\"/private/settings/reaction.json\\\" for registry fixture import\");\n      } catch (error) {\n        Logger.warn(\"Skipped loading settings from reaction.json.\");\n        Logger.debug(error, \"loadSettings reaction.json not loaded.\");\n      }\n    }\n\n    if (!!registryFixtureData) {\n      const validatedJson = EJSON.parse(registryFixtureData);\n\n      if (!Array.isArray(validatedJson[0])) {\n        Logger.warn(\"Registry fixture data is not an array. Failed to load.\");\n      } else {\n        registryFixtureData = validatedJson;\n      }\n    }\n\n    const layouts = [];\n    // for each shop, we're loading packages in a unique registry\n    _.each(this.Packages, (config, pkgName) => {\n      return Shops.find().forEach((shop) => {\n        const shopId = shop._id;\n        if (!shopId) return [];\n\n        // existing registry will be upserted with changes, perhaps we should add:\n        this.assignOwnerRoles(shopId, pkgName, config.registry);\n\n        // Settings from the package registry.js\n        const settingsFromPackage = {\n          name: pkgName,\n          icon: config.icon,\n          enabled: !!config.autoEnable,\n          settings: config.settings,\n          registry: config.registry,\n          layout: config.layout\n        };\n\n        // Setting from a fixture file, most likely reaction.json\n        let settingsFromFixture;\n        if (registryFixtureData) {\n          settingsFromFixture = _.find(registryFixtureData[0], (packageSetting) => {\n            return config.name === packageSetting.name;\n          });\n        }\n\n        // Setting already imported into the packages collection\n        const settingsFromDB = _.find(packages, (ps) => {\n          return (config.name === ps.name && shopId === ps.shopId);\n        });\n\n        const combinedSettings = merge({}, settingsFromPackage, settingsFromFixture || {}, settingsFromDB || {});\n\n        // populate array of layouts that don't already exist in Shops\n        if (combinedSettings.layout) {\n          // filter out layout Templates\n          for (const pkg of combinedSettings.layout) {\n            if (pkg.layout) {\n              layouts.push(pkg);\n            }\n          }\n        }\n        // Import package data\n        this.Import.package(combinedSettings, shopId);\n        return Logger.debug(`Initializing ${shop.name} ${pkgName}`);\n      }); // end shops\n    });\n\n    // helper for removing layout duplicates\n    const uniqLayouts = uniqWith(layouts, _.isEqual);\n    // import layouts into Shops\n    Shops.find().forEach((shop) => {\n      this.Import.layout(uniqLayouts, shop._id);\n    });\n\n    //\n    // package cleanup\n    //\n    Shops.find().forEach((shop) => {\n      return Packages.find().forEach((pkg) => {\n        // delete registry entries for packages that have been removed\n        if (!_.has(this.Packages, pkg.name)) {\n          Logger.debug(`Removing ${pkg.name}`);\n          return Packages.remove({ shopId: shop._id, name: pkg.name });\n        }\n        return false;\n      });\n    });\n  },\n  setAppVersion() {\n    const version = packageJson.version;\n    Logger.info(`Reaction Version: ${version}`);\n    Shops.update({}, { $set: { appVersion: version } }, { multi: true });\n  }\n};\n","import { Mongo } from \"meteor/mongo\";\nimport { EJSON } from \"meteor/ejson\";\nimport * as Collections from \"/lib/collections\";\nimport Hooks from \"../hooks\";\nimport Logger from \"../logger\";\nimport doRightJoinNoIntersection from \"./rightJoin\";\n\n/**\n * @file Exposes the Import object implementing methods for bulk imports.\n * @author Tom De CaluwÃ©\n */\n\nexport const Import = {};\n\nImport._buffers = {};\nImport._contexts = {};\nImport._count = {};\nImport._indications = {};\nImport._limit = 1000;\n\nImport._name = function (collection) {\n  return collection._name;\n};\n\nImport._upsert = function () {\n  return true;\n};\n\n//\n// TODO Verify if Import.startup is deprecated\n//\nImport.startup = function () {\n  return true;\n};\n\nImport.load = function (key, object) {\n  check(object, Object);\n\n  this.object(this.identify(object), key, object);\n};\n\nImport.indication = function (field, collection, probability) {\n  check(field, String);\n  check(collection, Mongo.Collection);\n  check(probability, Number);\n\n  this._indications[field] = { collection, probability };\n};\n\n/**\n * Import.identify\n * @summary Tries to identify the schema associated with a document.\n * @param {Object} document - A document with unknown schema\n * @returns {Mongo.Collection} Returns a MongoDB collection in which the\n * document can be inserted.\n * @throws {Error} Throws an error if the schema couldn't be determined.\n *\n * The algorithm initially assumes the document can be anything. It associates\n * with each field in the document a probability that it isn't following some\n * schema other than the one the field is associated with.\n *\n * Afterwards the schema with the maximal probability is selected. An error is\n * thrown if the schema cannot be determined.\n */\nImport.identify = function (document) {\n  check(document, Object);\n\n  const probabilities = {};\n\n  for (key of Object.keys(document)) {\n    if (this._indications[key]) {\n      const collection = this._name(this._indications[key].collection);\n      probabilities[collection] = probabilities[collection] || 1.0 * this._indications[\n        key].probability;\n    }\n  }\n\n  let total = 1.0;\n  for (key of Object.keys(probabilities)) {\n    total *= probabilities[key];\n  }\n\n  let max = 0.0;\n  let name;\n  for (key of Object.keys(probabilities)) {\n    const probability = total / probabilities[key];\n    if (probability > max) {\n      max = probability;\n      name = key;\n    } else if (probability === max) {\n      name = undefined;\n    }\n  }\n\n  if (name && max > 0.3) {\n    return Collections[name];\n  }\n  throw new Error(\n    \"Couldn't determine the schema associated with this document\");\n};\n\n/**\n * @summary Commit the buffer for a given collection to the database.\n * @param {Mongo.Collection} collection The target collection to be flushed to disk\n * @returns {undefined}\n */\nImport.commit = function (collection) {\n  check(collection, Mongo.Collection);\n  // Construct a collection identifier.\n  const name = this._name(collection);\n\n  // Only commit if the buffer isn't empty (otherwise it'll throw).\n  if (this._count[name]) {\n    this.buffer(collection).execute(function (error, result) {\n      // Inserted document counts don't affect the modified document count, so we\n      // throw everything together.\n      const nImported = result.nModified + result.nInserted + result.nUpserted;\n      const nTouched = result.nMatched + result.nInserted + result.nUpserted;\n      const nRemoved = result.nRemoved;\n      // Log some information about the import.\n      if (nTouched) {\n        let message = \"Modified \" + nImported + (nImported === 1 ? \" document\" : \" documents\");\n        message += \" while importing \" + nTouched + \" to \" + name;\n        Logger.debug(message);\n      }\n      if (nRemoved) {\n        let message = \"Removed \" + nRemoved + (nRemoved === 1 ? \" document\" : \" documents\");\n        message += \" from \" + name;\n        Logger.debug(message);\n      }\n      // Log any errors returned.\n      const message = \"Error while importing to \" + name;\n      const writeErrors = result.getWriteErrors();\n      for (let i = 0; i < writeErrors.length; i++) {\n        Logger.warn(message + \": \" + writeErrors[i].errmsg);\n      }\n      const writeConcernError = result.getWriteConcernError();\n      if (writeConcernError) {\n        Logger.warn(message + \": \" + writeConcernError.errmsg);\n      }\n    });\n    // Reset the buffer.\n    delete this._buffers[name];\n    this._count[name] = 0;\n  }\n};\n\n/**\n * @summary Process the buffer for a given collection and commit the database.\n * @param {Mongo.Collection} collection optional - supply a Mongo collection, or leave empty to commit all buffer entries\n * @returns {undefined}\n */\nImport.flush = function (collection) {\n  if (!collection) {\n    for (const name of Object.keys(this._buffers)) {\n      this.commit(Collections[name]);\n    }\n    return;\n  }\n  this.commit(collection);\n};\n\n/**\n * @summary Get a validation context for a given collection.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} [selector] A selector object to retrieve the correct schema.\n * @returns {SimpleSchemaValidationContext} A validation context.\n *\n * The validation context is requested from the schema associated with the\n * collection.\n */\nImport.context = function (collection, selector) {\n  check(collection, Mongo.Collection);\n  check(selector, Match.Optional(Object));\n\n  // Construct a context identifier.\n  let name = this._name(collection);\n  if (selector && selector.type) {\n    name = `${name}_${selector.type}`;\n  }\n  // Construct a new validation context if necessary.\n  if (this._contexts[name]) {\n    return this._contexts[name];\n  }\n  this._contexts[name] = collection.simpleSchema(selector).newContext();\n  return this._contexts[name];\n};\n\n/**\n * @summary Get an import buffer for a given collection.\n * @param {Object} collection The target collection\n * @returns {Object} return buffer\n * If no buffer is presented, a new one will be constructed.\n */\nImport.buffer = function (collection) {\n  check(collection, Mongo.Collection);\n\n  if (!MongoInternals.NpmModule.Collection.prototype.initializeUnorderedBulkOp) {\n    throw Error(\"Couldn't detect the MongoDB bulk API, are you using MongoDB 2.6 or above?\");\n  }\n\n  // Construct a buffer identifier.\n  const name = this._name(collection);\n\n  // Construct a new buffer if necessary.\n  if (this._buffers[name]) {\n    return this._buffers[name];\n  }\n  this._count[name] = 0;\n  this._buffers[name] = collection.rawCollection().initializeUnorderedBulkOp();\n  return this._buffers[name];\n};\n\n/**\n * @summary Store a product in the import buffer.\n * @param {Object} key A key to look up the product\n * @param {Object} product The product data to be updated\n * @param {Object} parent A key to identify the parent product\n * @returns {Object}\n * Importing a variant currently consists of the following steps:\n *\n * * Pull the variant from non-matching parent products.\n * * Push the variant if it doesn't exist.\n * * Update the variant.\n */\nImport.product = function (key, product, parent) {\n  check(parent, Object);\n\n  return this.object(Collections.Products, key, product);\n};\n\n/**\n * @summary Store a package in the import buffer.\n * @param {Object} pkg The package data to be updated\n * @param {String} shopId The package data to be updated\n * @returns {undefined}\n */\nImport.package = function (pkg, shopId) {\n  check(pkg, Object);\n  check(shopId, String);\n  const key = {\n    name: pkg.name,\n    shopId: shopId\n  };\n  return this.object(Collections.Packages, key, pkg);\n};\n\n//\n// Import.translation\n// server/startup/i18n.js\n//\n\n/**\n * @summary Store a template in the import buffer.\n * @param {Object} templateInfo The template data to be updated\n * @param {String} shopId The package data to be updated\n * @returns {undefined}\n */\nImport.template = function (templateInfo) {\n  check(templateInfo, Object);\n\n  const key = {\n    name: templateInfo.name,\n    type: templateInfo.type || \"template\"\n  };\n\n  return this.object(Collections.Templates, key, templateInfo);\n};\n\n/**\n * @summary Store a translation in the import buffer.\n * @param {Object} key A key to look up the translation\n * @param {Object} translation The translation data to be updated\n * @returns {Object} updated translation buffer\n */\nImport.translation = function (key, translation) {\n  const modifiedKey = Object.assign(key, { ns: translation.ns });\n  return this.object(Collections.Translations, modifiedKey, translation);\n};\n\n/**\n * @summary Store a shop in the import buffer.\n * @param {Object} key A key to look up the shop\n * @param {Object} shop The shop data to be updated\n * @returns {Object} this shop\n */\nImport.shop = function (key, shop) {\n  return this.object(Collections.Shops, key, shop);\n};\n\n/**\n * @summary store a shop layout in the import buffer\n * @param {Array} layout - an array of layouts to be added to shop\n * @param {String} shopId shopId\n * @returns {Object} this shop\n */\nImport.layout = function (layout, shopId) {\n  const key = {\n    _id: shopId\n  };\n  return this.object(Collections.Shops, key, {\n    _id: shopId,\n    layout: layout\n  });\n};\n\n/**\n * @summary Store shipping in the import buffer.\n * @param {Object} key A shipping service key used in combination with provider\n * @param {Object} shipping The shipping data to be updated\n * @returns {Object} this shipping\n */\nImport.shipping = function (key, shipping) {\n  let importKey = {};\n  //\n  // we have a bit of a strange structure in Shipping\n  // and don't really have a key that is good for\n  // determining if we imported this before\n  // so we're just saying that if this service\n  // already exists then we're not going to import\n  //\n  const result = Collections.Shipping.findOne(key);\n  if (result) {\n    importKey = {\n      _id: result._id,\n      shopId: result.shopId\n    };\n    delete shipping.methods;\n  }\n  const modifiedKey = Object.assign({}, key, importKey);\n  return this.object(Collections.Shipping, modifiedKey, shipping);\n};\n\n/**\n * @summary Store a tag in the import buffer.\n * @param {Object} key A key to look up the tag\n * @param {Object} tag The tag data to be updated\n * @returns {Object} this tag\n */\nImport.tag = function (key, tag) {\n  return this.object(Collections.Tags, key, tag);\n};\n\n/**\n * @summary Push a new upsert document to the import buffer.\n * @param {Mongo.Collection} collection The target collection\n * @param {Object} key A key to look up the object\n * @param {Object} object The object data to be updated\n * @returns {undefined}\n */\nImport.object = function (collection, key, object) {\n  check(collection, Mongo.Collection);\n  check(key, Object);\n  check(object, Object);\n  const updateObject = object;\n\n  // enforce strings instead of Mongo.ObjectId\n  if (!collection.findOne(key) && !object._id) key._id = Random.id();\n\n  // hooks for additional import manipulation.\n  const importObject = Hooks.Events.run(`onImport${this._name(collection)}`, object);\n\n  // Clone object for cleaning\n  const cleanedObject = Object.assign({}, importObject);\n\n  // Cleaning the object adds default values from schema, if value doesn't exist\n  collection.simpleSchema(importObject).clean(cleanedObject);\n\n  // And validate the object against the schema\n  this.context(collection, updateObject).validate(cleanedObject, {});\n\n  // Disjoint importObject and cleanedObject again\n  // to prevent `Cannot update '<field>' and '<field>' at the same time` errors\n  const defaultValuesObject = doRightJoinNoIntersection(importObject, cleanedObject);\n\n  // Upsert the object.\n  const find = this.buffer(collection).find(key);\n\n  // With the upsert option set to true, if no matching documents exist for the Bulk.find() condition,\n  // then the update or the replacement operation performs an insert.\n  // https://docs.mongodb.com/manual/reference/method/Bulk.find.upsert/\n  if (Object.keys(defaultValuesObject).length === 0) {\n    find.upsert().update({\n      $set: importObject\n    });\n  } else {\n    find.upsert().update({\n      $set: importObject,\n      $setOnInsert: defaultValuesObject\n    });\n  }\n  if (this._count[this._name(collection)]++ >= this._limit) {\n    this.flush(collection);\n  }\n};\n\n/**\n * @summary Process a json array of import documents using a callback.\n * @param {Object[]} json An array containing the import documents\n * @param {string[]} keys Fields that should be used as the import key.\n * @param {Function} callback A callback accepting two parameters.\n * The callback should accept a key document to consult the database as a first\n * parameter and an update document as the second parameter.\n * @returns {undefined}\n */\nImport.process = function (json, keys, callback) {\n  check(json, String);\n  check(keys, Array);\n  check(callback, Function);\n\n  const array = EJSON.parse(json);\n\n  for (let i = 0; i < array.length; i++) {\n    const key = {};\n    for (let j = 0; j < keys.length; j++) {\n      key[keys[j]] = array[i][keys[j]];\n    }\n    callback.call(this, key, array[i]);\n  }\n};\n\nImport.indication(\"i18n\", Collections.Translations, 0.2);\nImport.indication(\"hashtags\", Collections.Products, 0.5);\nImport.indication(\"barcode\", Collections.Products, 0.5);\nImport.indication(\"price\", Collections.Products, 0.5);\nImport.indication(\"ancestors\", Collections.Products, 0.5);\nImport.indication(\"languages\", Collections.Shops, 0.5);\nImport.indication(\"currencies\", Collections.Shops, 0.5);\nImport.indication(\"timezone\", Collections.Shops, 0.5);\nImport.indication(\"isTopLevel\", Collections.Tags, 0.4);\nImport.indication(\"slug\", Collections.Tags, 0.5);\nImport.indication(\"provider\", Collections.Shipping, 0.2);\n\n//\n// exporting Fixture\n// use this instead of Import if you want\n// Bulk.find.upsert() to equal false\n//\nexport const Fixture = Object.assign({}, Import, {\n  _upsert: () => { return false; }\n});\n","import Core from \"./core\";\nimport * as Accounts from \"./accounts\";\nimport * as AddDefaultRoles from \"./addDefaultRoles\";\nimport * as AssignRoles from \"./assignRoles\";\nimport * as Email from \"./email\";\nimport * as Import from \"./import\";\nimport * as LoadSettings from \"./loadSettings\";\nimport Log from \"../logger\";\nimport Router from \"../router\";\nimport * as SetDomain from \"./setDomain\";\nimport * as ShopName from \"./shopName\";\nimport * as UI from \"./ui\";\nimport * as Utils from \"./utils\";\n\nimport * as Collections from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\n\n/**\n * Reaction methods (server)\n */\nconst Reaction = Object.assign({},\n  Core,\n  { Accounts },\n  AddDefaultRoles,\n  AssignRoles,\n  { Collections },\n  { Email },\n  Import,\n  LoadSettings,\n  { Log },\n  { Router },\n  { Schemas },\n  SetDomain,\n  ShopName,\n  UI,\n  Utils\n);\n\nexport default Reaction;\n","import { Packages } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\nimport { EJSON } from \"meteor/ejson\";\n\n/**\n * ReactionRegistry.loadSettings\n * @description\n * This basically allows you to \"hardcode\" all the settings. You can change them\n * via admin etc for the session, but when the server restarts they'll\n * be restored back to the supplied json\n *\n * All settings are private unless added to `settings.public`\n *\n * Meteor account services can be added in `settings.services`\n * @summary updates package settings, accepts json string\n * @param {Object} json - json object to insert\n * @return {Boolean} boolean -  returns true on insert\n * @example\n *  ReactionRegistry.loadSettings Assets.getText(\"settings/reaction.json\")\n */\nexport function loadSettings(json) {\n  check(json, String);\n  let exists;\n  let service;\n  let services;\n  let settings;\n  const validatedJson = EJSON.parse(json);\n\n  // validate json and error out if not an array\n  if (!_.isArray(validatedJson[0])) {\n    Logger.warn(\n      \"Load Settings is not an array. Failed to load settings.\");\n    return;\n  }\n\n  // loop settings and upsert packages.\n  for (const pkg of validatedJson) {\n    for (const item of pkg) {\n      exists = Packages.findOne({\n        name: item.name\n      });\n      //\n      // TODO migrate functionality to Reaction.Import\n      // Reaction.Import.package(item, shopId);\n      //\n      // insert into the Packages collection\n      if (exists) {\n        result = Packages.upsert({\n          name: item.name\n        }, {\n          $set: {\n            settings: item.settings,\n            enabled: item.enabled\n          }\n        }, {\n          multi: true,\n          upsert: true,\n          validate: false\n        });\n      }\n      // sets the private settings of various\n      // accounts authentication services\n      if (item.settings.services) {\n        for (services of item.settings.services) {\n          for (service in services) {\n            // actual settings for the service\n            if ({}.hasOwnProperty.call(services, service)) {\n              settings = services[service];\n              ServiceConfiguration.configurations.upsert({\n                service: service\n              }, {\n                $set: settings\n              });\n              Logger.debug(\"service configuration loaded: \" +\n                item.name + \" | \" + service);\n            }\n          }\n        }\n      }\n      Logger.debug(`loaded local package data: ${item.name}`);\n    }\n  }\n}\n","/**\n * @summary Returns an disjoint object as right join. For a visualization, see:\n *          http://www.codeproject.com/KB/database/Visual_SQL_Joins/Visual_SQL_JOINS_orig.jpg\n *          Additionally, the join is done recursively on properties of\n *          nested objects as well. Nested arrays are handled like\n *          primitive values.\n * @author Tom De CaluwÃ©\n * @param {Object} leftSet An object that can contain nested sub-objects\n * @param {Object} rightSet An object that can contain nested sub-objects\n * @returns {Object} The disjoint object that does only contain properties\n *                   from the rightSet. But only those, that were not present\n *                   in the leftSet.\n */\nconst doRightJoinNoIntersection = (leftSet, rightSet) => {\n  if (rightSet === null) return null;\n\n  let rightJoin;\n  if (Array.isArray(rightSet)) {\n    rightJoin = [];\n  } else {\n    rightJoin = {};\n  }\n  const findRightOnlyProperties = () => {\n    return Object.keys(rightSet).filter(function (key) {\n      if (typeof(rightSet[key]) === \"object\" &&\n        !Array.isArray(rightSet[key])) {\n        // Nested objects are always considered\n        return true;\n      }\n      // Array or primitive value\n      return !leftSet.hasOwnProperty(key);\n    });\n  };\n\n  for (const key of findRightOnlyProperties()) {\n    if (typeof(rightSet[key]) === \"object\") {\n      // subobject or array\n      if (leftSet.hasOwnProperty(key) && (typeof(leftSet[key]) !== \"object\" ||\n           Array.isArray(leftSet[key]) !== Array.isArray(rightSet[ key ]))) {\n        // This is not expected!\n        throw new Error(\n          \"Left object and right object's internal structure must be \" +\n          \"congruent! Offending key: \" + key\n        );\n      }\n      const rightSubJoin = doRightJoinNoIntersection(\n        leftSet.hasOwnProperty(key) ? leftSet[key] : {},\n        rightSet[key]\n      );\n\n      const obj = {};\n      if (rightSubJoin === null) {\n        obj[key] = null;\n      } else if (Object.keys(rightSubJoin).length !== 0 ||\n                 Array.isArray(rightSubJoin)) {\n        // object or (empty) array\n        obj[key] = rightSubJoin;\n      }\n      rightJoin = Object.assign(rightJoin, obj);\n    } else {\n      // primitive value (or array)\n      if (Array.isArray(rightSet)) {\n        rightJoin.push(rightSet[key]);\n      } else {\n        const obj = {};\n        obj[key] = rightSet[key];\n        rightJoin = Object.assign(rightJoin, obj);\n      }\n    }\n  }\n  return rightJoin;\n};\n\nexport default doRightJoinNoIntersection;\n","import { Shops } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\n\n/**\n * getDomain\n * local helper for creating admin users\n * @param {String} requestUrl - url\n * @return {String} domain name stripped from requestUrl\n */\nexport function getRegistryDomain(requestUrl) {\n  const url = requestUrl || process.env.ROOT_URL;\n  const domain = url.match(/^https?\\:\\/\\/([^\\/:?#]+)(?:[\\/:?#]|$)/i)[1];\n  return domain;\n}\n\n\n/**\n *  @private setDomain\n *  @summary update the default shop url if ROOT_URL supplied is different from current\n *  @return {String} returns insert result\n */\nexport function setDomain() {\n  let currentDomain;\n  // we automatically update the shop domain when ROOT_URL changes\n  try {\n    currentDomain = Shops.findOne().domains[0];\n  } catch (_error) {\n    Logger.error(_error, \"Failed to determine default shop.\");\n  }\n  // if the server domain changes, update shop\n  const domain = getRegistryDomain();\n  if (currentDomain && currentDomain !== domain) {\n    Logger.debug(\"Updating domain to \" + domain);\n    Shops.update({\n      domains: currentDomain\n    }, {\n      $set: {\n        \"domains.$\": domain\n      }\n    });\n  }\n}\n","import { Shops } from \"/lib/collections\";\nimport { Logger } from \"/server/api\";\n\n/**\n *  setShopName\n *  @private setShopName\n *  @param {Object} shop - shop\n *  @summary when new shop is created, set shop name if REACTION_SHOP_NAME env var exists\n *  @returns {undefined} undefined\n */\nexport function setShopName(shop) {\n  const shopName = process.env.REACTION_SHOP_NAME;\n\n  if (shopName) {\n    // if this shop name has already been used, don't use it again\n    if (!!Shops.findOne({\n      name: shopName\n    })) {\n      Logger.info(`Default shop name ${shopName} already used`);\n    } else {\n      // update the shop name with the REACTION_SHOP_NAME env var\n      try {\n        Shops.update({\n          _id: shop._id\n        }, {\n          $set: {\n            name: shopName\n          }\n        });\n      } catch (err) {\n        Logger.error(\"Failed to update shop name\", err);\n      }\n    }\n  }\n}\n","import React from \"react\";\nimport ReactDOMServer from \"react-dom/server\";\nimport Handlebars from \"handlebars\";\nimport Immutable from \"immutable\";\nimport { Assets, Templates } from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\nlet registeredTemplates = Immutable.OrderedMap();\nlet templateCache = Immutable.Map();\nlet templateParsers = Immutable.Map();\n\n// var ReactComponentPrototype = React.Component.prototype\n// var ReactClassComponentPrototype = (Object.getPrototypeOf(Object.getPrototypeOf(new (React.createClass({ render () {} }))())))\n\nexport const TEMPLATE_PARSER_REACT = \"react\";\nexport const TEMPLATE_PARSER_HANDLEBARS = \"handlebars\";\n\nexport function registerTemplate(templateInfo, shopId, insertImmediately = false) {\n  const literal = registerTemplateForMemoryCache(templateInfo, shopId);\n  const reference = registerTemplateForDatabase(templateInfo, shopId, insertImmediately);\n\n  return {\n    templateLiteral: literal,\n    templateReference: reference\n  };\n}\n\nexport function registerTemplateForMemoryCache(templateInfo, shopId) {\n  // Process template info and cache in memory.\n  // This allows us to have function and class references for the templates for\n  // React and other custom parsers\n  const templateInfoForMemoryCache = processTemplateInfoForMemoryCache(templateInfo);\n  let shopTemplates = registeredTemplates.get(shopId);\n\n  if (!shopTemplates) {\n    shopTemplates = {};\n  }\n\n  shopTemplates[templateInfo.name] = templateInfoForMemoryCache;\n  registeredTemplates = registeredTemplates.set(shopId, shopTemplates);\n\n  return templateInfoForMemoryCache;\n}\n\nexport function registerTemplateForDatabase(templateInfo) {\n  // Process template info for use in a database\n  // Namely, any literals like functions are stripped as they cannot be safetly,\n  // and should not stored in the database\n  const templateInfoForDatabase = processTemplateInfoForDatabase(templateInfo);\n\n  // Import template into the Assets collecton.\n  Assets.update({\n    type: \"template\",\n    name: templateInfoForDatabase.name\n  }, {\n    $set: {\n      content: JSON.stringify(templateInfoForDatabase)\n    }\n  }, {\n    upsert: true\n  });\n\n  // Return template data crafted for entry into a database\n  return templateInfoForDatabase;\n}\n\nexport function getTemplateByName(templateName, shopId) {\n  const registeredTemplate = registeredTemplates.get(shopId)[templateName];\n\n  if (registeredTemplate) {\n    return registeredTemplate;\n  }\n\n  const templateInfo = Templates.findOne({\n    name: templateName,\n    $or: [\n      // Attemt to find user editable / edited templated first\n      {\n        isOriginalTemplate: false\n      },\n      // Fallback to the original templates\n      {\n        isOriginalTemplate: true\n      }\n    ],\n    shopId\n  });\n\n  return registerTemplateForMemoryCache(templateInfo);\n}\n\nexport function processTemplateInfoForMemoryCache(templateInfo) {\n  // Avoid mutating the original passed in param\n  const info = Immutable.Map(templateInfo);\n\n  if (typeof templateInfo.template === \"string\") {\n    // Set the template parser to Handlebars for string based templates\n    return info.set(\"parser\", TEMPLATE_PARSER_HANDLEBARS).toObject();\n  } else if (typeof templateInfo.template === \"function\") {\n    // Set the parser to react for React components\n    return info.set(\"parser\", TEMPLATE_PARSER_REACT).toObject();\n  } else if (typeof templateInfo.template === \"object\") {\n    // Set the parser to react for React components\n    return info.set(\"parser\", TEMPLATE_PARSER_REACT).toObject();\n  }\n\n  return null;\n}\n\nexport function processTemplateInfoForDatabase(templateInfo) {\n  const templateData = {\n    name: templateInfo.name,\n    title: templateInfo.title,\n    type: templateInfo.type,\n    subject: templateInfo.subject,\n    templateFor: templateInfo.templateFor\n  };\n\n\n  if (typeof templateInfo.template === \"string\") {\n    templateData.template = templateInfo.template;\n    templateData.parser = TEMPLATE_PARSER_HANDLEBARS;\n  } else if (typeof templateInfo.template === \"object\") {\n    templateData.template = templateInfo.template;\n    templateData.parser = TEMPLATE_PARSER_REACT;\n  } else if (typeof templateInfo.template === \"function\") {\n    templateData.parser = TEMPLATE_PARSER_REACT;\n  }\n\n  return templateData;\n}\n\n\nexport function registerTemplateParser(name, renderFunction) {\n  templateParsers = templateParsers.set(name, renderFunction);\n}\n\nexport function renderTemplate(templateInfo, data = {}) {\n  if (templateInfo.parser === TEMPLATE_PARSER_REACT) {\n    return null;\n  } else if (templateInfo.parser === TEMPLATE_PARSER_HANDLEBARS) {\n    return renderHandlebarsTemplate(templateInfo, data);\n  }\n\n  if (typeof templateParsers.get(name) === \"function\") {\n    return templateParsers.get(name)(templateInfo, data);\n  }\n\n  return false;\n}\n\n/**\n * Compile and cache Handlebars template\n * @param {String} name Name of template to register amd save to cache\n * @param {String} template markup\n * @return {Function} Compiled handlebars template.\n */\nexport function compileHandlebarsTemplate(name, template) {\n  const compiledTemplate = Handlebars.compile(template);\n  templateCache = templateCache.set(name, compiledTemplate);\n  return compiledTemplate;\n}\n\nexport function renderHandlebarsTemplate(templateInfo, data) {\n  if (templateCache[templateInfo.name] === undefined) {\n    compileHandlebarsTemplate(templateInfo.name, templateInfo.template);\n  }\n\n  const compiledTemplate = templateCache.get(templateInfo.name);\n  return compiledTemplate(data);\n}\n\nexport function renderTemplateToStaticMarkup(template, props) {\n  return ReactDOMServer.renderToStaticMarkup(\n    React.createElement(template, props)\n  );\n}\n\n/**\n * Reset regestered templates\n * This is mostly useful for aiding in unit testing\n * @return {Immutable.OrderedMap} immultable.js OrderedMap\n */\nexport function resetRegisteredTemplates() {\n  registeredTemplates = Immutable.OrderedMap();\n}\n\n\nexport function initTemplates() {\n  /**\n   * Hook to setup core Templates imports during Reaction init\n   */\n  Hooks.Events.add(\"afterCoreInit\", () => {\n    Assets.find({ type: \"template\" }).forEach((t) => {\n      Logger.debug(`Importing ${t.name} template`);\n      if (t.content) {\n        Reaction.Import.template(JSON.parse(t.content));\n      } else {\n        Logger.debug(`No template content found for ${t.name} asset`);\n      }\n    });\n    Reaction.Import.flush();\n  });\n}\n\n\nexport default {\n  get registeredTemplates() {\n    return registeredTemplates;\n  },\n  get templateCache() {\n    return templateCache;\n  },\n  get templateParsers() {\n    return templateParsers;\n  },\n  registerTemplate,\n  getTemplateByName,\n  processTemplateInfoForDatabase,\n  processTemplateInfoForMemoryCache,\n  compileHandlebarsTemplate,\n  renderHandlebarsTemplate,\n  renderTemplateToStaticMarkup\n};\n","import postcss from \"postcss\";\nimport postcssJS from \"postcss-js\";\nimport autoprefixer from \"autoprefixer\";\nimport cssAnnotation from \"css-annotation\";\nimport { Shops, Themes } from \"/lib/collections\";\nimport { Reaction } from \"./core\";\n\nconst prefixer = postcssJS.sync([autoprefixer]);\n\nfunction annotateCSS(stylesheet) {\n  check(stylesheet, String);\n  return cssAnnotation.parse(stylesheet);\n}\n\nfunction cssToObject(styles) {\n  check(styles, Match.OneOf(String, null, undefined, void 0));\n\n  const parsedStyle = postcss.parse(styles || baseStyles);\n  const styleObject = postcssJS.objectify(parsedStyle);\n\n  return styleObject;\n}\n\nfunction objectToCSS(styles) {\n  const prefixedStyles = prefixer(styles);\n  return postcss().process(prefixedStyles, { parser: postcssJS });\n}\n\nfunction themeToCSS(theme) {\n  check(theme, Object);\n  let output = \"\";\n\n  for (const component of theme.components) {\n    output += component.styles;\n  }\n\n  return output;\n}\n\nfunction updateStyles(data) {\n  check(data, Object);\n  this.unblock();\n\n  objectToCSS(data.styles).then((result) => {\n    if (result.css) {\n      return Themes.update({\n        \"name\": data.theme.name,\n        \"components.name\": data.component.name\n      }, {\n        $set: {\n          [\"components.$.styles\"]: result.css\n        }\n      });\n    }\n  });\n}\n\nfunction publishTheme(theme) {\n  check(theme, Object);\n  this.unblock();\n  const styles = themeToCSS(theme);\n\n  Shops.update({\n    _id: Reaction.getShopId()\n  }, {\n    $set: {\n      theme: {\n        themeId: theme._id,\n        styles: styles\n      }\n    }\n  });\n}\n\nexport function registerTheme(styles) {\n  check(styles, String);\n\n  const annotations = cssAnnotation.parse(styles);\n  const {\n    name,\n    label,\n    theme\n  } = annotations[0];\n\n  const hasComponent = Themes.find({\n    \"name\": theme,\n    \"components.name\": name\n  }).count();\n\n  if (hasComponent) {\n    Themes.update({\n      \"name\": theme,\n      \"components.name\": name\n    }, {\n      $set: {\n        \"components.$\": {\n          name,\n          label: label || name,\n          styles,\n          annotations\n        }\n      }\n    });\n  } else {\n    Themes.upsert({\n      name: theme\n    }, {\n      $set: {\n        name: theme\n      },\n      $push: {\n        components: {\n          name,\n          label: label || name,\n          styles,\n          annotations\n        }\n      }\n    });\n  }\n}\n\nfunction duplicateTheme(name) {\n  check(name, String);\n\n  const theme = Themes.find({\n    theme: name\n  });\n\n  delete theme._id;\n  theme.name = `${name} copy`;\n\n  return Themes.insert(theme);\n}\n\n\nMeteor.methods({\n  \"ui/updateStyles\": updateStyles,\n  \"ui/publishTheme\": publishTheme,\n  \"ui/cssToObject\": cssToObject,\n  \"ui/registerTheme\": registerTheme,\n  \"ui/processAnnotations\": annotateCSS,\n  \"ui/duplicateTheme\": duplicateTheme,\n  \"ui/themeToCSS\": themeToCSS\n});\n","import { slugify } from \"transliteration\";\n\n/**\n * getSlug - return a slugified string using \"slugify\" from transliteration\n * https://www.npmjs.com/package/transliteration\n * @param  {String} slugString - string to slugify\n * @return {String} slugified string\n */\nexport function getSlug(slugString) {\n  return slugString ? slugify(slugString) : \"\";\n}\n","import { Packages } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\nimport { HTTP } from \"meteor/http\";\nimport { Meteor } from \"meteor/meteor\";\n\n/**\n * meteor-geocoder\n * modifed for reaction core.\n *\n * https://github.com/aldeed/meteor-geocoder\n * The MIT License (MIT)\n * Copyright (c) 2014 Eric Dobbertin\n */\n\n// backwards compatibility\nif (typeof Meteor.wrapAsync === \"undefined\") {\n  Meteor.wrapAsync = Meteor._wrapAsync;\n}\n/* eslint func-style: 1 */\n//\n// init geocoder\nexport const GeoCoder = (options) => {\n  let extra;\n  const self = this;\n  // fetch shop settings for api auth credentials\n  const shopSettings = Packages.findOne({\n    shopId: Reaction.getShopId(),\n    name: \"core\"\n  }, {\n    fields: {\n      settings: 1\n    }\n  });\n\n  if (shopSettings) {\n    if (shopSettings.settings.google) {\n      extra = {\n        clientId: shopSettings.settings.google.clientId,\n        apiKey: shopSettings.settings.google.apiKey\n      };\n    }\n  }\n\n  self.options = _.extend({\n    geocoderProvider: \"google\",\n    httpAdapter: \"https\",\n    extra: extra\n  }, options || {});\n};\n\nfunction gc(address, options, callback) {\n  const g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter,\n    options.extra);\n  g.geocode(address, callback);\n}\n\nGeoCoder.prototype.geocode = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n      if (error) throw error;\n    });\n    gc(geoAddress, this.options, geoCallback);\n  } else {\n    geoAddress = Meteor.wrapAsync(gc)(geoAddress, this.options);\n    return geoAddress[0];\n  }\n};\n\nfunction rv(lat, lng, options, callback) {\n  const g = require(\"node-geocoder\")(options.geocoderProvider, options.httpAdapter,\n    options.extra);\n  g.reverse({\n    lat: lat,\n    lon: lng\n  }, callback);\n}\n\nGeoCoder.prototype.reverse = function geoCoderReverse(lat, lng, callback) {\n  let geoCallback = callback;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n      if (error) throw error;\n    });\n    rv(lat, lng, this.options, geoCallback);\n  } else {\n    try {\n      address = Meteor.wrapAsync(rv)(lat, lng, this.options);\n      return address[0];\n    } catch (_error) {\n      return {\n        latitude: null,\n        longitude: null,\n        country: \"United States\",\n        city: null,\n        state: null,\n        stateCode: null,\n        zipcode: null,\n        streetName: null,\n        streetNumber: null,\n        countryCode: \"US\"\n      };\n    }\n  }\n};\n\nfunction gi(address, callback) {\n  let lookupAddress = address;\n  // short term solution to an haproxy ssl cert installation issue\n  process.env.NODE_TLS_REJECT_UNAUTHORIZED = 0;\n  // if we're local, let's let freegeoip guess.\n  if (lookupAddress === \"127.0.0.1\" || lookupAddress === null) {\n    lookupAddress = \"\";\n  }\n  // calls a private reaction hosted version of freegeoip\n  HTTP.call(\"GET\", `https://geo.getreaction.io/json/${lookupAddress}`, callback);\n}\n\nGeoCoder.prototype.geoip = function geoCoderGeocode(address, callback) {\n  let geoCallback = callback;\n  let geoAddress = address;\n  if (geoCallback) {\n    geoCallback = Meteor.bindEnvironment(geoCallback, function (error) {\n      if (error) throw error;\n    });\n    gi(geoAddress, this.options, geoCallback);\n  } else {\n    try {\n      geoAddress = Meteor.wrapAsync(gi)(geoAddress);\n      return geoAddress.data;\n    } catch (error) {\n      Logger.warn(\"shop/getLocale geoip lookup failure\", error);\n      return {};\n    }\n  }\n};\n","import { Meteor } from \"meteor/meteor\";\n/**\n * Callback hooks to alter the behavior of common operations or trigger other things.\n * @namespace Hooks.Events\n */\nconst Hooks = {};\nHooks.Events = {};\n\n\n/**\n * Add a callback function to a hook\n * @param {String} name - The name of the hook\n * @param {Function} callback - The callback function\n * @return {Array} array of the currently defined hooks\n */\nHooks.Events.add = (name, callback) => {\n  // if callback array doesn't exist yet, initialize it\n  if (typeof Hooks.Events[name] === \"undefined\") {\n    Hooks.Events[name] = [];\n  }\n  return Hooks.Events[name].push(callback);\n};\n\n\n/**\n * Remove a callback from a hook\n * @param {String} name - The name of the hook\n * @param {String} callbackName - The name of the function to remove\n * @return {Array} array of remaining callbacks\n */\nHooks.Events.remove = (name, callbackName) => {\n  Hooks.Events[name] = _.reject(Hooks.Events[name], (callback) => {\n    return callback.name === callbackName;\n  });\n\n  return Hooks.Events;\n};\n\n\n/**\n * Successively run all of a hook's callbacks on an item\n * @param {String} name - The name of the hook\n * @param {Object} item - The object, modifier, etc. on which to run the callbacks\n * @param {Object} [constant] - An optional constant that will be passed along to each callback\n * @return {Object} Returns the item after it has been through all callbacks for this hook\n */\nHooks.Events.run = (name, item, constant) => {\n  const callbacks = Hooks.Events[name];\n\n  // if the hook exists, and contains callbacks to run\n  if (typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    return callbacks.reduce((result, callback) => {\n      return callback(result, constant);\n    }, item);\n  }\n  return item;\n};\n\n\n/**\n * Successively run all of a hook's callbacks on an item, in async mode (only works on server)\n * @param {String} name - The name of the hook\n * @param {Object} item - The object, modifier, etc. on which to run the callbacks\n * @param {Object} [constant] - An optional constant that will be passed along to each callback\n * @return {Object} Returns the item after it has been through all callbacks for this hook\n */\nHooks.Events.runAsync = (name, item, constant) => {\n  const callbacks = Hooks.Events[name];\n\n  if (Meteor.isServer && typeof callbacks !== \"undefined\" && !!callbacks.length) {\n    // use defer to avoid holding up client\n    Meteor.defer(() => {\n      // run all async server callbacks successively on object\n      callbacks.forEach((callback) => {\n        callback(item, constant);\n      });\n    });\n  }\n  return item;\n};\n\n\nexport default Hooks;\n","import Reaction from \"./core\";\nimport * as Accounts from \"./core/accounts\";\nimport Router from \"./router\";\nimport { GeoCoder } from \"./geocoder\";\nimport Hooks from \"./hooks\";\nimport Logger from \"./logger\";\nimport { MethodHooks } from \"./method-hooks\";\n\n// Legacy globals\n// TODO: add deprecation warnings\nReactionCore = Reaction;\nReactionRouter = Router;\nReactionRegistry = {\n  assignOwnerRoles: Reaction.assignOwnerRoles,\n  createDefaultAdminUser: Reaction.createDefaultAdminUser,\n  getRegistryDomain: Reaction.getRegistryDomain,\n  loadPackages: Reaction.loadPackages,\n  loadSettings: Reaction.loadSettings,\n  Packages: Reaction.Packages,\n  setDomain: Reaction.setDomain,\n  setShopName: Reaction.setShopName\n};\n\nexport {\n  Reaction,\n  Accounts,\n  Router,\n  GeoCoder,\n  Hooks,\n  Logger,\n  MethodHooks\n};\n","import bunyan from \"bunyan\";\nimport bunyanFormat from \"bunyan-format\";\nimport Bunyan2Loggly from \"bunyan-loggly\";\nimport { includes } from \"lodash\";\n\n// configure bunyan logging module for reaction server\n// See: https://github.com/trentm/node-bunyan#levels\nconst levels = [\"FATAL\", \"ERROR\", \"WARN\", \"INFO\", \"DEBUG\", \"TRACE\"];\n\n// set stdout log level\nlet level = process.env.REACTION_LOG_LEVEL || Meteor.settings.REACTION_LOG_LEVEL || \"INFO\";\nlet outputMode = \"short\";\n\nlevel = level.toUpperCase();\n\nif (!includes(levels, level)) {\n  level = \"INFO\";\n}\n\nif (level === \"TRACE\") {\n  outputMode = \"json\";\n}\n\n// default console config (stdout)\nconst streams = [{\n  level,\n  stream: bunyanFormat({ outputMode })\n}];\n\n// Loggly config (only used if configured)\nconst logglyToken = process.env.LOGGLY_TOKEN;\nconst logglySubdomain = process.env.LOGGLY_SUBDOMAIN;\n\nif (logglyToken && logglySubdomain) {\n  const logglyStream = {\n    type: \"raw\",\n    level: process.env.LOGGLY_LOG_LEVEL || \"DEBUG\",\n    stream: new Bunyan2Loggly({\n      token: logglyToken,\n      subdomain: logglySubdomain\n    })\n  };\n  streams.push(logglyStream);\n}\n\n// create default logger instance\nconst Logger = bunyan.createLogger({\n  name: \"Reaction\",\n  streams\n});\n\nexport default Logger;\n","import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\n\n/*\n *  Blatant reuse of Meteor method hooks from\n *  @see https://github.com/hitchcott/meteor-method-hooks\n *  @see https://github.com/Workpop/meteor-method-hooks\n */\nexport const MethodHooks = {};\n\n/**\n * A hook to be run before or after a method.\n * @name Hook\n * @function\n * @return {*} The result of the method. Ignored for before hooks, passed as the methodResult to subsequent method hooks.\n * You can mutate the return value in after hooks.\n * @param {{result: *, error: *, arguments: Array, hooksProcessed: Number}} An options parameter that has the result and\n * error from calling the method and the arguments used to call that method. `result` and `error` are null for before\n * hooks, since the method has not yet been called. On the client, after hooks are called when the method returns from\n * the server, but before the callback is invoked. `hooksProcessed` gives you the number of hooks processed so far,\n * since previous hooks may have mutated the arguments.\n *\n * After hooks can change the result values. Use `hooksProcessed` to keep track of how many modifications have been\n * made.\n */\n\n/**\n * A collection of after hooks\n * @type {Object.<String, [Hook]>} A mapping from method names to arrays of hooks\n * @private\n */\nMethodHooks._afterHooks = {};\n\n/**\n * A collection of before hooks\n * @type {Object.<String, [Hook]>} A mapping from method names to arrays of hooks\n * @private\n */\nMethodHooks._beforeHooks = {};\n\n/**\n * handlers\n * The method handler definitions appropriate to the environment\n */\nMethodHooks._handlers = Meteor.isClient ? Meteor.connection._methodHandlers :\n  Meteor.server.method_handlers;\n\n/**\n * The original method handlers\n * @type {Object.<String, Function>} Method handler mapping\n * @private\n */\nMethodHooks._originalMethodHandlers = {};\n\n/**\n * Wrappers\n * @type {Object.<String, Function>} A mapping from method names to method functions\n * @private\n */\nMethodHooks._wrappers = {};\n\n/**\n *  initializeHook\n * @summary Initializes a new hook\n * @param {String} mapping - map hook: a is  place to store the mapping\n * @param {String} methodName - The name of the method\n * @param {Function} hookFunction - The hook function\n * @private\n * @return {String} - returns transformed data\n */\nMethodHooks._initializeHook = function (mapping, methodName, hookFunction) {\n  mapping[methodName] = mapping[methodName] || [];\n  mapping[methodName].push(hookFunction);\n\n  // Initialize a wrapper for the given method name. Idempotent, it will not erase existing handlers.\n  const method = MethodHooks._handlers[methodName];\n  // If no method is found, or a wrapper already exists, return\n  if (!method || MethodHooks._wrappers[methodName]) {\n    return;\n  }\n\n  // Get a reference to the original handler\n  MethodHooks._originalMethodHandlers[methodName] = method;\n\n  MethodHooks._wrappers[methodName] = function () {\n    // Get arguments you can mutate\n    const args = _.toArray(arguments);\n    let beforeResult;\n    // Call the before hooks\n\n    const beforeHooks = MethodHooks._beforeHooks[methodName];\n    _.each(beforeHooks, (beforeHook, hooksProcessed) => {\n      beforeResult = beforeHook.call(this, {\n        result: undefined,\n        error: undefined,\n        arguments: args,\n        hooksProcessed: hooksProcessed\n      });\n\n      if (beforeResult === false) {\n        return false;\n      }\n    });\n\n    if (beforeResult === false) {\n      return false;\n    }\n    let methodResult;\n    let methodError;\n\n    // Call the main method body\n    // check(args, Match.Any);\n    try {\n      methodResult = MethodHooks._originalMethodHandlers[methodName].apply(this, args);\n    } catch (error) {\n      methodError = error;\n    }\n\n    // Call after hooks, providing the result and the original arguments\n    const afterHooks = MethodHooks._afterHooks[methodName];\n    _.each(afterHooks, (afterHook, hooksProcessed) => {\n      const hookResult = afterHook.call(this, {\n        result: methodResult,\n        error: methodError,\n        arguments: args,\n        hooksProcessed: hooksProcessed\n      });\n      // If the after hook did not return a value and the methodResult is not undefined, warn and fix\n      if (_.isUndefined(hookResult) && !_.isUndefined(methodResult)) {\n        Meteor._debug(\"Expected the after hook to return a value.\");\n      } else {\n        methodResult = hookResult;\n      }\n    });\n\n    // If an error was thrown, throw it after the after hooks. Ought to include the correct stack information\n    if (methodError) {\n      throw methodError;\n    }\n\n    // Return the method result, possibly modified by the after hook\n    return methodResult;\n  };\n\n  // Assign to a new handler\n  MethodHooks._handlers[methodName] = MethodHooks._wrappers[\n    methodName];\n};\n\n/**\n * Reaction MethodHooks before\n * @summary Add a function to call before the specified method\n * @param {String} methodName - methodName\n * @param {String} beforeFunction - beforeFunction\n * @return {String} - returns transformed data\n */\nMethodHooks.before = function (methodName, beforeFunction) {\n  MethodHooks._initializeHook(MethodHooks._beforeHooks,\n    methodName, beforeFunction);\n};\n\n/**\n * MethodHooks.after\n * Add a function to call after the specified method\n * @param {String} methodName - methodName\n * @param {String} afterFunction - afterFunction\n * @return {String} - returns transformed data\n */\nMethodHooks.after = function (methodName, afterFunction) {\n  MethodHooks._initializeHook(MethodHooks._afterHooks,\n    methodName, afterFunction);\n};\n\n/**\n * MethodHooks.beforeMethods\n * Call the provided hook in values for the key'd method names\n * @param {Object.<string, Hook>} dict - dict\n * @return {String} - returns transformed data\n */\nMethodHooks.beforeMethods = function (dict) {\n  _.each(dict, function (v, k) {\n    MethodHooks.before(k, v);\n  });\n};\n\n/**\n * Call the provided hook in values for the key'd method names\n * @param {Object.<string, Hook>} dict - dict\n * @return {String} - returns transformed data\n */\nMethodHooks.afterMethods = function (dict) {\n  _.each(dict, function (v, k) {\n    MethodHooks.after(k, v);\n  });\n};\n","// server can defer loading\nconst Router = {};\nexport default Router;\n","import { Meteor } from \"meteor/meteor\";\nimport { Cart } from \"/lib/collections\";\nimport { Logger, MethodHooks } from \"/server/api\";\n// this needed to keep correct loading order. Methods should be loaded before hooks\nimport \"../cart\";\n\n// // Meteor.after to call after\nMethodHooks.after(\"cart/submitPayment\", function (options) {\n  // if cart/submit had an error we won't copy cart to Order\n  // and we'll throw an error.\n  Logger.debug(\"MethodHooks after cart/submitPayment\", options);\n  // Default return value is the return value of previous call in method chain\n  // or an empty object if there's no result yet.\n  const result = options.result || {};\n  if (typeof options.error === \"undefined\") {\n    const cart = Cart.findOne({\n      userId: Meteor.userId()\n    });\n\n    // update workflow\n    Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"paymentSubmitted\");\n\n    // create order\n    if (cart) {\n      if (!cart.billing) {\n        Logger.debug(\"MethodHooks after cart/submitPayment. No billing address after payment! userId:\", Meteor.userId(), \"options:\", options);\n      }\n\n      if (cart.items && cart.billing && cart.billing[0].paymentMethod) {\n        const orderId = Meteor.call(\"cart/copyCartToOrder\", cart._id);\n        // Return orderId as result from this after hook call.\n        // This is done by extending the existing result.\n        result.orderId = orderId;\n      } else {\n        throw new Meteor.Error(\n          \"An error occurred verifing payment method. Failed to save order.\"\n        );\n      }\n    }\n  }\n  return result;\n});\n","import { Logger, MethodHooks } from \"/server/api\";\n// this needed to keep correct loading order. Methods should be loaded before hooks\nimport \"../shop\";\n\nMethodHooks.after(\"shop/createTag\", function (options) {\n  if (options.error) {\n    Logger.warn(\"Failed to add new tag:\", options.error.reason);\n    return options.error;\n  }\n  if (typeof options.result === \"string\") {\n    Logger.debug(`Created tag with _id: ${options.result}`);\n  }\n\n  return options.result;\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Reaction } from \"/server/api\";\n\n\n/**\n *  Step 4 of the \"workflow/pushOrderWorkflow\" flow\n *\tThe following methods are called from Orders.before.update hook.\n *\n *\t@see packages/reaction-schema/common/hooks/orders.js\n *\t@see packages/reaction-core/common/methods/workflow.js\n */\nMeteor.methods({\n  /**\n   * workflow/coreOrderWorkflow/coreOrderProcessing\n   * Workflow method that checks permissions for a given user to allow them to\n   * move an order into the processing phase.\n   * @param  {Object} options An object containing arbitary data\n   * @return {Boolean} true to allow action, false to cancel execution of hook\n   */\n  \"workflow/coreOrderWorkflow/coreOrderProcessing\": function (options) {\n    check(options, Match.OrderHookOptions());\n    const userId = options.userId;\n\n    return Reaction.hasPermission([\"dashboard/orders\"], userId);\n  },\n\n  /**\n   * workflow/coreOrderWorkflow/coreOrderCompleted\n   * Workflow method that performs verios check to determine if an order may be\n   * moved into the completed phase.\n   * @param  {Object} options An object containing arbitary data\n   * @return {Boolean} true to allow action, false to cancel execution of hook\n   */\n  \"workflow/coreOrderWorkflow/coreOrderCompleted\": function (options) {\n    check(options, Match.OrderHookOptions());\n\n    const order = options.order;\n\n    const result = _.every(order.items, (item) => {\n      return _.includes(item.workflow.workflow, \"coreOrderItemWorkflow/completed\");\n    });\n\n    return result;\n  }\n});\n","import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport * as Collections from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * quantityProcessing\n * @summary perform calculations admissibility of adding product to cart\n * @param {Object} product - product to add to Cart\n * @param {Object} variant - product variant\n * @param {Number} itemQty - qty to add to cart, defaults to 1, deducts\n *  from inventory\n * @since 1.10.1\n * @return {Number} quantity - revised quantity to be added to cart\n */\nfunction quantityProcessing(product, variant, itemQty = 1) {\n  let quantity = itemQty;\n  const MIN = variant.minOrderQuantity || 1;\n  const MAX = variant.inventoryQuantity || Infinity;\n\n  if (MIN > MAX) {\n    Logger.debug(`productId: ${product._id}, variantId ${variant._id\n      }: inventoryQuantity lower then minimum order`);\n    throw new Meteor.Error(`productId: ${product._id}, variantId ${variant._id\n      }: inventoryQuantity lower then minimum order`);\n  }\n\n  // TODO: think about #152 implementation here\n  switch (product.type) {\n    case \"not-in-stock\":\n      break;\n    default: // type: `simple` // todo: maybe it should be \"variant\"\n      if (quantity < MIN) {\n        quantity = MIN;\n      } else if (variant.inventoryPolicy && quantity > MAX) {\n        quantity = MAX;\n      }\n  }\n\n  return quantity;\n}\n\n/**\n * getSessionCarts\n * @summary get Cart cursor with all session carts\n * @param {String} userId - current user _id\n * @param {String} sessionId - current user session id\n * @param {String} shopId - shop id\n * @since 0.10.2\n * @return {Mongo.Cursor} with array of session carts\n */\nfunction getSessionCarts(userId, sessionId, shopId) {\n  const carts = Collections.Cart.find({\n    $and: [{\n      userId: {\n        $ne: userId\n      }\n    }, {\n      sessionId: {\n        $eq: sessionId\n      }\n    }, {\n      shopId: {\n        $eq: shopId\n      }\n    }]\n  });\n\n  // we can't use Array.map here, because we need to reduce the number of array\n  // elements if element belongs to registered user, we should throw it.\n  const allowedCarts = [];\n\n  // only anonymous user carts allowed\n  carts.forEach(cart => {\n    if (Roles.userIsInRole(cart.userId, \"anonymous\", shopId)) {\n      allowedCarts.push(cart);\n    }\n  });\n\n  return allowedCarts;\n}\n\n/**\n * Reaction Cart Methods\n */\n\n\nMeteor.methods({\n  /**\n   * cart/mergeCart\n   * @summary merge matching sessionId cart into specified userId cart\n   *\n   * There should be one cart for each independent, non logged in user session\n   * When a user logs in that cart now belongs to that user and we use the a\n   * single user cart.\n   * If they are logged in on more than one devices, regardless of session,the\n   * user cart will be used\n   * If they had more than one cart, on more than one device,logged in at\n   * separate times then merge the carts\n   *\n   * @param {String} cartId - cartId of the cart to merge matching session\n   * carts into.\n   * @param {String} [currentSessionId] - current client session id\n   * @todo I think this method should be moved out from methods to a Function\n   * Declaration to keep it more secure\n   * @return {Object|Boolean} cartId - cartId on success or false\n   */\n  \"cart/mergeCart\": function (cartId, currentSessionId) {\n    check(cartId, String);\n    check(currentSessionId, Match.Optional(String));\n\n    // we don't process current cart, but merge into it.\n    const currentCart = Collections.Cart.findOne(cartId);\n    if (!currentCart) {\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n    // just used to filter out the current cart\n    // we do additional check of cart exists here and if it not exist, next\n    // check supposed to throw 403 error\n    const userId = currentCart && currentCart.userId;\n    // user should have an access to operate with only one - his - cart\n    if (this.userId !== null && userId !== this.userId) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // persistent sessions, see: publications/sessions.js\n    // this is the last place where we still need `Reaction.sessionId`.\n    // The use case is: on user log in. I don't know how pass `sessionId` down\n    // at that moment.\n    const sessionId = currentSessionId || Reaction.sessionId;\n    const shopId = Reaction.getShopId();\n\n    // no need to merge anonymous carts\n    if (Roles.userIsInRole(userId, \"anonymous\", shopId)) {\n      return false;\n    }\n    Logger.debug(\"merge cart: matching sessionId\");\n    Logger.debug(\"current userId:\", userId);\n    Logger.debug(\"sessionId:\", sessionId);\n    // get session carts without current user cart cursor\n    const sessionCarts = getSessionCarts(userId, sessionId, shopId);\n\n    Logger.debug(\n      `merge cart: begin merge processing of session ${\n      sessionId} into: ${currentCart._id}`\n    );\n    // loop through session carts and merge into user cart\n    sessionCarts.forEach(sessionCart => {\n      Logger.debug(\n        `merge cart: merge user userId: ${userId}, sessionCart.userId: ${\n          sessionCart.userId}, sessionCart id: ${sessionCart._id}`\n      );\n      // really if we have no items, there's nothing to merge\n      if (sessionCart.items) {\n        // if currentCart already have a cartWorkflow, we don't need to clean it\n        // up completely, just to `coreCheckoutShipping` stage. Also, we will\n        // need to recalculate shipping rates\n        if (typeof currentCart.workflow === \"object\" &&\n        typeof currentCart.workflow.workflow === \"object\") {\n          if (currentCart.workflow.workflow.length > 2) {\n            Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n            // refresh shipping quotes\n            Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n          }\n        } else {\n          // if user logged in he doesn't need to show `checkoutLogin` step\n          Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n        }\n\n        // We got an additional db call because of `workflow/revertCartWorkflow`\n        // call, but we also got things more cleaner in my opinion.\n        // merge session cart into current cart\n        Collections.Cart.update(currentCart._id, {\n          $addToSet: {\n            items: {\n              $each: sessionCart.items\n            }\n          }\n        });\n      }\n\n      // cleanup session Carts after merge.\n      if (sessionCart.userId !== this.userId) {\n        // clear the cart that was used for a session\n        // and we're also going to do some garbage Collection\n        Collections.Cart.remove(sessionCart._id);\n        // cleanup user/accounts\n        Collections.Accounts.remove({\n          userId: sessionCart.userId\n        });\n        Meteor.users.remove(sessionCart.userId);\n        Logger.debug(\n          `merge cart: delete cart ${\n          sessionCart._id} and user: ${sessionCart.userId}`\n        );\n      }\n      Logger.debug(\n        `merge cart: processed merge for cartId ${sessionCart._id}`\n      );\n    });\n\n    // `checkoutLogin` should be used for anonymous only. Registered users\n    // no need see this.\n    if (currentCart.workflow.status === \"new\") {\n      // to call `workflow/pushCartWorkflow` two times is the only way to move\n      // from status \"new\" to \"checkoutAddressBook\" which I found without\n      // refactoring of `workflow/pushCartWorkflow`\n      // We send `cartId` as arguments because this method could be called from\n      // publication method and in half cases it could be so, that\n      // Meteor.userId() will be null.\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"checkoutLogin\", cartId);\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"checkoutAddressBook\", cartId);\n    }\n\n    return currentCart._id;\n  },\n\n  /**\n   * cart/createCart\n   * @description create new cart for user, but all checks for current cart's\n   * existence should go before this method will be called, to keep it clean\n   * @summary create and return new cart for user\n   * @param {String} userId - userId to create cart for\n   * @param {String} sessionId - current client session id\n   * @todo I think this method should be moved out from methods to a Function\n   * Declaration to keep it more secure\n   * @returns {String} cartId - users cartId\n   */\n  \"cart/createCart\": function (userId, sessionId) {\n    check(userId, String);\n    check(sessionId, String);\n\n    const shopId = Reaction.getShopId();\n    // check if user has `anonymous` role.( this is a visitor)\n    const anonymousUser = Roles.userIsInRole(userId, \"anonymous\", shopId);\n    const sessionCartCount = getSessionCarts(userId, sessionId, shopId).length;\n\n    Logger.debug(\"create cart: shopId\", shopId);\n    Logger.debug(\"create cart: userId\", userId);\n    Logger.debug(\"create cart: sessionId\", sessionId);\n    Logger.debug(\"create cart: sessionCarts.count\", sessionCartCount);\n    Logger.debug(\"create cart: anonymousUser\", anonymousUser);\n\n    // we need to create a user cart for the new authenticated user or\n    // anonymous.\n    const currentCartId = Collections.Cart.insert({\n      sessionId: sessionId,\n      userId: userId\n    });\n    Logger.debug(\"create cart: into new user cart. created: \" +  currentCartId +\n      \" for user \" + userId);\n\n    // merge session carts into the current cart\n    if (sessionCartCount > 0 && !anonymousUser) {\n      Logger.debug(\"create cart: found existing cart. merge into \" + currentCartId\n        + \" for user \" + userId);\n      Meteor.call(\"cart/mergeCart\", currentCartId, sessionId);\n    }\n\n    // we should check for an default billing/shipping address in user account.\n    // this needed after submitting order, when user receives new cart\n    const account = Collections.Accounts.findOne(userId);\n    if (account && account.profile && account.profile.addressBook) {\n      account.profile.addressBook.forEach(address => {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", currentCartId, address);\n        }\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", currentCartId, address);\n        }\n      });\n    }\n\n    // attach current user currency to cart\n    const currentUser = Meteor.user();\n    let userCurrency = Reaction.getShopCurrency();\n\n    // Check to see if the user has a custom currency saved to their profile\n    // Use it if they do\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = currentUser.profile.currency;\n    }\n    Meteor.call(\"cart/setUserCurrency\", currentCartId, userCurrency);\n\n    return currentCartId;\n  },\n\n  /**\n   *  cart/addToCart\n   *  @summary add items to a user cart\n   *  when we add an item to the cart, we want to break all relationships\n   *  with the existing item. We want to fix price, qty, etc into history\n   *  however, we could check reactively for price /qty etc, adjustments on\n   *  the original and notify them\n   *  @param {String} productId - productId to add to Cart\n   *  @param {String} variantId - product variant _id\n   *  @param {Number} [itemQty] - qty to add to cart\n   *  @return {Number|Object} Mongo insert response\n   */\n  \"cart/addToCart\": function (productId, variantId, itemQty) {\n    check(productId, String);\n    check(variantId, String);\n    check(itemQty, Match.Optional(Number));\n\n    const cart = Collections.Cart.findOne({ userId: this.userId });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n    // With the flattened model we no longer need to work directly with the\n    // products. But product still could be necessary for a `quantityProcessing`\n    // TODO: need to understand: do we really need product inside\n    // `quantityProcessing`?\n    let product;\n    let variant;\n    Collections.Products.find({ _id: { $in: [\n      productId,\n      variantId\n    ] } }).forEach(doc => {\n      if (doc.type === \"simple\") {\n        product = doc;\n      } else {\n        variant = doc;\n      }\n    });\n\n    // TODO: this lines still needed. We could uncomment them in future if\n    // decide to not completely remove product data from this method\n    // const product = Collections.Products.findOne(productId);\n    // const variant = Collections.Products.findOne(variantId);\n    if (!product) {\n      Logger.warn(`Product: ${ productId } was not found in database`);\n      throw new Meteor.Error(404, \"Product not found\",\n        \"Product with such id was not found!\");\n    }\n    if (!variant) {\n      Logger.warn(`Product variant: ${ variantId } was not found in database`);\n      throw new Meteor.Error(404, \"ProductVariant not found\",\n        \"ProductVariant with such id was not found!\");\n    }\n    // performs calculations admissibility of adding product to cart\n    const quantity = quantityProcessing(product, variant, itemQty);\n    // performs search of variant inside cart\n    const cartVariantExists = cart.items && cart.items\n      .some(item => item.variants._id === variantId);\n\n    if (cartVariantExists) {\n      return Collections.Cart.update({\n        \"_id\": cart._id,\n        \"items.variants._id\": variantId\n      }, {\n        $inc: {\n          \"items.$.quantity\": quantity\n        }\n      }, function (error, result) {\n        if (error) {\n          Logger.warn(\"error adding to cart\",\n            Collections.Cart.simpleSchema().namedContext().invalidKeys());\n          return error;\n        }\n\n        // refresh shipping quotes\n        Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n        // revert workflow to checkout shipping step.\n        Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n        // reset selected shipment method\n        Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n        Logger.debug(`cart: increment variant ${variantId} quantity by ${\n          quantity}`);\n\n        return result;\n      });\n    }\n\n    // cart variant doesn't exist\n    return Collections.Cart.update({\n      _id: cart._id\n    }, {\n      $addToSet: {\n        items: {\n          _id: Random.id(),\n          shopId: product.shopId,\n          productId: productId,\n          quantity: quantity,\n          variants: variant,\n          title: product.title,\n          type: product.type,\n          parcel: product.parcel || null\n        }\n      }\n    }, function (error, result) {\n      if (error) {\n        Logger.error(error);\n        Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(),\n          \"Invalid keys. Error adding to cart.\");\n        return error;\n      }\n\n      // refresh shipping quotes\n      Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n      // revert workflow to checkout shipping step.\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n      // reset selected shipment method\n      Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n      Logger.debug(`cart: add variant ${variantId} to cartId ${cart._id}`);\n\n      return result;\n    });\n  },\n\n  /**\n   * cart/removeFromCart\n   * @summary removes or adjust quantity of a variant from the cart\n   * @param {String} itemId - cart item _id\n   * @param {Number} [quantity] - if provided will adjust increment by quantity\n   * @returns {Number} returns Mongo update result\n   */\n  \"cart/removeFromCart\": function (itemId, quantity) {\n    check(itemId, String);\n    check(quantity, Match.Optional(Number));\n\n    const userId = Meteor.userId();\n    const cart = Collections.Cart.findOne({\n      userId: userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(\"cart-not-found\", \"Cart not found for user with such id\");\n    }\n\n    let cartItem;\n\n    if (cart.items) {\n      cartItem = _.find(cart.items, (item) => item._id === itemId);\n    }\n\n    // extra check of item exists\n    if (typeof cartItem !== \"object\") {\n      Logger.error(`Unable to find an item: ${itemId} within the cart: ${cart._id}`);\n      throw new Meteor.Error(\"cart-item-not-found\", \"Unable to find an item with such id in cart.\");\n    }\n\n    // refresh shipping quotes\n    Meteor.call(\"shipping/updateShipmentQuotes\", cart._id);\n    // revert workflow to checkout shipping step.\n    Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    // reset selected shipment method\n    Meteor.call(\"cart/resetShipmentMethod\", cart._id);\n\n    if (!quantity || quantity >= cartItem.quantity) {\n      return Collections.Cart.update({\n        _id: cart._id\n      }, {\n        $pull: {\n          items: {\n            _id: itemId\n          }\n        }\n      }, (error, result) => {\n        if (error) {\n          Logger.error(error);\n          Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(),\n            \"error removing from cart\");\n          return error;\n        }\n        Logger.debug(`cart: deleted cart item variant id ${cartItem.variants._id}`);\n        return result;\n      });\n    }\n\n    // if quantity lets convert to negative and increment\n    const removeQuantity = Math.abs(quantity) * -1;\n    return Collections.Cart.update({\n      \"_id\": cart._id,\n      \"items._id\": cartItem._id\n    }, {\n      $inc: {\n        \"items.$.quantity\": removeQuantity\n      }\n    }, (error, result) => {\n      if (error) {\n        Logger.error(error);\n        Logger.error(Collections.Cart.simpleSchema().namedContext().invalidKeys(),\n          \"error removing from cart\");\n        return error;\n      }\n      Logger.debug(`cart: removed variant ${cartItem._id} quantity of ${quantity}`);\n      return result;\n    });\n  },\n\n  /**\n   * cart/copyCartToOrder\n   * @summary transform cart to order when a payment is processed we want to\n   * copy the cart over to an order object, and give the user a new empty\n   * cart. reusing the cart schema makes sense, but integrity of the order, we\n   * don't want to just make another cart item\n   * @todo:  Partial order processing, shopId processing\n   * @todo:  Review Security on this method\n   * @param {String} cartId - cartId to transform to order\n   * @return {String} returns orderId\n   */\n  \"cart/copyCartToOrder\": function (cartId) {\n    check(cartId, String);\n    const cart = Collections.Cart.findOne(cartId);\n    // security check\n    if (cart.userId !== this.userId) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const order = Object.assign({}, cart);\n    const sessionId = cart.sessionId;\n\n    if (!order.items || order.items.length === 0) {\n      const msg = \"An error occurred saving the order. Missing cart items.\";\n      Logger.error(msg);\n      throw new Meteor.Error(\"no-cart-items\", msg);\n    }\n\n    Logger.debug(\"cart/copyCartToOrder\", cartId);\n    // reassign the id, we'll get a new orderId\n    order.cartId = cart._id;\n\n    // a helper for guest login, we let guest add email afterwords\n    // for ease, we'll also add automatically for logged in users\n    if (order.userId && !order.email) {\n      const user = Collections.Accounts.findOne(order.userId);\n      // we could have a use case here when email is not defined by some reason,\n      // we could throw an error, but it's not pretty clever, so let it go w/o\n      // email\n      if (typeof user === \"object\" && user.emails) {\n        for (const email of user.emails) {\n          // alternate order email address\n          if (email.provides === \"orders\") {\n            order.email = email.address;\n          } else if (email.provides === \"default\") {\n            order.email = email.address;\n          }\n        }\n      }\n    }\n\n    // schema should provide order defaults\n    // so we'll delete the cart autovalues\n    delete order.createdAt; // autovalues\n    delete order.updatedAt;\n    delete order.cartCount;\n    delete order.cartShipping;\n    delete order.cartSubTotal;\n    delete order.cartTaxes;\n    delete order.cartDiscounts;\n    delete order.cartTotal;\n    delete order._id;\n\n    // `order.shipping` is array ?\n    if (Array.isArray(order.shipping)) {\n      if (order.shipping.length > 0) {\n        order.shipping[0].paymentId = order.billing[0]._id;\n\n        if (!Array.isArray(order.shipping[0].items)) {\n          order.shipping[0].items = [];\n        }\n      }\n    } else { // if not - create it\n      order.shipping = [];\n    }\n\n    // Add current exchange rate into order.billing.currency\n    // If user currenct === shop currency, exchange rate = 1.0\n    const currentUser = Meteor.user();\n    let userCurrency = Reaction.getShopCurrency();\n    let exchangeRate = \"1.00\";\n\n    if (currentUser && currentUser.profile && currentUser.profile.currency) {\n      userCurrency = Meteor.user().profile.currency;\n    }\n\n    if (userCurrency !== Reaction.getShopCurrency()) {\n      const userExchangeRate = Meteor.call(\"shop/getCurrencyRates\", userCurrency);\n\n      if (typeof userExchangeRate === \"number\") {\n        exchangeRate = userExchangeRate;\n      } else {\n        Logger.warn(\"Failed to get currency exchange rates. Setting exchange rate to null.\");\n        exchangeRate = null;\n      }\n    }\n\n    if (!order.billing[0].currency) {\n      order.billing[0].currency = {\n        userCurrency: userCurrency\n      };\n    }\n\n    _.each(order.items, (item) => {\n      if (order.shipping[0].items) {\n        order.shipping[0].items.push({\n          _id: item._id,\n          productId: item.productId,\n          shopId: item.shopId,\n          variantId: item.variants._id\n        });\n      }\n    });\n\n    order.shipping[0].items.packed = false;\n    order.shipping[0].items.shipped = false;\n    order.shipping[0].items.delivered = false;\n\n    order.billing[0].currency.exchangeRate = exchangeRate;\n    order.workflow.status = \"new\";\n    order.workflow.workflow = [\"coreOrderWorkflow/created\"];\n\n    // insert new reaction order\n    const orderId = Collections.Orders.insert(order);\n\n    if (orderId) {\n      Collections.Cart.remove({\n        _id: order.cartId\n      });\n      // create a new cart for the user\n      // even though this should be caught by\n      // subscription handler, it's not always working\n      const newCartExists = Collections.Cart.find({ userId: order.userId });\n      if (newCartExists.count() === 0) {\n        Meteor.call(\"cart/createCart\", this.userId, sessionId);\n        // after recreate new cart we need to make it looks like previous by\n        // updating `cart/workflow/status` to \"coreCheckoutShipping\"\n        // by calling `workflow/pushCartWorkflow` three times. This is the only\n        // way to do that without refactoring of `workflow/pushCartWorkflow`\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutLogin\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"checkoutAddressBook\");\n        Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\", \"coreCheckoutShipping\");\n      }\n\n      Logger.info(\"Transitioned cart \" + cartId + \" to order \" + orderId);\n      // catch send notification, we don't want\n      // to block because of notification errors\n\n      if (order.email) {\n        Meteor.call(\"orders/sendNotification\", Collections.Orders.findOne(orderId), (err) => {\n          if (err) {\n            Logger.error(err, `Error in orders/sendNotification for order ${orderId}`);\n          }\n        });\n      }\n\n      // order success\n      return orderId;\n    }\n    // we should not have made it here, throw error\n    throw new Meteor.Error(400, \"cart/copyCartToOrder: Invalid request\");\n  },\n\n  /**\n   * cart/setShipmentMethod\n   * @summary saves method as order default\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} method - shipmentMethod object\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setShipmentMethod\": function (cartId, method) {\n    check(cartId, String);\n    check(method, Object);\n    // get current cart\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: Meteor.userId()\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n\n    // temp hack until we build out multiple shipping handlers\n    let selector;\n    let update;\n    // temp hack until we build out multiple shipment handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (cart.shipping) {\n      selector = {\n        \"_id\": cartId,\n        \"shipping._id\": cart.shipping[0]._id\n      };\n      update = {\n        $set: {\n          \"shipping.$.shipmentMethod\": method\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          shipping: {\n            shipmentMethod: method\n          }\n        }\n      };\n    }\n\n    // update or insert method\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e, `Error adding rates to cart ${cartId}`);\n      throw new Meteor.Error(\"An error occurred saving the order\", e);\n    }\n\n    // this will transition to review\n    return Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n      \"coreCheckoutShipping\");\n  },\n\n  /**\n   * cart/setUserCurrency\n   * @summary saves user currency in cart, to be paired with order/setCurrencyExhange\n   * @param {String} cartId - cartId to apply setUserCurrency\n   * @param {String} userCurrency - userCurrency to set to cart\n   * @return {Number} update result\n   */\n  \"cart/setUserCurrency\": function (cartId, userCurrency) {\n    check(cartId, String);\n    check(userCurrency, String);\n    const cart = Collections.Cart.findOne({\n      _id: cartId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(\"Cart not found for user with such id\");\n    }\n\n    const userCurrencyString = {\n      userCurrency: userCurrency\n    };\n\n    let selector;\n    let update;\n\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.currency\": userCurrencyString\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            currency: userCurrencyString\n          }\n        }\n      };\n    }\n\n    // add / or set the shipping address\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred adding the currency\");\n    }\n\n    return true;\n  },\n\n  /**\n   * cart/resetShipmentMethod\n   * @summary removes `shipmentMethod` object from cart\n   * @param {String} cartId - cart _id\n   * @return {Number} update result\n   */\n  \"cart/resetShipmentMethod\": function (cartId) {\n    check(cartId, String);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${this.userId}`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        `Cart: ${cartId} not found for user: ${this.userId}`);\n    }\n\n    return Collections.Cart.update({ _id: cartId }, {\n      $unset: { \"shipping.0.shipmentMethod\": \"\" }\n    });\n  },\n\n  /**\n   * cart/setShipmentAddress\n   * @summary adds address book to cart shipping\n   * @param {String} cartId - cartId to apply shipmentMethod\n   * @param {Object} address - addressBook object\n   * @return {Number} update result\n   */\n  \"cart/setShipmentAddress\": function (cartId, address) {\n    check(cartId, String);\n    check(address, Reaction.Schemas.Address);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple shipment handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (Array.isArray(cart.shipping) && cart.shipping.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"shipping._id\": cart.shipping[0]._id\n      };\n      update = {\n        $set: {\n          \"shipping.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          shipping: {\n            address: address\n          }\n        }\n      };\n    }\n\n    // add / or set the shipping address\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred adding the address\");\n    }\n\n    // refresh shipping quotes\n    Meteor.call(\"shipping/updateShipmentQuotes\", cartId);\n\n    if (typeof cart.workflow !== \"object\") {\n      throw new Meteor.Error(500, \"Internal Server Error\",\n        \"Cart workflow object not detected.\");\n    }\n\n    // ~~it's ok for this to be called multiple times~~\n    // call it only once when we at the `checkoutAddressBook` step\n    if (typeof cart.workflow.workflow === \"object\" &&\n      cart.workflow.workflow.length < 2) {\n      Meteor.call(\"workflow/pushCartWorkflow\", \"coreCartWorkflow\",\n        \"coreCheckoutShipping\");\n    }\n\n    // if we change default address during further steps, we need to revert\n    // workflow back to `coreCheckoutShipping` step\n    if (typeof cart.workflow.workflow === \"object\" &&\n      cart.workflow.workflow.length > 2) { // \"2\" index of\n      // `coreCheckoutShipping`\n      Meteor.call(\"workflow/revertCartWorkflow\", \"coreCheckoutShipping\");\n    }\n\n    return true;\n  },\n\n  /**\n   * cart/setPaymentAddress\n   * @summary adds addressbook to cart payments\n   * @param {String} cartId - cartId to apply payment address\n   * @param {Object} address - addressBook object\n   * @todo maybe we need to rename this method to `cart/setBillingAddress`?\n   * @return {Number} return Mongo update result\n   */\n  \"cart/setPaymentAddress\": function (cartId, address) {\n    check(cartId, String);\n    check(address, Reaction.Schemas.Address);\n\n    const cart = Collections.Cart.findOne({\n      _id: cartId,\n      userId: this.userId\n    });\n\n    if (!cart) {\n      Logger.error(`Cart not found for user: ${ this.userId }`);\n      throw new Meteor.Error(404, \"Cart not found\",\n        \"Cart not found for user with such id\");\n    }\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (Array.isArray(cart.billing) && cart.billing.length > 0) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.address\": address\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          billing: {\n            address: address\n          }\n        }\n      };\n    }\n\n    return Collections.Cart.update(selector, update);\n  },\n\n  /**\n   * cart/unsetAddresses\n   * @description removes address from cart.\n   * @param {String} addressId - address._id\n   * @param {String} userId - cart owner _id\n   * @param {String} [type] - billing default or shipping default\n   * @since 0.10.1\n   * @todo check if no more address in cart as shipping, we should reset\n   * `cartWorkflow` to second step\n   * @return {Number|Object|Boolean} The number of removed documents or error\n   * object or `false` if we don't need to update cart\n   */\n  \"cart/unsetAddresses\": function (addressId, userId, type) {\n    check(addressId, String);\n    check(userId, String);\n    check(type, Match.Optional(String));\n\n    // do we actually need to change anything?\n    let needToUpdate = false;\n    // we need to revert the workflow after a \"shipping\" address was removed\n    let isShippingDeleting = false;\n    const cart = Collections.Cart.findOne({\n      userId: userId\n    });\n    const selector = {\n      _id: cart._id\n    };\n    const update = { $unset: {} };\n    // user could turn off the checkbox in address to not to be default, then we\n    // receive `type` arg\n    if (typeof type === \"string\") {\n      // we assume that the billing/shipping arrays can hold only one element [0]\n      if (cart[type] && typeof cart[type][0].address === \"object\" &&\n        cart[type][0].address._id === addressId) {\n        update.$unset[`${type}.0.address`] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = type === \"shipping\";\n      }\n    } else { // or if we remove address itself, when we run this part we assume\n      // that the billing/shipping arrays can hold only one element [0]\n      if (cart.billing && typeof cart.billing[0].address === \"object\" &&\n        cart.billing[0].address._id === addressId) {\n        update.$unset[\"billing.0.address\"] = \"\";\n        needToUpdate = true;\n      }\n      if (cart.shipping && typeof cart.shipping[0].address === \"object\" &&\n        cart.shipping[0].address._id === addressId) {\n        update.$unset[\"shipping.0.address\"] = \"\";\n        needToUpdate = true;\n        isShippingDeleting = true;\n      }\n    }\n\n    if (needToUpdate) {\n      try {\n        Collections.Cart.update(selector, update);\n      } catch (e) {\n        Logger.error(e);\n        throw new Meteor.Error(\"Error updating cart\");\n      }\n\n      if (isShippingDeleting) {\n        // if we remove shipping address from cart, we need to revert\n        // `cartWorkflow` to the `checkoutAddressBook` step.\n        Meteor.call(\"workflow/revertCartWorkflow\", \"checkoutAddressBook\");\n      }\n    }\n    return true;\n  },\n\n  /**\n   * cart/submitPayment\n   * @summary saves a submitted payment to cart, triggers workflow\n   * and adds \"paymentSubmitted\" to cart workflow\n   * Note: this method also has a client stub, that forwards to cartCompleted\n   * @param {Object} paymentMethod - paymentMethod object\n   * directly within this method, just throw down though hooks\n   * @return {String} returns update result\n   */\n  \"cart/submitPayment\": function (paymentMethod) {\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n\n    const checkoutCart = Collections.Cart.findOne({\n      userId: Meteor.userId()\n    });\n\n    const cart = _.clone(checkoutCart);\n    const cartId = cart._id;\n    const invoice = {\n      shipping: cart.cartShipping(),\n      subtotal: cart.cartSubTotal(),\n      taxes: cart.cartTaxes(),\n      discounts: cart.cartDiscounts(),\n      total: cart.cartTotal()\n    };\n\n    // we won't actually close the order at this stage.\n    // we'll just update the workflow and billing data where\n    // method-hooks can process the workflow update.\n\n    let selector;\n    let update;\n    // temp hack until we build out multiple billing handlers\n    // if we have an existing item update it, otherwise add to set.\n    if (cart.billing) {\n      selector = {\n        \"_id\": cartId,\n        \"billing._id\": cart.billing[0]._id\n      };\n      update = {\n        $set: {\n          \"billing.$.paymentMethod\": paymentMethod,\n          \"billing.$.invoice\": invoice\n        }\n      };\n    } else {\n      selector = {\n        _id: cartId\n      };\n      update = {\n        $addToSet: {\n          \"billing.paymentMethod\": paymentMethod,\n          \"billing.invoice\": invoice\n        }\n      };\n    }\n\n    try {\n      Collections.Cart.update(selector, update);\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(\"An error occurred saving the order\");\n    }\n\n    return Collections.Cart.findOne(selector);\n  }\n});\n","import _ from \"lodash\";\nimport path from \"path\";\nimport moment from \"moment\";\nimport accounting from \"accounting-js\";\nimport Future from \"fibers/future\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { getSlug } from \"/lib/api\";\nimport { Media, Orders, Products, Shops, Packages } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Hooks, Reaction } from \"/server/api\";\n\n\n// helper to return the order credit object\n// the first credit paymentMethod on the order\n// returns entire payment method\nexport function orderCreditMethod(order) {\n  return order.billing.filter(value => value.paymentMethod.method ===  \"credit\")[0];\n}\n// helper to return the order debit object\nexport function orderDebitMethod(order) {\n  return order.billing.filter(value => value.paymentMethod.method ===  \"debit\")[0];\n}\n\n/**\n * ordersInventoryAdjust\n * adjust inventory when an order is placed\n * @param {String} orderId - add tracking to orderId\n * @return {null} no return value\n */\nexport function ordersInventoryAdjust(orderId) {\n  check(orderId, String);\n\n  if (!Reaction.hasPermission(\"orders\")) {\n    throw new Meteor.Error(403, \"Access Denied\");\n  }\n\n  const order = Orders.findOne(orderId);\n  order.items.forEach(item => {\n    Products.update({\n      _id: item.variants._id\n    }, {\n      $inc: {\n        inventoryQuantity: -item.quantity\n      }\n    }, {\n      publish: true,\n      selector: {\n        type: \"variant\"\n      }\n    });\n  });\n}\n\n\n/**\n * Reaction Order Methods\n */\nexport const methods = {\n  /**\n   * orders/shipmentPacked\n   *\n   * @summary update packing status\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @param {Boolean} packed - packed status\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentPacked\": function (order, shipment, packed) {\n    check(order, Object);\n    check(shipment, Object);\n    check(packed, Boolean);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    if (order) {\n      Orders.update({\n        \"_id\": order._id,\n        \"shipping._id\": shipment._id\n      }, {\n        $set: {\n          \"shipping.$.packed\": packed\n        }\n      });\n\n      // Set the status of the items as packed\n      const itemIds = shipment.items.map((item) => {\n        return item._id;\n      });\n\n      const result = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/packed\", order, itemIds);\n      if (result === 1) {\n        return Orders.update({\n          \"_id\": order._id,\n          \"shipping._id\": shipment._id\n        }, {\n          $set: {\n            \"shipping.$.packed\": packed\n          }\n        });\n      }\n      return result;\n    }\n  },\n\n  /**\n   * orders/makeAdjustmentsToInvoice\n   *\n   * @summary Update the status of an invoice to allow adjustments to be made\n   * @param {Object} order - order object\n   * @return {Object} Mongo update\n   */\n  \"orders/makeAdjustmentsToInvoice\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"adjustments\"\n      }\n    });\n  },\n\n  /**\n   * orders/approvePayment\n   *\n   * @summary Approve payment and apply any adjustments\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/approvePayment\": function (order) {\n    check(order, Object);\n    const invoice = orderCreditMethod(order).invoice;\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    // this is server side check to verify\n    // that the math all still adds up.\n    const subTotal = invoice.subtotal;\n    const shipping = invoice.shipping;\n    const taxes = invoice.taxes;\n    const discount = invoice.discounts;\n    const discountTotal = Math.max(0, subTotal - discount); // ensure no discounting below 0.\n    const total = accounting.toFixed(discountTotal + shipping + taxes, 2);\n\n    // Updates flattened inventory count on variants in Products collection\n    ordersInventoryAdjust(order._id);\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.amount\": total,\n        \"billing.$.paymentMethod.status\": \"approved\",\n        \"billing.$.paymentMethod.mode\": \"capture\",\n        \"billing.$.invoice.discounts\": discount,\n        \"billing.$.invoice.total\": Number(total)\n      }\n    });\n  },\n\n  /**\n   * orders/cancelOrder\n   *\n   * @summary Start the cancel order process\n   * @param {Object} order - order object\n   * @param {Boolean} returnToStock - condition to return product to stock\n   * @return {Object} ret\n   */\n  \"orders/cancelOrder\": function (order, returnToStock) {\n    check(order, Object);\n    check(returnToStock, Boolean);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    if (!returnToStock) {\n      ordersInventoryAdjust(order._id);\n    }\n\n    let paymentMethod = orderCreditMethod(order).paymentMethod;\n    paymentMethod = Object.assign(paymentMethod, { amount: Number(paymentMethod.amount) });\n    const invoiceTotal = order.billing[0].invoice.total;\n    const shipment = order.shipping[0];\n    const itemIds = shipment.items.map((item) => {\n      return item._id;\n    });\n\n    // refund payment to customer\n    Meteor.call(\"orders/refunds/create\", order._id, paymentMethod, Number(invoiceTotal));\n\n    // send notification to user\n    const prefix = Reaction.getShopPrefix();\n    const url = `${prefix}/notifications`;\n    const sms = true;\n    Meteor.call(\"notification/send\", order.userId, \"orderCancelled\", url, sms, (err) => {\n      if (err) Logger.error(err);\n    });\n\n    // update item workflow\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/canceled\", order, itemIds);\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"billing.paymentMethod.method\": \"credit\"\n    }, {\n      $set: {\n        \"workflow.status\": \"coreOrderWorkflow/canceled\",\n        \"billing.$.paymentMethod.mode\": \"cancel\"\n      },\n      $push: {\n        \"workflow.workflow\": \"coreOrderWorkflow/canceled\"\n      }\n    });\n  },\n\n  /**\n   * orders/processPayment\n   *\n   * @summary trigger processPayment and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return this.processPayment result\n   */\n  \"orders/processPayment\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    return Meteor.call(\"orders/processPayments\", order._id, function (error, result) {\n      if (result) {\n        Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"coreProcessPayment\", order._id);\n\n        // Set the status of the items as shipped\n        const itemIds = order.shipping[0].items.map((item) => {\n          return item._id;\n        });\n\n        Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n\n        return this.processPayment(order);\n      }\n      return false;\n    });\n  },\n  /**\n   * orders/shipmentShipped\n   *\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @param {Object} shipment - shipment object\n   * @return {Object} return results of several operations\n   */\n  \"orders/shipmentShipped\": function (order, shipment) {\n    check(order, Object);\n    check(shipment, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      Logger.error(\"User does not have 'orders' permissions\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    let completedItemsResult;\n    let completedOrderResult;\n\n    const itemIds = shipment.items.map((item) => {\n      return item._id;\n    });\n\n    // TODO: In the future, this could be handled by shipping delivery status\n    Hooks.Events.run(\"onOrderShipmentShipped\", order, itemIds);\n    const workflowResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/shipped\", order, itemIds);\n\n    if (workflowResult === 1) {\n      // Move to completed status for items\n      completedItemsResult = Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n      if (completedItemsResult === 1) {\n        // Then try to mark order as completed.\n        completedOrderResult = Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      }\n    }\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, \"shipped\");\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.shipped\": true\n      }\n    });\n\n    return {\n      workflowResult: workflowResult,\n      completedItems: completedItemsResult,\n      completedOrder: completedOrderResult\n    };\n  },\n\n  /**\n   * orders/shipmentDelivered\n   *\n   * @summary trigger shipmentShipped status and workflow update\n   * @param {Object} order - order object\n   * @return {Object} return workflow result\n   */\n  \"orders/shipmentDelivered\": function (order) {\n    check(order, Object);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    const shipment = order.shipping[0];\n\n    if (order.email) {\n      Meteor.call(\"orders/sendNotification\", order, (err) => {\n        if (err) {\n          Logger.error(err, \"orders/shipmentDelivered: Failed to send notification\");\n        }\n      });\n    } else {\n      Logger.warn(\"No order email found. No notification sent.\");\n    }\n\n    const itemIds = shipment.items.map((item) => {\n      return item._id;\n    });\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/delivered\", order, itemIds);\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/completed\", order, itemIds);\n\n    const isCompleted = _.every(order.items, (item) => {\n      return _.includes(item.workflow.workflow, \"coreOrderItemWorkflow/completed\");\n    });\n\n    Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        \"shipping.$.delivered\": true\n      }\n    });\n\n    if (isCompleted === true) {\n      Hooks.Events.run(\"onOrderShipmentDelivered\", order._id);\n      Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"completed\", order);\n      return true;\n    }\n\n    Meteor.call(\"workflow/pushOrderWorkflow\", \"coreOrderWorkflow\", \"processing\", order);\n\n    return false;\n  },\n\n  /**\n   * orders/sendNotification\n   *\n   * @summary send order notification email\n   * @param {Object} order - order object\n   * @param {Object} action - send notification action\n   * @return {Boolean} email sent or not\n   */\n  \"orders/sendNotification\": function (order, action) {\n    check(order, Object);\n    check(action, Match.OneOf(String, undefined));\n\n    if (!this.userId) {\n      Logger.error(\"orders/sendNotification: Access denied\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    // Get Shop information\n    const shop = Shops.findOne(order.shopId);\n\n    // Get shop logo, if available\n    let emailLogo;\n    if (Array.isArray(shop.brandAssets)) {\n      const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n      const mediaId = Media.findOne(brandAsset.mediaId);\n      emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n    } else {\n      emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n    }\n\n    const billing = orderCreditMethod(order);\n    const refundResult = Meteor.call(\"orders/refunds/list\", order);\n    let refundTotal = 0;\n\n    _.each(refundResult, function (item) {\n      refundTotal += parseFloat(item.amount);\n    });\n\n    // Get user currency formatting from shops collection, remove saved rate\n    const userCurrencyFormatting = _.omit(shop.currencies[billing.currency.userCurrency], [\"enabled\", \"rate\"]);\n\n    // Get user currency exchange rate at time of transaction\n    const userCurrencyExchangeRate = billing.currency.exchangeRate;\n\n    // Combine same products into single \"product\" for display purposes\n    const combinedItems = [];\n    if (order) {\n      // Loop through all items in the order. The items are split into indivital items\n      for (const orderItem of order.items) {\n        // Find an exising item in the combinedItems array\n        const foundItem = combinedItems.find((combinedItem) => {\n          // If and item variant exists, then we return true\n          if (combinedItem.variants) {\n            return combinedItem.variants._id === orderItem.variants._id;\n          }\n\n          return false;\n        });\n\n        // Increment the quantity count for the duplicate product variants\n        if (foundItem) {\n          foundItem.quantity++;\n        } else {\n          // Otherwise push the unique item into the combinedItems array\n\n          // Add displayPrice to match user currency settings\n          orderItem.variants.displayPrice = accounting.formatMoney(\n            orderItem.variants.price * userCurrencyExchangeRate, userCurrencyFormatting\n          );\n\n          combinedItems.push(orderItem);\n\n          // Placeholder image if there is no product image\n          orderItem.placeholderImage = Meteor.absoluteUrl() + \"resources/placeholder.gif\";\n\n          const variantImage = Media.findOne({\n            \"metadata.productId\": orderItem.productId,\n            \"metadata.variantId\": orderItem.variants._id\n          });\n          // variant image\n          if (variantImage) {\n            orderItem.variantImage = path.join(Meteor.absoluteUrl(), variantImage.url());\n          }\n          // find a default image\n          const productImage = Media.findOne({ \"metadata.productId\": orderItem.productId });\n          if (productImage) {\n            orderItem.productImage = path.join(Meteor.absoluteUrl(), productImage.url());\n          }\n        }\n      }\n\n      // Merge data into single object to pass to email template\n      const dataForEmail = {\n        // Shop Data\n        shop: shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo: emailLogo,\n        copyrightDate: moment().format(\"YYYY\"),\n        legalName: shop.addressBook[0].company,\n        physicalAddress: {\n          address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n          city: shop.addressBook[0].city,\n          region: shop.addressBook[0].region,\n          postal: shop.addressBook[0].postal\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Order Data\n        order: order,\n        billing: {\n          address: {\n            address: billing.address.address1,\n            city: billing.address.city,\n            region: billing.address.region,\n            postal: billing.address.postal\n          },\n          paymentMethod: billing.paymentMethod.storedCard || billing.paymentMethod.processor,\n          subtotal: accounting.formatMoney(\n            billing.invoice.subtotal * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          shipping: accounting.formatMoney(\n            billing.invoice.shipping * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          taxes: accounting.formatMoney(\n            billing.invoice.taxes * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          discounts: accounting.formatMoney(\n            billing.invoice.discounts * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          refunds: accounting.formatMoney(\n            refundTotal * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          total: accounting.formatMoney(\n            billing.invoice.total * userCurrencyExchangeRate, userCurrencyFormatting\n          ),\n          adjustedTotal: accounting.formatMoney(\n            (billing.paymentMethod.amount - refundTotal) * userCurrencyExchangeRate, userCurrencyFormatting\n          )\n        },\n        combinedItems: combinedItems,\n        orderDate: moment(order.createdAt).format(\"MM/DD/YYYY\"),\n        orderUrl: getSlug(shop.name) + \"/cart/completed?_id=\" + order.cartId,\n        shipping: {\n          tracking: order.shipping[0].tracking,\n          carrier: order.shipping[0].shipmentMethod.carrier,\n          address: {\n            address: order.shipping[0].address.address1,\n            city: order.shipping[0].address.city,\n            region: order.shipping[0].address.region,\n            postal: order.shipping[0].address.postal\n          }\n        }\n      };\n\n      Logger.debug(`orders/sendNotification status: ${order.workflow.status}`);\n\n\n      // handle missing root shop email\n      if (!shop.emails[0].address) {\n        shop.emails[0].address = \"no-reply@reactioncommerce.com\";\n        Logger.warn(\"No shop email configured. Using no-reply to send mail\");\n      }\n\n      // anonymous users without emails.\n      if (!order.email) {\n        const msg = \"No order email found. No notification sent.\";\n        Logger.warn(msg);\n        throw new Meteor.Error(\"email-error\", msg);\n      }\n\n      // Compile Email with SSR\n      let subject;\n      let tpl;\n\n      if (action === \"shipped\") {\n        tpl = \"orders/shipped\";\n        subject = \"orders/shipped/subject\";\n      } else if (action === \"refunded\") {\n        tpl = \"orders/refunded\";\n        subject = \"orders/refunded/subject\";\n      } else {\n        tpl = `orders/${order.workflow.status}`;\n        subject = `orders/${order.workflow.status}/subject`;\n      }\n\n      SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n      SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n      Reaction.Email.send({\n        to: order.email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * orders/updateShipmentTracking\n   * @summary Adds tracking information to order without workflow update.\n   * Call after any tracking code is generated\n   * @param {Object} order - An Order object\n   * @param {Object} shipment - A Shipment object\n   * @param {String} tracking - tracking id\n   * @return {String} returns order update result\n   */\n  \"orders/updateShipmentTracking\": function (order, shipment, tracking) {\n    check(order, Object);\n    check(shipment, Object);\n    check(tracking, String);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Orders.update({\n      \"_id\": order._id,\n      \"shipping._id\": shipment._id\n    }, {\n      $set: {\n        [\"shipping.$.tracking\"]: tracking\n      }\n    });\n  },\n\n  /**\n   * orders/addOrderEmail\n   * @summary Adds email to order, used for guest users\n   * @param {String} cartId - add tracking to orderId\n   * @param {String} email - valid email address\n   * @return {String} returns order update result\n   */\n  \"orders/addOrderEmail\": function (cartId, email) {\n    check(cartId, String);\n    check(email, String);\n    /**\n    *Instead of checking the Orders permission, we should check if user is\n    *connected.This is only needed for guest where email is\n    *provided for tracking order progress.\n    */\n\n    if (!Meteor.userId()) {\n      throw new Meteor.Error(403, \"Access Denied. You are not connected.\");\n    }\n\n    return Orders.update({\n      cartId: cartId\n    }, {\n      $set: {\n        email: email\n      }\n    });\n  },\n\n  /**\n   * orders/updateHistory\n   * @summary adds order history item for tracking and logging order updates\n   * @param {String} orderId - add tracking to orderId\n   * @param {String} event - workflow event\n   * @param {String} value - event value\n   * @return {String} returns order update result\n   */\n  \"orders/updateHistory\": function (orderId, event, value) {\n    check(orderId, String);\n    check(event, String);\n    check(value, Match.Optional(String));\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Orders.update(orderId, {\n      $addToSet: {\n        history: {\n          event: event,\n          value: value,\n          userId: Meteor.userId(),\n          updatedAt: new Date()\n        }\n      }\n    });\n  },\n\n\n  /**\n   * orders/capturePayments\n   * @summary Finalize any payment where mode is \"authorize\"\n   * and status is \"approved\", reprocess as \"capture\"\n   * @todo: add tests working with new payment methods\n   * @todo: refactor to use non Meteor.namespace\n   * @param {String} orderId - add tracking to orderId\n   * @return {null} no return value\n   */\n  \"orders/capturePayments\": (orderId) => {\n    check(orderId, String);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const order = Orders.findOne(orderId);\n    const itemIds = order.shipping[0].items.map((item) => {\n      return item._id;\n    });\n\n    Meteor.call(\"workflow/pushItemWorkflow\", \"coreOrderItemWorkflow/captured\", order, itemIds);\n\n    // process order..payment.paymentMethod\n    _.each(order.billing, function (billing) {\n      const paymentMethod = billing.paymentMethod;\n      const transactionId = paymentMethod.transactionId;\n\n      if (paymentMethod.mode === \"capture\" && paymentMethod.status === \"approved\" && paymentMethod.processor) {\n        // Grab the amount from the shipment, otherwise use the original amount\n        const processor = paymentMethod.processor.toLowerCase();\n\n        Meteor.call(`${processor}/payment/capture`, paymentMethod, (error, result) => {\n          if (result && result.saved === true) {\n            const metadata = Object.assign(billing.paymentMethod.metadata || {}, result.metadata || {});\n\n            Orders.update({\n              \"_id\": orderId,\n              \"billing.paymentMethod.transactionId\": transactionId\n            }, {\n              $set: {\n                \"billing.$.paymentMethod.mode\": \"capture\",\n                \"billing.$.paymentMethod.status\": \"completed\",\n                \"billing.$.paymentMethod.metadata\": metadata\n              },\n              $push: {\n                \"billing.$.paymentMethod.transactions\": result\n              }\n            });\n\n            // event onOrderPaymentCaptured used for confirmation hooks\n            // ie: confirmShippingMethodForOrder is triggered here\n            Hooks.Events.run(\"onOrderPaymentCaptured\", orderId);\n          } else {\n            if (result && result.error) {\n              Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, result.error);\n            } else {\n              Logger.fatal(\"Failed to capture transaction.\", order, paymentMethod.transactionId, error);\n            }\n\n            Orders.update({\n              \"_id\": orderId,\n              \"billing.paymentMethod.transactionId\": transactionId\n            }, {\n              $set: {\n                \"billing.$.paymentMethod.mode\": \"capture\",\n                \"billing.$.paymentMethod.status\": \"error\"\n              },\n              $push: {\n                \"billing.$.paymentMethod.transactions\": result\n              }\n            });\n\n            return { error: \"orders/capturePayments: Failed to capture transaction\" };\n          }\n          return { error, result };\n        });\n      }\n    });\n  },\n\n  /**\n   * orders/refund/list\n   * loop through order's payments and find existing refunds.\n   * @summary Get a list of refunds for a particular payment method.\n   * @param {Object} order - order object\n   * @return {null} no return value\n   */\n  \"orders/refunds/list\": function (order) {\n    check(order, Object);\n    const paymentMethod = orderCreditMethod(order).paymentMethod;\n\n    if (!this.userId === order.userId && !Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    this.unblock();\n\n    const future = new Future();\n    const processor = paymentMethod.processor.toLowerCase();\n\n    Meteor.call(`${processor}/refund/list`, paymentMethod, (error, result) => {\n      if (error) {\n        future.return(error);\n      } else {\n        check(result, [Schemas.Refund]);\n        future.return(result);\n      }\n    });\n\n    return future.wait();\n  },\n\n  /**\n   * orders/refund/create\n   *\n   * @summary Apply a refund to an already captured order\n   * @param {String} orderId - order object\n   * @param {Object} paymentMethod - paymentMethod object\n   * @param {Number} amount - Amount of the refund, as a positive number\n   * @return {null} no return value\n   */\n  \"orders/refunds/create\": function (orderId, paymentMethod, amount) {\n    check(orderId, String);\n    check(paymentMethod, Reaction.Schemas.PaymentMethod);\n    check(amount, Number);\n\n    if (!Reaction.hasPermission(\"orders\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const processor = paymentMethod.processor.toLowerCase();\n    const order = Orders.findOne(orderId);\n    const transactionId = paymentMethod.transactionId;\n\n    const packageId = paymentMethod.paymentPackageId;\n    const settingsKey = paymentMethod.paymentSettingsKey;\n    // check if payment provider supports de-authorize\n    const checkSupportedMethods = Packages.findOne({\n      _id: packageId,\n      shopId: Reaction.getShopId()\n    }).settings[settingsKey].support;\n\n    const orderStatus = paymentMethod.status;\n    const orderMode = paymentMethod.mode;\n\n    let result;\n    let query = {};\n    if (_.includes(checkSupportedMethods, \"De-authorize\")) {\n      result = Meteor.call(`${processor}/payment/deAuthorize`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n      // Send email to notify cuustomer of a refund\n      Meteor.call(\"orders/sendNotification\", order);\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for de-authorize transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to de-authorize transaction failed\", result.error);\n      }\n    } else if (orderStatus === \"completed\" && orderMode === \"capture\") {\n      result = Meteor.call(`${processor}/refund/create`, paymentMethod, amount);\n      query = {\n        $push: {\n          \"billing.$.paymentMethod.transactions\": result\n        }\n      };\n      // Send email to notify cuustomer of a refund\n      Meteor.call(\"orders/sendNotification\", order, \"refunded\");\n      if (result.saved === false) {\n        Logger.fatal(\"Attempt for refund transaction failed\", order._id, paymentMethod.transactionId, result.error);\n        throw new Meteor.Error(\"Attempt to refund transaction failed\", result.error);\n      }\n    }\n\n    Orders.update({\n      \"_id\": orderId,\n      \"billing.paymentMethod.transactionId\": transactionId\n    }, {\n      $set: {\n        \"billing.$.paymentMethod.status\": \"refunded\"\n      },\n      query\n    });\n\n    Hooks.Events.run(\"onOrderRefundCreated\", orderId);\n  }\n};\n\nMeteor.methods(methods);\n","import { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Reaction } from \"/server/api\";\n\nexport const methods = {\n  /**\n   * payments/apply\n   * @summary adds payment to order\n   * @param {String} id - id\n   * @param {Object} paymentMethod - formatted payment method object\n   * @param  {String} collection collection (either Orders or Cart)\n   * @returns {String} return cart update result\n   */\n  \"payments/apply\": function (id, paymentMethod, collection = \"Cart\") {\n    check(id, String);\n    check(paymentMethod, Object);\n    check(collection, String);\n    const Collection = Reaction.Collections[collection];\n\n    return Collection.update({\n      _id: id\n    }, {\n      $addToSet: {\n        billing: { paymentMethod: paymentMethod }\n      }\n    });\n  }\n};\n\n// export methods to Meteor\nMeteor.methods(methods);\n","import { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Packages } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport { mergeDeep } from \"/lib/api\";\n\nexport const methods = {\n  \"registry/update\": function (packageId, name, fields) {\n    check(packageId, String);\n    check(name, String);\n    check(fields, Array);\n    // settings use just the last name from full name so that schemas don't need to define overly complex names based with\n    // x/x/x formatting.\n    // TODO name could be optional, just use package name as default\n    const setting = name.split(\"/\").splice(-1);\n    let dataToSave = {};\n    dataToSave[setting] = {};\n    const currentPackage = Packages.findOne(packageId);\n\n    _.each(fields, function (field) {\n      dataToSave[setting][field.property] = field.value;\n    });\n\n    if (currentPackage && currentPackage.settings) {\n      dataToSave = mergeDeep(currentPackage.settings, dataToSave);\n    }\n    // user must have permission to package to update settings\n    if (Reaction.hasPermission([currentPackage.name])) {\n      return Packages.upsert({\n        _id: packageId,\n        name: currentPackage.name,\n        enabled: currentPackage.enabled\n      }, {\n        $set: {\n          settings: dataToSave\n        }\n      }, { upsert: true });\n    }\n\n    return false;\n  }\n};\n\nMeteor.methods(methods);\n","import { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Cart } from \"/lib/collections\";\nimport { Logger, Hooks } from \"/server/api\";\nimport { Cart as CartSchema } from \"/lib/collections/schemas\";\n\n/*\n * Reaction Shipping Methods\n * methods typically used for checkout (shipping, taxes, etc)\n */\nexport const methods = {\n  /**\n   * shipping/updateShipmentQuotes\n   * @summary gets shipping rates and updates the users cart methods\n   * @todo add orderId argument/fallback\n   * @param {String} cartId - cartId\n   * @return {undefined}\n   */\n  \"shipping/updateShipmentQuotes\": function (cartId) {\n    check(cartId, String);\n    if (!cartId) {\n      return [];\n    }\n    this.unblock();\n    const cart = Cart.findOne(cartId);\n    check(cart, CartSchema);\n\n    if (cart) {\n      const rates = Meteor.call(\"shipping/getShippingRates\", cart);\n      let selector;\n      let update;\n      // temp hack until we build out multiple shipment handlers if we have an existing item update it, otherwise add to set.\n      if (cart.shipping) {\n        selector = {\n          \"_id\": cartId,\n          \"shipping._id\": cart.shipping[0]._id\n        };\n        update = {\n          $set: {\n            \"shipping.$.shipmentQuotes\": rates\n          }\n        };\n      } else {\n        selector = {\n          _id: cartId\n        };\n        update = {\n          $push: {\n            shipping: {\n              shipmentQuotes: rates\n            }\n          }\n        };\n      }\n      // add quotes to the cart\n      Cart.update(selector, update, function (error) {\n        if (error) {\n          Logger.warn(`Error adding rates to cart ${cartId}`, error);\n          return;\n        }\n        Logger.debug(`Success adding rates to cart ${cartId}`, rates);\n      });\n    }\n  },\n\n  /**\n   * shipping/getShippingRates\n   * @summary just gets rates, without updating anything\n   * @param {Object} cart - cart object\n   * @return {Array} return updated rates in cart\n   */\n  \"shipping/getShippingRates\": function (cart) {\n    check(cart, CartSchema);\n    const rates = [];\n    // must have items to calculate shipping\n    if (!cart.items) {\n      return rates;\n    }\n    // hooks for other shipping rate events\n    // all callbacks should return rates\n    Hooks.Events.run(\"onGetShippingRates\", rates, cart);\n    Logger.debug(\"getShippingRates returning rates\", rates);\n    return rates;\n  }\n};\n\nMeteor.methods(methods);\n","import { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { HTTP } from \"meteor/http\";\nimport { Job } from \"meteor/vsivsi:job-collection\";\nimport * as Collections from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { GeoCoder, Logger, Reaction } from \"/server/api\";\n\n/**\n * Reaction Shop Methods\n */\nMeteor.methods({\n  /**\n   * shop/createShop\n   * @param {String} shopAdminUserId - optionally create shop for provided userId\n   * @param {Object} shopData - optionally provide shop object to customize\n   * @return {String} return shopId\n   */\n  \"shop/createShop\": function (shopAdminUserId, shopData) {\n    check(shopAdminUserId, Match.Optional(String));\n    check(shopData, Match.Optional(Schemas.Shop));\n    let shop = {};\n    // must have owner access to create new shops\n    if (!Reaction.hasOwnerAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    // this.unblock();\n    const count = Collections.Shops.find().count() || \"\";\n    const currentUser = Meteor.userId();\n    // we'll accept a shop object, or clone the current shop\n    shop = shopData || Collections.Shops.findOne(Reaction.getShopId());\n    // if we don't have any shop data, use fixture\n\n    check(shop, Schemas.Shop);\n    if (!currentUser) {\n      throw new Meteor.Error(\"Unable to create shop with specified user\");\n    }\n\n    // identify a shop admin\n    const userId = shopAdminUserId || Meteor.userId();\n    const adminRoles = Roles.getRolesForUser(currentUser, Reaction.getShopId());\n    // ensure unique id and shop name\n    shop._id = Random.id();\n    shop.name = shop.name + count;\n\n    check(shop, Schemas.Shop);\n    try {\n      Collections.Shops.insert(shop);\n    } catch (error) {\n      return Logger.error(error, \"Failed to shop/createShop\");\n    }\n    // we should have created new shop, or errored\n    Logger.info(\"Created shop: \", shop._id);\n    Roles.addUsersToRoles([currentUser, userId], adminRoles, shop._id);\n    return shop._id;\n  },\n\n  /**\n   * shop/getLocale\n   * @summary determine user's countryCode and return locale object\n   * determine local currency and conversion rate from shop currency\n   * @return {Object} returns user location and locale\n   */\n  \"shop/getLocale\": function () {\n    this.unblock();\n    let clientAddress;\n    const geo = new GeoCoder();\n    const result = {};\n    let defaultCountryCode = \"US\";\n    let localeCurrency = \"USD\";\n    // if called from server, ip won't be defined.\n    if (this.connection !== null) {\n      clientAddress = this.connection.clientAddress;\n    } else {\n      clientAddress = \"127.0.0.1\";\n    }\n\n    // get shop locale/currency related data\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n\n    if (!shop) {\n      throw new Meteor.Error(\n        \"Failed to find shop data. Unable to determine locale.\");\n    }\n    // cofigure default defaultCountryCode\n    // fallback to shop settings\n    if (shop.addressBook) {\n      if (shop.addressBook.length >= 1) {\n        if (shop.addressBook[0].country) {\n          defaultCountryCode = shop.addressBook[0].country;\n        }\n      }\n    }\n    // geocode reverse ip lookup\n    const geoCountryCode = geo.geoip(clientAddress).country_code;\n\n    // countryCode either from geo or defaults\n    const countryCode = (geoCountryCode || defaultCountryCode).toUpperCase();\n\n    // get currency rates\n    result.currency = {};\n    result.locale = shop.locales.countries[countryCode];\n\n    // to return default currency if rates will failed, we need to bring access\n    // to this data\n    result.shopCurrency = shop.currencies[shop.currency];\n\n    // check if locale has a currency defined\n    if (typeof result.locale === \"object\" &&\n      typeof result.locale.currency === \"string\") {\n      localeCurrency = result.locale.currency.split(\",\");\n    }\n\n    // localeCurrency is an array of allowed currencies\n    _.each(localeCurrency, function (currency) {\n      let exchangeRate;\n      if (shop.currencies[currency]) {\n        result.currency = shop.currencies[currency];\n        // only fetch rates if locale and shop currency are not equal\n        // if shop.curency = locale currency the rate is 1\n        if (shop.currency !== currency) {\n          exchangeRate = Meteor.call(\"shop/getCurrencyRates\", currency);\n\n          if (typeof exchangeRate === \"number\") {\n            result.currency.exchangeRate = exchangeRate;\n          } else {\n            Logger.warn(\"Failed to get currency exchange rates.\");\n          }\n        }\n      }\n    });\n\n    // set server side locale\n    Reaction.Locale = result;\n\n    // should contain rates, locale, currency\n    return result;\n  },\n\n  /**\n   * shop/getCurrencyRates\n   * @summary It returns the current exchange rate against the shop currency\n   * usage: Meteor.call(\"shop/getCurrencyRates\",\"USD\")\n   * @param {String} currency code\n   * @return {Number|Object} currency conversion rate\n   */\n  \"shop/getCurrencyRates\": function (currency) {\n    check(currency, String);\n    this.unblock();\n\n    const field = `currencies.${currency}.rate`;\n    const shop = Collections.Shops.findOne(Reaction.getShopId(), {\n      fields: {\n        [field]: 1\n      }\n    });\n\n    return typeof shop.currencies[currency].rate === \"number\" &&\n      shop.currencies[currency].rate;\n  },\n\n  /**\n   * shop/fetchCurrencyRate\n   * @summary fetch the latest currency rates from\n   * https://openexchangerates.org\n   * usage: Meteor.call(\"shop/fetchCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/fetchCurrencyRate\": function () {\n    this.unblock();\n\n    const shopId = Reaction.getShopId();\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        addressBook: 1,\n        locales: 1,\n        currencies: 1,\n        currency: 1\n      }\n    });\n    const baseCurrency = shop.currency || \"USD\";\n    const shopCurrencies = shop.currencies;\n\n    // fetch shop settings for api auth credentials\n    const shopSettings = Collections.Packages.findOne({\n      shopId: shopId,\n      name: \"core\"\n    }, {\n      fields: {\n        settings: 1\n      }\n    });\n\n    // update Shops.currencies[currencyKey].rate\n    // with current rates from Open Exchange Rates\n    // warn if we don't have app_id\n    if (!shopSettings.settings.openexchangerates) {\n      throw new Meteor.Error(\"notConfigured\",\n        \"Open Exchange Rates not configured. Configure for current rates.\");\n    } else {\n      if (!shopSettings.settings.openexchangerates.appId) {\n        throw new Meteor.Error(\"notConfigured\",\n          \"Open Exchange Rates AppId not configured. Configure for current rates.\");\n      } else {\n        // shop open exchange rates appId\n        const openexchangeratesAppId = shopSettings.settings.openexchangerates.appId;\n\n        // we'll update all the available rates in Shops.currencies whenever we\n        // get a rate request, using base currency\n        const rateUrl =\n          `https://openexchangerates.org/api/latest.json?base=${\n          baseCurrency}&app_id=${openexchangeratesAppId}`;\n        let rateResults;\n\n        // We can get an error if we try to change the base currency with a simple\n        // account\n        try {\n          rateResults = HTTP.get(rateUrl);\n        } catch (error) {\n          if (error.error) {\n            Logger.error(error.message);\n            throw new Meteor.Error(error.message);\n          } else {\n            // https://openexchangerates.org/documentation#errors\n            throw new Meteor.Error(error.response.data.description);\n          }\n        }\n\n        const exchangeRates = rateResults.data.rates;\n\n        _.each(shopCurrencies, function (currencyConfig, currencyKey) {\n          if (exchangeRates[currencyKey] !== undefined) {\n            const rateUpdate = {\n              // this needed for shop/flushCurrencyRates Method\n              \"currencies.updatedAt\": new Date(rateResults.data.timestamp * 1000)\n            };\n            const collectionKey = `currencies.${currencyKey}.rate`;\n            rateUpdate[collectionKey] = exchangeRates[currencyKey];\n            Collections.Shops.update(shopId, {\n              $set: rateUpdate\n            });\n          }\n        });\n      }\n    }\n  },\n\n  /**\n   * shop/flushCurrencyRate\n   * @description Method calls by cron job\n   * @summary It removes exchange rates that are too old\n   * usage: Meteor.call(\"shop/flushCurrencyRate\")\n   * @fires Collections.Shops#update\n   * @returns {undefined}\n   */\n  \"shop/flushCurrencyRate\": function () {\n    this.unblock();\n\n    const shopId = Reaction.getShopId();\n    const shop = Collections.Shops.findOne(shopId, {\n      fields: {\n        currencies: 1\n      }\n    });\n    const updatedAt = shop.currencies.updatedAt;\n\n    // if updatedAt is not a Date(), then there is no rates yet\n    if (typeof updatedAt !== \"object\") {\n      throw new Meteor.Error(\"notExists\",\n        \"[flushCurrencyRates worker]: There is nothing to flush.\");\n    }\n\n    updatedAt.setHours(updatedAt.getHours() + 48);\n    const now = new Date();\n\n    if (now < updatedAt) { // todo remove this line. its for tests\n      _.each(shop.currencies, function (currencyConfig, currencyKey) {\n        const rate = `currencies.${currencyKey}.rate`;\n\n        if (typeof currencyConfig.rate === \"number\") {\n          Collections.Shops.update(shopId, {\n            $unset: {\n              [rate]: \"\"\n            }\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * shop/updateShopExternalServices\n   * @description On submit OpenExchangeRatesForm handler\n   * @summary we need to rerun fetch exchange rates job on every form submit,\n   * that's why we update autoform type to \"method-update\"\n   * @param {Object} modifier - the modifier object generated from the form values\n   * @param {String} _id - the _id of the document being updated\n   * @fires Collections.Packages#update\n   * @todo This method fires Packages collection, so maybe someday it could be\n   * @returns {undefined}\n   * moved to another file\n   */\n  \"shop/updateShopExternalServices\": function (modifier, _id) {\n    check(modifier, Match.Optional(Schemas.CorePackageConfig));\n    check(_id, String);\n\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    // we should run new job on every form change, even if not all of them will\n    // change currencyRate job\n    const refreshPeriod = modifier.$set[\"settings.openexchangerates.refreshPeriod\"];\n    const fetchCurrencyRatesJob = new Job(Collections.Jobs, \"shop/fetchCurrencyRates\", {})\n      .priority(\"normal\")\n      .retry({\n        retries: 5,\n        wait: 60000,\n        backoff: \"exponential\" // delay by twice as long for each subsequent retry\n      })\n      .repeat({\n        // wait: refreshPeriod * 60 * 1000\n        schedule: Collections.Jobs.later.parse.text(refreshPeriod)\n      })\n      .save({\n        // Cancel any jobs of the same type,\n        // but only if this job repeats forever.\n        cancelRepeats: true\n      });\n\n    Collections.Packages.update(_id, modifier);\n    return fetchCurrencyRatesJob;\n  },\n\n  /**\n   * shop/locateAddress\n   * @summary determine user's full location for autopopulating addresses\n   * @param {Number} latitude - latitude\n   * @param {Number} longitude - longitude\n   * @return {Object} returns address\n   */\n  \"shop/locateAddress\": function (latitude, longitude) {\n    check(latitude, Match.Optional(Number));\n    check(longitude, Match.Optional(Number));\n    let clientAddress;\n    this.unblock();\n\n    // if called from server, ip won't be defined.\n    if (this.connection !== null) {\n      clientAddress = this.connection.clientAddress;\n    } else {\n      clientAddress = \"127.0.0.1\";\n    }\n\n    // begin actual address lookups\n    if (latitude !== null && longitude !== null) {\n      const geo = new GeoCoder();\n      return geo.reverse(latitude, longitude);\n    }\n    // geocode reverse ip lookup\n    const geo = new GeoCoder();\n    return geo.geoip(clientAddress);\n  },\n\n  /**\n   * shop/createTag\n   * @summary creates new tag\n   * @param {String} tagName - new tag name\n   * @param {Boolean} isTopLevel - if true -- new tag will be created on top of\n   * tags tree\n   * @since 0.14.0\n   * @hooks after method\n   * @return {String} with created tag _id\n   */\n  \"shop/createTag\": function (tagName, isTopLevel) {\n    check(tagName, String);\n    check(isTopLevel, Boolean);\n\n    // must have 'core' permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const tag = {\n      name: tagName,\n      slug: Reaction.getSlug(tagName),\n      isTopLevel: isTopLevel,\n      updatedAt: new Date(),\n      createdAt: new Date()\n    };\n\n    return Collections.Tags.insert(tag);\n  },\n\n  /**\n   * shop/updateHeaderTags\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} tagName will insert, tagName + tagId will update existing\n   * @param {String} tagId - tagId to update\n   * @param {String} currentTagId - currentTagId will update related/hierarchy\n   * @return {Boolean} return true/false after insert\n   */\n  \"shop/updateHeaderTags\": function (tagName, tagId, currentTagId) {\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null, void 0));\n    check(currentTagId, Match.OneOf(String, null, void 0));\n\n    let newTagId = {};\n    // must have 'core' permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n\n    const existingTag = Collections.Tags.findOne({\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    });\n\n    if (tagId) {\n      return Collections.Tags.update(tagId, {\n        $set: newTag\n      }, function () {\n        Logger.debug(\n          `Changed name of tag ${tagId} to ${tagName}`);\n        return true;\n      });\n    } else if (existingTag) {\n      // if is currentTag\n      if (currentTagId) {\n        return Collections.Tags.update(currentTagId, {\n          $addToSet: {\n            relatedTagIds: existingTag._id\n          }\n        }, function () {\n          Logger.debug(\n            `Added tag ${existingTag.name} to the related tags list for tag ${currentTagId}`\n          );\n          return true;\n        });\n      }\n      // update existing tag\n      return Collections.Tags.update(existingTag._id, {\n        $set: {\n          isTopLevel: true\n        }\n      }, function () {\n        Logger.debug(`Marked tag ${existingTag.name} as a top level tag`);\n        return true;\n      });\n    }\n    // create newTags\n    newTagId = Meteor.call(\"shop/createTag\", tagName, !currentTagId);\n\n    // if result is an Error object, we return it immediately\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    if (currentTagId) {\n      return Collections.Tags.update(currentTagId, {\n        $addToSet: {\n          relatedTagIds: newTagId\n        }\n      }, function () {\n        Logger.debug(`Added tag${newTag.name} to the related tags list for tag ${currentTagId}`);\n        return true;\n      });\n      // TODO: refactor this. unnecessary check\n    } else if (typeof newTagId === \"string\" && !currentTagId) {\n      return true;\n    }\n    throw new Meteor.Error(403, \"Failed to update header tags.\");\n  },\n\n  /**\n   * shop/removeHeaderTag\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\n  \"shop/removeHeaderTag\": function (tagId, currentTagId) {\n    check(tagId, String);\n    check(currentTagId, String);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n    // remove from related tag use\n    Collections.Tags.update(currentTagId, {\n      $pull: {\n        relatedTagIds: tagId\n      }\n    });\n    // check to see if tag is in use.\n    const productCount = Collections.Products.find({\n      hashtags: {\n        $in: [tagId]\n      }\n    }).count();\n    // check to see if in use as a related tag\n    const relatedTagsCount = Collections.Tags.find({\n      relatedTagIds: {\n        $in: [tagId]\n      }\n    }).count();\n    // not in use anywhere, delete it\n    if (productCount === 0 && relatedTagsCount === 0) {\n      return Collections.Tags.remove(tagId);\n    }\n    // unable to delete anything\n    throw new Meteor.Error(403, \"Unable to delete tags that are in use.\");\n  },\n\n  /**\n   * shop/hideHeaderTag\n   * @param {String} tagId - method to remove tag navigation tags\n   * @param {String} currentTagId - currentTagId\n   * @return {String} returns remove result\n   */\n  \"shop/hideHeaderTag\": function (tagId) {\n    check(tagId, String);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n    // hide it\n    return Collections.Tags.update({\n      _id: tagId\n    }, {\n      $set: {\n        isTopLevel: false\n      }\n    });\n  },\n\n  /**\n   * shop/getWorkflow\n   * @summary gets the current shop workflows\n   * @param {String} name - workflow name\n   * @return {Array} returns workflow array\n   */\n  \"shop/getWorkflow\": function (name) {\n    check(name, String);\n\n    const shopWorkflows = Collections.Shops.findOne({\n      defaultWorkflows: {\n        $elemMatch: {\n          provides: name\n        }\n      }\n    }, {\n      fields: {\n        defaultWorkflows: true\n      }\n    });\n    return shopWorkflows;\n  },\n  /**\n   * shop/updateLanguageConfiguration\n   * @summary enable / disable a language\n   * @param {String} language - language name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Array} returns workflow array\n   */\n  \"shop/updateLanguageConfiguration\": function (language, enabled) {\n    check(language, String);\n    check(enabled, Boolean);\n\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n\n    const defaultLanguage = shop.language;\n\n    if (language === \"all\") {\n      const updateObject = {};\n\n      if (Array.isArray(shop.languages)) {\n        shop.languages.forEach((languageData, index) => {\n          if (languageData.i18n === defaultLanguage) {\n            updateObject[`languages.${index}.enabled`] = true;\n          } else {\n            updateObject[`languages.${index}.enabled`] = enabled;\n          }\n        });\n      }\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (language === defaultLanguage) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"languages.i18n\": language\n      }, {\n        $set: {\n          \"languages.$.enabled\": true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      \"_id\": Reaction.getShopId(),\n      \"languages.i18n\": language\n    }, {\n      $set: {\n        \"languages.$.enabled\": enabled\n      }\n    });\n  },\n\n  /**\n   * shop/updateCurrencyConfiguration\n   * @summary enable / disable a currency\n   * @param {String} currency - currency name | \"all\" to bulk enable / disable\n   * @param {Boolean} enabled - true / false\n   * @return {Number} returns mongo update result\n   */\n  \"shop/updateCurrencyConfiguration\": function (currency, enabled) {\n    check(currency, String);\n    check(enabled, Boolean);\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const shop = Collections.Shops.findOne({\n      _id: Reaction.getShopId()\n    });\n\n    const defaultCurrency = shop.currency;\n\n    if (currency === \"all\") {\n      const updateObject = {};\n      for (const currencyName in shop.currencies) {\n        if ({}.hasOwnProperty.call(shop.currencies, currencyName) && currencyName !== \"updatedAt\") {\n          if (currencyName === defaultCurrency) {\n            updateObject[`currencies.${currencyName}.enabled`] = true;\n          } else {\n            updateObject[`currencies.${currencyName}.enabled`] = enabled;\n          }\n        }\n      }\n\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: updateObject\n      });\n    } else if (currency === defaultCurrency) {\n      return Collections.Shops.update({\n        _id: Reaction.getShopId()\n      }, {\n        $set: {\n          [`currencies.${currency}.enabled`]: true\n        }\n      });\n    }\n\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $set: {\n        [`currencies.${currency}.enabled`]: enabled\n      }\n    });\n  },\n\n  /**\n   * shop/updateBrandAsset\n   * @param {Object} asset - brand asset {mediaId: \"\", type, \"\"}\n   * @return {Int} returns update result\n   */\n  \"shop/updateBrandAssets\": function (asset) {\n    check(asset, {\n      mediaId: String,\n      type: String\n    });\n    // must have core permissions\n    if (!Reaction.hasPermission(\"core\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    // Does our shop contain the brandasset we're tring to add\n    const shopWithBrandAsset = Collections.Shops.findOne({\n      \"_id\": Reaction.getShopId(),\n      \"brandAssets.type\": asset.type\n    });\n\n    // If it does, then we update it with the new asset reference\n    if (shopWithBrandAsset) {\n      return Collections.Shops.update({\n        \"_id\": Reaction.getShopId(),\n        \"brandAssets.type\": \"navbarBrandImage\"\n      }, {\n        $set: {\n          \"brandAssets.$\": {\n            mediaId: asset.mediaId,\n            type: asset.type\n          }\n        }\n      });\n    }\n\n    // Otherwise we insert a new brand asset reference\n    return Collections.Shops.update({\n      _id: Reaction.getShopId()\n    }, {\n      $push: {\n        brandAssets: {\n          mediaId: asset.mediaId,\n          type: asset.type\n        }\n      }\n    });\n  },\n\n  /*\n   * shop/togglePackage\n   * @summary enable/disable Reaction package\n   * @param {String} packageId - package _id\n   * @param {Boolean} enabled - current package `enabled` state\n   * @return {Number} mongo update result\n   */\n  \"shop/togglePackage\": function (packageId, enabled) {\n    check(packageId, String);\n    check(enabled, Boolean);\n    if (!Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Collections.Packages.update(packageId, {\n      $set: {\n        enabled: !enabled\n      }\n    });\n  },\n  /*\n  * shop/changeLayout\n  * @summary Change the layout for all workflows so you can use a custom one\n  * @param {String} shopId - the shop's ID\n  * @param {String} layout - new layout to use\n  * @return {Number} mongo update result\n   */\n  \"shop/changeLayouts\": function (shopId, newLayout) {\n    check(shopId, String);\n    check(newLayout, String);\n    const shop = Collections.Shops.findOne(shopId);\n    for (let i = 0; i < shop.layout.length; i++) {\n      shop.layout[i].layout = newLayout;\n    }\n    return Collections.Shops.update(shopId, {\n      $set: { layout: shop.layout }\n    });\n  }\n});\n","import _ from \"lodash\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check } from \"meteor/check\";\nimport { Accounts } from \"meteor/accounts-base\";\nimport { Reaction, Logger } from \"/server/api\";\n\nMeteor.methods({\n\n  \"accounts/sendResetPasswordEmail\"(options) {\n    check(options, {\n      email: String\n    });\n\n    const user = Accounts.findUserByEmail(options.email);\n\n    if (!user) {\n      Logger.error(\"accounts/sendResetPasswordEmail - User not found\");\n      throw new Meteor.Error(\"user-not-found\", \"User not found\");\n    }\n\n    const emails = _.map(user.emails || [], \"address\");\n\n    const caseInsensitiveEmail = _.find(emails, (email) => {\n      return email.toLowerCase() === options.email.toLowerCase();\n    });\n\n    Reaction.Accounts.sendResetPasswordEmail(user._id, caseInsensitiveEmail);\n  }\n});\n","import _ from \"lodash\";\nimport moment from \"moment\";\nimport path from \"path\";\nimport { Accounts as MeteorAccounts } from \"meteor/accounts-base\";\nimport { Accounts, Cart, Media, Shops, Packages } from \"/lib/collections\";\nimport * as Schemas from \"/lib/collections/schemas\";\nimport { Logger, Reaction } from \"/server/api\";\n\n\n/**\n * @summary Returns the name of the geocoder method to use\n * @returns {string} Name of the Geocoder method to use\n */\nfunction getValidator() {\n  const shopId = Reaction.getShopId();\n  const geoCoders = Packages.find({\n    \"registry.provides\": \"addressValidation\",\n    \"settings.addressValidation.enabled\": true,\n    \"shopId\": shopId,\n    \"enabled\": true\n  }).fetch();\n\n  if (!geoCoders.length) {\n    return \"\";\n  }\n  let geoCoder;\n  // Just one?, use that one\n  if (geoCoders.length === 1) {\n    geoCoder = geoCoders[0];\n  }\n  // If there are two, we default to the one that is not the Reaction one\n  if (geoCoders.length === 2) {\n    geoCoder = _.filter(geoCoders, function (coder) {\n      return !_.includes(coder.name, \"reaction\");\n    })[0];\n  }\n\n  // check if addressValidation is enabled but the package is disabled, don't do address validation\n  let registryName;\n  for (const registry of geoCoder.registry) {\n    if (registry.provides === \"addressValidation\") {\n      registryName = registry.name;\n    }\n  }\n  const packageKey = registryName.split(\"/\")[2];  // \"taxes/addressValidation/{packageKey}\"\n  if (!_.get(geoCoder.settings[packageKey], \"enabled\")) {\n    return \"\";\n  }\n\n  const methodName = geoCoder.settings.addressValidation.addressValidationMethod;\n  return methodName;\n}\n\n/**\n * @summary Compare individual fields of address and accumulate errors\n * @param {Object} address - the address provided by the customer\n * @param {Object} validationAddress - address provided by validator\n * @returns {Array} Array of errors (or empty)\n */\nfunction compareAddress(address, validationAddress) {\n  const errors = [];\n  // first check, if a field is missing (and was present in original address), that means it didn't validate\n  // TODO rewrite with just a loop over field names but KISS for now\n  if (address.address1 && !validationAddress.address1) {\n    errors.push({ address1: \"Address line one did not validate\" });\n  }\n\n  if (address.address2 && validationAddress.address2 && _.trim(_.upperCase(address.address2)) !== _.trim(_.upperCase(validationAddress.address2))) {\n    errors.push({ address2: \"Address line 2 did not validate\" });\n  }\n\n  if (!validationAddress.city) {\n    errors.push({ city: \"City did not validate\" });\n  }\n  if (address.postal && !validationAddress.postal) {\n    errors.push({ postal: \"Postal did not validate\" });\n  }\n\n  if (address.region && !validationAddress.region) {\n    errors.push({ region: \"Region did not validate\" });\n  }\n\n  if (address.country && !validationAddress.country) {\n    errors.push({ country: \"Country did not validate\" });\n  }\n  // second check if both fields exist, but they don't match (which almost always happen for certain fields on first time)\n  if (validationAddress.address1 && address.address1 && _.trim(_.upperCase(address.address1)) !== _.trim(_.upperCase(validationAddress.address1))) {\n    errors.push({ address1: \"Address line 1 did not match\" });\n  }\n\n  if (validationAddress.address2 && address.address2 && (_.upperCase(address.address2) !== _.upperCase(validationAddress.address2))) {\n    errors.push({ address2: \"Address line 2\" });\n  }\n\n  if (validationAddress.city && address.city && _.trim(_.upperCase(address.city)) !== _.trim(_.upperCase(validationAddress.city))) {\n    errors.push({ city: \"City did not match\" });\n  }\n\n  if (validationAddress.postal && address.postal && _.trim(_.upperCase(address.postal)) !== _.trim(_.upperCase(validationAddress.postal))) {\n    errors.push({ postal: \"Postal Code did not match\" });\n  }\n\n  if (validationAddress.region && address.region && _.trim(_.upperCase(address.region)) !== _.trim(_.upperCase(validationAddress.region))) {\n    errors.push({ region: \"Region did not match\" });\n  }\n\n  if (validationAddress.country && address.country && _.upperCase(address.country) !== _.upperCase(validationAddress.country)) {\n    errors.push({ country: \"Country did not match\" });\n  }\n  return errors;\n}\n\n/**\n * @summary Validates an address, and if fails returns details of issues\n * @param {Object} address - The address object to validate\n * @returns {{validated: boolean, address: *}} - The results of the validation\n */\nfunction validateAddress(address) {\n  check(address, Object);\n  let validated = true;\n  let validationErrors;\n  let validatedAddress = address;\n  let formErrors;\n  Schemas.Address.clean(address);\n  const validator = getValidator();\n  if (validator) {\n    const validationResult = Meteor.call(validator, address);\n    validatedAddress = validationResult.validatedAddress;\n    formErrors = validationResult.errors;\n    if (validatedAddress) {\n      validationErrors = compareAddress(address, validatedAddress);\n      if (validationErrors.length || formErrors.length) {\n        validated = false;\n      }\n    } else {\n      // No address, fail validation\n      validated = false;\n    }\n  }\n  const validationResults = { validated, fieldErrors: validationErrors, formErrors, validatedAddress };\n  return validationResults;\n}\n\n/**\n * Reaction Account Methods\n */\nMeteor.methods({\n  \"accounts/validateAddress\": validateAddress,\n  /*\n   * check if current user has password\n   */\n  \"accounts/currentUserHasPassword\": function () {\n    const user = Meteor.users.findOne(Meteor.userId());\n    if (user.services.password) {\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * accounts/addressBookAdd\n   * @description add new addresses to an account\n   * @param {Object} address - address\n   * @param {String} [accountUserId] - `account.userId` used by admin to edit\n   * users\n   * @return {Object} with keys `numberAffected` and `insertedId` if doc was\n   * inserted\n   */\n  \"accounts/addressBookAdd\": function (address, accountUserId) {\n    check(address, Schemas.Address);\n    check(accountUserId, Match.Optional(String));\n    // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n    if (typeof accountUserId === \"string\") { // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n    this.unblock();\n\n    const userId = accountUserId || Meteor.userId();\n    // required default id\n    if (!address._id) {\n      address._id = Random.id();\n    }\n    // if address got shippment or billing default, we need to update cart\n    // addresses accordingly\n    if (address.isShippingDefault || address.isBillingDefault) {\n      const cart = Cart.findOne({ userId: userId });\n      // if cart exists\n      // First amend the cart,\n      if (typeof cart === \"object\") {\n        if (address.isShippingDefault) {\n          Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n        }\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n        }\n      }\n      // then change the address that has been affected\n      if (address.isShippingDefault) {\n        Accounts.update({\n          \"userId\": userId,\n          \"profile.addressBook.isShippingDefault\": true\n        }, {\n          $set: {\n            \"profile.addressBook.$.isShippingDefault\": false\n          }\n        });\n      }\n      if (address.isBillingDefault) {\n        Accounts.update({\n          \"userId\": userId,\n          \"profile.addressBook.isBillingDefault\": true\n        }, {\n          $set: {\n            \"profile.addressBook.$.isBillingDefault\": false\n          }\n        });\n      }\n    }\n\n    return Accounts.upsert({\n      userId: userId\n    }, {\n      $set: {\n        userId: userId\n      },\n      $addToSet: {\n        \"profile.addressBook\": address\n      }\n    });\n  },\n\n  /**\n   * accounts/addressBookUpdate\n   * @description update existing address in user's profile\n   * @param {Object} address - address\n   * @param {String|null} [accountUserId] - `account.userId` used by admin to\n   * edit users\n   * @param {shipping|billing} [type] - name of selected address type\n   * @return {Number} The number of affected documents\n   */\n  \"accounts/addressBookUpdate\": function (address, accountUserId, type) {\n    check(address, Schemas.Address);\n    check(accountUserId, Match.OneOf(String, null, undefined));\n    check(type, Match.Optional(String));\n    // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n    if (typeof accountUserId === \"string\") { // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n    this.unblock();\n\n    const userId = accountUserId || Meteor.userId();\n    // we need to compare old state of isShippingDefault, isBillingDefault with\n    // new state and if it was enabled/disabled reflect this changes in cart\n    const account = Accounts.findOne({\n      userId: userId\n    });\n    const oldAddress = account.profile.addressBook.find(function (addr) {\n      return addr._id === address._id;\n    });\n\n    // happens when the user clicked the address in grid. We need to set type\n    // to `true`\n    if (typeof type === \"string\") {\n      Object.assign(address, { [type]: true });\n    }\n\n    // We want the cart addresses to be updated when current default address\n    // (shipping or Billing) are different than the previous one, but also\n    // when the current default address(ship or bill) gets edited(so Current and Previous default are the same).\n    // This check can be simplified to :\n    if  (address.isShippingDefault || address.isBillingDefault ||\n         oldAddress.isShippingDefault || address.isBillingDefault) {\n      const cart = Cart.findOne({ userId: userId });\n      // Cart should exist to this moment, so we doesn't need to to verify its\n      // existence.\n      if (oldAddress.isShippingDefault !== address.isShippingDefault) {\n        // if isShippingDefault was changed and now it is `true`\n        if (address.isShippingDefault) {\n          // we need to add this address to cart\n          Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n          // then, if another address was `ShippingDefault`, we need to unset it\n          Accounts.update({\n            \"userId\": userId,\n            \"profile.addressBook.isShippingDefault\": true\n          }, {\n            $set: {\n              \"profile.addressBook.$.isShippingDefault\": false\n            }\n          });\n        } else {\n          // if new `isShippingDefault` state is false, then we need to remove\n          // this address from `cart.shipping`\n          Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"shipping\");\n        }\n      } else if (address.isShippingDefault && oldAddress.isShippingDefault) {\n        // If current Shipping Address was edited but not changed update it to cart too\n        Meteor.call(\"cart/setShipmentAddress\", cart._id, address);\n      }\n\n      // the same logic used for billing\n      if (oldAddress.isBillingDefault !== address.isBillingDefault) {\n        if (address.isBillingDefault) {\n          Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n          Accounts.update({\n            \"userId\": userId,\n            \"profile.addressBook.isBillingDefault\": true\n          }, {\n            $set: {\n              \"profile.addressBook.$.isBillingDefault\": false\n            }\n          });\n        } else {\n          Meteor.call(\"cart/unsetAddresses\", address._id, userId, \"billing\");\n        }\n      } else if (address.isBillingDefault && oldAddress.isBillingDefault) {\n        // If current Billing Address was edited but not changed update it to cart too\n        Meteor.call(\"cart/setPaymentAddress\", cart._id, address);\n      }\n    }\n\n    return Accounts.update({\n      \"userId\": userId,\n      \"profile.addressBook._id\": address._id\n    }, {\n      $set: {\n        \"profile.addressBook.$\": address\n      }\n    });\n  },\n\n  /**\n   * accounts/addressBookRemove\n   * @description remove existing address in user's profile\n   * @param {String} addressId - address `_id`\n   * @param {String} [accountUserId] - `account.userId` used by admin to edit\n   * users\n   * @return {Number|Object} The number of removed documents or error object\n   */\n  \"accounts/addressBookRemove\": function (addressId, accountUserId) {\n    check(addressId, String);\n    check(accountUserId, Match.Optional(String));\n    // security, check for admin access. We don't need to check every user call\n    // here because we are calling `Meteor.userId` from within this Method.\n    if (typeof accountUserId === \"string\") { // if this will not be a String -\n      // `check` will not pass it.\n      if (!Reaction.hasAdminAccess()) {\n        throw new Meteor.Error(403, \"Access denied\");\n      }\n    }\n    this.unblock();\n\n    const userId = accountUserId || Meteor.userId();\n    // remove this address in cart, if used, before completely removing\n    Meteor.call(\"cart/unsetAddresses\", addressId, userId);\n\n    return Accounts.update({\n      \"userId\": userId,\n      \"profile.addressBook._id\": addressId\n    }, {\n      $pull: {\n        \"profile.addressBook\": {\n          _id: addressId\n        }\n      }\n    });\n  },\n\n  /**\n   * accounts/inviteShopMember\n   * invite new admin users\n   * (not consumers) to secure access in the dashboard\n   * to permissions as specified in packages/roles\n   * @param {String} shopId - shop to invite user\n   * @param {String} email - email of invitee\n   * @param {String} name - name to address email\n   * @returns {Boolean} returns true\n   */\n  \"accounts/inviteShopMember\": function (shopId, email, name) {\n    check(shopId, String);\n    check(email, String);\n    check(name, String);\n\n    this.unblock();\n\n    const shop = Shops.findOne(shopId);\n\n    if (!shop) {\n      const msg = `accounts/inviteShopMember - Shop ${shopId} not found`;\n      Logger.error(msg);\n      throw new Meteor.Error(\"shop-not-found\", msg);\n    }\n\n    if (!Reaction.hasPermission(\"reaction-accounts\", this.userId, shopId)) {\n      Logger.error(`User ${this.userId} does not have reaction-accounts permissions`);\n      throw new Meteor.Error(\"access-denied\", \"Access denied\");\n    }\n\n    const currentUser = Meteor.users.findOne(this.userId);\n\n    let currentUserName;\n\n    if (currentUser) {\n      if (currentUser.profile) {\n        currentUserName = currentUser.profile.name || currentUser.username;\n      } else {\n        currentUserName = currentUser.username;\n      }\n    } else {\n      currentUserName = \"Admin\";\n    }\n\n    const user = Meteor.users.findOne({\n      \"emails.address\": email\n    });\n\n    if (!user) {\n      const userId = MeteorAccounts.createUser({\n        email: email,\n        username: name\n      });\n\n      const newUser = Meteor.users.findOne(userId);\n\n      if (!newUser) {\n        throw new Error(\"Can't find user\");\n      }\n\n      const token = Random.id();\n\n      Meteor.users.update(userId, {\n        $set: {\n          \"services.password.reset\": { token, email, when: new Date() }\n        }\n      });\n\n      // Get shop logo, if available. If not, use default logo from file-system\n      let emailLogo;\n      if (Array.isArray(shop.brandAssets)) {\n        const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n        const mediaId = Media.findOne(brandAsset.mediaId);\n        emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n      } else {\n        emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n      }\n\n      const dataForEmail = {\n        // Shop Data\n        shop: shop,\n        contactEmail: shop.emails[0].address,\n        homepage: Meteor.absoluteUrl(),\n        emailLogo: emailLogo,\n        copyrightDate: moment().format(\"YYYY\"),\n        legalName: shop.addressBook[0].company,\n        physicalAddress: {\n          address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n          city: shop.addressBook[0].city,\n          region: shop.addressBook[0].region,\n          postal: shop.addressBook[0].postal\n        },\n        shopName: shop.name,\n        socialLinks: {\n          display: true,\n          facebook: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n            link: \"https://www.facebook.com\"\n          },\n          googlePlus: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n            link: \"https://plus.google.com\"\n          },\n          twitter: {\n            display: true,\n            icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n            link: \"https://www.twitter.com\"\n          }\n        },\n        // Account Data\n        user: Meteor.user(),\n        currentUserName,\n        invitedUserName: name,\n        url: MeteorAccounts.urls.enrollAccount(token)\n      };\n\n      // Compile Email with SSR\n      const tpl = \"accounts/inviteShopMember\";\n      const subject = \"accounts/inviteShopMember/subject\";\n      SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n      SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n      Reaction.Email.send({\n        to: email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n    } else {\n      Reaction.Email.send({\n        to: email,\n        from: `${shop.name} <${shop.emails[0].address}>`,\n        subject: SSR.render(subject, dataForEmail),\n        html: SSR.render(tpl, dataForEmail)\n      });\n    }\n    return true;\n  },\n\n  /**\n   * accounts/sendWelcomeEmail\n   * send an email to consumers on sign up\n   * @param {String} shopId - shopId of new User\n   * @param {String} userId - new userId to welcome\n   * @returns {Boolean} returns boolean\n   */\n  \"accounts/sendWelcomeEmail\": function (shopId, userId) {\n    check(shopId, String);\n    check(userId, String);\n\n    this.unblock();\n\n    const user = Accounts.findOne(userId);\n    const shop = Shops.findOne(shopId);\n\n    // Get shop logo, if available. If not, use default logo from file-system\n    let emailLogo;\n    if (Array.isArray(shop.brandAssets)) {\n      const brandAsset = _.find(shop.brandAssets, (asset) => asset.type === \"navbarBrandImage\");\n      const mediaId = Media.findOne(brandAsset.mediaId);\n      emailLogo = path.join(Meteor.absoluteUrl(), mediaId.url());\n    } else {\n      emailLogo = Meteor.absoluteUrl() + \"resources/email-templates/shop-logo.png\";\n    }\n\n    const dataForEmail = {\n      // Shop Data\n      shop: shop,\n      contactEmail: shop.emails[0].address,\n      homepage: Meteor.absoluteUrl(),\n      emailLogo: emailLogo,\n      copyrightDate: moment().format(\"YYYY\"),\n      legalName: shop.addressBook[0].company,\n      physicalAddress: {\n        address: shop.addressBook[0].address1 + \" \" + shop.addressBook[0].address2,\n        city: shop.addressBook[0].city,\n        region: shop.addressBook[0].region,\n        postal: shop.addressBook[0].postal\n      },\n      shopName: shop.name,\n      socialLinks: {\n        display: true,\n        facebook: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/facebook-icon.png\",\n          link: \"https://www.facebook.com\"\n        },\n        googlePlus: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/google-plus-icon.png\",\n          link: \"https://plus.google.com\"\n        },\n        twitter: {\n          display: true,\n          icon: Meteor.absoluteUrl() + \"resources/email-templates/twitter-icon.png\",\n          link: \"https://www.twitter.com\"\n        }\n      },\n      // Account Data\n      user: Meteor.user()\n    };\n\n    // anonymous users arent welcome here\n    if (!user.emails || !user.emails.length > 0) {\n      return true;\n    }\n\n    const userEmail = user.emails[0].address;\n\n    let shopEmail;\n    // provide some defaults for missing shop email.\n    if (!shop.emails) {\n      shopEmail = `${shop.name}@localhost`;\n      Logger.debug(`Shop email address not configured. Using ${shopEmail}`);\n    } else {\n      shopEmail = shop.emails[0].address;\n    }\n\n    const tpl = \"accounts/sendWelcomeEmail\";\n    const subject = \"accounts/sendWelcomeEmail/subject\";\n    SSR.compileTemplate(tpl, Reaction.Email.getTemplate(tpl));\n    SSR.compileTemplate(subject, Reaction.Email.getSubject(tpl));\n\n    Reaction.Email.send({\n      to: userEmail,\n      from: `${shop.name} <${shopEmail}>`,\n      subject: SSR.render(subject, dataForEmail),\n      html: SSR.render(tpl, dataForEmail)\n    });\n\n    return true;\n  },\n\n  /**\n   * accounts/addUserPermissions\n   * @param {String} userId - userId\n   * @param {Array|String} permissions -\n   *               Name of role/permission.  If array, users\n   *               returned will have at least one of the roles\n   *               specified but need not have _all_ roles.\n   * @param {String} [group] Optional name of group to restrict roles to.\n   *                         User\"s Roles.GLOBAL_GROUP will also be checked.\n   * @returns {Boolean} success/failure\n   */\n  \"accounts/addUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n    check(userId, Match.OneOf(String, Array));\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String));\n    this.unblock();\n    try {\n      return Roles.addUsersToRoles(userId, permissions, group);\n    } catch (error) {\n      return Logger.error(error);\n    }\n  },\n\n  /*\n   * accounts/removeUserPermissions\n   */\n  \"accounts/removeUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n    check(userId, String);\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String, null));\n    this.unblock();\n\n    try {\n      return Roles.removeUsersFromRoles(userId, permissions, group);\n    } catch (error) {\n      Logger.error(error);\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n  },\n\n  /**\n   * accounts/setUserPermissions\n   * @param {String} userId - userId\n   * @param {String|Array} permissions - string/array of permissions\n   * @param {String} group - group\n   * @returns {Boolean} returns Roles.setUserRoles result\n   */\n  \"accounts/setUserPermissions\": function (userId, permissions, group) {\n    if (!Reaction.hasPermission(\"reaction-accounts\", Meteor.userId(), group)) {\n      throw new Meteor.Error(403, \"Access denied\");\n    }\n    check(userId, String);\n    check(permissions, Match.OneOf(String, Array));\n    check(group, Match.Optional(String));\n    this.unblock();\n    try {\n      return Roles.setUserRoles(userId, permissions, group);\n    } catch (error) {\n      Logger.error(error);\n      return error;\n    }\n  }\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Reaction } from \"/server/api\";\n\n\nMeteor.methods({\n  \"accounts/updateServiceConfiguration\": function (service, fields) {\n    check(service, String);\n    check(fields, Array);\n    const dataToSave = {};\n\n    _.each(fields, function (field) {\n      dataToSave[field.property] = field.value;\n    });\n\n    if (Reaction.hasPermission([\"dashboard/accounts\"])) {\n      return ServiceConfiguration.configurations.upsert({\n        service: service\n      }, {\n        $set: dataToSave\n      });\n    }\n    return false;\n  }\n});\n","import _ from  \"lodash\";\nimport { EJSON } from \"meteor/ejson\";\nimport { check } from \"meteor/check\";\nimport { Meteor } from \"meteor/meteor\";\nimport { copyFile, ReactionProduct } from \"/lib/api\";\nimport { ProductRevision as Catalog } from \"/imports/plugins/core/revisions/server/hooks\";\nimport { Media, Products, Revisions, Tags } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\n/**\n * Reaction Product Methods\n */\n/* eslint new-cap: 0 */\n/* eslint no-loop-func: 0 */\n/* eslint quotes: 0 */\n\n/**\n * updateVariantProductField\n * @summary updates the variant\n * @param {Array} variants - the array of variants\n * @param {String} field - the field to update\n * @param {String} value - the value to add\n * @return {Array} - return an array\n */\nfunction updateVariantProductField(variants, field, value) {\n  return variants.map(variant => {\n    Meteor.call(\"products/updateProductField\", variant._id, field, value);\n  });\n}\n\n/**\n * @array toDenormalize\n * @summary contains a list of fields, which should be denormalized\n * @type {string[]}\n */\nconst toDenormalize = [\n  \"price\",\n  \"inventoryQuantity\",\n  \"lowInventoryWarningThreshold\",\n  \"inventoryPolicy\",\n  \"inventoryManagement\"\n];\n\n/**\n * @function createTitle\n * @description Recursive method which trying to find a new `title`, given the\n * existing copies\n * @param {String} newTitle - product `title`\n * @param {String} productId - current product `_id`\n * @return {String} title - modified `title`\n */\nfunction createTitle(newTitle, productId) {\n  // exception product._id needed for cases then double triggering happens\n  let title = newTitle || \"\";\n  const titleCount = Products.find({\n    title: title,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n  // current product \"copy\" number\n  let titleNumberSuffix = 0;\n  // product handle prefix\n  let titleString = title;\n  // copySuffix \"-copy-number\" suffix of product\n  const copySuffix = titleString.match(/-copy-\\d+$/) || titleString.match(/-copy$/);\n  // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    titleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1;\n    // removing last numbers and last \"-\" if it presents\n    titleString = title.replace(/\\d+$/, '').replace(/-$/, '');\n  }\n\n  // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n  if (titleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (titleNumberSuffix > 0) {\n      title = `${titleString}-${titleNumberSuffix + titleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      title = `${titleString}-copy${ titleCount > 1 ? \"-\" + titleCount : \"\"}`;\n    }\n  }\n\n  // we should check again if there are any new matches with DB\n  if (Products.find({\n    title: title\n  }).count() !== 0) {\n    title = createTitle(title, productId);\n  }\n  return title;\n}\n\n/**\n * @function createHandle\n * @description Recursive method which trying to find a new `handle`, given the\n * existing copies\n * @param {String} productHandle - product `handle`\n * @param {String} productId - current product `_id`\n * @return {String} handle - modified `handle`\n */\nfunction createHandle(productHandle, productId) {\n  let handle = productHandle || \"\";\n  // exception product._id needed for cases then double triggering happens\n  const handleCount = Products.find({\n    handle: handle,\n    _id: {\n      $nin: [productId]\n    }\n  }).count();\n  // current product \"copy\" number\n  let handleNumberSuffix = 0;\n  // product handle prefix\n  let handleString = handle;\n  // copySuffix \"-copy-number\" suffix of product\n  const copySuffix = handleString.match(/-copy-\\d+$/) || handleString.match(/-copy$/);\n\n  // if product is a duplicate, we should take the copy number, and cut\n  // the handle\n  if (copySuffix) {\n    // we can have two cases here: copy-number and just -copy. If there is\n    // no numbers in copySuffix then we should put 1 in handleNumberSuffix\n    handleNumberSuffix = +String(copySuffix).match(/\\d+$/) || 1;\n    // removing last numbers and last \"-\" if it presents\n    handleString = handle.replace(/\\d+$/, '').replace(/-$/, '');\n  }\n\n  // if we have more than one product with the same handle, we should mark\n  // it as \"copy\" or increment our product handle if it contain numbers.\n  if (handleCount > 0) {\n    // if we have product with name like \"product4\", we should take care\n    // about its uniqueness\n    if (handleNumberSuffix > 0) {\n      handle = `${handleString}-${handleNumberSuffix + handleCount}`;\n    } else {\n      // first copy will be \"...-copy\", second: \"...-copy-2\"\n      handle = `${handleString}-copy${ handleCount > 1\n        ? '-' + handleCount : ''}`;\n    }\n  }\n\n  // we should check again if there are any new matches with DB\n  if (Products.find({\n    handle: handle\n  }).count() !== 0) {\n    handle = createHandle(handle, productId);\n  }\n\n  return handle;\n}\n\n/**\n * @function copyMedia\n * @description copy images links to cloned variant from original\n * @param {String} newId - [cloned|original] product _id\n * @param {String} variantOldId - old variant _id\n * @param {String} variantNewId - - cloned variant _id\n * @return {Number} Media#update result\n */\nfunction copyMedia(newId, variantOldId, variantNewId) {\n  Media.find({\n    \"metadata.variantId\": variantOldId\n  }).forEach(function (fileObj) {\n    // Copy File and insert directly, bypasing revision control\n    copyFile(fileObj, {\n      productId: newId,\n      variantId: variantNewId\n    });\n  });\n}\n\n/**\n * @function denormalize\n * @description With flattened model we do not want to get variant docs in\n * `products` publication, but we need some data from variants to display price,\n * quantity, etc. That's why we are denormalizing these properties into product\n * doc. Also, this way should have a speed benefit comparing the way where we\n * could dynamically build denormalization inside `products` publication.\n * @summary update product denormalized properties if variant was updated or\n * removed\n * @param {String} id - product _id\n * @param {String} field - type of field. Could be:\n * \"price\",\n * \"inventoryQuantity\",\n * \"inventoryManagement\",\n * \"inventoryPolicy\",\n * \"lowInventoryWarningThreshold\"\n * @since 0.11.0\n * @return {Number} - number of successful update operations. Should be \"1\".\n */\nfunction denormalize(id, field) {\n  const doc = Products.findOne(id);\n  let variants;\n  if (doc.type === \"simple\") {\n    variants = Catalog.getTopVariants(id);\n  } else if (doc.type === \"variant\" && doc.ancestors.length === 1) {\n    variants = Catalog.getVariants(id);\n  }\n  const update = {};\n\n  switch (field) {\n    case \"inventoryPolicy\":\n    case \"inventoryQuantity\":\n    case \"inventoryManagement\":\n      Object.assign(update, {\n        isSoldOut: isSoldOut(variants),\n        isLowQuantity: isLowQuantity(variants),\n        isBackorder: isBackorder(variants)\n      });\n      break;\n    case \"lowInventoryWarningThreshold\":\n      Object.assign(update, {\n        isLowQuantity: isLowQuantity(variants)\n      });\n      break;\n    default: // \"price\" is object with range, min, max\n      const priceObject = Catalog.getProductPriceRange(id);\n      Object.assign(update, {\n        price: priceObject\n      });\n  }\n  Products.update(id, {\n    $set: update\n  }, {\n    selector: {\n      type: \"simple\"\n    }\n  });\n}\n\n/**\n * isSoldOut\n * @description We are stop accepting new orders if product marked as\n * `isSoldOut`.\n * @param {Array} variants - Array with top-level variants\n * @return {Boolean} true if summary product quantity is zero.\n */\nfunction isSoldOut(variants) {\n  return variants.every(variant => {\n    if (variant.inventoryManagement && variant.inventoryPolicy) {\n      return Catalog.getVariantQuantity(variant) <= 0;\n    }\n    return false;\n  });\n}\n\n/**\n * isLowQuantity\n * @description If at least one of the variants is less than the threshold,\n * then function returns `true`\n * @param {Array} variants - array of child variants\n * @return {boolean} low quantity or not\n */\nfunction isLowQuantity(variants) {\n  return variants.some(variant => {\n    const quantity = Catalog.getVariantQuantity(variant);\n    // we need to keep an eye on `inventoryPolicy` too and qty > 0\n    if (variant.inventoryManagement && variant.inventoryPolicy && quantity) {\n      return quantity <= variant.lowInventoryWarningThreshold;\n    }\n    // TODO: need to test this function with real data\n    return false;\n  });\n}\n\n/**\n * isBackorder\n * @description Is products variants is still available to be ordered after\n * summary variants quantity is zero\n * @param {Array} variants - array with variant objects\n * @return {boolean} is backorder allowed or now for a product\n */\nfunction isBackorder(variants) {\n  return variants.every(variant => {\n    return !variant.inventoryPolicy && variant.inventoryManagement &&\n      variant.inventoryQuantity === 0;\n  });\n}\n\n/**\n * flushQuantity\n * @description if variant `inventoryQuantity` not zero, function update it to\n * zero. This needed in case then option with it's own `inventoryQuantity`\n * creates to top-level variant. In that case top-level variant should display\n * sum of his options `inventoryQuantity` fields.\n * @param {String} id - variant _id\n * @return {Number} - collection update results\n */\nfunction flushQuantity(id) {\n  const variant = Products.findOne(id);\n  // if variant already have descendants, quantity should be 0, and we don't\n  // need to do all next actions\n  if (variant.inventoryQuantity === 0) {\n    return 1; // let them think that we have one successful operation here\n  }\n\n  return Products.update({\n    _id: id\n  }, {\n    $set: {\n      inventoryQuantity: 0\n    }\n  }, {\n    selector: {\n      type: \"variant\"\n    }\n  });\n}\n\nMeteor.methods({\n  /**\n   * products/cloneVariant\n   * @summary clones a product variant into a new variant\n   * @description the method copies variants, but will also create and clone\n   * child variants (options)\n   * @param {String} productId - the productId we're whose variant we're\n   * cloning\n   * @param {String} variantId - the variantId that we're cloning\n   * @todo rewrite @description\n   * @return {Array} - list with cloned variants _ids\n   */\n  \"products/cloneVariant\": function (productId, variantId) {\n    check(productId, String);\n    check(variantId, String);\n    // user needs createProduct permission to clone\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const variant = Products.findOne(variantId);\n\n    // Verify that this variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n    if (ReactionProduct.isAncestorDeleted(variant, true)) {\n      throw new Meteor.Error(403, \"Unable to create product variant\");\n    }\n\n    const variants = Products.find({\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }],\n      type: \"variant\"\n    }).fetch();\n    // exit if we're trying to clone a ghost\n    if (variants.length === 0) {\n      return;\n    }\n    const variantNewId = Random.id(); // for the parent variant\n    // we need to make sure that top level variant will be cloned first, his\n    // descendants later.\n    // we could use this way in future: http://stackoverflow.com/questions/\n    // 9040161/mongo-order-by-length-of-array, by now following are allowed\n    // @link https://lodash.com/docs#sortBy\n    const sortedVariants = _.sortBy(variants, doc => doc.ancestors.length);\n\n    return sortedVariants.map(sortedVariant => {\n      const oldId = sortedVariant._id;\n      let type = \"child\";\n      const clone = {};\n      if (variantId === sortedVariant._id) {\n        type = \"parent\";\n        Object.assign(clone, sortedVariant, {\n          _id: variantNewId,\n          title: `${sortedVariant.title} - copy`\n        });\n      } else {\n        const parentIndex = sortedVariant.ancestors.indexOf(variantId);\n        const ancestorsClone = sortedVariant.ancestors.slice(0);\n        // if variantId exists in ancestors, we override it by new _id\n        !!~parentIndex && ancestorsClone.splice(parentIndex, 1, variantNewId);\n        Object.assign(clone, variant, {\n          _id: Random.id(),\n          ancestors: ancestorsClone\n        });\n      }\n      delete clone.updatedAt;\n      delete clone.createdAt;\n      delete clone.inventoryQuantity;\n      copyMedia(productId, oldId, clone._id);\n      return Products.insert(clone, {\n        validate: false\n      }, (error, result) => {\n        if (result) {\n          if (type === \"child\") {\n            Logger.debug(\n              `products/cloneVariant: created sub child clone: ${\n                clone._id} from ${variantId}`\n            );\n          } else {\n            Logger.debug(\n              `products/cloneVariant: created clone: ${\n                clone._id} from ${variantId}`\n            );\n          }\n        }\n        if (error) {\n          Logger.error(\n            `products/cloneVariant: cloning of ${variantId} was failed: ${error}`\n          );\n        }\n      });\n    });\n  },\n\n  /**\n   * products/createVariant\n   * @summary initializes empty variant template\n   * @param {String} parentId - the product _id or top level variant _id where\n   * we create variant\n   * @param {Object} [newVariant] - variant object\n   * @return {String} new variantId\n   */\n  \"products/createVariant\": function (parentId, newVariant) {\n    check(parentId, String);\n    check(newVariant, Match.Optional(Object));\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const newVariantId = Random.id();\n    // get parent ancestors to build new ancestors array\n    const product = Products.findOne(parentId);\n    const { ancestors } = product;\n\n    // Verify that the parent variant and any ancestors are not deleted.\n    // Child variants cannot be added if a parent product or product revision\n    // is marked as `{ isDeleted: true }`\n    if (ReactionProduct.isAncestorDeleted(product, true)) {\n      throw new Meteor.Error(403, \"Unable to create product variant\");\n    }\n\n    Array.isArray(ancestors) && ancestors.push(parentId);\n    const assembledVariant = Object.assign(newVariant || {}, {\n      _id: newVariantId,\n      ancestors: ancestors,\n      type: \"variant\"\n    });\n\n    if (!newVariant) {\n      Object.assign(assembledVariant, {\n        title: \"\",\n        price: 0.00\n      });\n    }\n\n    // if we are inserting child variant to top-level variant, we need to remove\n    // all top-level's variant inventory records and flush it's quantity,\n    // because it will be hold sum of all it descendants quantities.\n    if (ancestors.length === 2) {\n      flushQuantity(parentId);\n    }\n\n    Products.insert(assembledVariant,\n      (error, result) => {\n        if (result) {\n          Logger.debug(\n            `products/createVariant: created variant: ${\n              newVariantId} for ${parentId}`\n          );\n        }\n      }\n    );\n\n    return newVariantId;\n  },\n\n  /**\n   * products/updateVariant\n   * @summary update individual variant with new values, merges into original\n   * only need to supply updated information. Currently used for a one use case\n   * - to manage top-level variant autoform.\n   * @param {Object} variant - current variant object\n   * @todo some use cases of this method was moved to \"products/\n   * updateProductField\", but it still used\n   * @return {Number} returns update result\n   */\n  \"products/updateVariant\": function (variant) {\n    check(variant, Object);\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const currentVariant = Products.findOne(variant._id);\n    // update variants\n    if (typeof currentVariant === \"object\") {\n      const newVariant = Object.assign({}, currentVariant, variant);\n\n      return Products.update({\n        _id: variant._id\n      }, {\n        $set: newVariant // newVariant already contain `type` property, so we\n          // do not need to pass it explicitly\n      }, {\n        validate: false\n      }, (error, result) => {\n        if (result) {\n          const productId = currentVariant.ancestors[0];\n          // we need manually check is these fields were updated?\n          // we can't stop after successful denormalization, because we have a\n          // case when several fields could be changed in top-level variant\n          // before form will be submitted.\n          toDenormalize.forEach(field => {\n            if (currentVariant[field] !== variant[field]) {\n              denormalize(productId, field);\n            }\n          });\n        }\n      });\n    }\n  },\n\n  /**\n   * products/deleteVariant\n   * @summary delete variant, which should also delete child variants\n   * @param {String} variantId - variantId to delete\n   * @returns {Boolean} returns update results: `true` - if at least one variant\n   * was removed or `false` if nothing was removed\n   */\n  \"products/deleteVariant\": function (variantId) {\n    check(variantId, String);\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const selector = {\n      // Don't \"archive\" variants that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: variantId\n      }, {\n        ancestors: {\n          $in: [variantId]\n        }\n      }]\n    };\n    const toDelete = Products.find(selector).fetch();\n    // out if nothing to delete\n    if (!Array.isArray(toDelete) || toDelete.length === 0) return false;\n\n    const deleted = Products.remove(selector);\n\n    // after variant were removed from product, we need to recalculate all\n    // denormalized fields\n    const productId = toDelete[0].ancestors[0];\n    toDenormalize.forEach(field => denormalize(productId, field));\n\n    return typeof deleted === \"number\" && deleted > 0;\n  },\n\n  /**\n   * products/cloneProduct\n   * @summary clone a whole product, defaulting visibility, etc\n   * in the future we are going to do an inheritance product\n   * that maintains relationships with the cloned product tree\n   * @param {Array} productOrArray - products array to clone\n   * @returns {Array} returns insert results\n   */\n  \"products/cloneProduct\": function (productOrArray) {\n    check(productOrArray, Match.OneOf(Array, Object));\n    // must have createProduct permissions\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    // this.unblock();\n\n    let result;\n    let products;\n    const results = [];\n    const pool = []; // pool of id pairs: { oldId, newId }\n\n    function getIds(id) {\n      return pool.filter(function (pair) {\n        return pair.oldId === this.id;\n      }, {\n        id: id\n      });\n    }\n\n    function setId(ids) {\n      return pool.push(ids);\n    }\n\n    function buildAncestors(ancestors) {\n      const newAncestors = [];\n      ancestors.map(oldId => {\n        const pair = getIds(oldId);\n        // TODO do we always have newId on this step?\n        newAncestors.push(pair[0].newId);\n      });\n      return newAncestors;\n    }\n\n    if (!Array.isArray(productOrArray)) {\n      products = [productOrArray];\n    } else {\n      products = productOrArray;\n    }\n\n    for (const product of products) {\n      // cloning product\n      const productNewId = Random.id();\n      setId({\n        oldId: product._id,\n        newId: productNewId\n      });\n\n      const newProduct = Object.assign({}, product, {\n        _id: productNewId\n          // ancestors: product.ancestors.push(product._id)\n      });\n      delete newProduct.updatedAt;\n      delete newProduct.createdAt;\n      delete newProduct.publishedAt;\n      delete newProduct.positions;\n      delete newProduct.handle;\n      newProduct.isVisible = false;\n      if (newProduct.title) {\n        // todo test this\n        newProduct.title = createTitle(newProduct.title, newProduct._id);\n        newProduct.handle = createHandle(\n          Reaction.getSlug(newProduct.title),\n          newProduct._id\n        );\n      }\n      result = Products.insert(newProduct, {\n        validate: false\n      });\n      results.push(result);\n\n      // cloning variants\n      const variants = Products.find({\n        ancestors: {\n          $in: [product._id]\n        },\n        type: \"variant\"\n      }).fetch();\n      // why we are using `_.sortBy` described in `products/cloneVariant`\n      const sortedVariants = _.sortBy(variants, doc => doc.ancestors.length);\n      for (const variant of sortedVariants) {\n        const variantNewId = Random.id();\n        setId({\n          oldId: variant._id,\n          newId: variantNewId\n        });\n        const ancestors = buildAncestors(variant.ancestors);\n        const newVariant = Object.assign({}, variant, {\n          _id: variantNewId,\n          ancestors: ancestors\n        });\n        delete newVariant.updatedAt;\n        delete newVariant.createdAt;\n        delete newVariant.publishedAt; // TODO can variant have this param?\n\n        result = Products.insert(\n          newVariant, {\n            validate: false\n          }\n        );\n        copyMedia(productNewId, variant._id, variantNewId);\n        results.push(result);\n      }\n    }\n    return results;\n  },\n\n  /**\n   * products/createProduct\n   * @summary when we create a new product, we create it with an empty variant.\n   * all products have a variant with pricing and details\n   * @param {Object} [product] - optional product object\n   * @return {String} return insert result\n   */\n  \"products/createProduct\": function (product) {\n    check(product, Match.Optional(Object));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    // if a product object was provided\n    if (product) {\n      return Products.insert(product);\n    }\n\n    return Products.insert({\n      type: \"simple\" // needed for multi-schema\n    }, {\n      validate: false\n    }, (error, result) => {\n      // additionally, we want to create a variant to a new product\n      if (result) {\n        Products.insert({\n          ancestors: [result],\n          price: 0.00,\n          title: \"\",\n          type: \"variant\" // needed for multi-schema\n        });\n      }\n    });\n  },\n\n  /**\n   * products/archiveProduct\n   * @summary archive a product and unlink it from all media\n   * @param {String} productId - productId to delete\n   * @returns {Number} returns number of removed products\n   */\n  \"products/archiveProduct\": function (productId) {\n    check(productId, Match.OneOf(Array, String));\n    // must have admin permission to delete\n    if (!Reaction.hasPermission(\"createProduct\") && !Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    let productIds;\n\n    if (!Array.isArray(productId)) {\n      productIds = [productId];\n    } else {\n      productIds = productId;\n    }\n    const productsWithVariants = Products.find({\n      // Don't \"archive\" products that are already marked deleted.\n      isDeleted: {\n        $in: [false, undefined]\n      },\n      $or: [{\n        _id: {\n          $in: productIds\n        }\n      }, {\n        ancestors: {\n          $in: productIds\n        }\n      }]\n    }, {\n      fields: {\n        type: 1\n      }\n    }).fetch();\n\n    const ids = [];\n    productsWithVariants.map(doc => {\n      ids.push(doc._id);\n    });\n\n    Products.remove({\n      _id: {\n        $in: ids\n      }\n    });\n\n    const numRemoved = Revisions.find({\n      \"documentId\": {\n        $in: ids\n      },\n      \"documentData.isDeleted\": true\n    }).count();\n\n    if (numRemoved > 0) {\n      // we can get removes results only in async way\n      Media.update({\n        \"metadata.productId\": {\n          $in: ids\n        },\n        \"metadata.variantId\": {\n          $in: ids\n        }\n      }, {\n        $set: {\n          \"metadata.isDeleted\": true\n        }\n      });\n      return numRemoved;\n    }\n    throw new Meteor.Error(304, \"Something went wrong, nothing was deleted\");\n  },\n\n  /**\n   * products/updateProductField\n   * @summary update single product or variant field\n   * @param {String} _id - product._id or variant._id to update\n   * @param {String} field - key to update\n   * @param {*} value - update property value\n   * @todo rename it to something like \"products/updateField\" to  reflect\n   * @todo we need to know which type of entity field belongs. For that we could\n   * do something like: const type = Products.findOne(_id).type or transmit type\n   * as param if it possible\n   * latest changes. its used for products and variants\n   * @return {Number} returns update result\n   */\n  \"products/updateProductField\": function (_id, field, value) {\n    check(_id, String);\n    check(field, String);\n    check(value, Match.OneOf(String, Object, Array, Boolean, Number));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const doc = Products.findOne(_id);\n    const type = doc.type;\n    let update;\n    // handle booleans with correct typing\n    if (value === \"false\" || value === \"true\") {\n      update = EJSON.parse(`{${field}:${value}}`);\n    } else {\n      const stringValue = EJSON.stringify(value);\n      update = EJSON.parse(\"{\\\"\" + field + \"\\\":\" + stringValue + \"}\");\n    }\n\n    // we need to use sync mode here, to return correct error and result to UI\n    let result;\n\n    try {\n      result = Products.update(_id, {\n        $set: update\n      }, {\n        selector: {\n          type: type\n        }\n      });\n    } catch (e) {\n      throw new Meteor.Error(e.message);\n    }\n\n    // If we get a result from the product update,\n    // meaning the update went past revision control,\n    // denormalize and attach results to top-level product\n    if (result === 1) {\n      if (type === \"variant\" && ~toDenormalize.indexOf(field)) {\n        denormalize(doc.ancestors[0], field);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * products/updateProductTags\n   * @summary method to insert or update tag with hierarchy\n   * @param {String} productId - productId\n   * @param {String} tagName - tagName\n   * @param {String} tagId - tagId\n   * @return {Number} return result\n   */\n  \"products/updateProductTags\": function (productId, tagName, tagId) {\n    check(productId, String);\n    check(tagName, String);\n    check(tagId, Match.OneOf(String, null));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const newTag = {\n      slug: Reaction.getSlug(tagName),\n      name: tagName\n    };\n\n    const existingTag = Tags.findOne({\n      slug: Reaction.getSlug(tagName)\n    });\n\n    if (existingTag) {\n      const productCount = Products.find({\n        _id: productId,\n        hashtags: {\n          $in: [existingTag._id]\n        }\n      }).count();\n      if (productCount > 0) {\n        throw new Meteor.Error(403, \"Existing Tag, Update Denied\");\n      }\n      return Products.update(productId, {\n        $push: {\n          hashtags: existingTag._id\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } else if (tagId) {\n      return Tags.update(tagId, {\n        $set: newTag\n      });\n    }\n\n    const newTagId = Meteor.call(\"shop/createTag\", tagName, false);\n\n    // if result is an Error object, we return it immediately\n    if (typeof newTagId !== \"string\") {\n      return newTagId;\n    }\n\n    return Products.update(productId, {\n      $push: {\n        hashtags: newTagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * products/removeProductTag\n   * @summary method to remove tag from product\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/removeProductTag\": function (productId, tagId) {\n    check(productId, String);\n    check(tagId, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    Products.update(productId, {\n      $pull: {\n        hashtags: tagId\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * products/setHandle\n   * @summary copy of \"products/setHandleTag\", but without tag\n   * @param {String} productId - productId\n   * @returns {String} handle - product handle\n   */\n  \"products/setHandle\": function (productId) {\n    check(productId, String);\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const product = Products.findOne(productId);\n    let handle = Reaction.getSlug(product.title);\n    handle = createHandle(handle, product._id);\n    Products.update(product._id, {\n      $set: {\n        handle: handle,\n        type: \"simple\"\n      }\n    });\n\n    return handle;\n  },\n\n  /**\n   * products/setHandleTag\n   * @summary set or toggle product handle\n   * @param {String} productId - productId\n   * @param {String} tagId - tagId\n   * @return {String} return update result\n   */\n  \"products/setHandleTag\": function (productId, tagId) {\n    check(productId, String);\n    check(tagId, String);\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    function getSet(handle) {\n      return {\n        $set: {\n          handle: handle,\n          type: \"simple\"\n        }\n      };\n    }\n\n    const product = Products.findOne(productId);\n    const tag = Tags.findOne(tagId);\n    // set handle\n    if (product.handle === tag.slug) {\n      let handle = Reaction.getSlug(product.title);\n      handle = createHandle(handle, product._id);\n      Products.update(product._id, getSet(handle));\n\n      return handle;\n    }\n    // toggle handle\n    const existingHandles = Products.find({\n      handle: tag.slug\n    }).fetch();\n    // this is needed to take care about product's handle which(product) was\n    // previously tagged.\n    for (const currentProduct of existingHandles) {\n      const currentProductHandle = createHandle(\n        Reaction.getSlug(currentProduct.title),\n        currentProduct._id);\n      Products.update(currentProduct._id,\n        getSet(currentProductHandle));\n    }\n    Products.update(product._id, getSet(tag.slug));\n\n    return tag.slug;\n  },\n\n  /**\n   * products/updateProductPosition\n   * @summary update product grid positions\n   * @param {String} productId - productId\n   * @param {Object} positionData -  an object with position,dimensions\n   * @param {String} tag - current route name. If it is not tag, then we using\n   * shop name as base `positions` name. Could be useful for multi-shopping.\n   * @return {Number} collection update returns\n   */\n  \"products/updateProductPosition\": function (productId, positionData, tag) {\n    check(productId, String);\n    check(positionData, Object);\n    check(tag, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    this.unblock();\n\n    const position = `positions.${tag}.position`;\n    const pinned = `positions.${tag}.pinned`;\n    const weight = `positions.${tag}.weight`;\n    const updatedAt = `positions.${tag}.updatedAt`;\n\n    return Products.update({\n      _id: productId\n    }, {\n      $set: {\n        [position]: positionData.position,\n        [pinned]: positionData.pinned,\n        [weight]: positionData.weight,\n        [updatedAt]: new Date(),\n        type: \"simple\" // for multi-schema\n      }\n    });\n  },\n\n  /**\n   * products/updateVariantsPosition\n   * @description updates top level variant position index\n   * @param {Array} sortedVariantIds - array of top level variant `_id`s\n   * @since 0.11.0\n   * @return {Number} Products.update result\n   */\n  \"products/updateVariantsPosition\": function (sortedVariantIds) {\n    check(sortedVariantIds, [String]);\n    // TODO: to make this work we need to remove auditArgumentsCheck I suppose\n    // new SimpleSchema({\n    //   sortedVariantIds: { type: [String] }\n    // }).validate({ sortedVariantIds });\n\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    sortedVariantIds.forEach((id, index) => {\n      Products.update(id, {\n        $set: {\n          index: index\n        }\n      }, {\n        selector: {\n          type: \"variant\"\n        }\n      }, (error, result) => {\n        if (result) {\n          Logger.debug(\n            `Variant ${id} position was updated to index ${index}`\n          );\n        }\n      });\n    });\n  },\n\n  /**\n   * products/updateMetaFields\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} updatedMeta - update object with metadata\n   * @param {Object|Number|undefined|null} meta - current meta object, or a number index\n   * @todo should this method works for variants also?\n   * @return {Number} collection update result\n   */\n  \"products/updateMetaFields\": function (productId, updatedMeta, meta) {\n    check(productId, String);\n    check(updatedMeta, Object);\n    check(meta, Match.OneOf(Object, Number, undefined, null));\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    // update existing metadata\n    if (typeof meta === \"object\") {\n      return Products.update({\n        _id: productId,\n        metafields: meta\n      }, {\n        $set: {\n          \"metafields.$\": updatedMeta\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    } else if (typeof meta === \"number\") {\n      return Products.update({\n        _id: productId\n      }, {\n        $set: {\n          [`metafields.${meta}`]: updatedMeta\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n    }\n\n    // adds metadata\n    return Products.update({\n      _id: productId\n    }, {\n      $addToSet: {\n        metafields: updatedMeta\n      }\n    }, {\n      selector: {\n        type: \"simple\"\n      }\n    });\n  },\n\n  /**\n   * products/removeMetaFields\n   * @summary update product metafield\n   * @param {String} productId - productId\n   * @param {Object} metafields - metadata object to remove\n   * @param {Object} type - optional product type for schema selection\n   * @return {Number} collection update result\n   */\n  \"products/removeMetaFields\": function (productId, metafields, type = \"simple\") {\n    check(productId, String);\n    check(metafields, Object);\n    check(type, String);\n\n    // must have createProduct permission\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    return Products.update({\n      _id: productId,\n      type: type\n    }, {\n      $pull: {\n        metafields: metafields\n      }\n    });\n  },\n\n  /**\n   * products/publishProduct\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/publishProduct\": function (productId) {\n    check(productId, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const product = Products.findOne(productId);\n    const variants = Products.find({\n      ancestors: {\n        $in: [productId]\n      }\n    }).fetch();\n    let variantValidator = true;\n\n    if (typeof product === \"object\" && product.title.length > 1) {\n      if (variants.length > 0) {\n        variants.forEach(variant => {\n          // if this is a top variant with children, we avoid it to check price\n          // because we using price of its children\n          if (variant.ancestors.length === 1 &&\n            !Catalog.getVariants(variant._id, \"variant\").length ||\n            variant.ancestors.length !== 1) {\n            if (!(typeof variant.price === \"number\" && variant.price > 0)) {\n              variantValidator = false;\n            }\n          }\n          // if variant has no title\n          if (typeof variant.title === \"string\" && !variant.title.length) {\n            variantValidator = false;\n          }\n          if (typeof optionTitle === \"string\" && !optionTitle.length) {\n            variantValidator = false;\n          }\n        });\n      } else {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(403, \"Forbidden\", \"Variant is required\");\n      }\n\n      if (!variantValidator) {\n        Logger.debug(\"invalid product visibility \", productId);\n        throw new Meteor.Error(403, \"Forbidden\",\n          \"Some properties are missing.\");\n      }\n\n      // update product visibility\n      Logger.debug(\"toggle product visibility \", product._id, !product.isVisible);\n\n      const res = Products.update(product._id, {\n        $set: {\n          isVisible: !product.isVisible\n        }\n      }, {\n        selector: {\n          type: \"simple\"\n        }\n      });\n      // update product variants visibility\n      updateVariantProductField(variants, \"isVisible\", !product.isVisible);\n      // if collection updated we return new `isVisible` state\n      return res === 1 && !product.isVisible;\n    }\n    Logger.debug(\"invalid product visibility \", productId);\n    throw new Meteor.Error(400, \"Bad Request\");\n  },\n  /**\n   * products/publishProduct\n   * @summary publish (visibility) of product\n   * @todo hook into publishing flow\n   * @param {String} productId - productId\n   * @return {Boolean} product.isVisible\n   */\n  \"products/toggleVisibility\": function (productId) {\n    check(productId, String);\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n\n    const product = Products.findOne(productId);\n    const res = Products.update(productId, {\n      $set: {\n        isVisible: !product.isVisible\n      }\n    }, {\n      selector: {\n        type: product.type\n      }\n    });\n\n    if (Array.isArray(product.ancestors) && product.ancestors.length) {\n      const updateId = product.ancestors[0] || product._id;\n      const updatedPriceRange = ReactionProduct.getProductPriceRange(updateId);\n\n      Meteor.call(\"products/updateProductField\", updateId, \"price\", updatedPriceRange);\n    }\n\n    // if collection updated we return new `isVisible` state\n    return res === 1 && !product.isVisible;\n  }\n});\n","import getServiceConfig from \"nodemailer-wellknown\";\nimport { Meteor } from \"meteor/meteor\";\nimport { check, Match } from \"meteor/check\";\nimport { Jobs, Packages } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\n\nMeteor.methods({\n  /**\n   * Verify the current email configuration\n   * @param {Object} settings - optional settings object (otherwise uses settings in database)\n   * @return {Boolean} - returns true if SMTP connection succeeds\n   */\n  \"email/verifySettings\"(settings) {\n    if (!Reaction.hasPermission([\"owner\", \"admin\", \"dashboard\"], this.userId)) {\n      Logger.error(\"email/verifySettings: Access Denied\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    this.unblock();\n\n    check(settings, Match.Optional(Object));\n\n    let config;\n\n    // if a settings object has been provided, build a config\n    if (typeof settings === \"object\") {\n      const { service, host, port, user, password } = settings;\n\n      if (service === \"custom\" && host && port && user && password) {\n        // create a custom Nodemailer config\n        config = { host, port, auth: { user, pass: password } };\n      } else if (service && user && password) {\n        // create a Nodemailer config from the nodemailer-wellknown services\n        config = getServiceConfig(service) || {};\n        config.auth = { user, pass: password };\n      }\n    }\n\n    const { Email } = Reaction;\n\n    try {\n      return Meteor.wrapAsync(Email.verifyConfig)(config || Email.getMailConfig());\n    } catch (e) {\n      Logger.error(e);\n      throw new Meteor.Error(e.responseCode, e.response);\n    }\n  },\n\n\n  /**\n   * Save new email configuration\n   * @param {Object} settings - mail provider settings\n   * @return {Boolean} - returns true if update succeeds\n   */\n  \"email/saveSettings\"(settings) {\n    if (!Reaction.hasPermission([\"owner\", \"admin\", \"dashboard\"], this.userId)) {\n      Logger.error(\"email/saveSettings: Access Denied\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    check(settings, {\n      service: String,\n      host: Match.Optional(String),\n      port: Match.Optional(Number),\n      user: String,\n      password: String\n    });\n\n    Packages.update({ name: \"core\", shopId: Reaction.getShopId() }, {\n      $set: {\n        \"settings.mail\": settings\n      }\n    });\n\n    delete settings.password;\n\n    Logger.info(settings, \"Email settings updated\");\n\n    return true;\n  },\n\n\n  /**\n   * Retry a failed or cancelled email job\n   * @param {String} jobId - a sendEmail job ID\n   * @return {Boolean} - returns true if job is successfully restarted\n   */\n  \"emails/retryFailed\"(jobId) {\n    if (!Reaction.hasPermission([\"owner\", \"admin\", \"dashboard\"], this.userId)) {\n      Logger.error(\"email/retryFailed: Access Denied\");\n      throw new Meteor.Error(\"access-denied\", \"Access Denied\");\n    }\n\n    check(jobId, String);\n\n    Logger.debug(`emails/retryFailed - restarting email job \"${jobId}\"`);\n\n    Jobs.update({ _id: jobId }, {\n      $set: {\n        status: \"ready\"\n      }\n    });\n\n    return true;\n  }\n});\n","import { Translations } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport { loadCoreTranslations } from \"/server/startup/i18n\";\n\n/**\n * Reaction Shop Methods\n */\nMeteor.methods({\n  /**\n   * i18n/flushTranslations\n   * @summary Helper method to remove all translations, and reload from jsonFiles\n   * @return {undefined}\n   */\n  \"i18n/flushTranslations\": function () {\n    if (!Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const shopId = Reaction.getShopId();\n    Translations.remove({\n      shopId: shopId\n    });\n    loadCoreTranslations();\n    Reaction.Import.flush();\n  },\n  /**\n   * i18n/addTranslation\n   * @param {String | Array} lng - language\n   * @param {String} namespace - namespace\n   * @param {String} key - i18n key\n   * @param {String} message - i18n message\n   * @summary Helper method to add translations\n   * @return {String} insert result\n   */\n  \"i18n/addTranslation\": function (lng, namespace, key, message) {\n    check(lng, Match.OneOf(String, Array));\n    check(namespace, String);\n    check(key, String);\n    check(message, String);\n    // string or first langauge\n    let i18n = lng;\n    if (typeof lng === \"object\") {\n      i18n = lng[0];\n    }\n\n    if (!Reaction.hasAdminAccess()) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const tran = `\n      \"i18n\": \"${i18n}\",\n      \"shopId\": \"${Reaction.getShopId()}\"\n    `;\n\n    const setTran = `\"translation.${namespace}.${key}\": \"${message}\"`;\n    Translations.update({ tran }, { setTran });\n  }\n});\n","import \"./media\";\n","import { Media } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * removeMedia\n * @summary remove media from mongodb collection\n * @type {ValidatedMethod}\n * @param {String} mediaId - media _id\n * @return {Error|Undefined} object with error or nothing\n */\nexport const removeMedia = new ValidatedMethod({\n  name: \"removeMedia\",\n  validate: new SimpleSchema({\n    mediaId: { type: String }\n  }).validator(),\n  run({ mediaId }) {\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    return Media.remove({ _id: mediaId });\n  }\n});\n\n/**\n * updateMediaPriorities\n * @summary sorting media by array indexes\n * @type {ValidatedMethod}\n * @param {Array} sortedMedias - array with images _ids\n * @return {Array} with results\n */\nexport const updateMediaPriorities = new ValidatedMethod({\n  name: \"updateMediaPriorities\",\n  validate: new SimpleSchema({\n    sortedMedias: { type: [new SimpleSchema({ mediaId: { type: String } })] }\n  }).validator(),\n  run({ sortedMedias }) {\n    if (!Reaction.hasPermission(\"createProduct\")) {\n      throw new Meteor.Error(403, \"Access Denied\");\n    }\n    const results = [];\n    sortedMedias.forEach((image, index) => {\n      results.push(Media.update(image.mediaId, {\n        $set: {\n          \"metadata.priority\": index\n        }\n      }));\n    });\n\n    return results;\n  }\n});\n","import { Reaction } from \"/server/api\";\n\n/**\n * Publish ServiceConfiguration\n * @param {String} checkUserId - we not using it directly because if shows not\n * correct userId. Instead of it we are believe only to `this.userId`\n */\nMeteor.publish(\"ServiceConfiguration\", function (checkUserId) {\n  check(checkUserId, Match.OneOf(String, null));\n  if (this.userId === null) {\n    return this.ready();\n  }\n  // Admins and account managers can manage the login methods for the shop\n  if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"dashboard/accounts\"],\n      Reaction.getShopId())) {\n    return ServiceConfiguration.configurations.find({}, {\n      fields: {\n        secret: 1\n      }\n    });\n  }\n\n  return ServiceConfiguration.configurations.find({});\n});\n","import _ from \"lodash\";\nimport * as Collections from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * accounts\n */\n\nMeteor.publish(\"Accounts\", function (userId) {\n  check(userId, Match.OneOf(String, null));\n  // we could additionally make checks of useId defined, but this could lead to\n  // situation when user will may not have time to get an account\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  const nonAnonUsers = _.map(Meteor.users.find({\n    [`roles.${shopId}`]: {\n      $nin: [ \"anonymous\" ]\n    }\n  }, {\n    fields: { _id: 1 }\n  }).fetch(), \"_id\");\n\n  // global admin can get all accounts\n  if (Roles.userIsInRole(this.userId, [\"owner\"], Roles.GLOBAL_GROUP)) {\n    return Collections.Accounts.find({\n      _id: { $in: nonAnonUsers }\n    });\n  // shop admin gets accounts for just this shop\n  } else if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    return Collections.Accounts.find({\n      _id: { $in: nonAnonUsers },\n      shopId: shopId\n    });\n  }\n  // regular users should get just their account\n  return Collections.Accounts.find({\n    userId: this.userId\n  });\n});\n\n/**\n * Single account\n * @params {String} userId -  id of user to find\n */\nMeteor.publish(\"UserAccount\", function (userId) {\n  check(userId, Match.OneOf(String, null));\n\n  const shopId = Reaction.getShopId();\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    return Collections.Accounts.find({\n      userId: userId\n    });\n  }\n  return this.ready();\n});\n\n/**\n * userProfile\n * @deprecated since version 0.10.2\n * get any user name,social profile image\n * should be limited, secure information\n * users with permissions  [\"dashboard/orders\", \"owner\", \"admin\", \"dashboard/\n * customers\"] may view the profileUserId\"s profile data.\n *\n * @params {String} profileUserId -  view this users profile when permitted\n */\nMeteor.publish(\"UserProfile\", function (profileUserId) {\n  check(profileUserId, Match.OneOf(String, null));\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  const permissions = [\"dashboard/orders\", \"owner\", \"admin\",\n    \"dashboard/customers\"];\n  // no need to normal user so see his password hash\n  const fields = {\n    \"emails\": 1,\n    \"profile.lang\": 1,\n    \"profile.firstName\": 1,\n    \"profile.lastName\": 1,\n    \"profile.familyName\": 1,\n    \"profile.secondName\": 1,\n    \"profile.name\": 1,\n    \"services.twitter.profile_image_url_https\": 1,\n    \"services.facebook.id\": 1,\n    \"services.google.picture\": 1,\n    \"services.github.username\": 1,\n    \"services.instagram.profile_picture\": 1\n  };\n  // TODO: this part currently not working as expected.\n  // we could have three situation here:\n  // 1 - registered user log in.\n  // 2 - admin log in\n  // 3 - admin want to get user data\n  // I'm not sure about the 3rd case, but we do not cover 2nd case here, because\n  // we can see a situation when anonymous user still represented by\n  // `profileUserId`, but admin user already could be found by `this.userId`\n  // In that case what we should do here?\n  if (profileUserId !== this.userId && Roles.userIsInRole(this.userId,\n    permissions, shopId ||\n    Roles.userIsInRole(this.userId, permissions, Roles.GLOBAL_GROUP))) {\n    return Meteor.users.find({\n      _id: profileUserId\n    }, {\n      fields: fields\n    });\n  }\n\n  return Meteor.users.find({\n    _id: this.userId\n  }, {\n    fields: fields\n  });\n});\n","import { Cart, Media } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * cart\n */\n\nMeteor.publish(\"Cart\", function (sessionId, userId) {\n  check(sessionId, Match.OneOf(String, null));\n  check(userId, Match.OptionalOrNull(String));\n  // sessionId is required, not for selecting the cart, (userId), but as a key\n  // in merging anonymous user carts into authenticated existing user carts.\n  // we won't create carts unless we've got sessionId\n  if (this.userId === null || sessionId === null) {\n    return this.ready();\n  }\n  // use case happens between switching from anonymous to registered user. and\n  // vice versa\n  if (typeof userId === \"string\" && this.userId !== userId) {\n    return this.ready();\n  }\n  // we have a very rare case when cart has not been created for an anonymous\n  // and because of that, for some reason, he is considered as not logged in.\n  // in that case he doesn't have `userId`. Only way for him to get userId is\n  // to flush browser's session or log in as normal user. We could detect this\n  // case from here by comparing this.userId is string and this.userId !==\n  // Meteor.userId(). If this case will happens someday, we could try to send\n  // some logout call to accounts. This is it: https://github.com/meteor/meteor/\n  // issues/5103\n\n  // shopId is also required.\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  // exclude these fields\n  // from the client cart\n  const fields = {\n    taxes: 0\n  };\n\n  // select user cart\n  const cart = Cart.find({\n    userId: this.userId,\n    shopId: shopId\n  }, {\n    fields: fields\n  });\n\n  if (cart.count()) {\n    // we could keep `sessionId` of normal user up to date from here, but with\n    // current session logic we don't need this. That's why we just return\n    // cursor as is with whatever `sessionId`.\n    return cart;\n  }\n  // we may create a cart if we didn't find one.\n  const cartId = Meteor.call(\"cart/createCart\", this.userId, sessionId);\n\n  return Cart.find(cartId);\n});\n\nMeteor.publish(\"CartItemImage\", function (cartItem) {\n  check(cartItem, Match.Optional(Object));\n  const productId = cartItem.productId;\n\n  return Media.find({\n    \"metadata.productId\": productId,\n    \"metadata.workflow\": { $nin: [\"archived\", \"unpublished\"] }\n  });\n});\n","import { Media, Revisions } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport { RevisionApi } from \"/imports/plugins/core/revisions/lib/api/revisions\";\n\n\n/**\n * CollectionFS - Image/Video Publication\n * @params {Array} shops - array of current shop object\n */\nMeteor.publish(\"Media\", function (shops) {\n  check(shops, Match.Optional(Array));\n  let selector;\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  if (shopId) {\n    selector = {\n      \"metadata.shopId\": shopId\n    };\n  }\n  if (shops) {\n    selector = {\n      \"metadata.shopId\": {\n        $in: shops\n      }\n    };\n  }\n\n  // Product editors can see both published and unpublished images\n  if (!Reaction.hasPermission([\"createProduct\"], this.userId)) {\n    selector[\"metadata.workflow\"] = {\n      $in: [null, \"published\"]\n    };\n  } else {\n    // but no one gets to see archived images\n    selector[\"metadata.workflow\"] = {\n      $nin: [\"archived\"]\n    };\n  }\n\n  if (RevisionApi.isRevisionControlEnabled()) {\n    const revisionHandle = Revisions.find({\n      \"documentType\": \"image\",\n      \"workflow.status\": { $nin: [ \"revision/published\"] }\n    }).observe({\n      added: (revision) => {\n        const media = Media.findOne(revision.documentId);\n        if (media) {\n          this.added(\"Media\", media._id, media);\n          this.added(\"Revisions\", revision._id, revision);\n        }\n      },\n      changed: (revision) => {\n        const media = Media.findOne(revision.documentId);\n        this.changed(\"Media\", media._id, media);\n        this.changed(\"Revisions\", revision._id, revision);\n      },\n      removed: (revision) => {\n        if (revision) {\n          const media = Media.findOne(revision.documentId);\n          if (media) {\n            this.removed(\"Media\", media._id, media);\n            this.removed(\"Revisions\", revision._id, revision);\n          }\n        }\n      }\n    });\n\n    this.onStop(() => {\n      revisionHandle.stop();\n    });\n  }\n\n  return Media.find({\n    \"metadata.type\": \"brandAsset\"\n  });\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { EJSON } from \"meteor/ejson\";\n\nimport { Roles } from \"meteor/alanning:roles\";\n\nimport { Logger, Reaction } from \"/server/api\";\n\n/* eslint quote-props: 0 */\n/**\n * ShopMembers\n * This publication is only exposed to owner/admin in\n * Accounts page, and should not be used anywhere else.\n *\n * @return {Array} users\n */\nMeteor.publish(\"ShopMembers\", function () {\n  // here we are comparing with the string to make it compatible with tests\n  if (typeof this.userId !== \"string\") {\n    return this.ready();\n  }\n  const readPermissions = [\"reaction-orders\", \"owner\", \"admin\", \"reaction-accounts\"];\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  if (Roles.userIsInRole(this.userId, readPermissions, shopId)) {\n    // seems like we can't use \"`\" inside db.call directly\n    // do not add comments or otherwise format this query\n    const selector = `{\"roles.${shopId}\": {\"$nin\": [\"anonymous\"]}}`;\n    const publish = {\n      fields: {\n        _id: 1,\n        emails: 1,\n        username: 1,\n        roles: 1,\n        \"profile.lang\": 1,\n        \"services.google.name\": 1,\n        \"services.google.email\": 1,\n        \"services.google.picture\": 1,\n        \"services.twitter.name\": 1,\n        \"services.twitter.email\": 1,\n        \"services.twitter.profile_image_url_https\": 1,\n        \"services.facebook.name\": 1,\n        \"services.facebook.email\": 1,\n        \"services.facebook.id\": 1,\n        \"services.weibo.name\": 1,\n        \"services.weibo.email\": 1,\n        \"services.weibo.picture\": 1,\n        \"services.github.name\": 1,\n        \"services.github.email\": 1,\n        \"services.github.username\": 1\n      }\n    };\n\n    return Meteor.users.find(EJSON.parse(selector), publish);\n  }\n\n  Logger.debug(\"ShopMembers access denied\");\n  return this.ready();\n});\n","import { Counts } from \"meteor/tmeasday:publish-counts\";\nimport { Orders } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nconst OrderHelper =  {\n  makeQuery(filter) {\n    const shopId = Reaction.getShopId();\n    let query = {};\n\n    switch (filter) {\n      // New orders\n      case \"new\":\n        query = {\n          \"shopId\": shopId,\n          \"workflow.status\": \"new\"\n        };\n        break;\n\n      // Orders that have yet to be captured & shipped\n      case \"processing\":\n        query = {\n          \"shopId\": shopId,\n          \"workflow.status\": \"coreOrderWorkflow/processing\"\n        };\n        break;\n\n      // Orders that have been shipped, based on if the items have been shipped\n      case \"shipped\":\n        query = {\n          \"shopId\": shopId,\n          \"items.workflow.status\": \"coreOrderItemWorkflow/shipped\"\n        };\n        break;\n\n      // Orders that are complete, including all items with complete status\n      case \"completed\":\n        query = {\n          \"shopId\": shopId,\n          \"workflow.status\": {\n            $in: [\"coreOrderWorkflow/completed\", \"coreOrderWorkflow/canceled\"]\n          },\n          \"items.workflow.status\": {\n            $in: [\"coreOrderItemWorkflow/completed\", \"coreOrderItemWorkflow/canceled\"]\n          }\n        };\n        break;\n\n      // Orders that have been captured, but not yet shipped\n      case \"captured\":\n        query = {\n          \"shopId\": shopId,\n          \"billing.paymentMethod.status\": \"completed\",\n          \"shipping.shipped\": false\n        };\n        break;\n\n      case \"canceled\":\n        query = {\n          \"shopId\": shopId,\n          \"workflow.status\": \"canceled\"\n        };\n        break;\n\n      // Orders that have been refunded partially or fully\n      case \"refunded\":\n        query = {\n          \"shopId\": shopId,\n          \"billing.paymentMethod.status\": \"captured\",\n          \"shipping.shipped\": true\n        };\n        break;\n      default:\n    }\n\n    return query;\n  }\n};\n\n/**\n * orders\n */\n\nMeteor.publish(\"Orders\", function () {\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    return Orders.find({\n      shopId: shopId\n    });\n  }\n  return Orders.find({\n    shopId: shopId,\n    userId: this.userId\n  });\n});\n\n/**\n * paginated orders\n */\n\nMeteor.publish(\"PaginatedOrders\", function (filter, limit) {\n  check(filter, Match.OptionalOrNull(String));\n  check(limit, Number);\n\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"], shopId)) {\n    Counts.publish(this, \"newOrder-count\", Orders.find(OrderHelper.makeQuery(\"new\")), { noReady: true });\n    Counts.publish(this, \"processingOrder-count\", Orders.find(OrderHelper.makeQuery(\"processing\")), { noReady: true });\n    Counts.publish(this, \"completedOrder-count\", Orders.find(OrderHelper.makeQuery(\"completed\")), { noReady: true });\n    return Orders.find(OrderHelper.makeQuery(filter), { limit: limit });\n  }\n  return Orders.find({\n    shopId: shopId,\n    userId: this.userId\n  });\n});\n\n/**\n * account orders\n */\nMeteor.publish(\"AccountOrders\", function (userId, currentShopId) {\n  check(userId, Match.OptionalOrNull(String));\n  check(currentShopId, Match.OptionalOrNull(String));\n  if (this.userId === null) {\n    return this.ready();\n  }\n  if (typeof userId === \"string\" && this.userId !== userId) {\n    return this.ready();\n  }\n  const shopId = currentShopId || Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  return Orders.find({\n    shopId: shopId,\n    userId: this.userId\n  });\n});\n\n/**\n * completed cart order\n */\nMeteor.publish(\"CompletedCartOrder\", function (userId, cartId) {\n  check(userId, Match.OneOf(String, null));\n  check(cartId, String);\n  if (this.userId === null) {\n    return this.ready();\n  }\n  if (typeof userId === \"string\" && userId !== this.userId) {\n    return this.ready();\n  }\n\n  return Orders.find({\n    cartId: cartId,\n    userId: userId\n  });\n});\n","import { Packages } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport { translateRegistry } from \"/lib/api\";\nimport { Roles } from \"meteor/alanning:roles\";\n\n/**\n * Packages contains user specific configuration\n * @summary  package publication settings, filtered by permissions\n * @param {Object} shopCursor - current shop object\n * @returns {Object} packagesCursor - current packages for shop\n */\n\n// for transforming packages before publication sets some defaults for the client and adds i18n while checking\n// privileged settings for enabled status.\nfunction transform(doc, userId) {\n  const registrySettings = {};\n  const packageSettings = {};\n  let permissions = [\"admin\", \"owner\", doc.name];\n\n  // Get all permissions, add them to an array\n  if (doc.registry && doc.registry.permissions) {\n    for (const item of doc.registry.permissions) {\n      permissions.push(item.permission);\n    }\n  }\n  permissions = _.uniq(permissions);\n\n  // check for admin,owner or package permissions to view settings\n  const hasAdmin = Roles.userIsInRole(userId, permissions, doc.shopId);\n\n  if (doc.registry) {\n    for (let registry of doc.registry) {\n      // add some normalized defaults\n      registry.packageId = doc._id;\n      registry.shopId = doc.shopId;\n      registry.packageName = registry.packageName || doc.name;\n      registry.settingsKey = (registry.name || doc.name).split(\"/\").splice(-1)[0];\n      // check and set package enabled state\n      registry.permissions = [...permissions];\n      if (registry.route) {\n        registry.permissions.push(registry.name || doc.name + \"/\" + registry.template);\n      }\n      if (doc.settings && doc.settings[registry.settingsKey]) {\n        registry.enabled = !!doc.settings[registry.settingsKey].enabled;\n      } else {\n        registry.enabled = !!doc.enabled;\n      }\n      // define export settings\n      registrySettings[registry.settingsKey] = {\n        enabled: registry.enabled\n      };\n\n      // add i18n keys\n      registry = translateRegistry(registry, doc);\n    }\n  }\n  // admin users get all settings the intent of this it so block publication of settings without limiting the use settings\n  // in this transform. non admin users should get public setting\n  if (hasAdmin === false && doc.settings) {\n    registrySettings.public = doc.settings.public;\n    delete doc.settings;\n    Object.assign(packageSettings, registrySettings);\n    doc.settings = packageSettings;\n  }\n\n  return doc;\n}\n\n//\n//  Packages Publication\n//\nMeteor.publish(\"Packages\", function (shopCursor) {\n  check(shopCursor, Match.Optional(Object));\n  const self = this;\n  const shop = shopCursor || Reaction.getCurrentShop();\n\n  // user is required.\n  if (self.userId) {\n    // default options, we're limiting fields here that we don't want to publish unless admin user. in particular, settings\n    // should not be published but we need to use settings in the transform everything except settings.public and\n    // settings.*.enabled are removed in transform\n    let options = {\n      fields: {\n        shopId: 1,\n        name: 1,\n        enabled: 1,\n        registry: 1,\n        layout: 1,\n        icon: 1,\n        settings: 1,\n        audience: 1\n      }\n    };\n\n    // we should always have a shop\n    if (shop) {\n      // if admin user, return all shop properties\n      if (Roles.userIsInRole(self.userId, [\n        \"dashboard\", \"owner\", \"admin\"\n      ], Reaction.getShopId() || Roles.userIsInRole(self.userId, [\n        \"owner\", \"admin\"\n      ], Roles.GLOBAL_GROUP))) {\n        options = {};\n      }\n      // observe and transform Package registry adds i18n and other meta data\n      const observer = Packages.find({\n        shopId: shop._id\n      }, options).observe({\n        added: function (doc) {\n          self.added(\"Packages\", doc._id, transform(doc, self.userId));\n        },\n        changed: function (newDoc, origDoc) {\n          self.changed(\"Packages\", origDoc._id, transform(newDoc, self.userId));\n        },\n        removed: function (origDoc) {\n          self.removed(\"Packages\", origDoc._id);\n        }\n      });\n\n      self.onStop(function () {\n        observer.stop();\n      });\n    }\n    return self.ready();\n  }\n});\n","import { Media, Products, Revisions } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\nimport { RevisionApi } from \"/imports/plugins/core/revisions/lib/api/revisions\";\n\nexport function findProductMedia(publicationInstance, productIds) {\n  const shopId = Reaction.getShopId();\n  const selector = {};\n\n  if (!shopId) {\n    return publicationInstance.ready();\n  }\n\n  if (Array.isArray(productIds)) {\n    selector[\"metadata.productId\"] = {\n      $in: productIds\n    };\n  } else {\n    selector[\"metadata.productId\"] = productIds;\n  }\n\n  if (shopId) {\n    selector[\"metadata.shopId\"] = shopId;\n  }\n\n  // No one needs to see archived images on products\n  selector[\"metadata.workflow\"] = {\n    $nin: [\"archived\"]\n  };\n\n  // Product editors can see both published and unpublished images\n  if (!Reaction.hasPermission([\"createProduct\"], publicationInstance.userId)) {\n    selector[\"metadata.workflow\"].$in = [null, \"published\"];\n  }\n\n  return Media.find(selector, {\n    sort: {\n      \"metadata.priority\": 1\n    }\n  });\n}\n\n\n/**\n * product detail publication\n * @param {String} productId - productId or handle\n * @return {Object} return product cursor\n */\nMeteor.publish(\"Product\", function (productId) {\n  check(productId, Match.OptionalOrNull(String));\n  if (!productId) {\n    Logger.debug(\"ignoring null request on Product subscription\");\n    return this.ready();\n  }\n  let _id;\n  const shop = Reaction.getCurrentShop();\n  // verify that shop is ready\n  if (typeof shop !== \"object\") {\n    return this.ready();\n  }\n\n  let selector = {};\n  selector.isVisible = true;\n  selector.isDeleted = { $in: [null, false] };\n\n  if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"],\n      shop._id)) {\n    selector.isVisible = {\n      $in: [true, false]\n    };\n  }\n  // TODO review for REGEX / DOS vulnerabilities.\n  if (productId.match(/^[23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz]{17}$/)) {\n    selector._id = productId;\n    // TODO try/catch here because we can have product handle passed by such regex\n    _id = productId;\n  } else {\n    selector.handle = {\n      $regex: productId,\n      $options: \"i\"\n    };\n    const products = Products.find(selector).fetch();\n    if (products.length > 0) {\n      _id = products[0]._id;\n    } else {\n      return this.ready();\n    }\n  }\n\n  // Selector for hih?\n  selector = {\n    isVisible: true,\n    isDeleted: { $in: [null, false] },\n    $or: [\n      { handle: _id },\n      { _id: _id },\n      {\n        ancestors: {\n          $in: [_id]\n        }\n      }\n    ]\n  };\n\n  // Authorized content curators fo the shop get special publication of the product\n  // all all relevant revisions all is one package\n  if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"], shop._id)) {\n    selector.isVisible = {\n      $in: [true, false, undefined]\n    };\n\n    if (RevisionApi.isRevisionControlEnabled()) {\n      const productCursor = Products.find(selector);\n      const productIds = productCursor.map(p => p._id);\n\n      const handle = productCursor.observeChanges({\n        added: (id, fields) => {\n          const revisions = Revisions.find({\n            \"documentId\": id,\n            \"workflow.status\": {\n              $nin: [\n                \"revision/published\"\n              ]\n            }\n          }).fetch();\n          fields.__revisions = revisions;\n\n          this.added(\"Products\", id, fields);\n        },\n        changed: (id, fields) => {\n          const revisions = Revisions.find({\n            \"documentId\": id,\n            \"workflow.status\": {\n              $nin: [\n                \"revision/published\"\n              ]\n            }\n          }).fetch();\n\n          fields.__revisions = revisions;\n          this.changed(\"Products\", id, fields);\n        },\n        removed: (id) => {\n          this.removed(\"Products\", id);\n        }\n      });\n\n      const handle2 = Revisions.find({\n        \"workflow.status\": {\n          $nin: [\n            \"revision/published\"\n          ]\n        }\n      }).observe({\n        added: (revision) => {\n          let product;\n          if (!revision.parentDocument) {\n            product = Products.findOne(revision.documentId);\n          } else {\n            product = Products.findOne(revision.parentDocument);\n          }\n          if (product) {\n            this.added(\"Products\", product._id, product);\n            this.added(\"Revisions\", revision._id, revision);\n          }\n        },\n        changed: (revision) => {\n          let product;\n          if (!revision.parentDocument) {\n            product = Products.findOne(revision.documentId);\n          } else {\n            product = Products.findOne(revision.parentDocument);\n          }\n\n          if (product) {\n            product.__revisions = [revision];\n            this.changed(\"Products\", product._id, product);\n            this.changed(\"Revisions\", revision._id, revision);\n          }\n        },\n        removed: (revision) => {\n          let product;\n          if (!revision.parentDocument) {\n            product = Products.findOne(revision.documentId);\n          } else {\n            product = Products.findOne(revision.parentDocument);\n          }\n          if (product) {\n            product.__revisions = [];\n            this.changed(\"Products\", product._id, product);\n            this.removed(\"Revisions\", revision._id, revision);\n          }\n        }\n      });\n\n      this.onStop(() => {\n        handle.stop();\n        handle2.stop();\n      });\n\n      return [\n        findProductMedia(this, productIds)\n      ];\n    }\n\n    // Revision control is disabled, but is an admin\n    const productCursor = Products.find(selector);\n    const productIds = productCursor.map(p => p._id);\n    const mediaCursor = findProductMedia(this, productIds);\n\n    return [\n      productCursor,\n      mediaCursor\n    ];\n  }\n\n  // Everyone else gets the standard, visibile products and variants\n  const productCursor = Products.find(selector);\n  const productIds = productCursor.map(p => p._id);\n  const mediaCursor = findProductMedia(this, productIds);\n\n  return [\n    productCursor,\n    mediaCursor\n  ];\n});\n","import { Products, Revisions } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\nimport { RevisionApi } from \"/imports/plugins/core/revisions/lib/api/revisions\";\nimport { findProductMedia } from \"./product\";\n\n//\n// define search filters as a schema so we can validate\n// params supplied to the products publication\n//\nconst filters = new SimpleSchema({\n  \"shops\": {\n    type: [String],\n    optional: true\n  },\n  \"tags\": {\n    type: [String],\n    optional: true\n  },\n  \"query\": {\n    type: String,\n    optional: true\n  },\n  \"visibility\": {\n    type: Boolean,\n    optional: true\n  },\n  \"details\": {\n    type: Object,\n    optional: true\n  },\n  \"details.key\": {\n    type: String,\n    optional: true\n  },\n  \"details.value\": {\n    type: String,\n    optional: true\n  },\n  \"price\": {\n    type: Object,\n    optional: true\n  },\n  \"price.min\": {\n    type: String,\n    optional: true\n  },\n  \"price.max\": {\n    type: String,\n    optional: true\n  },\n  \"weight\": {\n    type: Object,\n    optional: true\n  },\n  \"weight.min\": {\n    type: String,\n    optional: true\n  },\n  \"weight.max\": {\n    type: String,\n    optional: true\n  }\n});\n\n/**\n * products publication\n * @param {Number} productScrollLimit - optional, defaults to 24\n * @param {Array} shops - array of shopId to retrieve product from.\n * @return {Object} return product cursor\n */\nMeteor.publish(\"Products\", function (productScrollLimit = 24, productFilters, sort = {}) {\n  check(productScrollLimit, Number);\n  check(productFilters, Match.OneOf(undefined, Object));\n  check(sort, Match.OneOf(undefined, Object));\n\n  // if there are filter/params that don't match the schema\n  // validate, catch except but return no results\n  try {\n    check(productFilters, Match.OneOf(undefined, filters));\n  } catch (e) {\n    Logger.debug(e, \"Invalid Product Filters\");\n    return this.ready();\n  }\n  // ensure that we've got a shop instance\n  const shop = Reaction.getCurrentShop();\n  if (typeof shop !== \"object\") {\n    return this.ready();\n  }\n\n  if (shop) {\n    const selector = {};\n    if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"], shop._id)) {\n      _.extend(selector, {\n        isDeleted: { $in: [null, false] },\n        ancestors: { $exists: true },\n        shopId: shop._id\n      });\n    } else { // Changing the selector for non admin users only. To get top-level products.\n      _.extend(selector, {\n        isDeleted: { $in: [null, false] },\n        ancestors: [],\n        shopId: shop._id\n      });\n    }\n\n    if (productFilters) {\n      // handle multiple shops\n      if (productFilters.shops) {\n        _.extend(selector, {\n          shopId: {\n            $in: productFilters.shops\n          }\n        });\n\n        // check if this user is a shopAdmin\n        for (const thisShopId of productFilters.shops) {\n          if (Roles.userIsInRole(this.userId, [\"admin\", \"createProduct\"], thisShopId)) {\n            shopAdmin = true;\n          }\n        }\n      }\n\n      // filter by tags\n      if (productFilters.tags) {\n        _.extend(selector, {\n          hashtags: {\n            $in: productFilters.tags\n          }\n        });\n      }\n\n      // filter by query\n      if (productFilters.query) {\n        const cond = {\n          $regex: productFilters.query,\n          $options: \"i\"\n        };\n        _.extend(selector, {\n          $or: [{\n            title: cond\n          }, {\n            pageTitle: cond\n          }, {\n            description: cond\n          }]\n        });\n      }\n\n      // filter by details\n      if (productFilters.details) {\n        _.extend(selector, {\n          metafields: {\n            $elemMatch: {\n              key: {\n                $regex: productFilters.details.key,\n                $options: \"i\"\n              },\n              value: {\n                $regex: productFilters.details.value,\n                $options: \"i\"\n              }\n            }\n          }\n        });\n      }\n\n      // filter by visibility\n      if (productFilters.visibility !== undefined) {\n        _.extend(selector, {\n          isVisible: productFilters.visibility\n        });\n      }\n\n      // filter by gte minimum price\n      if (productFilters[\"price.min\"] && !productFilters[\"price.max\"]) {\n        _.extend(selector, {\n          \"price.min\": {\n            $gte: parseFloat(productFilters[\"price.min\"])\n          }\n        });\n      }\n\n      // filter by lte maximum price\n      if (productFilters[\"price.max\"] && !productFilters[\"price.min\"]) {\n        _.extend(selector, {\n          \"price.max\": {\n            $lte: parseFloat(productFilters[\"price.max\"])\n          }\n        });\n      }\n\n      // filter with a price range\n      if (productFilters[\"price.min\"] && productFilters[\"price.max\"]) {\n        const pmin = parseFloat(productFilters[\"price.min\"]);\n        const pmax = parseFloat(productFilters[\"price.max\"]);\n        // where product A has min 12.99 variant and a 19.99 variant\n        // price.min=12.99&price.max=19.98\n        // should return product A\n        _.extend(selector, {\n          \"price.min\": {\n            $lt: pmax\n          },\n          \"price.max\": {\n            $gt: pmin\n          }\n        });\n      }\n\n      // filter by gte minimum weight\n      if (productFilters[\"weight.min\"] && !productFilters[\"weight.max\"]) {\n        _.extend(selector, {\n          weight: {\n            $gte: parseFloat(productFilters[\"weight.min\"])\n          }\n        });\n      }\n\n      // filter by lte maximum weight\n      if (productFilters[\"weight.max\"] && !productFilters[\"weight.min\"]) {\n        _.extend(selector, {\n          weight: {\n            $lte: parseFloat(productFilters[\"weight.max\"])\n          }\n        });\n      }\n\n      // filter with a weight range\n      if (productFilters[\"weight.min\"] && productFilters[\"weight.max\"]) {\n        const wmin = parseFloat(productFilters[\"weight.min\"]);\n        const wmax = parseFloat(productFilters[\"weight.max\"]);\n        _.extend(selector, {\n          weight: {\n            $lt: wmax,\n            $gt: wmin\n          }\n        });\n      }\n    } // end if productFilters\n\n    // Authorized content curators fo the shop get special publication of the product\n    // with all relevant revisions all is one package\n\n    if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"createProduct\"], shop._id)) {\n      selector.isVisible = {\n        $in: [true, false, undefined]\n      };\n\n      // Get _ids of top-level products\n      const productIds = Products.find(selector, {\n        sort: sort,\n        limit: productScrollLimit\n      }).map(product => product._id);\n\n      let newSelector = selector;\n\n      // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n      if (productFilters && productFilters.tags) {\n        newSelector = _.omit(selector, [\"hashtags\"]);\n\n        // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n        _.extend(newSelector, {\n          $or: [\n            {\n              ancestors: {\n                $in: productIds\n              }\n            }, {\n              hashtags: {\n                $in: productFilters.tags\n              }\n            }\n          ]\n        });\n      }\n\n      if (RevisionApi.isRevisionControlEnabled()) {\n        const productCursor = Products.find(newSelector);\n        const handle = productCursor.observeChanges({\n          added: (id, fields) => {\n            const revisions = Revisions.find({\n              \"$or\": [\n                { documentId: id },\n                { parentDocument: id }\n              ],\n              \"workflow.status\": {\n                $nin: [\n                  \"revision/published\"\n                ]\n              }\n            }).fetch();\n            fields.__revisions = revisions;\n\n            this.added(\"Products\", id, fields);\n          },\n          changed: (id, fields) => {\n            const revisions = Revisions.find({\n              \"$or\": [\n                { documentId: id },\n                { parentDocument: id }\n              ],\n              \"workflow.status\": {\n                $nin: [\n                  \"revision/published\"\n                ]\n              }\n            }).fetch();\n\n            fields.__revisions = revisions;\n            this.changed(\"Products\", id, fields);\n          },\n          removed: (id) => {\n            this.removed(\"Products\", id);\n          }\n        });\n\n        const handle2 = Revisions.find({\n          \"workflow.status\": {\n            $nin: [\n              \"revision/published\"\n            ]\n          }\n        }).observe({\n          added: (revision) => {\n            let product;\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.documentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n\n            if (product) {\n              this.added(\"Products\", product._id, product);\n              this.added(\"Revisions\", revision._id, revision);\n            }\n          },\n          changed: (revision) => {\n            let product;\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.documentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n            if (product) {\n              product.__revisions = [revision];\n              this.changed(\"Products\", product._id, product);\n              this.changed(\"Revisions\", revision._id, revision);\n            }\n          },\n          removed: (revision) => {\n            let product;\n\n            if (!revision.documentType || revision.documentType === \"product\") {\n              product = Products.findOne(revision.documentId);\n            } else if (revision.docuentType === \"image\" || revision.documentType === \"tag\") {\n              product = Products.findOne(revision.parentDocument);\n            }\n            if (product) {\n              product.__revisions = [];\n              this.changed(\"Products\", product._id, product);\n              this.removed(\"Revisions\", revision._id, revision);\n            }\n          }\n        });\n\n\n        this.onStop(() => {\n          handle.stop();\n          handle2.stop();\n        });\n\n        const mediaProductIds = productCursor.fetch().map((p) => p._id);\n        const mediaCursor = findProductMedia(this, mediaProductIds);\n\n        return [\n          mediaCursor\n        ];\n      }\n      // Revision control is disabled, but is admin\n      const productCursor = Products.find(newSelector, {\n        sort: sort,\n        limit: productScrollLimit\n      });\n      const mediaProductIds = productCursor.fetch().map((p) => p._id);\n      const mediaCursor = findProductMedia(this, mediaProductIds);\n\n      return [\n        productCursor,\n        mediaCursor\n      ];\n    }\n\n    // Everyone else gets the standard, visible products\n    selector.isVisible = true;\n\n    // Get _ids of top-level products\n    const productIds = Products.find(selector, {\n      sort: sort,\n      limit: productScrollLimit\n    }).map(product => product._id);\n\n    let newSelector = selector;\n\n    // Remove hashtag filter from selector (hashtags are not applied to variants, we need to get variants)\n    if (productFilters && productFilters.tags) {\n      newSelector = _.omit(selector, [\"hashtags\"]);\n\n      // Re-configure selector to pick either Variants of one of the top-level products, or the top-level products in the filter\n      _.extend(newSelector, {\n        $or: [\n          {\n            ancestors: {\n              $in: productIds\n            }\n          }, {\n            hashtags: {\n              $in: productFilters.tags\n            }\n          }\n        ]\n      });\n    }\n    // Returning Complete product tree for top level products to avoid sold out warning.\n    const productCursor = Products.find({\n      $or: [\n        { _id: { $in: productIds } },\n        { ancestors: { $in: productIds } }\n      ]\n    });\n\n    const mediaProductIds = productCursor.fetch().map((p) => p._id);\n    const mediaCursor = findProductMedia(this, mediaProductIds);\n\n    return [\n      productCursor,\n      mediaCursor\n    ];\n  }\n});\n","import { Revisions } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport { check, Match } from \"meteor/check\";\n\n/**\n * accounts\n */\n\nMeteor.publish(\"Revisions\", function (documentIds) {\n  check(documentIds, Match.OneOf(String, Array));\n\n  // we could additionally make checks of useId defined, but this could lead to\n  // situation when user will may not have time to get an account\n  if (this.userId === null) {\n    return this.ready();\n  }\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n\n  if (Roles.userIsInRole(this.userId, [\"admin\", \"owner\"])) {\n    if (Array.isArray(documentIds)) {\n      return Revisions.find({\n        // shopId,\n        documentId: {\n          $in: documentIds\n        }\n      });\n    }\n\n    // global admin can get all accounts\n    return Revisions.find({\n      // shopId,\n      documentId: documentIds\n    });\n  }\n  // regular users should get just their account\n  return this.ready();\n});\n","import { Mongo } from \"meteor/mongo\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * Reaction Server / amplify permanent sessions\n * If no id is passed we create a new session\n * Load the session\n * If no session is loaded, creates a new one\n */\n\nexport const ServerSessions = new Mongo.Collection(\"Sessions\");\nthis.ServerSessions = ServerSessions;\n\nMeteor.publish(\"Sessions\", function (sessionId) {\n  check(sessionId, Match.OneOf(String, null));\n  const created = new Date().getTime();\n  let newSessionId;\n  // if we don\"t have a sessionId create a new session\n  // REALLY - we should always have a client sessionId\n  if (!sessionId) {\n    newSessionId = ServerSessions.insert({\n      created: created\n    });\n  } else {\n    newSessionId = sessionId;\n  }\n  // get the session from existing sessionId\n  const serverSession = ServerSessions.find(newSessionId);\n\n  // if not found, also create a new server session\n  if (serverSession.count() === 0) {\n    ServerSessions.insert({\n      _id: newSessionId,\n      created: created\n    });\n  }\n\n  // set global sessionId\n  Reaction.sessionId = newSessionId;\n\n  // return cursor\n  return ServerSessions.find(newSessionId);\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Match, check } from \"meteor/check\";\nimport { Counts } from \"meteor/tmeasday:publish-counts\";\nimport { Shipping } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n/**\n * shipping\n */\n\nMeteor.publish(\"Shipping\", function (query, options) {\n  check(query, Match.Optional(Object));\n  check(options, Match.Optional(Object));\n\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  const select = query || {};\n  select.shopId = shopId;\n\n  // appends a count to the collection\n  // we're doing this for use with griddleTable\n  Counts.publish(this, \"shipping-count\", Shipping.find(\n    select,\n    options\n  ));\n\n  return Shipping.find(\n    select,\n    options\n  );\n});\n","import { Reaction } from \"/server/api\";\n\n/**\n * shops\n * @returns {Object} shop - current shop cursor\n */\n\nMeteor.publish(\"Shops\", function () {\n  return Reaction.getCurrentShopCursor();\n});\n","import { Tags } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * tags\n */\nMeteor.publish(\"Tags\", function () {\n  const shopId = Reaction.getShopId();\n  if (!shopId) {\n    return this.ready();\n  }\n  return Tags.find({\n    shopId: shopId\n  });\n});\n","import { Themes } from \"/lib/collections\";\n\n/**\n * Themes\n * @returns {Object} thtmes - themes cursor\n */\n\nMeteor.publish(\"Themes\", function () {\n  return Themes.find({});\n});\n","import { Shops, Translations } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\n/**\n * Translations publication\n * @param {String, Array} sessionLanguages - current sessionLanguage default to 'en'\n * @returns { Object } returns Translations\n * @todo like to see the langages validated more with a schema\n */\nMeteor.publish(\"Translations\", function (languages) {\n  check(languages, Match.OneOf(String, Array));\n  const shopId = Reaction.getShopId();\n  const shopLanguage = Shops.findOne(shopId).language;\n  const sessionLanguages = [];\n  const langTranQuery = [];\n\n  // set shop default\n  sessionLanguages.push(shopLanguage);\n  // lets get all these langauges\n  if (typeof languages === \"array\") {\n    sessionLanguages.concat(languages);\n  } else {\n    sessionLanguages.push(languages);\n  }\n  // add in the shop filter\n  for (const sessionLanguage of sessionLanguages) {\n    langTranQuery.push({\n      i18n: sessionLanguage,\n      shopId: shopId\n    });\n  }\n\n  return Translations.find({\n    $or: langTranQuery\n  });\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Counts } from \"meteor/tmeasday:publish-counts\";\nimport { Shops } from \"/lib/collections\";\n\nMeteor.publish(\"shopsCount\", function () {\n  Counts.publish(this, \"shops-count\", Shops.find());\n});\n","import { Meteor } from \"meteor/meteor\";\nimport { Jobs } from \"/lib/collections\";\nimport { Roles } from \"meteor/alanning:roles\";\n\n/**\n * Email Job Logs\n * @type {Object} options - standard publication options object\n */\nMeteor.publish(\"Emails\", function (query, options) {\n  check(query, Match.Optional(Object));\n  check(options, Match.Optional(Object));\n\n  if (Roles.userIsInRole(this.userId, [\"owner\", \"admin\", \"dashboard\"])) {\n    Counts.publish(this, \"emails-count\", Jobs.find({ type: \"sendEmail\" }));\n    return Jobs.find({ type: \"sendEmail\" });\n  }\n\n  return this.ready();\n});\n","import { Reaction } from \"/server/api\";\n\n/*\n * register reaction core components as reaction packages\n */\nexport default function () {\n  Reaction.registerPackage({\n    label: \"Core\",\n    name: \"core\",\n    icon: \"fa fa-th\",\n    autoEnable: true,\n    settings: {\n      public: {\n        allowGuestCheckout: true\n      },\n      mail: {\n        user: \"\",\n        password: \"\",\n        host: \"\",\n        port: \"\"\n      },\n      openexchangerates: {\n        appId: \"\",\n        refreshPeriod: \"every 1 hour\"\n      },\n      paymentMethod: {\n        defaultPaymentMethod: \"\"\n      }\n    },\n    layout: [{\n      layout: \"coreLayout\",\n      workflow: \"coreWorkflow\",\n      theme: \"default\",\n      enabled: true,\n      structure: {\n        template: \"products\",\n        layoutHeader: \"layoutHeader\",\n        layoutFooter: \"layoutFooter\",\n        notFound: \"productNotFound\",\n        dashboardControls: \"dashboardControls\",\n        adminControlsFooter: \"adminControlsFooter\"\n      }\n    }, {\n      layout: \"coreLayout\",\n      workflow: \"coreWorkflow\",\n      theme: \"default\",\n      enabled: true,\n      structure: {\n        template: \"unauthorized\",\n        layoutHeader: \"layoutHeader\",\n        layoutFooter: \"layoutFooter\"\n      }\n    }]\n  });\n}\n","import Core from \"./core\";\nimport Router from \"./router\";\n\nexport default function () {\n  Core();\n  Router();\n}\n","import { Reaction } from \"/server/api\";\n\nexport default function () {\n  Reaction.registerPackage({\n    label: \"Router\",\n    name: \"reaction-router\",\n    icon: \"fa fa-share-square-o\",\n    autoEnable: true,\n    settings: {\n      name: \"Layout\"\n    },\n    registry: [{\n      provides: \"dashboard\",\n      label: \"Routing\",\n      description: \"Routing utilities\",\n      icon: \"fa fa-share-square-o\",\n      priority: 1,\n      container: \"utilities\"\n    }]\n  });\n}\n","import { Meteor } from \"meteor/meteor\";\nimport * as Collections from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\nexport default function () {\n  /**\n   * Make sure initial admin user has verified their\n   * email before allowing them to login.\n   *\n   * http://docs.meteor.com/#/full/accounts_validateloginattempt\n   */\n\n  Accounts.validateLoginAttempt(function (attempt) {\n    if (!attempt.allowed) {\n      return false;\n    }\n\n    // confirm this is the accounts-password login method\n    if (attempt.type !== \"password\" || attempt.methodName !== \"login\") {\n      return attempt.allowed;\n    }\n\n    if (!attempt.user) {\n      return attempt.allowed;\n    }\n\n    const loginEmail = attempt.methodArguments[0].user.email;\n    const adminEmail = process.env.REACTION_EMAIL;\n\n    if (loginEmail && loginEmail === adminEmail) {\n      // filter out the matching login email from any existing emails\n      const userEmail = _.filter(attempt.user.emails, function (email) {\n        return email.address === loginEmail;\n      });\n\n      // check if the email is verified\n      if (!userEmail.length || !userEmail[0].verified) {\n        throw new Meteor.Error(\"403\", \"Oops! Please validate your email first.\");\n      }\n    }\n\n    return attempt.allowed;\n  });\n\n  /**\n   * Reaction Accounts handlers\n   * creates a login type \"anonymous\"\n   * default for all unauthenticated visitors\n   */\n  Accounts.registerLoginHandler(function (options) {\n    if (!options.anonymous) {\n      return {};\n    }\n    const stampedToken = Accounts._generateStampedLoginToken();\n    const userId = Accounts.insertUserDoc({\n      services: {\n        anonymous: true\n      },\n      token: stampedToken.token\n    });\n    const loginHandler = {\n      type: \"anonymous\",\n      userId: userId\n    };\n    return loginHandler;\n  });\n\n  /**\n   * Accounts.onCreateUser event\n   * adding either a guest or anonymous role to the user on create\n   * adds Accounts record for reaction user profiles\n   * we clone the user into accounts, as the user collection is\n   * only to be used for authentication.\n   * - defaultVisitorRole\n   * - defaultRoles\n   * can be overriden from Shops\n   *\n   * @see: http://docs.meteor.com/#/full/accounts_oncreateuser\n   */\n  Accounts.onCreateUser((options, user) => {\n    const shop = Reaction.getCurrentShop();\n    const shopId = shop._id;\n    const defaultVisitorRole =  [\"anonymous\", \"guest\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"];\n    const defaultRoles =  [\"guest\", \"account/profile\", \"product\", \"tag\", \"index\", \"cart/checkout\", \"cart/completed\"];\n    const roles = {};\n    const additionals = {\n      profile: Object.assign({}, options && options.profile)\n    };\n    if (!user.emails) user.emails = [];\n    // init default user roles\n    // we won't create users unless we have a shop.\n    if (shop) {\n      // retain language when user has defined a language\n      // perhaps should be treated as additionals\n      // or in onLogin below, or in the anonymous method options\n      if (!(Meteor.users.find().count() === 0)) { // dont set on inital admin\n        if (!user.profile) user.profile = {};\n        const currentUser = Meteor.user(user);\n        if (currentUser && currentUser.profile) {\n          if (currentUser.profile.lang && !user.profile.lang) {\n            user.profile.lang = currentUser.profile.lang;\n          }\n          if (currentUser.profile.currency && !user.profile.currency) {\n            user.profile.currency = currentUser.profile.currency;\n          }\n        }\n      }\n\n      // if we don't have user.services we're an anonymous user\n      if (!user.services) {\n        roles[shopId] = shop.defaultVisitorRole || defaultVisitorRole;\n      } else {\n        roles[shopId] = shop.defaultRoles || defaultRoles;\n        // also add services with email defined to user.emails[]\n        for (const service in user.services) {\n          if (user.services[service].email) {\n            const email = {\n              provides: \"default\",\n              address: user.services[service].email,\n              verified: true\n            };\n            user.emails.push(email);\n          }\n          if (user.services[service].name) {\n            user.username = user.services[service].name;\n            additionals.profile.name = user.services[service].name;\n          }\n          // TODO: For now we have here instagram, twitter and google avatar cases\n          // need to make complete list\n          if (user.services[service].picture) {\n            additionals.profile.picture = user.services[service].picture;\n          } else if (user.services[service].profile_image_url_https) {\n            additionals.profile.picture = user.services[service].\n              dprofile_image_url_https;\n          } else if (user.services[service].profile_picture) {\n            additionals.profile.picture = user.services[service].profile_picture;\n          }\n        }\n      }\n      // clone before adding roles\n      const account = Object.assign({}, user, additionals);\n      account.userId = user._id;\n      Collections.Accounts.insert(account);\n\n      // send a welcome email to new users,\n      // but skip the first default admin user\n      // (default admins already get a verification email)\n      if (!(Meteor.users.find().count() === 0)) {\n        Meteor.call(\"accounts/sendWelcomeEmail\", shopId, user._id);\n      }\n\n      // assign default user roles\n      user.roles = roles;\n\n      // run onCreateUser hooks\n      // (the user object must be returned by all callbacks)\n      const userDoc = Hooks.Events.run(\"onCreateUser\", user, options);\n      return userDoc;\n    }\n  });\n\n  /**\n   * Accounts.onLogin event\n   * let's remove \"anonymous\" role, if the login type isn't \"anonymous\"\n   * @param {Object} options - user account creation options\n   * @fires \"cart/mergeCart\" Method\n   */\n  Accounts.onLogin((opts) => {\n    // run onLogin hooks\n    // (the options object must be returned by all callbacks)\n    options = Hooks.Events.run(\"onLogin\", opts);\n\n    // remove anonymous role\n    // all users are guest, but anonymous user don't have profile access\n    // or ability to order history, etc. so ensure its removed upon login.\n    if (options.type !== \"anonymous\" && options.type !== \"resume\") {\n      const update = {\n        $pullAll: {}\n      };\n\n      update.$pullAll[\"roles.\" + Reaction.getShopId()] = [\"anonymous\"];\n\n      Meteor.users.update({\n        _id: options.user._id\n      }, update, {\n        multi: true\n      });\n      // debug info\n      Logger.debug(\"removed anonymous role from user: \" +\n        options.user._id);\n\n      // do not call `cart/mergeCart` on methodName === `createUser`, because\n      // in this case `cart/mergeCart` calls from cart publication\n      if (options.methodName === \"createUser\") return true;\n\n      // onLogin, we want to merge session cart into user cart.\n      const cart = Collections.Cart.findOne({\n        userId: options.user._id\n      });\n\n      // for a rare use cases\n      if (typeof cart !== \"object\") return false;\n      // in current version currentSessionId will be available for anonymous\n      // users only, because it is unknown for me how to pass sessionId when user\n      // logged in\n      const currentSessionId = options.methodArguments &&\n        options.methodArguments.length === 1 &&\n        options.methodArguments[0].sessionId;\n\n      // changing of workflow status from now happens within `cart/mergeCart`\n      return Meteor.call(\"cart/mergeCart\", cart._id, currentSessionId);\n    }\n  });\n}\n","import fs from \"fs\";\nimport { Meteor } from \"meteor/meteor\";\nimport { Assets } from \"/lib/collections\";\nimport { Hooks, Logger, Reaction } from \"/server/api\";\n\n// taken from here: http://stackoverflow.com/a/32749571\nfunction directoryExists(dirPath) {\n  try {\n    return fs.statSync(dirPath).isDirectory();\n  } catch (err) {\n    return false;\n  }\n}\n\n/**\n * load a single translation object as an Asset\n * loadTranslation should generally be used\n * before startup, to ensure that Assets load.\n * @param  {Object} source a json i18next object\n * @return {Boolean} false if assets weren't loaded\n */\n\nexport function loadTranslation(source) {\n  try {\n    const content = typeof source === \"string\" ? JSON.parse(source) : source;\n    const json = typeof source === \"object\" ? JSON.stringify(source) : source;\n\n    Assets.update({\n      type: \"i18n\",\n      name: content[0].i18n,\n      ns: content[0].ns\n    }, {\n      $set: {\n        content: json\n      }\n    }, {\n      upsert: true\n    });\n\n    Logger.debug(\"Translation assets updated for \", content[0].ns);\n  } catch (e) {\n    return false;\n  }\n  return false;\n}\n\n/**\n * load an array of translation objects\n * and import using loadTranslation\n * @param  {Object} sources array of i18next translations\n * @return {Boolean} false if assets weren't loaded\n */\nexport function loadTranslations(sources) {\n  sources.forEach(function (source) {\n    loadTranslation(source);\n  });\n}\n\n\n/**\n * loadCoreTranslations imports i18n json\n * files from private/data/i18n\n * into the Assets collection\n * Assets collection is processed with Reaction.Import\n * after all assets have been loaded.\n */\n\nexport function loadCoreTranslations() {\n  const meteorPath = fs.realpathSync(process.cwd() + \"/../\");\n  const i18nFolder = `${meteorPath}/server/assets/app/data/i18n/`;\n\n  if (directoryExists(i18nFolder)) {\n    fs.readdir(i18nFolder, Meteor.bindEnvironment(function (err, files) {\n      if (err) throw new Meteor.Error(\"No translations found for import.\", err);\n      for (const file of files) {\n        if (~file.indexOf(\"json\")) {\n          Logger.debug(`Importing Translations from ${file}`);\n          const json = fs.readFileSync(i18nFolder + file, \"utf8\");\n          const content = JSON.parse(json);\n\n          Assets.update({\n            type: \"i18n\",\n            name: content[0].i18n,\n            ns: content[0].ns\n          }, {\n            $set: {\n              content: json\n            }\n          }, {\n            upsert: true\n          });\n        }\n      }\n\n      // purposely broad results here\n      // we will be processing assets\n      // inserted using loadTranslation\n      // as well.\n      Assets.find({ type: \"i18n\" }).forEach((t) => {\n        Logger.debug(`Importing ${t.name} translation for \\\"${t.ns}\\\"`);\n        if (t.content) {\n          Reaction.Import.process(t.content, [\"i18n\"], Reaction.Import.translation);\n        } else {\n          Logger.debug(`No translation content found for ${t.name} - ${t.ns} asset`);\n        }\n      });\n    }));\n  }\n}\n\nexport default function () {\n  /**\n   * Hook to setup core i18n imports during Reaction init\n   */\n  Hooks.Events.add(\"onCoreInit\", () => {\n    loadCoreTranslations();\n  });\n}\n","import Accounts from \"./accounts\";\nimport i18n from \"./i18n\";\nimport Packages from \"./packages\";\nimport Registry from \"./registry\";\nimport Init from \"./init\";\nimport Prerender from \"./prerender\";\nimport { initTemplates } from \"/server/api/core/templates\";\n\n\nexport default function () {\n  Accounts();\n  i18n();\n  initTemplates();\n  Packages();\n  Registry();\n  Init();\n  Prerender();\n}\n","import { Reaction, Logger } from \"/server/api\";\nimport LoadData from \"./load-data\";\n\n/*\n * Execute start up fixtures\n */\n\nexport default function () {\n  // load fixture data\n  LoadData();\n  // initialize Reaction\n  Reaction.init();\n  // we've finished all reaction core initialization\n  Logger.info(\"Reaction initialization finished.\");\n}\n","import { Shops } from \"/lib/collections\";\nimport { Logger, Reaction } from \"/server/api\";\nimport { Fixture } from \"/server/api/core/import\";\n\nexport default function () {\n  /**\n   * Hook to setup core additional imports during Reaction init (shops process first)\n   */\n  Logger.info(\"Load default data from /private/data/\");\n\n  try {\n    Reaction.Import.process(Assets.getText(\"data/Shops.json\"), [\"name\"], Reaction.Import.shop);\n    // ensure Shops are loaded first.\n    Reaction.Import.flush(Shops);\n  } catch (error) {\n    Logger.info(\"Bypassing loading Shop default data\");\n  }\n\n  try {\n    Fixture.process(Assets.getText(\"data/Shipping.json\"), [\"name\"], Reaction.Import.shipping);\n  } catch (error) {\n    Logger.info(\"Bypassing loading Shipping default data.\");\n  }\n\n  try {\n    Fixture.process(Assets.getText(\"data/Products.json\"), [\"title\"], Reaction.Import.load);\n  } catch (error) {\n    Logger.info(\"Bypassing loading Products default data.\");\n  }\n\n  try {\n    Fixture.process(Assets.getText(\"data/Tags.json\"), [\"name\"], Reaction.Import.load);\n  } catch (error) {\n    Logger.info(\"Bypassing loading Tags default data.\");\n  }\n  //\n  // these will flush and import with the rest of the imports from core init.\n  // but Bulk.find.upsert() = false\n  //\n  Fixture.flush();\n}\n","import _ from \"lodash\";\nimport { Products } from \"/lib/collections\";\n\nexport default function () {\n  /**\n   * Reaction Collection Hooks\n   * transform collections based on events\n   *\n   * See: https://github.com/matb33/meteor-collection-hooks\n   */\n\n  /**\n   * before product update\n   */\n  // TODO: review this.  not sure this does what it was intended to\n  Products.before.update((userId, product, fieldNames, modifier) => {\n    // handling product positions updates\n    if (_.indexOf(fieldNames, \"positions\") !== -1) {\n      if (modifier.$addToSet) {\n        if (modifier.$addToSet.positions) {\n          createdAt = new Date();\n          updatedAt = new Date();\n          if (modifier.$addToSet.positions.$each) {\n            for (position in modifier.$addToSet.positions.$each) {\n              if ({}.hasOwnProperty.call(modifier.$addToSet.positions.$each,\n                  position)) {\n                createdAt = new Date();\n                updatedAt = new Date();\n              }\n            }\n          } else {\n            modifier.$addToSet.positions.updatedAt = updatedAt;\n          }\n        }\n      }\n    }\n  });\n}\n","import prerender from \"prerender-node\";\nimport { WebApp } from \"meteor/webapp\";\nimport { Logger } from \"/server/api\";\n\nexport default function () {\n  if (process.env.PRERENDER_TOKEN && process.env.PRERENDER_HOST) {\n    prerender.set(\"prerenderToken\", process.env.PRERENDER_TOKEN);\n    prerender.set(\"host\", process.env.PRERENDER_HOST);\n    prerender.set(\"protocol\", \"https\");\n    WebApp.rawConnectHandlers.use(prerender);\n    Logger.info(\"Prerender Initialization finished.\");\n  }\n}\n","import { Shops } from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\nimport initRegistry from \"./registry/index\";\n\nexport default function () {\n  initRegistry();\n\n   // initialize shop registry when a new shop is added\n  Shops.find().observe({\n    added(doc) {\n      Reaction.setShopName(doc);\n      Reaction.setDomain();\n    },\n    removed() {\n      // TODO SHOP REMOVAL CLEANUP FOR #357\n    }\n  });\n}\n","import nodemailer from \"nodemailer\";\nimport { Emails, Jobs } from \"/lib/collections\";\nimport { Reaction, Logger } from \"/server/api\";\n\nexport default function () {\n  /**\n   * Send Email job\n   *\n   * Example usage:\n   * new Job(Jobs, \"sendEmail\", { from, to, subject, html }).save();\n   */\n  const sendEmail = Jobs.processJobs(\"sendEmail\", {\n    pollInterval: 5 * 60 * 1000, // poll every 5 mins as a backup - see the realtime observer below\n    workTimeout: 2 * 60 * 1000, // fail if it takes longer than 2mins\n    payload: 20\n  }, (jobs, callback) => {\n    jobs.forEach((job) => {\n      const { from, to, subject, html } = job.data;\n\n      if (!from || !to || !subject || !html) {\n        const msg = \"Email job requires an options object with to/from/subject/html.\";\n        Logger.error(`[Job]: ${msg}`);\n        return job.fail(msg, { fatal: true });\n      }\n\n      const jobId = job._doc._id;\n\n      Emails.update({ jobId }, {\n        $set: {\n          from,\n          to,\n          subject,\n          html,\n          status: \"processing\"\n        }\n      }, {\n        upsert: true\n      });\n\n      if (!Reaction.Email.getMailUrl()) {\n        Emails.update({ jobId }, {\n          $set: {\n            status: \"failed\"\n          }\n        });\n        const msg = \"Mail not configured\";\n        Logger.error(msg);\n        return job.fail(msg);\n      }\n\n      const config = Reaction.Email.getMailConfig();\n      Logger.debug(config, \"Sending email with config\");\n\n      const transport = nodemailer.createTransport(config);\n\n      transport.sendMail({ from, to, subject, html }, Meteor.bindEnvironment((error) => {\n        if (error) {\n          Emails.update({ jobId }, {\n            $set: {\n              status: \"failed\"\n            }\n          });\n          Logger.error(error, \"Email job failed\");\n          return job.fail(error.toString());\n        }\n        Emails.update({ jobId }, {\n          $set: {\n            status: \"completed\"\n          }\n        });\n        Logger.debug(`Successfully sent email to ${to}`);\n        return job.done();\n      }));\n\n      return true;\n    });\n\n    return callback();\n  });\n\n  // Job Collection Observer\n  // This processes an email sending job as soon as it's submitted\n  Jobs.find({\n    type: \"sendEmail\",\n    status: \"ready\"\n  }).observe({\n    added() {\n      sendEmail.trigger();\n    }\n  });\n}\n","import email from \"./email\";\n\nexport default function () {\n  email();\n}\n","import * as Collections from \"/lib/collections\";\nimport { Reaction } from \"/server/api\";\n\nconst {\n  Accounts,\n  Cart,\n  Packages,\n  Emails,\n  Jobs,\n  Media,\n  Orders,\n  Products,\n  Shipping,\n  Shops,\n  Tags,\n  Templates,\n  Translations\n} = Collections;\n\n/**\n * security definitions\n *\n * The following security definitions use the ongoworks:security package.\n * Rules within a single chain stack with AND relationship. Multiple\n * chains for the same collection stack with OR relationship.\n * See https://github.com/ongoworks/meteor-security\n *\n * It\"s important to note that these security rules are for inserts,\n * updates, and removes initiated from untrusted (client) code.\n * Thus there may be other actions that certain roles are allowed to\n * take, but they do not necessarily need to be listed here if the\n * database operation is executed in a server method.\n */\n\nexport default function () {\n  /*\n   * Define some additional rule chain methods\n   */\n  // use this rule for collections other than Shops\n  // matches this.shopId\n  Security.defineMethod(\"ifShopIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.shopId !== Reaction.getShopId();\n    }\n  });\n  // this rule is for the Shops collection\n  // use ifShopIdMatches for match on this._id\n  Security.defineMethod(\"ifShopIdMatchesThisId\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc._id !== Reaction.getShopId();\n    }\n  });\n\n  Security.defineMethod(\"ifFileBelongsToShop\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.metadata.shopId !== Reaction.getShopId();\n    }\n  });\n\n  Security.defineMethod(\"ifUserIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return userId && doc.userId && doc.userId !== userId || doc.userId && !userId;\n    }\n  });\n\n  Security.defineMethod(\"ifUserIdMatchesProp\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc[arg] !== userId;\n    }\n  });\n\n  // todo do we need this?\n  Security.defineMethod(\"ifSessionIdMatches\", {\n    fetch: [],\n    deny: function (type, arg, userId, doc) {\n      return doc.sessionId !== Reaction.sessionId;\n    }\n  });\n\n  /**\n   * Define all security rules\n   */\n\n  /**\n   * admin security\n   * Permissive security for users with the \"admin\" role\n   */\n\n  Security.permit([\"insert\", \"update\", \"remove\"]).collections([\n    Accounts,\n    Products,\n    Tags,\n    Translations,\n    Shipping,\n    Orders,\n    Packages,\n    Templates,\n    Jobs\n  ]).ifHasRole({\n    role: \"admin\",\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().exceptProps([\"shopId\"]).allowInClientCode();\n\n  /*\n   * Permissive security for users with the \"admin\" role for FS.Collections\n   */\n\n  Security.permit([\"insert\", \"update\", \"remove\"]).collections([Media]).ifHasRole({\n    role: [\"admin\", \"owner\", \"createProduct\"],\n    group: Reaction.getShopId()\n  }).ifFileBelongsToShop().allowInClientCode();\n\n  /*\n   * Users with the \"admin\" or \"owner\" role may update and\n   * remove their shop but may not insert one.\n   */\n\n  Shops.permit([\"update\", \"remove\"]).ifHasRole({\n    role: [\"admin\", \"owner\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatchesThisId().allowInClientCode();\n\n  /*\n   * Users with the \"admin\" or \"owner\" role may update and\n   * remove products, but createProduct allows just for just a product editor\n   */\n\n  Products.permit([\"insert\", \"update\", \"remove\"]).ifHasRole({\n    role: [\"createProduct\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().allowInClientCode();\n\n  /*\n   * Users with the \"owner\" role may remove orders for their shop\n   */\n\n  Orders.permit(\"remove\").ifHasRole({\n    role: [\"admin\", \"owner\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().exceptProps([\"shopId\"]).allowInClientCode();\n\n  /*\n   * Can update cart from client. Must insert/remove carts using\n   * server methods.\n   * Can update all session carts if not logged in or user cart if logged in as that user\n   * XXX should verify session match, but doesn't seem possible? Might have to move all cart updates to server methods, too?\n   */\n\n  Cart.permit([\"insert\", \"update\", \"remove\"]).ifHasRole({\n    role: [\"anonymous\", \"guest\"],\n    group: Reaction.getShopId()\n  }).ifShopIdMatches().ifUserIdMatches().ifSessionIdMatches().allowInClientCode();\n\n  /*\n   * Users may update their own account\n   */\n  Collections.Accounts.permit([\"insert\", \"update\"]).ifHasRole({\n    role: [\"anonymous\", \"guest\"],\n    group: Reaction.getShopId()\n  }).ifUserIdMatches().allowInClientCode();\n\n  /*\n   * apply download permissions to file collections\n   */\n  _.each([Media], function (fsCollection) {\n    return fsCollection.allow({\n      download: function () {\n        return true;\n      }\n    });\n  });\n\n  /**\n   * Emails - Deny all client side ops\n   */\n  Emails.deny({\n    insert: () => true,\n    update: () => true,\n    remove: () => true\n  });\n}\n","import Collections from \"./collections\";\nimport RateLimiters from \"./rate-limits\";\n\nexport default function () {\n  Collections();\n  RateLimiters();\n}\n","import url from \"url\";\nimport { BrowserPolicy } from \"meteor/browser-policy-common\";\nimport { WebApp } from \"meteor/webapp\";\n\n\n/**\n * Set headers for Reaction CDN\n */\nWebApp.rawConnectHandlers.use((req, res, next) => {\n  if (req._parsedUrl.pathname.match(/\\.(ttf|ttc|otf|eot|woff|svg|font\\.css|css)$/)) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"assets.reactioncommerce.com\");\n  }\n  next();\n});\n\n\n/**\n * Set browser policies\n */\nif (process.env.NODE_ENV === \"development\") {\n  BrowserPolicy.content.allowOriginForAll(\"localhost:*\");\n  BrowserPolicy.content.allowConnectOrigin(\"ws://localhost:*\");\n  BrowserPolicy.content.allowConnectOrigin(\"http://localhost:*\");\n  BrowserPolicy.content.allowConnectOrigin(\"https://localhost:*\");\n  BrowserPolicy.framing.allowAll();\n}\n\n// get current hostname of app\nconst { hostname } = url.parse(Meteor.absoluteUrl());\n\n// allow websockets (Safari fails without this)\nBrowserPolicy.content.allowConnectOrigin(`ws://${hostname}`);\nBrowserPolicy.content.allowConnectOrigin(`wss://${hostname}`);\n\nBrowserPolicy.content.allowOriginForAll(\"*.facebook.com\");\nBrowserPolicy.content.allowOriginForAll(\"*.fbcdn.net\");\nBrowserPolicy.content.allowOriginForAll(\"connect.facebook.net\");\nBrowserPolicy.content.allowOriginForAll(\"*.googleusercontent.com\");\n\nBrowserPolicy.content.allowImageOrigin(\"fbcdn-profile-a.akamaihd.net\");\nBrowserPolicy.content.allowImageOrigin(\"secure.gravatar.com\");\nBrowserPolicy.content.allowImageOrigin(\"i0.wp.com\");\n\nBrowserPolicy.content.allowFontDataUrl();\nBrowserPolicy.content.allowOriginForAll(\"assets.reactioncommerce.com\");\nBrowserPolicy.content.allowOriginForAll(\"cdnjs.cloudflare.com\");\nBrowserPolicy.content.allowOriginForAll(\"fonts.googleapis.com\");\nBrowserPolicy.content.allowOriginForAll(\"fonts.gstatic.com\");\nBrowserPolicy.content.allowOriginForAll(\"fonts.gstatic.com\");\n\nBrowserPolicy.content.allowOriginForAll(\"enginex.kadira.io\");\nBrowserPolicy.content.allowOriginForAll(\"*.stripe.com\");\n","import _ from \"lodash\";\nimport { DDPRateLimiter } from \"meteor/ddp-rate-limiter\";\n\n\nexport default function () {\n  /**\n   * Rate limit Meteor Accounts methods\n   * 2 attempts per connection per 5 seconds\n   */\n  const authMethods = [\n    \"login\",\n    \"logout\",\n    \"logoutOtherClients\",\n    \"getNewToken\",\n    \"removeOtherTokens\",\n    \"configureLoginService\",\n    \"changePassword\",\n    \"forgotPassword\",\n    \"resetPassword\",\n    \"verifyEmail\",\n    \"createUser\",\n    \"ATRemoveService\",\n    \"ATCreateUserServer\",\n    \"ATResendVerificationEmail\"\n  ];\n\n  DDPRateLimiter.addRule({\n    name: (name) => _.includes(authMethods, name),\n    connectionId: () => true\n  }, 2, 5000);\n\n\n  /**\n   * Rate limit \"orders/sendNotification\"\n   * 1 attempt per connection per 2 seconds\n   */\n  DDPRateLimiter.addRule({\n    name: \"orders/sendNotification\",\n    connectionId: () => true\n  }, 1, 2000);\n}\n","\n/**\n * ***** DO NOT EDIT THIS FILE MANUALLY *****\n * This file is generated automatically by the Reaction\n * plugin loader and will be reset at each startup.\n */\n\nimport '/imports/plugins/core/accounts/server';\nimport '/imports/plugins/core/catalog/server';\nimport '/imports/plugins/core/checkout/server';\nimport '/imports/plugins/core/dashboard/server';\nimport '/imports/plugins/core/discounts/server';\nimport '/imports/plugins/core/email/server';\nimport '/imports/plugins/core/i18n/server';\nimport '/imports/plugins/core/layout/server';\nimport '/imports/plugins/core/logging/server';\nimport '/imports/plugins/core/orders/server';\nimport '/imports/plugins/core/payments/server';\nimport '/imports/plugins/core/revisions/server';\nimport '/imports/plugins/core/router/server';\nimport '/imports/plugins/core/shipping/server';\nimport '/imports/plugins/core/taxes/server';\nimport '/imports/plugins/core/templates/server';\nimport '/imports/plugins/core/ui/server';\nimport '/imports/plugins/core/ui-grid/server';\nimport '/imports/plugins/core/ui-navbar/server';\nimport '/imports/plugins/core/ui-tagnav/server';\nimport '/imports/plugins/core/versions/server';\nimport '/imports/plugins/included/analytics/server';\nimport '/imports/plugins/included/default-theme/server';\nimport '/imports/plugins/included/discount-codes/server';\nimport '/imports/plugins/included/discount-rates/server';\nimport '/imports/plugins/included/email-templates/server';\nimport '/imports/plugins/included/inventory/server';\nimport '/imports/plugins/included/jobcontrol/server';\nimport '/imports/plugins/included/launchdock-connect/server';\nimport '/imports/plugins/included/notifications/server';\nimport '/imports/plugins/included/payments-authnet/server';\nimport '/imports/plugins/included/payments-braintree/server';\nimport '/imports/plugins/included/payments-paypal/server';\nimport '/imports/plugins/included/payments-stripe/server';\nimport '/imports/plugins/included/product-admin/server';\nimport '/imports/plugins/included/product-detail-simple/server';\nimport '/imports/plugins/included/product-variant/server';\nimport '/imports/plugins/included/search-mongo/server';\nimport '/imports/plugins/included/shipping-rates/server';\nimport '/imports/plugins/included/shippo/server';\nimport '/imports/plugins/included/sms/server';\nimport '/imports/plugins/included/social/server';\nimport '/imports/plugins/included/taxes-avalara/server';\nimport '/imports/plugins/included/taxes-taxcloud/server';\nimport '/imports/plugins/included/taxes-taxjar/server';\nimport '/imports/plugins/included/ui-search/server';\nimport '/imports/plugins/custom/payments-example/server';\nimport '/imports/plugins/core/accounts/register.js';\nimport '/imports/plugins/core/catalog/register.js';\nimport '/imports/plugins/core/checkout/register.js';\nimport '/imports/plugins/core/dashboard/register.js';\nimport '/imports/plugins/core/discounts/register.js';\nimport '/imports/plugins/core/email/register.js';\nimport '/imports/plugins/core/i18n/register.js';\nimport '/imports/plugins/core/layout/register.js';\nimport '/imports/plugins/core/logging/register.js';\nimport '/imports/plugins/core/orders/register.js';\nimport '/imports/plugins/core/payments/register.js';\nimport '/imports/plugins/core/revisions/register.js';\nimport '/imports/plugins/core/router/register.js';\nimport '/imports/plugins/core/shipping/register.js';\nimport '/imports/plugins/core/taxes/register.js';\nimport '/imports/plugins/core/templates/register.js';\nimport '/imports/plugins/core/ui/register.js';\nimport '/imports/plugins/core/ui-grid/register.js';\nimport '/imports/plugins/core/ui-navbar/register.js';\nimport '/imports/plugins/core/ui-tagnav/register.js';\nimport '/imports/plugins/core/versions/register.js';\nimport '/imports/plugins/included/analytics/register.js';\nimport '/imports/plugins/included/default-theme/register.js';\nimport '/imports/plugins/included/discount-codes/register.js';\nimport '/imports/plugins/included/email-templates/register.js';\nimport '/imports/plugins/included/inventory/register.js';\nimport '/imports/plugins/included/jobcontrol/register.js';\nimport '/imports/plugins/included/launchdock-connect/register.js';\nimport '/imports/plugins/included/notifications/register.js';\nimport '/imports/plugins/included/payments-authnet/register.js';\nimport '/imports/plugins/included/payments-braintree/register.js';\nimport '/imports/plugins/included/payments-paypal/register.js';\nimport '/imports/plugins/included/payments-stripe/register.js';\nimport '/imports/plugins/included/product-admin/register.js';\nimport '/imports/plugins/included/product-detail-simple/register.js';\nimport '/imports/plugins/included/product-variant/register.js';\nimport '/imports/plugins/included/search-mongo/register.js';\nimport '/imports/plugins/included/shipping-rates/register.js';\nimport '/imports/plugins/included/shippo/register.js';\nimport '/imports/plugins/included/sms/register.js';\nimport '/imports/plugins/included/social/register.js';\nimport '/imports/plugins/included/taxes-avalara/register.js';\nimport '/imports/plugins/included/taxes-taxcloud/register.js';\nimport '/imports/plugins/included/ui-search/register.js';\nimport '/imports/plugins/custom/payments-example/register.js';\n","import \"./methods\";\nimport Startup from \"./startup\";\nimport Security from \"./security\";\n\nMeteor.startup(() => {\n  Startup();\n  Security();\n});\n"]}